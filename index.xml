<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>潜水员的咖啡小屋</title>
    <link>https://ynikl.github.io/</link>
    <description>Recent content on 潜水员的咖啡小屋</description>
    <image>
      <url>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>gilfoyle.k@outlook.com (潜水员)</managingEditor>
    <webMaster>gilfoyle.k@outlook.com (潜水员)</webMaster>
    <copyright>2022 Ian Lin All rights reserved</copyright>
    <lastBuildDate>Thu, 03 Aug 2023 20:34:58 +0800</lastBuildDate><atom:link href="https://ynikl.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GO 代码结构中为什么老有 cmd 和 internal 文件夹</title>
      <link>https://ynikl.github.io/blog/golang-project-layout-cmd/</link>
      <pubDate>Thu, 03 Aug 2023 20:34:58 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-project-layout-cmd/</guid>
      <description>总结:
cmd 一个代码库多个启动程序, 清晰明了 internal 将外部依赖放置在 internal 外面, 避免内部逻辑代码直接引用. 比如, 数据持久层 MySQL 参考一下 ChatGPT 给我的答案:
在 Go 语言中，使用 cmd 目录和 internal 目录的组合是一种常见的方式来组织项目结构。 cmd 目录通常包含可执行程序的入口点。这些可执行程序可以是应用程序的命令行接口、工具或测试二进制文件。每个子目录都包含一个可执行程序的主要文件，以及与其关联的其他文件。这种风格使得每个程序都可以独立编译和分发，并且可以让其它人轻松了解和使用它们。
对于 internal 目录，其命名约束了该目录下的代码仅供内部使用。这意味着代码不应该由任何可以被外部依赖使用的包引用。这种风格允许对代码的控制更精细，因为程序员可以更好地控制哪些代码可以被其他人使用。
使用这样的结构来组织 Go 项目有很多好处，包括：
代码更易于维护和理解：使用独立的可执行程序和内部目录，可以让代码更清晰且更容易维护，使开发人员能够更好地理解代码的用途和位置。
扩展性强：该结构使得每个可执行程序都可以相对独立地进行开发、测试和部署。这也使得代码更有扩展和修改的完整性。
松耦合：使用 cmd 和 internal 目录方式可以大大增强代码间的松耦合度。这使得程序员可以更好地对代码变化做出反应，同时减少代码冲突及协调问题。
综上所述，使用 cmd 和 internal 目录方式更易于开发和维护，是现代化 Go 应用程序中广受欢迎的项目结构设计方式。</description>
      <content:encoded><![CDATA[<p>总结:</p>
<ul>
<li>cmd 一个代码库多个启动程序, 清晰明了</li>
<li>internal 将外部依赖放置在 internal 外面, 避免内部逻辑代码直接引用. 比如, 数据持久层 MySQL</li>
</ul>
<p>参考一下 ChatGPT 给我的答案:</p>
<blockquote>
<p>在 Go 语言中，使用 cmd 目录和 internal 目录的组合是一种常见的方式来组织项目结构。
cmd 目录通常包含可执行程序的入口点。这些可执行程序可以是应用程序的命令行接口、工具或测试二进制文件。每个子目录都包含一个可执行程序的主要文件，以及与其关联的其他文件。这种风格使得每个程序都可以独立编译和分发，并且可以让其它人轻松了解和使用它们。</p>
<p>对于 internal 目录，其命名约束了该目录下的代码仅供内部使用。这意味着代码不应该由任何可以被外部依赖使用的包引用。这种风格允许对代码的控制更精细，因为程序员可以更好地控制哪些代码可以被其他人使用。</p>
<p>使用这样的结构来组织 Go 项目有很多好处，包括：</p>
<p>代码更易于维护和理解：使用独立的可执行程序和内部目录，可以让代码更清晰且更容易维护，使开发人员能够更好地理解代码的用途和位置。</p>
<p>扩展性强：该结构使得每个可执行程序都可以相对独立地进行开发、测试和部署。这也使得代码更有扩展和修改的完整性。</p>
<p>松耦合：使用 cmd 和 internal 目录方式可以大大增强代码间的松耦合度。这使得程序员可以更好地对代码变化做出反应，同时减少代码冲突及协调问题。</p>
<p>综上所述，使用 cmd 和 internal 目录方式更易于开发和维护，是现代化 Go 应用程序中广受欢迎的项目结构设计方式。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Redis 在缓存场景中的应用模式</title>
      <link>https://ynikl.github.io/blog/redis-design-pattern/</link>
      <pubDate>Thu, 03 Aug 2023 18:49:09 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/redis-design-pattern/</guid>
      <description>总结:
先更新数据库, 再删除Key
陈皓大佬的 缓存更新的套路 唉， 叹息</description>
      <content:encoded><![CDATA[<p>总结:</p>
<p><strong>先更新数据库, 再删除Key</strong></p>
<p><a href="https://coolshell.cn/articles/17416.html">陈皓大佬的 缓存更新的套路 </a>  唉， 叹息</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>The Long View</title>
      <link>https://ynikl.github.io/books/the-long-view/</link>
      <pubDate>Mon, 03 Jul 2023 13:10:38 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/the-long-view/</guid>
      <description>总结 最大的收获是, 作为一个程序员现在去担心35岁会失业, 完全是多余的行为. 相反, 我现在 应该合理的规划自己45年, 3个阶段的职业生涯. 聚焦自己的长处. 当我35岁被迫离职之后, 我还是需要继续从事工作才能正常的存活下去, 那也是我的职业生涯的一部分.
职场燃料
可迁移的技能 有意义的经验 可持续的关系 四大黄金问题：
1、我是否正在学习和成长？ 2、我是否正对某些人、现在的公司，乃至整个社会拥有影响力？ 3、我体验到乐趣了么？ 4、我是否得到适当的奖励，并创造了经济价值？
书摘 《远见》 46个笔记
◆ 前言 用新思维构建属于你的职业生涯
于我而言，构建一段成功的职业生涯的目的并不仅在于找到你热爱的工作，而且是建立起你热爱的生活
我们需要一种包容了生活中所有方面的工作哲学，它能够指导我们如何保持进取之心并追求成功，同时不牺牲家庭、朋友、健康、理想等珍贵的东西。本书讲的是如何建立一个长期的职业规划，因为众所周知，在二三十岁带来快乐的东西会随着职业生涯的发展而改变、演化。我们需要一套能伴随着我们一起变化和成长的工具，毕竟生活中的每个瞬间都可能让你的观念和目标发生重大的变化。
◆ 01 远见思维：多行动，少忧虑
各个年龄层的大部分人都将职场生活视为一份工作，而不是一段职业生涯
他们大都将职业生涯当成一场短跑比赛，然而事实上，这是一场至少长达45年的马拉松
。职业生涯由三个主要阶段组成，分别持续大约15年时间。
在这一阶段，要为职业生涯打好基础并建立起良好的早期习惯。
第二阶段是聚焦长板的时候。该阶段的首要目标是寻找自己的甜蜜区，即你所擅长的、所热爱的和这个世界所需要的这三者之间的交集。
这种燃料有三个主要来源：可迁移技能、有意义的经验和持久的关系
4．职业生涯并不是以线性或者可预测的方式发展的。你必须时刻保持探索和学习的状态
．盘点职场清单，梳理你最有用处的技能、经验和关系。作为这份清单的一部分，你需要评估目前所处的职业生涯阶段，并描绘出职业生态系统。
进行“100小时测试”并完成一份“个人时间档案”，从而了解你目前的时间投资状况。你是否将足够多的时间投入到让你变得最成功和快乐的事情上了呢
◆ 02 3大阶段，聚焦45年职业生涯
第一阶段是探索和弥补自身短板的时候。如果你是个糟糕的演讲者，那就去参加相关的培训课程。如果你对待团队成员过于强势或弱势，那就去参加领导力培训。学习要比纯粹的成功更重要。有时跌倒并不可怕，只要你能吸取教训，并将这些经验加以利用就行。
着眼于核心长板，突破自我，更进一步吧。当你进入第二阶段时，补足短板已经难上加难了。更好的办法常常是专注于自己的长板，与能够帮助你、弥补你短板的人为伴。没有哪个卓越领袖可以面面俱到
◆ 03 储备3大职场燃料
职业生涯中存在三种基本形式的职场燃料，每一种对获得长远的成功都非常重要。可迁移技能；有意义的经验；持久的关系。
有的时候，如果我要解决一个复杂的问题，就会做一个名为“给妈妈写信”的练习。我会真的起草一封给妈妈的信，解释眼前的问题和我想采取的行动。由于我妈妈未曾涉足过我的行业，所以这一练习就会迫使我使用简单明了的语言，从而让关键点呈现得尤为清晰。下次你遇到什么棘手的挑战时，也可以试试“给妈妈写信”
罗里发现，在不同的环境中尝试不同的事情、试验不同的做事方法，这样能创造出更强的决策技能。如果我们一直用同一种方法做事，虽然会变得很有效率，但这种状态很脆弱。我们都知道，在遗传学中，一定程度的遗传多样性和基因突变会创造出更有活力的物种
身边的人才。你是否在职业生涯早期遇见了顶尖的领导者和相关领域的专家？你应该问自己这样一个问题：“如果我自己创建公司，周围的人里，我愿意带上谁，以及他们是否会接受我的邀请？”
。社会学家查尔斯·汉迪（Charles Handy）提出了一项很好的假设性练习：想象一下，当你40岁时不得不永远告别自己的工作，以一己之力创立一家公司，你会怎么做？这是一个很好的测试自主力的练习。
◆ 04 5个数字，树立正确的职场思维
2023/06/20发表想法 就算35程序员被迫退休，我还是需要选择新的工作，我的职业生涯并没有结束
1．职业生涯的长度：用62减去你目前的年龄。算出的结果是你距离提前退休的年数。
◆ 05 4大黄金问题，评估职业价值
2023/06/20发表想法 盘点自己的职场燃料
检查一下这三大主要的职场燃料吧： 可迁移技能； 有意义的经验； 持久的关系。</description>
      <content:encoded><![CDATA[<h2 id="总结">总结</h2>
<p>最大的收获是, 作为一个程序员现在去担心35岁会失业, 完全是多余的行为. 相反, 我现在
应该合理的规划自己45年, 3个阶段的职业生涯. 聚焦自己的长处. 当我35岁被迫离职之后,
我还是需要继续从事工作才能正常的存活下去, 那也是我的职业生涯的一部分.</p>
<p>职场燃料</p>
<ul>
<li>可迁移的技能</li>
<li>有意义的经验</li>
<li>可持续的关系</li>
</ul>
<p>四大黄金问题：</p>
<p>1、我是否正在学习和成长？
2、我是否正对某些人、现在的公司，乃至整个社会拥有影响力？
3、我体验到乐趣了么？
4、我是否得到适当的奖励，并创造了经济价值？</p>
<h2 id="书摘">书摘</h2>
<p>《远见》
46个笔记</p>
<p>◆ 前言 用新思维构建属于你的职业生涯</p>
<blockquote>
<blockquote>
<p>于我而言，构建一段成功的职业生涯的目的并不仅在于找到你热爱的工作，而且是建立起你热爱的生活</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>我们需要一种包容了生活中所有方面的工作哲学，它能够指导我们如何保持进取之心并追求成功，同时不牺牲家庭、朋友、健康、理想等珍贵的东西。本书讲的是如何建立一个长期的职业规划，因为众所周知，在二三十岁带来快乐的东西会随着职业生涯的发展而改变、演化。我们需要一套能伴随着我们一起变化和成长的工具，毕竟生活中的每个瞬间都可能让你的观念和目标发生重大的变化。</p>
</blockquote>
</blockquote>
<p>◆ 01 远见思维：多行动，少忧虑</p>
<blockquote>
<blockquote>
<p>各个年龄层的大部分人都将职场生活视为一份工作，而不是一段职业生涯</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>他们大都将职业生涯当成一场短跑比赛，然而事实上，这是一场至少长达45年的马拉松</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>。职业生涯由三个主要阶段组成，分别持续大约15年时间。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>在这一阶段，要为职业生涯打好基础并建立起良好的早期习惯。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>第二阶段是聚焦长板的时候。该阶段的首要目标是寻找自己的甜蜜区，即你所擅长的、所热爱的和这个世界所需要的这三者之间的交集。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>这种燃料有三个主要来源：可迁移技能、有意义的经验和持久的关系</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>4．职业生涯并不是以线性或者可预测的方式发展的。你必须时刻保持探索和学习的状态</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>．盘点职场清单，梳理你最有用处的技能、经验和关系。作为这份清单的一部分，你需要评估目前所处的职业生涯阶段，并描绘出职业生态系统。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>进行“100小时测试”并完成一份“个人时间档案”，从而了解你目前的时间投资状况。你是否将足够多的时间投入到让你变得最成功和快乐的事情上了呢</p>
</blockquote>
</blockquote>
<p>◆ 02 3大阶段，聚焦45年职业生涯</p>
<blockquote>
<blockquote>
<p>第一阶段是探索和弥补自身短板的时候。如果你是个糟糕的演讲者，那就去参加相关的培训课程。如果你对待团队成员过于强势或弱势，那就去参加领导力培训。学习要比纯粹的成功更重要。有时跌倒并不可怕，只要你能吸取教训，并将这些经验加以利用就行。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>着眼于核心长板，突破自我，更进一步吧。当你进入第二阶段时，补足短板已经难上加难了。更好的办法常常是专注于自己的长板，与能够帮助你、弥补你短板的人为伴。没有哪个卓越领袖可以面面俱到</p>
</blockquote>
</blockquote>
<p>◆ 03 储备3大职场燃料</p>
<blockquote>
<blockquote>
<p>职业生涯中存在三种基本形式的职场燃料，每一种对获得长远的成功都非常重要。可迁移技能；有意义的经验；持久的关系。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>有的时候，如果我要解决一个复杂的问题，就会做一个名为“给妈妈写信”的练习。我会真的起草一封给妈妈的信，解释眼前的问题和我想采取的行动。由于我妈妈未曾涉足过我的行业，所以这一练习就会迫使我使用简单明了的语言，从而让关键点呈现得尤为清晰。下次你遇到什么棘手的挑战时，也可以试试“给妈妈写信”</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>罗里发现，在不同的环境中尝试不同的事情、试验不同的做事方法，这样能创造出更强的决策技能。如果我们一直用同一种方法做事，虽然会变得很有效率，但这种状态很脆弱。我们都知道，在遗传学中，一定程度的遗传多样性和基因突变会创造出更有活力的物种</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>身边的人才。你是否在职业生涯早期遇见了顶尖的领导者和相关领域的专家？你应该问自己这样一个问题：“如果我自己创建公司，周围的人里，我愿意带上谁，以及他们是否会接受我的邀请？”</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>。社会学家查尔斯·汉迪（Charles Handy）提出了一项很好的假设性练习：想象一下，当你40岁时不得不永远告别自己的工作，以一己之力创立一家公司，你会怎么做？这是一个很好的测试自主力的练习。</p>
</blockquote>
</blockquote>
<p>◆ 04 5个数字，树立正确的职场思维</p>
<p>2023/06/20发表想法
就算35程序员被迫退休，我还是需要选择新的工作，我的职业生涯并没有结束</p>
<blockquote>
<blockquote>
<p>1．职业生涯的长度：用62减去你目前的年龄。算出的结果是你距离提前退休的年数。</p>
</blockquote>
</blockquote>
<p>◆ 05 4大黄金问题，评估职业价值</p>
<p>2023/06/20发表想法
盘点自己的职场燃料</p>
<blockquote>
<blockquote>
<p>检查一下这三大主要的职场燃料吧：
可迁移技能；
有意义的经验；
持久的关系。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>如果你将自己当成一个学生，那就自然会找到老师。在找到了能推动你职业生涯前进的人时，你就要想尽办法帮助他们、为其所用，或者花时间与他们相处</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>一旦找到了一名导师或支持者，首要任务就是欣赏他们，并与他们保持联系。时不时地给他们发条消息，告诉他们你现在的状况，分享你的成功和失败，向他们寻求建议。记住，对你的导师而言，这类沟通并不是什么负担，而是一种奖励。在职业生涯现阶段，谁是你的导师呢？谁可能会成为下一个呢？你是否做得够好，能够培养和赢得他们的支持呢</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>我是否正在学习和成长？我是否正在对某些人、现在的公司，乃至整个社会拥有影响力？我体验到乐趣了吗？我是否得到了适当的奖励，并创造了经济价值？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>至于奖励，要记住不能光看基本的薪水，而要衡量完整的收入，包括基本薪水、福利、津贴、假期、弹性时间、报销或补贴，可能还要加上你在积累的所有权或股份的任何变化。</p>
</blockquote>
</blockquote>
<p>◆ 06 100小时测试，合理投资时间</p>
<blockquote>
<blockquote>
<p>如果你问一个资深的财务顾问，如何让你的投资获得最高的长期产出，他会告诉你，关键是“资产配置”。换句话说就是，你是否在正确的时间投资了正确的东西，即股票、债券、期货和其他资产类型？职业生涯也是一样的道理，只不过关键的变量是你如何投资时间</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>因为我们平均每周都有大约100个小时是清醒的，所以你也可以轻而易举地画出这样一张图。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>像教学、社区活动和健身这样的高效能部分只要有一丁点儿变化，都会让我们发生巨大的改变。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>除了前摄时间迁移，与我交流过的成功人士大都将界限和专注列为应对忙碌职业生涯的策略的重点。</p>
</blockquote>
</blockquote>
<p>◆ 07 职场路径向导，做出正确的职业决策</p>
<blockquote>
<blockquote>
<p>我们要回答三个问题。你的职业理想是什么，或者至少假设一个你可能想要达到的目标。你目前手上有什么职场燃料？你需要什么职场燃料才能实现这个终极理想？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>但你需要确定它会给你的职业生涯带来什么样的特殊价值，思考它能否：增加你目前不具备的可迁移技能？帮助你重塑自我，改变职业生涯的方向？建立新的人际关系，并拓展职业生态系统？获得你目前没有的重要证书？加速你的探索步伐，即通过实践验证自己真正擅长和热爱的东西？</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>对穆罕默德·阿舒尔而言，他的选择归根结底还是出于他一开始追求医学的理由：他希望自己能创造宝贵的遗产，渴望拥有积极的影响力，并追求财务的稳定性，成为医生可以让他拥有这一切。而“想吃”公司也能让他做到以上这几点，甚至可能做得更好，只不过他要走的是一条从未预见过的道路</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>奥朗·霍夫曼还说：“当你有33%～66%的概率失败时，成长的速度也是最快的。要想精进，就得主动站在可能失败的立场上</p>
</blockquote>
</blockquote>
<p>◆ 08 第一阶段：加添燃料，强势开局</p>
<blockquote>
<blockquote>
<p>作为自己的品牌经理，请利用第一阶段培养好成功的职业生涯所需的技能和习惯。多多见识，全身心投入，成为某方面的专家，学习高效的沟通技巧，建立声望，寻求反馈，并创造价值。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>，所以每一次你都要说得一清二楚。其次，写下你的三个重点，加上用于佐证的事实和原因加强说服力。这意味着你既有观点，又有支撑它的证据。最后，直白地说出你希望听众接下来怎么做。</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>你做的事情是否能提高公司的声誉，如发表一篇文章、参加一场颇受好评的演讲活动、赢得一个奖项等，或者是否为人才库增加了一些重要的新生力量？尽可能多地关注产出，而不是行动。光是做你的本职工作只能让你维系目前的职位和薪酬</p>
</blockquote>
</blockquote>
<p>2023/06/22发表想法
身为领导也可以有机会拉进和底层员工的沟通，降低沟通成本，也方便员工的反馈</p>
<blockquote>
<blockquote>
<p>戴夫的“一万杯咖啡”平台本质上就是一条双向通道。寻求建议的年轻人可以得到想要的东西，而专家领袖也能得偿所愿。优质公司已经开始利用这个平台与内部员工沟通。他们发现了这是一个绝佳的平台，可以为创新和产品开发项目收集研究材料，并且让高层管理者与公司内部的年轻员工联系在一起。各大校友协会也在利用“一万杯咖啡”让他们的机构与校友圈子保持联系，同时让学生和校友能够围绕着共同的兴趣爱好建立关系</p>
</blockquote>
</blockquote>
<p>2023/06/22发表想法
我可以通过喝咖啡和各行各业了解一些行业的实践故事</p>
<blockquote>
<blockquote>
<p>生活不是线性的，它无法在教室里学会，而是要在实践中学。而最好的作品是在你不工作的时候诞生的</p>
</blockquote>
</blockquote>
<p>◆ 09 第二阶段：锚定甜蜜区，聚焦长板</p>
<blockquote>
<blockquote>
<p>但是到最后，由于与这一领域缺乏深度的联系，各种困扰就会出现，这往往会发生在我们40多岁的时候。我们会感到越来越无法投入工作，竞争力不断下降。我们天生的创造力已经快耗尽了。我们无法关注所在领域发生的变化，因为我们已经脱轨。更年轻、更有创造力，而且更廉价的人很快就会取代我</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>我们都见过那种始终高高在上的领导者，也见过另外一类似乎离地面只有几厘米、一直插手问题的领导者。不要一直做飞在高空的宇航员，也不要一直做飞在低空的扫地机</p>
</blockquote>
</blockquote>
<p>◆ 10 第三阶段：优化长尾，发挥持续影响力</p>
<blockquote>
<blockquote>
<p>在过去的一个世纪里，发达经济体的人口寿命增加了整整30年。正如贝特森指出的那样，这并不是让“老年时期”延长了，而是让我们在变老之前额外增加了一个生命阶段。</p>
</blockquote>
</blockquote>
<p>◆ 11 如何做好职场父母</p>
<blockquote>
<blockquote>
<p>米莱娜和保罗知道，紧张的全职工作和繁忙的家庭生活会扰乱他们的步伐。压力是会传染的。保罗说：“压力很大的父母会把它传递给孩子。面对一份像经营创业公司这样劳心费力的工作，大起大落的经历实在太多了。”这就是贝里夫妇为家庭时间划出明确界限，从而为生活留出一点空间和平静的原因之一。在晚上6—9点，他们一门心思扑在孩子身上，拒绝一切工作电话或电子邮件。这家人每天晚上都有一小时的时间专门用来一起读书</p>
</blockquote>
</blockquote>
<p>◆ 13 如何应对职场危机</p>
<blockquote>
<blockquote>
<p>每个人都有一个计划，直到被打掉牙的那一刻。迈克·泰森　世界重量级拳王</p>
</blockquote>
</blockquote>
<p>◆ 尾声 工作的未来</p>
<p>2023/06/25发表想法
程序员存在的意义，不仅仅是写代码，而是如何解决问题</p>
<blockquote>
<blockquote>
<p>相比之下，如果重复性和程序性的工作正在没落，那么要求员工用自己的大脑思考，并得出有创造力的原创想法的职位，就会在自动化面前拥有相当大的优势了。这对艺术家、设计师或工程师而言是个好消息</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>那么，机器的崛起对于我们长期的职业规划有什么启示呢？答案很简单：你需要确保能拥有一些与机器的工作不同或互补的人类技能。如果你做的事情全都是常规的计算、报告或执行，那么就该警惕了。如果你正在追求一份重复性很高而社交投入很低的工作，那么就真的应该捏一把汗了，你应当马上行动起来。如果无动于衷，那么在未来的某个时候，你就会被机器超越、取代或排斥</p>
</blockquote>
</blockquote>
<p>2023/06/25发表想法
我突然意识到，我已经很久没有进入过这种状态了</p>
<blockquote>
<blockquote>
<p>在《当下的幸福》（Flow： The Psychology of Optimal Experience）中，作者将心流描述为：“一个人的技能足以应付眼前挑战的一种感觉。此时，人的精力高度集中，以至于没有任何多余的注意力可以用来思考无关的事情或为其他问题忧心。这个人的自我意识消失了，而对时间的感觉也会发生扭曲。”一个处于“心流”状态的人表现为“用一种天衣无缝的无意识的熟练的方式行动，在其行为中产生流动的感觉</p>
</blockquote>
</blockquote>
<p>2023/06/25发表想法
检查自己在哪里</p>
<blockquote>
<blockquote>
<p>每年至少花一整天的时间反省和制订职业生涯的策略，进行职场盘点，尝试一些假设，确立目标，不断建立和更新你的职场燃料，监控你的进度</p>
</blockquote>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>MySQL 是怎样运行的</title>
      <link>https://ynikl.github.io/books/mysql-how-to-run/</link>
      <pubDate>Sun, 18 Jun 2023 18:46:44 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/mysql-how-to-run/</guid>
      <description>字符集和比较规则 我们上边说 utf8 字符集表示一个字符需要使用1~4个字节，但是我们常用的一些字符使用1~3个字节就可以表 示了。而在 MySQL 中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计 MySQL 的大叔偷偷的定义了两个概念: utf8mb3 :阉割过的 utf8 字符集，只使用1~3个字节表示字符。 utf8mb4 :正宗的 utf8 字符集，使用1~4个字节表示字符。 有一点需要大家十分的注意，在 MySQL 中 utf8 是 utf8mb3 的别名，所以之后在 MySQL 中提到 utf8 就意味着使 用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请 使用 utf8mb4 。
SHOW COLLATION LIKE &amp;lsquo;utf8_%&amp;rsquo;; 字符比较规则
MySQL 有4个级别的字符集和比较规则，分别是: 服务器级别 数据库级别 表级别 列级别
1 2 CREATE TABLE 表名 (列的信息) [[DEFAULT] CHARACTER SET 字符集名称] [COLLATE 比较规则名称] 1 2 3 CREATE TABLE 表名( 列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称], 其他列... ); InnoDB 而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我 们想从表中获取某些记录时， InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么?</description>
      <content:encoded><![CDATA[<h3 id="字符集和比较规则">字符集和比较规则</h3>
<p>我们上边说 utf8 字符集表示一个字符需要使用1~4个字节，但是我们常用的一些字符使用1~3个字节就可以表 示了。而在 MySQL 中字符集表示一个字符所用最大字节长度在某些方面会影响系统的存储和性能，所以设计
MySQL 的大叔偷偷的定义了两个概念: utf8mb3 :阉割过的 utf8 字符集，只使用1~3个字节表示字符。
utf8mb4 :正宗的 utf8 字符集，使用1~4个字节表示字符。
有一点需要大家十分的注意，在 MySQL 中 utf8 是 utf8mb3 的别名，所以之后在 MySQL 中提到 utf8 就意味着使 用1~3个字节来表示一个字符，如果大家有使用4字节编码一个字符的情况，比如存储一些emoji表情啥的，那请 使用 utf8mb4 。</p>
<p>SHOW COLLATION LIKE &lsquo;utf8_%&rsquo;;
字符比较规则</p>
<p>MySQL 有4个级别的字符集和比较规则，分别是:
服务器级别
数据库级别
表级别
列级别</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CREATE TABLE 表名 (列的信息)
</span></span><span class="line"><span class="cl">[[DEFAULT] CHARACTER SET 字符集名称] [COLLATE 比较规则名称]
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CREATE TABLE 表名(
</span></span><span class="line"><span class="cl">列名 字符串类型 [CHARACTER SET 字符集名称] [COLLATE 比较规则名称], 其他列...
</span></span><span class="line"><span class="cl">);
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="innodb">InnoDB</h3>
<p>而我们知道读写磁盘的速度非常慢，和内存读写差了几个数量级，所以当我 们想从表中获取某些记录时， InnoDB 存储引擎需要一条一条的把记录从磁盘上读出来么?不，那样会慢死，
InnoDB 采取的方式是:将数据划分为若干个页，以页作为磁盘和内存之间交互的基本单位，InnoDB中页的大小 一般为 16 KB。也就是在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中的16KB 内容刷新到磁盘中。</p>
<p>InnoDB 存储引擎的大叔们到现在为止设计了4种不同类型的 行格式 ，分别是 Compact 、 Redundant 、
Dynamic 和 Compressed 行格式</p>
<p><img loading="lazy" src="./mysql-innodb-compact.png" alt="mysql-innodb-compact"  />
</p>
<p>变长字段列表</p>
<ol>
<li>假设某个字符集中表示一个字符最多需要使用的字节数为 W ，也就是使用 SHOW CHARSET 语句的结果中的 Maxlen 列，比方说 utf8 字符集中的 W 就是 3 ， gbk 字符集中的 W 就是 2 ， ascii 字符集中的 W 就是 1。</li>
<li>对于变长类型 VARCHAR(M) 来说，这种类型表示能存储最多 M 个字符(注意是字符不是字节)，所以这个类 型能表示的字符串最多占用的字节数就是 M×W 。</li>
<li>假设它实际存储的字符串占用的字节数是 L 。</li>
</ol>
<p>如果该可变字段允许存储的最大字节数( M×W )超过255字节并且真实存储的字节数( L ) 超过127字节，则使用2个字节，否则使用1个字节。</p>
<p>NULL 值列表</p>
<p>如果表中没有允许存储 NULL 的列，则 NULL 也不存在了，否则将每个允许存储 NULL 的列对应一个
二进制位，二进制位按照列的顺序逆序排列，二进制位表示的意义如下: 二进制位的值为 1 时，代表该列的值为 NULL 。
二进制位的值为 0 时，代表该列的值不为 NULL 。</p>
<p><img loading="lazy" src="./mysql-real-data-auto-hide-col.png" alt="mysql-real-data-auto-hide-col"  />
</p>
<p>InnoDB 数据页的7个组成部分，知道了各个数据页可以组成一个 双向链表 ，而每个数据页 中的记录会按照主键值从小到大的顺序组成一个 单向链表 ，每个数据页都会为存储在它里边儿的记录生成一个
页目录 ，在通过主键查找某条记录的时候可以在 页目录 中使用二分法快速定位到对应的槽，然后再遍历该槽对 应分组中的记录即可快速找到指定的记录</p>
<p><img loading="lazy" src="./mysql-how-to-run-innodb-page-find.png" alt="mysql-how-to-run-innodb-page-find"  />
</p>
<p>我们必须通过一些诸如记录移动的操作来始终保 证这个状态一直成立:下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值。这个过程 我们也可以称为 页分裂 。</p>
<p><img loading="lazy" src="./mysql-how-to-run-page-divide.png" alt="mysql-how-to-run-page-divide"  />
</p>
<p>聚簇索引, 数据索引</p>
<p><img loading="lazy" src="./mysql-how-run-primary-key-index.png" alt="mysql-how-run-primary-key-index"  />
</p>
<p>二级索引</p>
<p><img loading="lazy" src="./mysql-how-run-primary-second-index.png" alt="mysql-how-run-primary-second-index"  />
</p>
<p>联合索引</p>
<p><img loading="lazy" src="./union-index.png" alt="union-index"  />
</p>
<ul>
<li>对于同一个联合索引来说，虽然对多个列都进行范围查找时只能用到最左边那个索引列，但是如果左边的列是精
确查找，则右边的列可以进行范围查找</li>
</ul>
<p>回表的代理</p>
<p><strong>需要回表的记录越多，使用二级索引的性能就越低，</strong> 甚至让某些查询宁愿使用全表扫描也不使用 二级索引 。比 方说 name 值在 Asa ~ Barlow 之间的用户记录数量占全部记录数量90%以上，那么如果使用
idx_name_birthday_phone_number 索引的话，有90%多的 id 值需要回表，这不是吃力不讨好么，还不如直接去 扫描聚簇索引(也就是全表扫描)。</p>
<p>覆盖索引</p>
<p>查询列表只包含索引列, 无需回表</p>
<h4 id="索引优化项">索引优化项</h4>
<ul>
<li>只为用于搜索、排序或分组的列创建索引</li>
<li>为列的基数大的列创建索引 (基数为集合中不同的个数)</li>
<li>索引列的类型尽量小</li>
<li>可以只对字符串值的前缀建立索引</li>
<li>只有索引列在比较表达式中单独出现才可以适用索引</li>
<li>为了尽可能少的让 聚簇索引 发生页面分裂和记录移位的情况，建议让主键拥有 AUTO_INCREMENT 属性。 定位并删除表中的重复和冗余索引</li>
<li>尽量使用 覆盖索引 进行查询，避免 回表 带来的性能损耗。</li>
</ul>
<h2 id="mysql-的数据目录">MySQL 的数据目录</h2>
<ul>
<li>一个库一个文件夹</li>
<li>frm 描述表结构的文件</li>
<li>ibd 独立表空间描述文件</li>
</ul>
<p>系统数据库</p>
<ul>
<li>mysql</li>
</ul>
<p>这个数据库贼核心，它存储了MySQL的用户账户和权限信息，一些存储过程、事件的定义信息，一些运行过 程中产生的日志信息，一些帮助信息以及时区信息等。</p>
<ul>
<li>information_schema</li>
</ul>
<p>这个数据库保存着MySQL服务器维护的所有其他数据库的信息，比如有哪些表、哪些视图、哪些触发器、哪 些列、哪些索引吧啦吧啦。这些信息并不是真实的用户数据，而是一些描述性信息，有时候也称之为元数 据。</p>
<ul>
<li>performance_schema</li>
</ul>
<p>这个数据库里主要保存MySQL服务器运行过程中的一些状态信息，算是对MySQL服务器的一个性能监控。 包括统计最近执行了哪些语句，在执行过程的每个阶段都花费了多长时间，内存的使用情况等等信息。</p>
<ul>
<li>sys</li>
</ul>
<p>这个数据库主要是通过视图的形式把 information_schema 和 performance_schema 结合起来，让程序员可以
更方便的了解MySQL服务器的一些性能信息。</p>
<h2 id="join">JOIN</h2>
<p>笛卡尔积</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select * from t1, t2
</span></span></code></pre></td></tr></table>
</div>
</div><p>连接过程</p>
<ol>
<li>选取代价的表, 作为驱动表, 先获取到查询结果</li>
<li>拿着驱动表获取到的数据, 到 被驱动表 中查询数据</li>
</ol>
<p><strong>驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集</strong>, 产生了 外连接 和 内连接</p>
<ul>
<li>内连接 ( INNER JOIN)</li>
</ul>
<p>驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果 集，我们上边提到的连接都是所谓的 内连接 。</p>
<ul>
<li>外连接 ( RIGHT JOIN, LEFT JOIN )</li>
</ul>
<p>驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。</p>
<p>在 MySQL 中，根据选取驱动表的不同，外连接仍然可以细分为2种:</p>
<ul>
<li>左外连接 选取左侧的表为驱动表。</li>
<li>右外连接 选取右侧的表为驱动表。</li>
</ul>
<p>连接中的 where 和 ON</p>
<p>不想把驱动表的所有的数据显示到结果集合中, 产生了 where 和 on</p>
<ul>
<li>where 会过滤所有不符合的记录</li>
<li>on 当外连接的时候, 会显示没有匹配的数据. 在内连接中 where 等价 on. on 被成为连接条件</li>
</ul>
<p>连接的实现方式</p>
<ol>
<li>嵌套循环连接</li>
<li>利用索引加速连接</li>
<li>基于块的嵌套循环连接 (批量驱动表数据)</li>
</ol>
<p>查看表的统计信息</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">SELECT * FROM mysql.innodb_table_stats;
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select * from mysql.innodb_index_stats 
</span></span></code></pre></td></tr></table>
</div>
</div><p>子查询结果集分类</p>
<ol>
<li>标量  单一值 <code>SELECT (SELECT m1 FROM t1 LIMIT 1);</code></li>
<li>行子查询 单一多个值 <code>SELECT * FROM t1 WHERE m1 = (SELECT MIN(m2) FROM t2);</code></li>
<li>列子查询 一列 <code>SELECT * FROM t1 WHERE m1 IN (SELECT m2 FROM t2);</code></li>
<li>表子查询  <code>SELECT * FROM t1 WHERE (m1, n1) IN (SELECT m2, n2 FROM t2);</code></li>
</ol>
<h3 id="事务">事务</h3>
<ol>
<li>原子性</li>
<li>隔离性</li>
<li>一致性 (提供 check 校验) 通过其他三点保证</li>
<li>持久性</li>
</ol>
<h3 id="redo">redo</h3>
<ol>
<li>体积小, 页码, 偏移量, 修改值</li>
<li>顺序写入</li>
</ol>
<h3 id="mvcc">MVCC</h3>
<p>事物并发问题</p>
<ol>
<li>脏读, 读到其他事务未提交的数据 (其他事务进行到一半)</li>
<li>脏写, 写到其他事务未提交的数据</li>
<li>不可重复读, 本事务第一次读到A值, 其他事务修改并提交B值, 本事务再读到B值 (不能重复读取到事务开始时的A值)</li>
<li>幻读, 事务开始后, 第二次范围查询的值与第一次范围查询不一致 ( 第一次查询AC, 其他事务插入B, 第二次查询 ABC)o</li>
</ol>
<p>MySQL 的隔离等级</p>
<ol>
<li>Read Uncommitted</li>
<li>Read committed 以提交读</li>
<li>Repeadted Read</li>
<li>Serializable</li>
</ol>
<ul>
<li>trx_id</li>
<li>roll_pointer</li>
</ul>
<h3 id="锁">锁</h3>
<ul>
<li>一致性读 ( 普通读 )</li>
<li>锁定读
<ul>
<li>S 共享锁 <code>select ... lock in share mode;</code></li>
<li>X 排他锁 <code>select ... for update;</code></li>
</ul>
</li>
</ul>
<p>意向锁: 当要对行加锁时, 在表上面加的锁, 方便快速知道该表是否可能直接加表锁.</p>
<p>IS、IX锁是表级锁，它们的提出仅仅为了在之后加表级别的S锁和X锁时可以快速判断表中的记录是否 被上锁，以避免用遍历的方式来查看表中有没有上锁的记录，也就是说其实IS锁和IX锁是兼容的，IX锁和IX锁是 兼容的</p>
<p>行级锁</p>
<ul>
<li><code>LOCK_REC_NOT_GAP</code></li>
<li><code>GAP Locks</code>  锁住当前记录的前方数据间隙, 用于解决幻读问题(与MVCC同时起作用). 引入两个伪记录 <code>Infimun, Supermum</code></li>
<li><code>Next-Key Locks</code> 记录锁 + 间隙锁</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>酥油</title>
      <link>https://ynikl.github.io/books/shuyou/</link>
      <pubDate>Sun, 18 Jun 2023 14:34:11 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/shuyou/</guid>
      <description>原先打算凭借着满腔热血骑着摩托车去体验一趟318吧. 但是, 读了这本书之后, 感觉藏地离我们还是很远. 不管是318, 219, 只在公路上驰骋, 就还是无法体验到他们生活, 观光客. 书中深入藏地, 让人感受到了藏民的信仰强烈. 给我印象最为深刻和触动的还是所画被挥刀砍废画画的手, 后面又遁入了佛门. 当人们越绝望的时候, 就会越需要信仰(&amp;hellip;)
摘抄 ◆ 第十五章 阿嘎的神
事实上，作为佛的授意者，活佛之所以受到人们的爱戴，不单从精神上他能给人指引光明，生活中，也在切实可靠地扶危济困，才会叫人由衷地敬爱。
◆ 第十六章 多农喇嘛
就这样四张大花脸站在院落里，开荒一样的，把多年不现人气的荒疏院落灌输进温暖，欢笑，明亮得可以捧起来的，那么多的欢笑。
◆ 第十七章 福气
兴奋的青年，举止间佯装得漫无目标，哈达却充满情意地在空中抖动，然后即以一种悠扬而坚定的姿态，落进我的怀里。
◆ 第三十三章 上路
女娃也不能直接从大路进入天葬场，我们得从寺庙背面绕过一座山进入。那个山不高，道路却极其曲折
是的，人的生命内容除了日常生活之外，最需要做的是安顿灵魂，或说精神。事实上灵魂如果无所依靠，那的确会叫人彷徨。
◆ 第四十二章 第一口血
最大的孤独，是你的热情掉进周围的寂寞世界。你说什么，你唱什么，你呐喊什么，你即使自寻短见，都是你一个人。大地无动于衷。
◆ 第四十七章 神医
但视觉上的光明怎么能够消除我精神上的恐惧呢。除非我能强迫自己睡过去，要不这个夜晚将要怎样捱过？
◆ 第五十二章 酥油里的孩子
老师，理想跟愿望有一点小小的区别。理想是对于未来事物的合理想象；愿望是希望将来能够达到某种目标的想法！”
◆ 第五十五章 雪山
有时候分离就是拖着沉重的情感逃亡，送别就是拱手相让。是的，
◆ 第五十九章 酥油病
沉厚的电梯铁门在我们面前缓缓张开。狭小逼仄的空间，车轮进入电梯时与凹槽碰撞发出的震动，叫我的心也在相应震动。金属和金属撞击的时候，血和肉也在撞击。推手术车的护士脸上紧蒙蓝色口罩，眼睛雪亮，表情严肃，步步紧守，像是我会逃跑
◆ 第七十七章 闭关
抬起眼，我不知道要把目光往哪里放。望天，天巨大空虚，没有尽头。人在它面前，蝼蚁不如。风很大，也很紧，抓住头发乱扯，像一群发狂的蝙蝠，要抓破人的皮肉，叫身体流血。 一头瘫坐在地，动不得身，想不起什么。没有那种漫浪或者悲伤的回忆。只是呆呆地坐着</description>
      <content:encoded><![CDATA[<p>原先打算凭借着满腔热血骑着摩托车去体验一趟318吧. 但是, 读了这本书之后, 感觉藏地离我们还是很远.
不管是318, 219, 只在公路上驰骋, 就还是无法体验到他们生活, 观光客.
书中深入藏地, 让人感受到了藏民的信仰强烈. 给我印象最为深刻和触动的还是所画被挥刀砍废画画的手,
后面又遁入了佛门. 当人们越绝望的时候, 就会越需要信仰(&hellip;)</p>
<h2 id="摘抄">摘抄</h2>
<p>◆ 第十五章 阿嘎的神</p>
<blockquote>
<blockquote>
<p>事实上，作为佛的授意者，活佛之所以受到人们的爱戴，不单从精神上他能给人指引光明，生活中，也在切实可靠地扶危济困，才会叫人由衷地敬爱。</p>
</blockquote>
</blockquote>
<p>◆ 第十六章 多农喇嘛</p>
<blockquote>
<blockquote>
<p>就这样四张大花脸站在院落里，开荒一样的，把多年不现人气的荒疏院落灌输进温暖，欢笑，明亮得可以捧起来的，那么多的欢笑。</p>
</blockquote>
</blockquote>
<p>◆ 第十七章 福气</p>
<blockquote>
<blockquote>
<p>兴奋的青年，举止间佯装得漫无目标，哈达却充满情意地在空中抖动，然后即以一种悠扬而坚定的姿态，落进我的怀里。</p>
</blockquote>
</blockquote>
<p>◆ 第三十三章 上路</p>
<blockquote>
<blockquote>
<p>女娃也不能直接从大路进入天葬场，我们得从寺庙背面绕过一座山进入。那个山不高，道路却极其曲折</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>是的，人的生命内容除了日常生活之外，最需要做的是安顿灵魂，或说精神。事实上灵魂如果无所依靠，那的确会叫人彷徨。</p>
</blockquote>
</blockquote>
<p>◆ 第四十二章 第一口血</p>
<blockquote>
<blockquote>
<p>最大的孤独，是你的热情掉进周围的寂寞世界。你说什么，你唱什么，你呐喊什么，你即使自寻短见，都是你一个人。大地无动于衷。</p>
</blockquote>
</blockquote>
<p>◆ 第四十七章 神医</p>
<blockquote>
<blockquote>
<p>但视觉上的光明怎么能够消除我精神上的恐惧呢。除非我能强迫自己睡过去，要不这个夜晚将要怎样捱过？</p>
</blockquote>
</blockquote>
<p>◆ 第五十二章 酥油里的孩子</p>
<blockquote>
<blockquote>
<p>老师，理想跟愿望有一点小小的区别。理想是对于未来事物的合理想象；愿望是希望将来能够达到某种目标的想法！”</p>
</blockquote>
</blockquote>
<p>◆ 第五十五章 雪山</p>
<blockquote>
<blockquote>
<p>有时候分离就是拖着沉重的情感逃亡，送别就是拱手相让。是的，</p>
</blockquote>
</blockquote>
<p>◆ 第五十九章 酥油病</p>
<blockquote>
<blockquote>
<p>沉厚的电梯铁门在我们面前缓缓张开。狭小逼仄的空间，车轮进入电梯时与凹槽碰撞发出的震动，叫我的心也在相应震动。金属和金属撞击的时候，血和肉也在撞击。推手术车的护士脸上紧蒙蓝色口罩，眼睛雪亮，表情严肃，步步紧守，像是我会逃跑</p>
</blockquote>
</blockquote>
<p>◆ 第七十七章 闭关</p>
<blockquote>
<blockquote>
<p>抬起眼，我不知道要把目光往哪里放。望天，天巨大空虚，没有尽头。人在它面前，蝼蚁不如。风很大，也很紧，抓住头发乱扯，像一群发狂的蝙蝠，要抓破人的皮肉，叫身体流血。
一头瘫坐在地，动不得身，想不起什么。没有那种漫浪或者悲伤的回忆。只是呆呆地坐着</p>
</blockquote>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>返读 Coolshell 记录</title>
      <link>https://ynikl.github.io/blog/reading-from-coolshell/</link>
      <pubDate>Fri, 26 May 2023 18:42:36 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/reading-from-coolshell/</guid>
      <description>返向读一遍陈皓老师在 coolshell 上发布的文档. 并简单做一下读后记录.
ETCD的内存问题
一个清晰的排查 Etcd 内存占用过大问题 一把梭：REST API 全用 POST
RESTFul 为通用惯用标准, 切有各大厂的指导文档背书. 身为程序员要对自己的代码负责, 有程序员的操守, 反对&amp;quot;优雅不能当饭吃&amp;quot; 反对讨论问题使用: 讨论都是在主观的“我觉得”，“我认为”，“感觉还好”…… TCP 的那些事儿 (上) tcp_syncookies 可以用于防止 sync 攻击 seq_num 是根传输字节相关 ISN 的与一个假时钟相关, 每4微妙加一 TCP 的那些事儿（下）
我做系统架构的一些原则
完备性比性能更重要 控制逻辑进行收口 服从标准, 规范, 最佳实践 双向显示文本
如何做一个有质量的技术分享
描述好问题 怎么做, 为什么 最佳实践和方法总结 GO编程模式：PIPELINE
在今天，流式处理，函数式编程，以及应用网关对微服务进行简单的API编排， 其实都是受pipeline这种技术方式的影响，Pipeline这种技术在可以很容易的把代码按单一 职责的原则拆分成多个高内聚低耦合的小模块，然后可以很方便地拼装起来去完成比较复杂 的功能。
golang 的 Pipeline 代码大家都会写, 但是我一直没有思考过为什么要这样子写.
GO编程模式：委托和反转控制
把控制逻辑与业务逻辑分层 未完待续&amp;hellip;</description>
      <content:encoded><![CDATA[<p>返向读一遍陈皓老师在 coolshell 上发布的文档. 并简单做一下读后记录.</p>
<p><a href="https://coolshell.cn/articles/22242.html">ETCD的内存问题</a></p>
<ul>
<li>一个清晰的排查 Etcd 内存占用过大问题</li>
</ul>
<p><a href="https://coolshell.cn/articles/22173.html">一把梭：REST API 全用 POST</a></p>
<ul>
<li>RESTFul 为通用惯用标准, 切有各大厂的指导文档背书.</li>
<li>身为程序员要对自己的代码负责, 有程序员的操守, 反对&quot;优雅不能当饭吃&quot;</li>
<li>反对讨论问题使用: 讨论都是在主观的“我觉得”，“我认为”，“感觉还好”……</li>
</ul>
<p><a href="https://coolshell.cn/articles/11564.html">TCP 的那些事儿 (上) </a></p>
<ul>
<li>tcp_syncookies 可以用于防止 sync 攻击</li>
<li>seq_num 是根传输字节相关</li>
<li>ISN 的与一个假时钟相关, 每4微妙加一</li>
</ul>
<p><a href="https://coolshell.cn/articles/11609.html">TCP 的那些事儿（下）</a></p>
<p><a href="https://coolshell.cn/articles/21672.html">我做系统架构的一些原则</a></p>
<ul>
<li>完备性比性能更重要</li>
<li>控制逻辑进行收口</li>
<li>服从标准, 规范, 最佳实践</li>
</ul>
<p><a href="https://coolshell.cn/articles/21649.html">双向显示文本</a></p>
<p><a href="https://coolshell.cn/articles/21589.html">如何做一个有质量的技术分享</a></p>
<ul>
<li>描述好问题</li>
<li>怎么做, 为什么</li>
<li>最佳实践和方法总结</li>
</ul>
<p><a href="https://coolshell.cn/articles/21228.html">GO编程模式：PIPELINE</a></p>
<blockquote>
<p>在今天，流式处理，函数式编程，以及应用网关对微服务进行简单的API编排，
其实都是受pipeline这种技术方式的影响，Pipeline这种技术在可以很容易的把代码按单一
职责的原则拆分成多个高内聚低耦合的小模块，然后可以很方便地拼装起来去完成比较复杂
的功能。</p>
</blockquote>
<p>golang 的 Pipeline 代码大家都会写, 但是我一直没有思考过为什么要这样子写.</p>
<p><a href="https://coolshell.cn/articles/21214.html">GO编程模式：委托和反转控制</a></p>
<ul>
<li>把控制逻辑与业务逻辑分层</li>
</ul>
<p>未完待续&hellip;</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang 100 mistake 的简单读书笔记</title>
      <link>https://ynikl.github.io/blog/golang-100mistake/</link>
      <pubDate>Thu, 25 May 2023 12:10:53 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-100mistake/</guid>
      <description>variable shadowing init 弊端
初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序 影响测试， 会在测试之前执行 获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试） 什么时候使用
避免错误产生没有err 不会产生全局变量 getters and setters 如果只是简单获取值的话，就不应该用
方法命名
获取值 Balance 而不是 （ GetBalance) 设置值 SetBalance interface pollution interface 的价值
通用的方法（ 如排序） 解耦 限制实体行为（仅提供特定方法） 只要在当我们真正用到的时候才去创建
we should create an interface when we need it, not when we foresee that we could need it
interface 抽象 是通过发现的，而不是通过创造的
生产端接口声明，与实现放在同一个包中 消费端接口声明，与使用interface的放在同一个包中 Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。
准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。
return interfaceBe conservative in what you do, be liberal in fr Be conservative in what you do, be liberal in what you accept from others.</description>
      <content:encoded><![CDATA[<h3 id="variable-shadowing">variable shadowing</h3>
<h3 id="init">init</h3>
<p>弊端</p>
<ol>
<li>初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序</li>
<li>影响测试， 会在测试之前执行</li>
<li>获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试）</li>
</ol>
<p>什么时候使用</p>
<ol>
<li>避免错误产生没有err</li>
<li>不会产生全局变量</li>
</ol>
<h3 id="getters-and-setters">getters and setters</h3>
<p>如果只是简单获取值的话，就不应该用</p>
<p>方法命名</p>
<ul>
<li>获取值 Balance 而不是 （ GetBalance)</li>
<li>设置值 SetBalance</li>
</ul>
<h3 id="interface-pollution">interface pollution</h3>
<p>interface 的价值</p>
<ul>
<li>通用的方法（ 如排序）</li>
<li>解耦</li>
<li>限制实体行为（仅提供特定方法）</li>
</ul>
<p>只要在当我们真正用到的时候才去创建</p>
<p>we should create an interface when we need it, not when we foresee that we could need it</p>
<p>interface 抽象 是通过发现的，而不是通过创造的</p>
<ul>
<li>生产端接口声明，与实现放在同一个包中</li>
<li>消费端接口声明，与使用interface的放在同一个包中</li>
</ul>
<p>Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。</p>
<p>准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。</p>
<h3 id="return-interfacebe-conservative-in-what-you-do-be-liberal-in-fr">return interfaceBe conservative in what you do, be liberal in fr</h3>
<p>Be conservative in what you do, be liberal in what you accept from others.</p>
<p>对自己依赖别人的功能保守，对自己赋予别人的能力保持开放</p>
<ul>
<li>尽量接收 interface</li>
<li>尽量返回 结构体</li>
</ul>
<p>正常 consumer 定义接口， 就会造成循环引用</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/12365435/1674099857741-bb77c007-cc4e-4f15-abd7-16bf11de95c5.png" alt=""  />
</p>
<p>如果 是现房new 的时候返回 interface 就会变成，由实现方来限制了限制了客户端使用接口消费的抽象组合方式</p>
<h3 id="confuse-generics">Confuse Generics</h3>
<p>限制 constraint， 可以是一下两种</p>
<ul>
<li>接口</li>
<li>任意类型</li>
</ul>
<p>~int， 限制 底层类型</p>
<h3 id="embbding">embbding</h3>
<p>错误使用将底层的方法公开出来</p>
<p>type client struct {
sync.Mutex // 错误地将 Lock() 和 Unlock() 方法暴露给客户端了
protectData map[string]string
}</p>
<p>Functional Options Parttern</p>
<p>定义闭包声明函数，更新和修改配置， 有几个好处</p>
<ul>
<li>使用默认配置时， 避免声明空的 cfg 参数结构体</li>
<li>通过闭包延迟 err 的处理， 聚合在客户端内部</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type options struct {
</span></span><span class="line"><span class="cl">    port *int
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">type Option func(opt options) error 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func WithPort(port int) Option {
</span></span><span class="line"><span class="cl">    return func(opt options) error {
</span></span><span class="line"><span class="cl">        opt.port = port
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func NewServer(c client, opts ...Option) {
</span></span><span class="line"><span class="cl">	var cfg options
</span></span><span class="line"><span class="cl">    for _, op := range opts {
</span></span><span class="line"><span class="cl">       	err := op(cfg)
</span></span><span class="line"><span class="cl">        if err != nil {
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func main() {
</span></span><span class="line"><span class="cl">    NewServer(http.DefaultClient, WihtPort(8080))
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="12-project-organization">12 Project Organization</h3>
<p><a href="https://github.com/golang-standards/project-layout">project-layout</a></p>
<p>We should minimize what should be exported as much as possible to reduce the coupling between pack-<br>
ages and keep unnecessary exported elements hidden.</p>
<p>包的成员，非必要不公开。</p>
<h3 id="13-utility-package">13 Utility Package</h3>
<p>创建类似与 common ， utility, base， shared 等没有意义的包名，共享一些工具类代码。</p>
<h3 id="14-ignoring-package-name-collisions">14 Ignoring Package name collisions</h3>
<p>避免包名和变量名冲突</p>
<ul>
<li>使用不同的变量名<code>redisClient</code></li>
<li>对引用的包取别名 <code>redisPkg</code></li>
</ul>
<h3 id="15-missing-code-documentation">15 Missing code documentation</h3>
<ol>
<li>exported 的公开变量 都需要进行文档备注</li>
<li><code>Deprecated: //</code></li>
<li>Package 的说明应该在 <code>doc.go</code> 文件 <code>// Package 包名</code>开头</li>
<li>与 Go 代码声明有空行间隔 会被忽略</li>
</ol>
<h3 id="16-not-using-linters">16 Not using linters</h3>
<h3 id="17-creating-confusion-with-octal-literal">17 Creating confusion with octal literal</h3>
<p>错误使用 010， 表示八进制</p>
<ul>
<li>0b 二进制</li>
<li>0x 十六进制</li>
<li>0i 虚数</li>
</ul>
<h3 id="18-integer-overflow">18 Integer Overflow</h3>
<p>整形溢出， 多注意</p>
<h3 id="19-floating-points">19 floating points</h3>
<h3 id="20-slice-length-and-capactity">20 slice length and capactity</h3>
<p>the slice length is the number of available elements in the slice,<br>
whereas the slice capacity is the number of elements in the backing arra</p>
<p>长度是 slice 可用的长度， 容量是slice底层数据的长度</p>
<h3 id="22-slice-empty-and-nil">22 slice empty and nil</h3>
<p>slice nil</p>
<ul>
<li>不需要分配内存， nil slice 是 empty slice</li>
</ul>
<p>empty slice</p>
<ul>
<li>长度等于 0</li>
</ul>
<h3 id="23-check-slice-by-nil">23 check slice by nil</h3>
<p>通过 <code>list == nil</code> 判断 slice 是否为空，是错误的</p>
<p>要通过长度判断 <code>len(list)</code>判断 slice 是否为空。</p>
<h3 id="24-copy-slice">24 copy slice</h3>
<p>赋值数量为最小两个slice 之间最小长度</p>
<p>复制之前应该，注意复制的目标数组的长度</p>
<p>src := []int{0, 1, 2}
dst := make([]int, len(src))
copy(dst, src)
fmt.Println(dst)</p>
<p>不同的复制方式</p>
<p>src := []int{0, 1, 2}
dst := append([]int(nil), src&hellip;)</p>
<h3 id="25-切片更新添加数据副作用">25 切片更新添加数据副作用</h3>
<p>s1 := []int{1,2,3}
s2 := s1[1:2]
s3 := append(s2, 10}</p>
<p>// Output:
// s1 [1, 2, 10]</p>
<h3 id="26-slice-导致内存泄露">26 slice 导致内存泄露</h3>
<p>使用切变承接输入的大数据数组， 获取小部分数据。</p>
<p>小数据的slice， 仍然会指向大数组的空间，内存占用仍会较高。</p>
<p>需要重新声明 slice， 使用copy 复制需要的数据。</p>
<p>GC 不会回收 slice 已经分配但没有使用的空间。</p>
<h3 id="27--map-初始化">27  Map 初始化</h3>
<p><code>load factor</code>
<code>overflowed</code></p>
<p>make(map, hint_size)
初始化 map, 带预计大小, 可以避免map 在插入的时候, 需要复制.</p>
<ul>
<li>获取足够的内存</li>
<li>重新平衡分配元素到各个bucket</li>
</ul>
<h3 id="28-map-memory-leaks">28 map memory leaks</h3>
<p><code>A map can only grow and have more buckets; it never shrinks.</code></p>
<p>GC 可以回收 map 的元素, 但是无法回收 map 本身占用的空间大小.</p>
<p>解决方法</p>
<ul>
<li>创建副本, 创建一个新的map, 复制现有的值, 释放原有的map</li>
<li>map的value 存放 指针, 缩小每一个空的bucket 占用的空间大小 (指针空间 8bytes or 4bytes)</li>
</ul>
<h3 id="29-值比较">29 值比较</h3>
<p> Booleans—Compare whether two Booleans are equal.<br>
 Numerics (int, float, and complex types)—Compare whether two numerics are equal.</p>
<ul>
<li>
<p> Strings—Compare whether two strings are equal.</p>
</li>
<li>
<p>  Channels—Compare whether two channels were created by the same call to</p>
<p>make or if both are nil.</p>
</li>
<li>
<p>  Interfaces—Compare whether two interfaces have identical dynamic types and</p>
<p>equal dynamic values or if both are nil.</p>
</li>
<li>
<p>  Pointers—Compare whether two pointers point to the same value in memory or</p>
<p>if both are nil.</p>
</li>
<li>
<p>  Structs and arrays—Compare whether they are composed of similar types.</p>
</li>
</ul>
<p>对比方法</p>
<ul>
<li>简单通过 <code>==</code>  对比, 无法处理复杂类型</li>
<li><code>reflect.DeepEuqal</code> 有性能瓶颈</li>
<li>自己实现对比方法, 参考已经有标准库, 如<code>bytes.Compare</code></li>
</ul>
<h3 id="30-copy-value-in-range">30 copy value in range</h3>
<p>在 <code>range</code> 遍历的过程中, 是值复制</p>
<h3 id="31-range-expresion-evaluated">31 range expresion evaluated</h3>
<p><code>for i, v := range exp</code>
exp 针对不同类型表达式, 会在 开始执行 loop 之前, 对exp 进行复制</p>
<h4 id="slice">slice</h4>
<p>range 会在开始range的时候, 计算slice 的长度和容量, 并创建一个临时的 slice</p>
<p>![[Pasted image 20230221093451.png]]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">s := []int{0, 1, 2}
</span></span><span class="line"><span class="cl">for i := 0; i &lt; len(s); i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    s = append(s, 10)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>会无限执行下去, 因为 <code>len</code> 是每次执行的时候都会计算一次</p>
<h4 id="channel">channel</h4>
<p>与slice 一样, 同样会在开始的时候为 channel 创建一个临时变量.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ch := ch1
</span></span><span class="line"><span class="cl">for v := range ch {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    fmt.Println(v)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ch = ch2 }
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个在range 这替换的动作是无效的, range 的仍然是ch1</p>
<h4 id="array">array</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [3]int{0, 1, 2}
</span></span><span class="line"><span class="cl">for i, v := range a {
</span></span><span class="line"><span class="cl">    a[2] = 10
</span></span><span class="line"><span class="cl">    if i == 2 {
</span></span><span class="line"><span class="cl">        fmt.Println(v)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>会对 a 整个数据进行复制, 输出是2, 原数组不变</p>
<p>修改原数组方案</p>
<ul>
<li>使用 index , 访问和修改数据</li>
<li>对数据取指针方法 <code>for i, v := range &amp;a</code></li>
</ul>
<h3 id="32-range-过程中使用-遍历元素的指针">32 range 过程中使用 遍历元素的指针</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for _, customer := range customers {
</span></span><span class="line"><span class="cl">        s.m[customer.ID] = &amp;customer
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>&amp;customer</code> 指向的是 range 复制出来的内存</p>
<h3 id="33-对-map-数据的错误消费">33 对 map 数据的错误消费</h3>
<ol>
<li>依赖 map 的顺序， map 的数据是无序的</li>
<li>在遍历过程中继续插入新的数据， 结果是不可预测的。有可能会被遍历到，也有可能会被跳过</li>
</ol>
<h3 id="34-break-层的错误理解">34 break 层的错误理解</h3>
<p>break 对 for, select, switch 三个语句的最内层生效</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for i := 0; i &lt; 5; i++ {
</span></span><span class="line"><span class="cl">	switch i {
</span></span><span class="line"><span class="cl">	case 2:
</span></span><span class="line"><span class="cl">	break
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>没有中断， 结果正常遍历。</p>
<p>可以使用 Label 达到中断 for 的方式， 标准库也经常采用该种写法。</p>
<h3 id="35-在-for-中使用-defer">35 在 for 中使用 defer</h3>
<h3 id="36-没有理解-rune">36 没有理解 rune</h3>
<p>string 是一个结构体, 有两个字段</p>
<ul>
<li>A pointer to an immutable byte sequence</li>
<li>长度</li>
</ul>
<p>Unicode 是字符集
Utf-8 是编码方式</p>
<p>Rune 是 Unicode 的字符集表示，相当于一个字符, golang 使用utf-8编码方式， 所以一个rune 是1-4个字节 bytes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type rune = int32
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>len()</code>函数返回的是 bytes 的长度</p>
<h3 id="37-对-string-的错误遍历">37 对 string 的错误遍历</h3>
<p>获取字符串的字符个数 <code>utf8.RuneCountInString</code></p>
<p>获取字符串的第i个字符</p>
<ol>
<li>如果是纯ascii码字符串，直接通过str[i]获取。 获取出来的是 bytes 编码需要转成字符</li>
<li>如果存在非ascii 字符
<ol>
<li>通过 <code>for i, c := range str</code>遍历获取到第 i 个 rune 字符， 和 c 字符编码</li>
<li>通过索引获取， 需要先强制转化成 <code>[]rune(str)[i]</code> 可以直接获取字符串的第 i 个 rune 字符</li>
</ol>
</li>
</ol>
<h3 id="38-对-trimright--trimsuffix-混淆">38 对 TrimRight / TrimSuffix 混淆</h3>
<p>strings.TrimRight 是从右到开始移除所有符合的字符集，直到遇到第一个不符合的字符
TrimSuffix 是移除整个字符串</p>
<h3 id="39-使用--字符串拼接">39 使用 += 字符串拼接</h3>
<p>使用 += 拼接一系列字符串，会造成内存分配频繁，因为每一个字串都是不变的。
推荐使用 <code>strings.Builder</code></p>
<h3 id="40-冗余转化成字符串">40 冗余转化成字符串</h3>
<p>所有的字符串操作 strings 包， 在 bytes 包都会有相对应的替换方法，没有必要将 bytes 转化成 string 在进行操作。</p>
<h3 id="41-substring-导致内存泄露">41 subString 导致内存泄露</h3>
<p>substring 生成的 新字符串与旧字符串指向同一块内存，原理同slice</p>
<h3 id="42-方法值接受者和指针接收者">42 方法值接受者和指针接收者</h3>
<p>pointer receiver</p>
<ul>
<li>需要修改对象数据</li>
<li>接收者包含不能copy的对象，如 sync</li>
<li>接收者为大对象</li>
</ul>
<p>value receiver</p>
<ul>
<li>不修改接收者</li>
<li>接收者为 map, channel</li>
<li>接收者为小对象， 基础类型</li>
</ul>
<h3 id="43-命名的返回参数">43 命名的返回参数</h3>
<p>用处</p>
<ol>
<li>增加代码可读性， 如果无法增加可读性，就不需要命名</li>
<li>提前初始化变量</li>
<li>使用 naked return 的提前是函数短小，太长的函数会降低可读性，需要一直记住变量</li>
<li>不应改混着使用 naked return 和 带参数return</li>
</ol>
<h3 id="44-返回了未赋值的命名-err">44 返回了未赋值的命名 err</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func name(ctx context.Context) (a,b int, err error) {
</span></span><span class="line"><span class="cl">	if ctx.Err() != nil {
</span></span><span class="line"><span class="cl">	// err is nil
</span></span><span class="line"><span class="cl">	return 0, 0, err
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="45-interface-返回-non-nil">45 interface 返回 non-nil</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func Validate() error {
</span></span><span class="line"><span class="cl">	var m *MutilErrorStruct
</span></span><span class="line"><span class="cl">	return m
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// 返回值 err != nil 永远为true
</span></span></code></pre></td></tr></table>
</div>
</div><p>nil 的结构体， 在返回 interface 的函数之后就永远不等于 nil
![[Pasted image 20230309221827.png]]</p>
<p>解决方案，永远明确地返回 nil</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if m != nil {
</span></span><span class="line"><span class="cl">	return m
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">return nil
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="46-不用使用文件名作为参数">46 不用使用文件名作为参数</h3>
<p>使用 io.Reader 做为参数, 替代文件有两种好处</p>
<ol>
<li>方法的具体实现可以与数据源的类型无关, 文件, 或者http, 或者sock</li>
<li>方便测试, 无法因为测试而创建一堆文件</li>
</ol>
<h3 id="47-defer-参数的计算">47 defer 参数的计算</h3>
<p>defer 在代码执行到的时候会, 立刻使用当前函数的参数的变量值, 包括方法的接收者作为参数.</p>
<h3 id="48-panic">48 panic</h3>
<p>什么时候应该panic</p>
<ul>
<li>a pure programmer error ( 程序员编码错误 )</li>
<li>依赖初始化失败</li>
</ul>
<h3 id="49-error-wrap">49 Error Wrap</h3>
<p>什么时候使用 Error Wrap</p>
<ul>
<li>添加额外的信息</li>
<li>标记为某一特定的错误类型</li>
</ul>
<p>处理的信息的多种选择</p>
<ul>
<li>直接返回错误</li>
<li>自定义错误类型</li>
<li>fmt.Errorf + %w wrap 错误</li>
<li>fmt.Errorf + %v 包含错误文字</li>
</ul>
<p><img loading="lazy" src="https://s2.loli.net/2023/03/21/CPdiq867VhUcAwW.png" alt="错误处理的多种选择"  />
</p>
<h3 id="50-用-as-检查err类型">50 用 as 检查Err类型</h3>
<p>通过 wrap 的 error 需要使用 <code>error.As(err, &amp;targetErrorStruct{})</code> 判断是否为目标结构体</p>
<h3 id="51-errosis">51 erros.Is</h3>
<p>制定 error 错误信息的原则:</p>
<ol>
<li>可以预测的错误使用制定错误变量 <code>ErrFoo = errors.New(&quot;foo&quot;)</code></li>
<li>无法预测的错误,使用指定错误类型 <code>type BarError struct</code></li>
</ol>
<p>使用 <code>error.Is(err, sql.ErrNoRows)</code> 判断错误是否为指定的错误类型.</p>
<h3 id="52-多次处理同一个错误">52 多次处理同一个错误</h3>
<p>一个错误多次重复打日志, 会让调试更加艰难.</p>
<blockquote>
<p>打印错误也是一种错误的处理方式. 所有, 要么选择打印错误, 要么选择向上抛出错误.
不要两者同时.</p>
</blockquote>
<p>向上层函数抛出错误的时候, 需要通过 WrapErr 附加上当前的额外错误信息</p>
<h3 id="53-明确忽略的-error">53 明确忽略的 error</h3>
<p>使用 <code>_</code> 接收返回的error, 明确表示不处理, 错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> _ = funcReturnErr()
</span></span></code></pre></td></tr></table>
</div>
</div><p>建议再加上注释说明为什么不处理函数错误</p>
<h3 id="54-处理-defer-函数返回的错误">54 处理 defer 函数返回的错误</h3>
<p>记得要处理 defer 的函数返回的错误, 至少需要显示忽略</p>
<h3 id="55-并发和并行">55 并发和并行</h3>
<p>并发的重点是可以处理多项事务的设计结构, 并行是多项事务可以同时进行处理.</p>
<blockquote>
<p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.
—Rob Pike</p>
</blockquote>
<p>并发并不代表多件事务真正意义上的&quot;同时进行&quot;, 同时进行是并行, 并发主要处理阻塞的流程
优化</p>
<h3 id="56-并发-不一定更快">56 并发 不一定更快</h3>
<p>过小的切分任务, 会让时间消耗在创建和消费协程上, 并没有真正的提高&quot;并行&quot;能力.</p>
<h3 id="57-通道和互斥锁">57 通道和互斥锁</h3>
<p>通道的底层也是互斥锁.</p>
<p>当协程之间需要传递信息, 或者数据, 使用通道 &ndash; 互斥锁的更高抽象</p>
<h3 id="58-数据竞争data-race-和条件竞争race-condition">58 数据竞争(data race) 和条件竞争(race condition)</h3>
<p>数据竞争:</p>
<p>同时有多个协程同时访问统一块内存, 且至少有一个协程正在写入数据</p>
<p>条件竞争:</p>
<p>事件发生的先后顺序不可控制, 无法控制协程的执行先后顺序, 导致结果不可控.</p>
<h3 id="59-区分任务类型-计算密集或者-io密集型">59 区分任务类型 (计算密集或者 I/O密集型)</h3>
<p>如果是计算密集型, goroutine 的并发上线应该采用 <code>runtime.GOMAXPROCS(0)</code></p>
<p>过多的协程, 可能导致创建过得的 M, 就会出现多个 M 在一个 cpu 核心 中疯狂切换.</p>
<h3 id="60-conetxt">60 Conetxt</h3>
<ul>
<li>Deadline 设置超时时间 <code>context.WithTimeout</code></li>
<li>传递取消消息 <code>context.WithCancel</code></li>
<li>传递值 <code>context.WithValue</code></li>
<li><code>context.Err</code> 会返回解释, 为何<code>context.Done</code>关闭</li>
</ul>
<p>传递值时, key 不直接使用 string 是为了避免, 冲突覆盖.</p>
<blockquote>
<p>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables&rsquo; static type should be a pointer or interface.</p>
</blockquote>
<p>疑惑的时候就使用 <code>context.TODO</code></p>
<blockquote>
<p>When in doubt about which context to use, we should use context.TODO() instead of passing an empty context with context.Background.</p>
</blockquote>
<h3 id="61-传递-context">61 传递 context</h3>
<h3 id="62-关心-goroutine-什么时候停止">62 关心 goroutine 什么时候停止</h3>
<p>关心 goroutine 持有的文件描述符是否被正确的关闭
注意协程持有的资源</p>
<h3 id="63-注意-goroutine-获取循环变量">63 注意 goroutine 获取循环变量</h3>
<h3 id="64-select-是随机-case-先后顺序不保证优先级">64 select 是随机, case 先后顺序不保证优先级.</h3>
<h3 id="65-消息型-channel">65 消息型 channel</h3>
<p>消息型 channel 的数据结构应该使用 <code>make(chan struct{})</code> 空结构体, 编程惯例, 提醒
接收者, 传递的消息是没有任何意义的.</p>
<h3 id="66-使用-nil-channel">66 使用 nil channel</h3>
<p>在使用 select 的时候, 当 channel 已经 close 掉后, 就可以将channel 设置成 <code>nil</code> ,
让该 case 条件进入堵塞状态</p>
<h3 id="67-分清-buffed-and-unbeffed-channel-的使用场景">67 分清 buffed and unbeffed channel 的使用场景</h3>
<h3 id="68-string-format-的副作用">68 string format 的副作用</h3>
<p>如果有协程正在更新 ctx, context的值的话, 就会出现数据竞争, fmt 读取ctx的内部值</p>
<p><code>ctxKey := fmt.Sprintf(&quot;%v&quot;, ctx)</code></p>
<p>fmt 会读取 <code>string()</code> 的方法, 应注意该方法中的读写锁是否会造成死锁.</p>
<h3 id="69-append-的数据竞争">69 append 的数据竞争</h3>
<p>slice 更新和读取不通的index时不会出问题.</p>
<p>map 操作时存在更新, 无论key是否相同有可能产生冲突. 因为, map 的底层是数组, 不同的
key 也有可能指向相同的数组</p>
<h3 id="70">70</h3>
<h3 id="71-wgadd-在协程开启前">71 wg.Add 在协程开启前</h3>
<h3 id="72-sycncond">72 sycn.cond</h3>
<h3 id="73-errgroup">73 errgroup</h3>
<h3 id="74-sync-包不能被复制-要小心值复制">74 sync 包不能被复制, 要小心值复制</h3>
<h3 id="75-timeduration-的时间单位是-纳秒">75 time.Duration 的时间单位是 纳秒</h3>
<p>标准使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1 * time.Second
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="76-timeafte-导致内存泄露">76 time.Afte 导致内存泄露</h3>
<p>方法内部实现的协程, 需要等到时间到了, 才会释放资源, 所以不要在循环中调用.</p>
<h3 id="77-结构体-序列化和反序列化">77 结构体 序列化和反序列化</h3>
<h4 id="结构体嵌套">结构体嵌套</h4>
<p>直接嵌入未命名的结构体, 可能会使用sub embedding struct 的序列化接口方法, 导致bug</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type a struct {
</span></span><span class="line"><span class="cl">ID int 
</span></span><span class="line"><span class="cl">time.Time
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>a 结构体再序列化的时候会使用 <code>time.Time</code> 的<code>MarshalJSON()</code>的方法</p>
<ul>
<li>使用命名结构体接入</li>
<li>重新实现接口方法</li>
</ul>
<h4 id="time-的对比">time 的对比</h4>
<p>time 内部包含 wall clock 和 montonic clock 字段, 返回序列化后的 time 对象, 不包含
montonic clock 直接对比, 会不相同</p>
<blockquote>
<p>The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time.</p>
</blockquote>
<ul>
<li>可以使用 <code>time.Equal</code> 方法</li>
<li>或者使用 <code>Truncate</code> 移除 monotonic clock 数值</li>
</ul>
<h4 id="map">map</h4>
<p><code>map[string]any</code> 数值反序列化后类型都为 float64</p>
<h3 id="78-sql-错误">78 SQL 错误</h3>
<h4 id="sqlopen">sql.Open</h4>
<p><code>sql.Open()</code> 不一定是与数据库服务建立了连接, 具体还是需要看 驱动 实现, 可以通过
ping 方法, 强制建立连接</p>
<h4 id="sql-连接池的配置">sql 连接池的配置</h4>
<p>sql 连接状态分两种</p>
<ul>
<li>使用者</li>
<li>idle 等待使用, 已创建但没有再使用</li>
</ul>
<p>sql 连接池配置</p>
<ul>
<li>SetMaxOpenConns 最大连接数量, 考虑到下游服务的性能</li>
<li>SetMaxIdleConn 在并发高时适当增加, 避免创建耗时</li>
<li>SetConnMaxIdleTime 并发增加之后, 维持多久销毁连接</li>
<li>SetConnMaxLifetime 不希望一个连接持续过久</li>
</ul>
<h4 id="sqlprepared-语句">sql.prepared 语句</h4>
<ul>
<li>高效: 更加高效, 避免 SQL 重复编译</li>
<li>安全: 避免SQL注入</li>
</ul>
<h4 id="string-处理-null-值">string 处理 null 值</h4>
<ul>
<li>使用指针声明 <code>*string</code></li>
<li>使用 <code>sql.NullString</code> 类型</li>
</ul>
<h4 id="rowserr-错误捕获">rows.Err 错误捕获</h4>
<h3 id="79-资源关闭">79 资源关闭</h3>
<p>实现 <code>io.Closer</code> 的临时资源需要 及时 close</p>
<ul>
<li>http 请求的客户端, respBody 需要close</li>
<li>sql.Rows</li>
<li>os.File</li>
</ul>
<h3 id="80-http-handle-忘记-return">80 http handle 忘记 return</h3>
<h3 id="81-使用-默认http-client-和-server">81 使用 默认http client 和 server</h3>
<h4 id="client">client</h4>
<p>http 的请求步骤</p>
<ol>
<li>dial</li>
<li>tls 握手</li>
<li>send</li>
<li>read header</li>
<li>read body</li>
</ol>
<p><img loading="lazy" src="./__assets/100mistake-http-step1to5.png" alt="100mistake-http-step1to5"  />
</p>
<p>4个超时配置</p>
<ol>
<li><code>net.Dialer.Timeout</code> 建立连接超时</li>
<li><code>http.Transport.TLSHandshakeTimeout</code> TLS 握手超时</li>
<li><code>http.Transport.ResponseHeaderTimeout</code> 等待服务返回头此时</li>
<li><code>http.Client.Timeout</code> 这个请求的时间限制, from 上述步骤1到5</li>
</ol>
<p><code>net/http: request canceled (Client.Timeout exceeded while awaiting headers)</code> 报错
服务端返回超时, 在step4, 读取头时等待超时.</p>
<p>http 连接池</p>
<ul>
<li><code>http.Transport.IdleConnTimeout</code></li>
<li><code>http.Transport.MaxIdleConns</code></li>
<li><code>http.Transport.MaxIdleConnsPerHost</code> 默认为2, 严重影响并发</li>
</ul>
<h4 id="server">server</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">server := &amp;http.Server{}
</span></span><span class="line"><span class="cl">server.Serve(listener)
</span></span></code></pre></td></tr></table>
</div>
</div><p>服务端步骤</p>
<ol>
<li>等待请求</li>
<li>TLS</li>
<li>read request headers</li>
<li>read request body</li>
<li>write response</li>
</ol>
<p>3个 timeout</p>
<ul>
<li><code>http.Sever.ReadHeadersTimeout</code></li>
<li><code>http.Server.ReadTimeout</code></li>
<li><code>http.TimeoutHandler</code></li>
<li><code>http.Server.IdleTimeout</code> keep-alive 请求可以保持多久</li>
</ul>
<p><code>TimeoutHanlder 包裹 handle 当处理超时时,返回503</code></p>
<p><img loading="lazy" src="./__assets/100mistake-server-timeout1-5.png" alt="100mistake-server-timeout1-5"  />
</p>
<p>如果都没有配置超时的话, 服务器就没有超时机制, 会一直等待客户端主动关闭连接.
当服务暴露给不信任客户端时, 至少需要配置 ReadTimeout 和 TimeoutHandler 避免资源被耗尽.</p>
<h3 id="82-对单元测试进行分类">82 对单元测试进行分类</h3>
<p>避免执行不需要单元测试, 提升测试效率.</p>
<ol>
<li>使用 tag <code>go test --tags=integration -v .</code></li>
<li>根据环境变量, 使用<code>testing.Skip()</code> 显示调用为什么跳过测试</li>
<li>使用 <code>testing.Short()</code> 判断当前执行模式, 跳过需要长时间耗时的测试 <code>go test -short -v .</code></li>
</ol>
<h3 id="83-测试启用---race">83 测试启用 &ndash;race</h3>
<p>编译时带 <code>--race</code> 会增加程序消耗</p>
<ul>
<li>内存提高5-10倍</li>
<li>运行时间2-20倍</li>
</ul>
<p>避免在生产环境使用, 在CI的时候使用</p>
<h3 id="84-test-的执行模式">84 test 的执行模式</h3>
<p>parallel</p>
<p><code>testing.T.Parallel()</code> 会先暂停, 等待顺序测试任务完成后, 继续执行.</p>
<p><code>go test - parallel 16 .</code> 并发执行测试</p>
<p>shuffle</p>
<p><code>go test -shuffle=on -v .</code> 打乱 go test 函数的执行顺序</p>
<h3 id="85-table-driven-表驱动测试">85 Table-driven 表驱动测试</h3>
<p><code>t.Run(name, func(t *testing.T) {})</code></p>
<p>执行子测试
<code>go test -run=TestFoo/subtest_1 -v</code></p>
<h3 id="86-避免测试中的-sleep">86 避免测试中的 sleep</h3>
<p>在并发场景下, 我们使用 <code>time.Sleep</code> 模拟, 任务处理耗时, 但是我们不知道时间是否足够</p>
<ol>
<li>使用多次尝试校验, retry</li>
<li>mock 对象使用消息通知校验</li>
</ol>
<h3 id="87-处理依赖时间测试">87 处理依赖时间测试</h3>
<ul>
<li>改变依赖, 造假数据</li>
<li>修改方法, 让接口传入时间</li>
</ul>
<h3 id="88-单测工具包">88 单测工具包</h3>
<p>http 相关</p>
<ul>
<li>httptest.NewServer</li>
<li>httptest.NewRequest</li>
</ul>
<p>iotest</p>
<h3 id="89-正确使用-benchmark-测试">89 正确使用 benchmark 测试</h3>
<ul>
<li>忽略耗时函数</li>
<li>忽略对硬件底层</li>
</ul>
<h3 id="90-单元测试的拓展功能">90 单元测试的拓展功能</h3>
<ul>
<li>TestMain</li>
<li>从不同的包测试 ( 重视包对外的开放功能)</li>
<li>cover 单测覆盖率</li>
</ul>
<h3 id="91-cpu-cache">91 CPU cache</h3>
<p>cpu 三级缓存</p>
<p><img loading="lazy" src="./__assets/100mistakecpucache.png" alt="100mistakecpucache"  />
</p>
<ul>
<li>cpu cache Line 加载的  locality of reference, 局部性和相关性</li>
<li>cache line 一般 64 bytes,</li>
</ul>
<p>CPU 内存加载预测</p>
<ul>
<li>Unit stride</li>
<li>Constant stride</li>
<li>Non-Unit stride</li>
</ul>
<h3 id="92-通过-padding-避免并发操作相同内存复制到不同cpu-core-中">92 通过 padding 避免并发操作相同内存复制到不同cpu core 中</h3>
<p>cpu 会有cache line 加载数据, 如果两个协程, 并发操作的不同的数据字段(在同一块cache line 大小内存中)
内存中. 这块内存会被同时加载到不同的cpu 核心的缓存中. 因为cpu MESI保证内存一致, 一边更新另一边会失效.</p>
<blockquote>
<p>When a cache line is shared across multiple cores and at least one goroutine is a writer, the entire cache line is invalidated.</p>
</blockquote>
<p>使用 pading , 将同时操作的内存分到不同cache line 中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type result struct {
</span></span><span class="line"><span class="cl">	sumA int64
</span></span><span class="line"><span class="cl">	_ [56]byte // padding
</span></span><span class="line"><span class="cl">	sumB int64
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="93-考虑指令集优化">93 考虑指令集优化</h3>
<ul>
<li></li>
</ul>
<h3 id="94-内存对齐">94 内存对齐</h3>
<p>内存对齐可以减少结构体占用的内存大小.</p>
<p>结构体的内存对齐系数, 为各字段中最大的系数</p>
<p><a href="https://go.dev/ref/spec#Size%20and%20alignment%20guarantees">官方文档</a></p>
<h3 id="95-stack--heap">95 stack &amp;&amp; heap</h3>
<p>栈内存是不需要GC, 只是会根据栈的大小范围表示为不可用, 再次使用的时候, 新值直接覆盖旧值.</p>
<p>当变量内存分配到栈上, 且函数退出, 变量引用表示不可用 &ndash; 无法再次访问, 所以需要 堆.</p>
<p>堆的使用成本更大, 需要GC, 内存分配成本也更大.</p>
<h3 id="96-优化内存分配">96 优化内存分配</h3>
<ul>
<li>string.Builder 代替 +</li>
<li>避免 []byte 转 string</li>
<li>slice map 的初始化</li>
<li>结构体内存对齐</li>
<li>改变 interface 声明, 避免内存逃逸</li>
<li>sync.Pool</li>
<li>编译器优化, 避免 bytes-to-string 转化</li>
</ul>
<h3 id="97-编译器函数内联">97 编译器函数内联</h3>
<p>inline. 当调用的子函数较为简单时, 编译器会是将调用函数的内部实现嵌入当前调用点.</p>
<ul>
<li>避免函数的调用成本</li>
<li>可以使编译器进一步优化 (比如, 内存逃逸 直接分配到栈中)</li>
</ul>
<p>当子函数过为复杂时, 可以抽出子函数的复杂部分为另一个调用函数实现 mid inline. 让中间函数嵌入调用点.</p>
<h3 id="98-使用分析工具">98 使用分析工具</h3>
<ul>
<li>pprof</li>
<li>trace</li>
</ul>
<h3 id="99-gc">99 GC</h3>
<p>marks and sweep</p>
<ul>
<li>遍历所有对象, 标记是否在使用</li>
<li>遍历所以对象, 清除没有在使用的对象</li>
</ul>
<p>GOGC 配置 GC 的敏感度, 当 GOGC=100 时, 当堆内存容量涨100%时触发GC.</p>
<ul>
<li><a href="https://xargin.com/dynamic-gogc/">通过 GOGC 进行优化</a></li>
<li><a href="https://www.uber.com/en-TW/blog/how-we-saved-70k-cores-across-30-mission-critical-services/">uber 调优原文</a></li>
<li><a href="https://blog.ideawand.com/2020/08/01/go-gc-tuning-practice-1/">GOGC 调优</a></li>
</ul>
<h3 id="100-docker-和-k8s-资源分配对并发性能的影响">100 Docker 和 K8s 资源分配对并发性能的影响</h3>
<p>引用 <code>http://github.com/uber-go/automaxprocs</code> 自动设置 GOPROMAX</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang 100 mistake 的简单读书笔记</title>
      <link>https://ynikl.github.io/books/golang-100mistake/</link>
      <pubDate>Thu, 25 May 2023 12:10:53 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/golang-100mistake/</guid>
      <description>variable shadowing init 弊端
初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序 影响测试， 会在测试之前执行 获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试） 什么时候使用
避免错误产生没有err 不会产生全局变量 getters and setters 如果只是简单获取值的话，就不应该用
方法命名
获取值 Balance 而不是 （ GetBalance) 设置值 SetBalance interface pollution interface 的价值
通用的方法（ 如排序） 解耦 限制实体行为（仅提供特定方法） 只要在当我们真正用到的时候才去创建
we should create an interface when we need it, not when we foresee that we could need it
interface 抽象 是通过发现的，而不是通过创造的
生产端接口声明，与实现放在同一个包中 消费端接口声明，与使用interface的放在同一个包中 Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。
准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。
return interfaceBe conservative in what you do, be liberal in fr Be conservative in what you do, be liberal in what you accept from others.</description>
      <content:encoded><![CDATA[<h3 id="variable-shadowing">variable shadowing</h3>
<h3 id="init">init</h3>
<p>弊端</p>
<ol>
<li>初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序</li>
<li>影响测试， 会在测试之前执行</li>
<li>获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试）</li>
</ol>
<p>什么时候使用</p>
<ol>
<li>避免错误产生没有err</li>
<li>不会产生全局变量</li>
</ol>
<h3 id="getters-and-setters">getters and setters</h3>
<p>如果只是简单获取值的话，就不应该用</p>
<p>方法命名</p>
<ul>
<li>获取值 Balance 而不是 （ GetBalance)</li>
<li>设置值 SetBalance</li>
</ul>
<h3 id="interface-pollution">interface pollution</h3>
<p>interface 的价值</p>
<ul>
<li>通用的方法（ 如排序）</li>
<li>解耦</li>
<li>限制实体行为（仅提供特定方法）</li>
</ul>
<p>只要在当我们真正用到的时候才去创建</p>
<p>we should create an interface when we need it, not when we foresee that we could need it</p>
<p>interface 抽象 是通过发现的，而不是通过创造的</p>
<ul>
<li>生产端接口声明，与实现放在同一个包中</li>
<li>消费端接口声明，与使用interface的放在同一个包中</li>
</ul>
<p>Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。</p>
<p>准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。</p>
<h3 id="return-interfacebe-conservative-in-what-you-do-be-liberal-in-fr">return interfaceBe conservative in what you do, be liberal in fr</h3>
<p>Be conservative in what you do, be liberal in what you accept from others.</p>
<p>对自己依赖别人的功能保守，对自己赋予别人的能力保持开放</p>
<ul>
<li>尽量接收 interface</li>
<li>尽量返回 结构体</li>
</ul>
<p>正常 consumer 定义接口， 就会造成循环引用</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/12365435/1674099857741-bb77c007-cc4e-4f15-abd7-16bf11de95c5.png" alt=""  />
</p>
<p>如果 是现房new 的时候返回 interface 就会变成，由实现方来限制了限制了客户端使用接口消费的抽象组合方式</p>
<h3 id="confuse-generics">Confuse Generics</h3>
<p>限制 constraint， 可以是一下两种</p>
<ul>
<li>接口</li>
<li>任意类型</li>
</ul>
<p>~int， 限制 底层类型</p>
<h3 id="embbding">embbding</h3>
<p>错误使用将底层的方法公开出来</p>
<p>type client struct {
sync.Mutex // 错误地将 Lock() 和 Unlock() 方法暴露给客户端了
protectData map[string]string
}</p>
<p>Functional Options Parttern</p>
<p>定义闭包声明函数，更新和修改配置， 有几个好处</p>
<ul>
<li>使用默认配置时， 避免声明空的 cfg 参数结构体</li>
<li>通过闭包延迟 err 的处理， 聚合在客户端内部</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type options struct {
</span></span><span class="line"><span class="cl">    port *int
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">type Option func(opt options) error 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func WithPort(port int) Option {
</span></span><span class="line"><span class="cl">    return func(opt options) error {
</span></span><span class="line"><span class="cl">        opt.port = port
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func NewServer(c client, opts ...Option) {
</span></span><span class="line"><span class="cl">	var cfg options
</span></span><span class="line"><span class="cl">    for _, op := range opts {
</span></span><span class="line"><span class="cl">       	err := op(cfg)
</span></span><span class="line"><span class="cl">        if err != nil {
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        }
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">func main() {
</span></span><span class="line"><span class="cl">    NewServer(http.DefaultClient, WihtPort(8080))
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="12-project-organization">12 Project Organization</h3>
<p><a href="https://github.com/golang-standards/project-layout">project-layout</a></p>
<p>We should minimize what should be exported as much as possible to reduce the coupling between pack-<br>
ages and keep unnecessary exported elements hidden.</p>
<p>包的成员，非必要不公开。</p>
<h3 id="13-utility-package">13 Utility Package</h3>
<p>创建类似与 common ， utility, base， shared 等没有意义的包名，共享一些工具类代码。</p>
<h3 id="14-ignoring-package-name-collisions">14 Ignoring Package name collisions</h3>
<p>避免包名和变量名冲突</p>
<ul>
<li>使用不同的变量名<code>redisClient</code></li>
<li>对引用的包取别名 <code>redisPkg</code></li>
</ul>
<h3 id="15-missing-code-documentation">15 Missing code documentation</h3>
<ol>
<li>exported 的公开变量 都需要进行文档备注</li>
<li><code>Deprecated: //</code></li>
<li>Package 的说明应该在 <code>doc.go</code> 文件 <code>// Package 包名</code>开头</li>
<li>与 Go 代码声明有空行间隔 会被忽略</li>
</ol>
<h3 id="16-not-using-linters">16 Not using linters</h3>
<h3 id="17-creating-confusion-with-octal-literal">17 Creating confusion with octal literal</h3>
<p>错误使用 010， 表示八进制</p>
<ul>
<li>0b 二进制</li>
<li>0x 十六进制</li>
<li>0i 虚数</li>
</ul>
<h3 id="18-integer-overflow">18 Integer Overflow</h3>
<p>整形溢出， 多注意</p>
<h3 id="19-floating-points">19 floating points</h3>
<h3 id="20-slice-length-and-capactity">20 slice length and capactity</h3>
<p>the slice length is the number of available elements in the slice,<br>
whereas the slice capacity is the number of elements in the backing arra</p>
<p>长度是 slice 可用的长度， 容量是slice底层数据的长度</p>
<h3 id="22-slice-empty-and-nil">22 slice empty and nil</h3>
<p>slice nil</p>
<ul>
<li>不需要分配内存， nil slice 是 empty slice</li>
</ul>
<p>empty slice</p>
<ul>
<li>长度等于 0</li>
</ul>
<h3 id="23-check-slice-by-nil">23 check slice by nil</h3>
<p>通过 <code>list == nil</code> 判断 slice 是否为空，是错误的</p>
<p>要通过长度判断 <code>len(list)</code>判断 slice 是否为空。</p>
<h3 id="24-copy-slice">24 copy slice</h3>
<p>赋值数量为最小两个slice 之间最小长度</p>
<p>复制之前应该，注意复制的目标数组的长度</p>
<p>src := []int{0, 1, 2}
dst := make([]int, len(src))
copy(dst, src)
fmt.Println(dst)</p>
<p>不同的复制方式</p>
<p>src := []int{0, 1, 2}
dst := append([]int(nil), src&hellip;)</p>
<h3 id="25-切片更新添加数据副作用">25 切片更新添加数据副作用</h3>
<p>s1 := []int{1,2,3}
s2 := s1[1:2]
s3 := append(s2, 10}</p>
<p>// Output:
// s1 [1, 2, 10]</p>
<h3 id="26-slice-导致内存泄露">26 slice 导致内存泄露</h3>
<p>使用切变承接输入的大数据数组， 获取小部分数据。</p>
<p>小数据的slice， 仍然会指向大数组的空间，内存占用仍会较高。</p>
<p>需要重新声明 slice， 使用copy 复制需要的数据。</p>
<p>GC 不会回收 slice 已经分配但没有使用的空间。</p>
<h3 id="27--map-初始化">27  Map 初始化</h3>
<p><code>load factor</code>
<code>overflowed</code></p>
<p>make(map, hint_size)
初始化 map, 带预计大小, 可以避免map 在插入的时候, 需要复制.</p>
<ul>
<li>获取足够的内存</li>
<li>重新平衡分配元素到各个bucket</li>
</ul>
<h3 id="28-map-memory-leaks">28 map memory leaks</h3>
<p><code>A map can only grow and have more buckets; it never shrinks.</code></p>
<p>GC 可以回收 map 的元素, 但是无法回收 map 本身占用的空间大小.</p>
<p>解决方法</p>
<ul>
<li>创建副本, 创建一个新的map, 复制现有的值, 释放原有的map</li>
<li>map的value 存放 指针, 缩小每一个空的bucket 占用的空间大小 (指针空间 8bytes or 4bytes)</li>
</ul>
<h3 id="29-值比较">29 值比较</h3>
<p> Booleans—Compare whether two Booleans are equal.<br>
 Numerics (int, float, and complex types)—Compare whether two numerics are equal.</p>
<ul>
<li>
<p> Strings—Compare whether two strings are equal.</p>
</li>
<li>
<p>  Channels—Compare whether two channels were created by the same call to</p>
<p>make or if both are nil.</p>
</li>
<li>
<p>  Interfaces—Compare whether two interfaces have identical dynamic types and</p>
<p>equal dynamic values or if both are nil.</p>
</li>
<li>
<p>  Pointers—Compare whether two pointers point to the same value in memory or</p>
<p>if both are nil.</p>
</li>
<li>
<p>  Structs and arrays—Compare whether they are composed of similar types.</p>
</li>
</ul>
<p>对比方法</p>
<ul>
<li>简单通过 <code>==</code>  对比, 无法处理复杂类型</li>
<li><code>reflect.DeepEuqal</code> 有性能瓶颈</li>
<li>自己实现对比方法, 参考已经有标准库, 如<code>bytes.Compare</code></li>
</ul>
<h3 id="30-copy-value-in-range">30 copy value in range</h3>
<p>在 <code>range</code> 遍历的过程中, 是值复制</p>
<h3 id="31-range-expresion-evaluated">31 range expresion evaluated</h3>
<p><code>for i, v := range exp</code>
exp 针对不同类型表达式, 会在 开始执行 loop 之前, 对exp 进行复制</p>
<h4 id="slice">slice</h4>
<p>range 会在开始range的时候, 计算slice 的长度和容量, 并创建一个临时的 slice</p>
<p>![[Pasted image 20230221093451.png]]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">s := []int{0, 1, 2}
</span></span><span class="line"><span class="cl">for i := 0; i &lt; len(s); i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    s = append(s, 10)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>会无限执行下去, 因为 <code>len</code> 是每次执行的时候都会计算一次</p>
<h4 id="channel">channel</h4>
<p>与slice 一样, 同样会在开始的时候为 channel 创建一个临时变量.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ch := ch1
</span></span><span class="line"><span class="cl">for v := range ch {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    fmt.Println(v)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ch = ch2 }
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个在range 这替换的动作是无效的, range 的仍然是ch1</p>
<h4 id="array">array</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [3]int{0, 1, 2}
</span></span><span class="line"><span class="cl">for i, v := range a {
</span></span><span class="line"><span class="cl">    a[2] = 10
</span></span><span class="line"><span class="cl">    if i == 2 {
</span></span><span class="line"><span class="cl">        fmt.Println(v)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>会对 a 整个数据进行复制, 输出是2, 原数组不变</p>
<p>修改原数组方案</p>
<ul>
<li>使用 index , 访问和修改数据</li>
<li>对数据取指针方法 <code>for i, v := range &amp;a</code></li>
</ul>
<h3 id="32-range-过程中使用-遍历元素的指针">32 range 过程中使用 遍历元素的指针</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for _, customer := range customers {
</span></span><span class="line"><span class="cl">        s.m[customer.ID] = &amp;customer
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>&amp;customer</code> 指向的是 range 复制出来的内存</p>
<h3 id="33-对-map-数据的错误消费">33 对 map 数据的错误消费</h3>
<ol>
<li>依赖 map 的顺序， map 的数据是无序的</li>
<li>在遍历过程中继续插入新的数据， 结果是不可预测的。有可能会被遍历到，也有可能会被跳过</li>
</ol>
<h3 id="34-break-层的错误理解">34 break 层的错误理解</h3>
<p>break 对 for, select, switch 三个语句的最内层生效</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for i := 0; i &lt; 5; i++ {
</span></span><span class="line"><span class="cl">	switch i {
</span></span><span class="line"><span class="cl">	case 2:
</span></span><span class="line"><span class="cl">	break
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>没有中断， 结果正常遍历。</p>
<p>可以使用 Label 达到中断 for 的方式， 标准库也经常采用该种写法。</p>
<h3 id="35-在-for-中使用-defer">35 在 for 中使用 defer</h3>
<h3 id="36-没有理解-rune">36 没有理解 rune</h3>
<p>string 是一个结构体, 有两个字段</p>
<ul>
<li>A pointer to an immutable byte sequence</li>
<li>长度</li>
</ul>
<p>Unicode 是字符集
Utf-8 是编码方式</p>
<p>Rune 是 Unicode 的字符集表示，相当于一个字符, golang 使用utf-8编码方式， 所以一个rune 是1-4个字节 bytes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type rune = int32
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>len()</code>函数返回的是 bytes 的长度</p>
<h3 id="37-对-string-的错误遍历">37 对 string 的错误遍历</h3>
<p>获取字符串的字符个数 <code>utf8.RuneCountInString</code></p>
<p>获取字符串的第i个字符</p>
<ol>
<li>如果是纯ascii码字符串，直接通过str[i]获取。 获取出来的是 bytes 编码需要转成字符</li>
<li>如果存在非ascii 字符
<ol>
<li>通过 <code>for i, c := range str</code>遍历获取到第 i 个 rune 字符， 和 c 字符编码</li>
<li>通过索引获取， 需要先强制转化成 <code>[]rune(str)[i]</code> 可以直接获取字符串的第 i 个 rune 字符</li>
</ol>
</li>
</ol>
<h3 id="38-对-trimright--trimsuffix-混淆">38 对 TrimRight / TrimSuffix 混淆</h3>
<p>strings.TrimRight 是从右到开始移除所有符合的字符集，直到遇到第一个不符合的字符
TrimSuffix 是移除整个字符串</p>
<h3 id="39-使用--字符串拼接">39 使用 += 字符串拼接</h3>
<p>使用 += 拼接一系列字符串，会造成内存分配频繁，因为每一个字串都是不变的。
推荐使用 <code>strings.Builder</code></p>
<h3 id="40-冗余转化成字符串">40 冗余转化成字符串</h3>
<p>所有的字符串操作 strings 包， 在 bytes 包都会有相对应的替换方法，没有必要将 bytes 转化成 string 在进行操作。</p>
<h3 id="41-substring-导致内存泄露">41 subString 导致内存泄露</h3>
<p>substring 生成的 新字符串与旧字符串指向同一块内存，原理同slice</p>
<h3 id="42-方法值接受者和指针接收者">42 方法值接受者和指针接收者</h3>
<p>pointer receiver</p>
<ul>
<li>需要修改对象数据</li>
<li>接收者包含不能copy的对象，如 sync</li>
<li>接收者为大对象</li>
</ul>
<p>value receiver</p>
<ul>
<li>不修改接收者</li>
<li>接收者为 map, channel</li>
<li>接收者为小对象， 基础类型</li>
</ul>
<h3 id="43-命名的返回参数">43 命名的返回参数</h3>
<p>用处</p>
<ol>
<li>增加代码可读性， 如果无法增加可读性，就不需要命名</li>
<li>提前初始化变量</li>
<li>使用 naked return 的提前是函数短小，太长的函数会降低可读性，需要一直记住变量</li>
<li>不应改混着使用 naked return 和 带参数return</li>
</ol>
<h3 id="44-返回了未赋值的命名-err">44 返回了未赋值的命名 err</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func name(ctx context.Context) (a,b int, err error) {
</span></span><span class="line"><span class="cl">	if ctx.Err() != nil {
</span></span><span class="line"><span class="cl">	// err is nil
</span></span><span class="line"><span class="cl">	return 0, 0, err
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="45-interface-返回-non-nil">45 interface 返回 non-nil</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func Validate() error {
</span></span><span class="line"><span class="cl">	var m *MutilErrorStruct
</span></span><span class="line"><span class="cl">	return m
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">// 返回值 err != nil 永远为true
</span></span></code></pre></td></tr></table>
</div>
</div><p>nil 的结构体， 在返回 interface 的函数之后就永远不等于 nil
![[Pasted image 20230309221827.png]]</p>
<p>解决方案，永远明确地返回 nil</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if m != nil {
</span></span><span class="line"><span class="cl">	return m
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">return nil
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="46-不用使用文件名作为参数">46 不用使用文件名作为参数</h3>
<p>使用 io.Reader 做为参数, 替代文件有两种好处</p>
<ol>
<li>方法的具体实现可以与数据源的类型无关, 文件, 或者http, 或者sock</li>
<li>方便测试, 无法因为测试而创建一堆文件</li>
</ol>
<h3 id="47-defer-参数的计算">47 defer 参数的计算</h3>
<p>defer 在代码执行到的时候会, 立刻使用当前函数的参数的变量值, 包括方法的接收者作为参数.</p>
<h3 id="48-panic">48 panic</h3>
<p>什么时候应该panic</p>
<ul>
<li>a pure programmer error ( 程序员编码错误 )</li>
<li>依赖初始化失败</li>
</ul>
<h3 id="49-error-wrap">49 Error Wrap</h3>
<p>什么时候使用 Error Wrap</p>
<ul>
<li>添加额外的信息</li>
<li>标记为某一特定的错误类型</li>
</ul>
<p>处理的信息的多种选择</p>
<ul>
<li>直接返回错误</li>
<li>自定义错误类型</li>
<li>fmt.Errorf + %w wrap 错误</li>
<li>fmt.Errorf + %v 包含错误文字</li>
</ul>
<p><img loading="lazy" src="https://s2.loli.net/2023/03/21/CPdiq867VhUcAwW.png" alt="错误处理的多种选择"  />
</p>
<h3 id="50-用-as-检查err类型">50 用 as 检查Err类型</h3>
<p>通过 wrap 的 error 需要使用 <code>error.As(err, &amp;targetErrorStruct{})</code> 判断是否为目标结构体</p>
<h3 id="51-errosis">51 erros.Is</h3>
<p>制定 error 错误信息的原则:</p>
<ol>
<li>可以预测的错误使用制定错误变量 <code>ErrFoo = errors.New(&quot;foo&quot;)</code></li>
<li>无法预测的错误,使用指定错误类型 <code>type BarError struct</code></li>
</ol>
<p>使用 <code>error.Is(err, sql.ErrNoRows)</code> 判断错误是否为指定的错误类型.</p>
<h3 id="52-多次处理同一个错误">52 多次处理同一个错误</h3>
<p>一个错误多次重复打日志, 会让调试更加艰难.</p>
<blockquote>
<p>打印错误也是一种错误的处理方式. 所有, 要么选择打印错误, 要么选择向上抛出错误.
不要两者同时.</p>
</blockquote>
<p>向上层函数抛出错误的时候, 需要通过 WrapErr 附加上当前的额外错误信息</p>
<h3 id="53-明确忽略的-error">53 明确忽略的 error</h3>
<p>使用 <code>_</code> 接收返回的error, 明确表示不处理, 错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> _ = funcReturnErr()
</span></span></code></pre></td></tr></table>
</div>
</div><p>建议再加上注释说明为什么不处理函数错误</p>
<h3 id="54-处理-defer-函数返回的错误">54 处理 defer 函数返回的错误</h3>
<p>记得要处理 defer 的函数返回的错误, 至少需要显示忽略</p>
<h3 id="55-并发和并行">55 并发和并行</h3>
<p>并发的重点是可以处理多项事务的设计结构, 并行是多项事务可以同时进行处理.</p>
<blockquote>
<p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.
—Rob Pike</p>
</blockquote>
<p>并发并不代表多件事务真正意义上的&quot;同时进行&quot;, 同时进行是并行, 并发主要处理阻塞的流程
优化</p>
<h3 id="56-并发-不一定更快">56 并发 不一定更快</h3>
<p>过小的切分任务, 会让时间消耗在创建和消费协程上, 并没有真正的提高&quot;并行&quot;能力.</p>
<h3 id="57-通道和互斥锁">57 通道和互斥锁</h3>
<p>通道的底层也是互斥锁.</p>
<p>当协程之间需要传递信息, 或者数据, 使用通道 &ndash; 互斥锁的更高抽象</p>
<h3 id="58-数据竞争data-race-和条件竞争race-condition">58 数据竞争(data race) 和条件竞争(race condition)</h3>
<p>数据竞争:</p>
<p>同时有多个协程同时访问统一块内存, 且至少有一个协程正在写入数据</p>
<p>条件竞争:</p>
<p>事件发生的先后顺序不可控制, 无法控制协程的执行先后顺序, 导致结果不可控.</p>
<h3 id="59-区分任务类型-计算密集或者-io密集型">59 区分任务类型 (计算密集或者 I/O密集型)</h3>
<p>如果是计算密集型, goroutine 的并发上线应该采用 <code>runtime.GOMAXPROCS(0)</code></p>
<p>过多的协程, 可能导致创建过得的 M, 就会出现多个 M 在一个 cpu 核心 中疯狂切换.</p>
<h3 id="60-conetxt">60 Conetxt</h3>
<ul>
<li>Deadline 设置超时时间 <code>context.WithTimeout</code></li>
<li>传递取消消息 <code>context.WithCancel</code></li>
<li>传递值 <code>context.WithValue</code></li>
<li><code>context.Err</code> 会返回解释, 为何<code>context.Done</code>关闭</li>
</ul>
<p>传递值时, key 不直接使用 string 是为了避免, 冲突覆盖.</p>
<blockquote>
<p>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables&rsquo; static type should be a pointer or interface.</p>
</blockquote>
<p>疑惑的时候就使用 <code>context.TODO</code></p>
<blockquote>
<p>When in doubt about which context to use, we should use context.TODO() instead of passing an empty context with context.Background.</p>
</blockquote>
<h3 id="61-传递-context">61 传递 context</h3>
<h3 id="62-关心-goroutine-什么时候停止">62 关心 goroutine 什么时候停止</h3>
<p>关心 goroutine 持有的文件描述符是否被正确的关闭
注意协程持有的资源</p>
<h3 id="63-注意-goroutine-获取循环变量">63 注意 goroutine 获取循环变量</h3>
<h3 id="64-select-是随机-case-先后顺序不保证优先级">64 select 是随机, case 先后顺序不保证优先级.</h3>
<h3 id="65-消息型-channel">65 消息型 channel</h3>
<p>消息型 channel 的数据结构应该使用 <code>make(chan struct{})</code> 空结构体, 编程惯例, 提醒
接收者, 传递的消息是没有任何意义的.</p>
<h3 id="66-使用-nil-channel">66 使用 nil channel</h3>
<p>在使用 select 的时候, 当 channel 已经 close 掉后, 就可以将channel 设置成 <code>nil</code> ,
让该 case 条件进入堵塞状态</p>
<h3 id="67-分清-buffed-and-unbeffed-channel-的使用场景">67 分清 buffed and unbeffed channel 的使用场景</h3>
<h3 id="68-string-format-的副作用">68 string format 的副作用</h3>
<p>如果有协程正在更新 ctx, context的值的话, 就会出现数据竞争, fmt 读取ctx的内部值</p>
<p><code>ctxKey := fmt.Sprintf(&quot;%v&quot;, ctx)</code></p>
<p>fmt 会读取 <code>string()</code> 的方法, 应注意该方法中的读写锁是否会造成死锁.</p>
<h3 id="69-append-的数据竞争">69 append 的数据竞争</h3>
<p>slice 更新和读取不通的index时不会出问题.</p>
<p>map 操作时存在更新, 无论key是否相同有可能产生冲突. 因为, map 的底层是数组, 不同的
key 也有可能指向相同的数组</p>
<h3 id="70">70</h3>
<h3 id="71-wgadd-在协程开启前">71 wg.Add 在协程开启前</h3>
<h3 id="72-sycncond">72 sycn.cond</h3>
<h3 id="73-errgroup">73 errgroup</h3>
<h3 id="74-sync-包不能被复制-要小心值复制">74 sync 包不能被复制, 要小心值复制</h3>
<h3 id="75-timeduration-的时间单位是-纳秒">75 time.Duration 的时间单位是 纳秒</h3>
<p>标准使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1 * time.Second
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="76-timeafte-导致内存泄露">76 time.Afte 导致内存泄露</h3>
<p>方法内部实现的协程, 需要等到时间到了, 才会释放资源, 所以不要在循环中调用.</p>
<h3 id="77-结构体-序列化和反序列化">77 结构体 序列化和反序列化</h3>
<h4 id="结构体嵌套">结构体嵌套</h4>
<p>直接嵌入未命名的结构体, 可能会使用sub embedding struct 的序列化接口方法, 导致bug</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type a struct {
</span></span><span class="line"><span class="cl">ID int 
</span></span><span class="line"><span class="cl">time.Time
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>a 结构体再序列化的时候会使用 <code>time.Time</code> 的<code>MarshalJSON()</code>的方法</p>
<ul>
<li>使用命名结构体接入</li>
<li>重新实现接口方法</li>
</ul>
<h4 id="time-的对比">time 的对比</h4>
<p>time 内部包含 wall clock 和 montonic clock 字段, 返回序列化后的 time 对象, 不包含
montonic clock 直接对比, 会不相同</p>
<blockquote>
<p>The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time.</p>
</blockquote>
<ul>
<li>可以使用 <code>time.Equal</code> 方法</li>
<li>或者使用 <code>Truncate</code> 移除 monotonic clock 数值</li>
</ul>
<h4 id="map">map</h4>
<p><code>map[string]any</code> 数值反序列化后类型都为 float64</p>
<h3 id="78-sql-错误">78 SQL 错误</h3>
<h4 id="sqlopen">sql.Open</h4>
<p><code>sql.Open()</code> 不一定是与数据库服务建立了连接, 具体还是需要看 驱动 实现, 可以通过
ping 方法, 强制建立连接</p>
<h4 id="sql-连接池的配置">sql 连接池的配置</h4>
<p>sql 连接状态分两种</p>
<ul>
<li>使用者</li>
<li>idle 等待使用, 已创建但没有再使用</li>
</ul>
<p>sql 连接池配置</p>
<ul>
<li>SetMaxOpenConns 最大连接数量, 考虑到下游服务的性能</li>
<li>SetMaxIdleConn 在并发高时适当增加, 避免创建耗时</li>
<li>SetConnMaxIdleTime 并发增加之后, 维持多久销毁连接</li>
<li>SetConnMaxLifetime 不希望一个连接持续过久</li>
</ul>
<h4 id="sqlprepared-语句">sql.prepared 语句</h4>
<ul>
<li>高效: 更加高效, 避免 SQL 重复编译</li>
<li>安全: 避免SQL注入</li>
</ul>
<h4 id="string-处理-null-值">string 处理 null 值</h4>
<ul>
<li>使用指针声明 <code>*string</code></li>
<li>使用 <code>sql.NullString</code> 类型</li>
</ul>
<h4 id="rowserr-错误捕获">rows.Err 错误捕获</h4>
<h3 id="79-资源关闭">79 资源关闭</h3>
<p>实现 <code>io.Closer</code> 的临时资源需要 及时 close</p>
<ul>
<li>http 请求的客户端, respBody 需要close</li>
<li>sql.Rows</li>
<li>os.File</li>
</ul>
<h3 id="80-http-handle-忘记-return">80 http handle 忘记 return</h3>
<h3 id="81-使用-默认http-client-和-server">81 使用 默认http client 和 server</h3>
<h4 id="client">client</h4>
<p>http 的请求步骤</p>
<ol>
<li>dial</li>
<li>tls 握手</li>
<li>send</li>
<li>read header</li>
<li>read body</li>
</ol>
<p><img loading="lazy" src="./100mistake-http-step1to5.png" alt="100mistake-http-step1to5"  />
</p>
<p>4个超时配置</p>
<ol>
<li><code>net.Dialer.Timeout</code> 建立连接超时</li>
<li><code>http.Transport.TLSHandshakeTimeout</code> TLS 握手超时</li>
<li><code>http.Transport.ResponseHeaderTimeout</code> 等待服务返回头此时</li>
<li><code>http.Client.Timeout</code> 这个请求的时间限制, from 上述步骤1到5</li>
</ol>
<p><code>net/http: request canceled (Client.Timeout exceeded while awaiting headers)</code> 报错
服务端返回超时, 在step4, 读取头时等待超时.</p>
<p>http 连接池</p>
<ul>
<li><code>http.Transport.IdleConnTimeout</code></li>
<li><code>http.Transport.MaxIdleConns</code></li>
<li><code>http.Transport.MaxIdleConnsPerHost</code> 默认为2, 严重影响并发</li>
</ul>
<h4 id="server">server</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">server := &amp;http.Server{}
</span></span><span class="line"><span class="cl">server.Serve(listener)
</span></span></code></pre></td></tr></table>
</div>
</div><p>服务端步骤</p>
<ol>
<li>等待请求</li>
<li>TLS</li>
<li>read request headers</li>
<li>read request body</li>
<li>write response</li>
</ol>
<p>3个 timeout</p>
<ul>
<li><code>http.Sever.ReadHeadersTimeout</code></li>
<li><code>http.Server.ReadTimeout</code></li>
<li><code>http.TimeoutHandler</code></li>
<li><code>http.Server.IdleTimeout</code> keep-alive 请求可以保持多久</li>
</ul>
<p><code>TimeoutHanlder 包裹 handle 当处理超时时,返回503</code></p>
<p><img loading="lazy" src="./100mistake-server-timeout1-5.png" alt="100mistake-server-timeout1-5"  />
</p>
<p>如果都没有配置超时的话, 服务器就没有超时机制, 会一直等待客户端主动关闭连接.
当服务暴露给不信任客户端时, 至少需要配置 ReadTimeout 和 TimeoutHandler 避免资源被耗尽.</p>
<h3 id="82-对单元测试进行分类">82 对单元测试进行分类</h3>
<p>避免执行不需要单元测试, 提升测试效率.</p>
<ol>
<li>使用 tag <code>go test --tags=integration -v .</code></li>
<li>根据环境变量, 使用<code>testing.Skip()</code> 显示调用为什么跳过测试</li>
<li>使用 <code>testing.Short()</code> 判断当前执行模式, 跳过需要长时间耗时的测试 <code>go test -short -v .</code></li>
</ol>
<h3 id="83-测试启用---race">83 测试启用 &ndash;race</h3>
<p>编译时带 <code>--race</code> 会增加程序消耗</p>
<ul>
<li>内存提高5-10倍</li>
<li>运行时间2-20倍</li>
</ul>
<p>避免在生产环境使用, 在CI的时候使用</p>
<h3 id="84-test-的执行模式">84 test 的执行模式</h3>
<p>parallel</p>
<p><code>testing.T.Parallel()</code> 会先暂停, 等待顺序测试任务完成后, 继续执行.</p>
<p><code>go test - parallel 16 .</code> 并发执行测试</p>
<p>shuffle</p>
<p><code>go test -shuffle=on -v .</code> 打乱 go test 函数的执行顺序</p>
<h3 id="85-table-driven-表驱动测试">85 Table-driven 表驱动测试</h3>
<p><code>t.Run(name, func(t *testing.T) {})</code></p>
<p>执行子测试
<code>go test -run=TestFoo/subtest_1 -v</code></p>
<h3 id="86-避免测试中的-sleep">86 避免测试中的 sleep</h3>
<p>在并发场景下, 我们使用 <code>time.Sleep</code> 模拟, 任务处理耗时, 但是我们不知道时间是否足够</p>
<ol>
<li>使用多次尝试校验, retry</li>
<li>mock 对象使用消息通知校验</li>
</ol>
<h3 id="87-处理依赖时间测试">87 处理依赖时间测试</h3>
<ul>
<li>改变依赖, 造假数据</li>
<li>修改方法, 让接口传入时间</li>
</ul>
<h3 id="88-单测工具包">88 单测工具包</h3>
<p>http 相关</p>
<ul>
<li>httptest.NewServer</li>
<li>httptest.NewRequest</li>
</ul>
<p>iotest</p>
<h3 id="89-正确使用-benchmark-测试">89 正确使用 benchmark 测试</h3>
<ul>
<li>忽略耗时函数</li>
<li>忽略对硬件底层</li>
</ul>
<h3 id="90-单元测试的拓展功能">90 单元测试的拓展功能</h3>
<ul>
<li>TestMain</li>
<li>从不同的包测试 ( 重视包对外的开放功能)</li>
<li>cover 单测覆盖率</li>
</ul>
<h3 id="91-cpu-cache">91 CPU cache</h3>
<p>cpu 三级缓存</p>
<p><img loading="lazy" src="./100mistakecpucache.png" alt="100mistakecpucache"  />
</p>
<ul>
<li>cpu cache Line 加载的  locality of reference, 局部性和相关性</li>
<li>cache line 一般 64 bytes,</li>
</ul>
<p>CPU 内存加载预测</p>
<ul>
<li>Unit stride</li>
<li>Constant stride</li>
<li>Non-Unit stride</li>
</ul>
<h3 id="92-通过-padding-避免并发操作相同内存复制到不同cpu-core-中">92 通过 padding 避免并发操作相同内存复制到不同cpu core 中</h3>
<p>cpu 会有cache line 加载数据, 如果两个协程, 并发操作的不同的数据字段(在同一块cache line 大小内存中)
内存中. 这块内存会被同时加载到不同的cpu 核心的缓存中. 因为cpu MESI保证内存一致, 一边更新另一边会失效.</p>
<blockquote>
<p>When a cache line is shared across multiple cores and at least one goroutine is a writer, the entire cache line is invalidated.</p>
</blockquote>
<p>使用 pading , 将同时操作的内存分到不同cache line 中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type result struct {
</span></span><span class="line"><span class="cl">	sumA int64
</span></span><span class="line"><span class="cl">	_ [56]byte // padding
</span></span><span class="line"><span class="cl">	sumB int64
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="93-考虑指令集优化">93 考虑指令集优化</h3>
<ul>
<li></li>
</ul>
<h3 id="94-内存对齐">94 内存对齐</h3>
<p>内存对齐可以减少结构体占用的内存大小.</p>
<p>结构体的内存对齐系数, 为各字段中最大的系数</p>
<p><a href="https://go.dev/ref/spec#Size%20and%20alignment%20guarantees">官方文档</a></p>
<h3 id="95-stack--heap">95 stack &amp;&amp; heap</h3>
<p>栈内存是不需要GC, 只是会根据栈的大小范围表示为不可用, 再次使用的时候, 新值直接覆盖旧值.</p>
<p>当变量内存分配到栈上, 且函数退出, 变量引用表示不可用 &ndash; 无法再次访问, 所以需要 堆.</p>
<p>堆的使用成本更大, 需要GC, 内存分配成本也更大.</p>
<h3 id="96-优化内存分配">96 优化内存分配</h3>
<ul>
<li>string.Builder 代替 +</li>
<li>避免 []byte 转 string</li>
<li>slice map 的初始化</li>
<li>结构体内存对齐</li>
<li>改变 interface 声明, 避免内存逃逸</li>
<li>sync.Pool</li>
<li>编译器优化, 避免 bytes-to-string 转化</li>
</ul>
<h3 id="97-编译器函数内联">97 编译器函数内联</h3>
<p>inline. 当调用的子函数较为简单时, 编译器会是将调用函数的内部实现嵌入当前调用点.</p>
<ul>
<li>避免函数的调用成本</li>
<li>可以使编译器进一步优化 (比如, 内存逃逸 直接分配到栈中)</li>
</ul>
<p>当子函数过为复杂时, 可以抽出子函数的复杂部分为另一个调用函数实现 mid inline. 让中间函数嵌入调用点.</p>
<h3 id="98-使用分析工具">98 使用分析工具</h3>
<ul>
<li>pprof</li>
<li>trace</li>
</ul>
<h3 id="99-gc">99 GC</h3>
<p>marks and sweep</p>
<ul>
<li>遍历所有对象, 标记是否在使用</li>
<li>遍历所以对象, 清除没有在使用的对象</li>
</ul>
<p>GOGC 配置 GC 的敏感度, 当 GOGC=100 时, 当堆内存容量涨100%时触发GC.</p>
<ul>
<li><a href="https://xargin.com/dynamic-gogc/">通过 GOGC 进行优化</a></li>
<li><a href="https://www.uber.com/en-TW/blog/how-we-saved-70k-cores-across-30-mission-critical-services/">uber 调优原文</a></li>
<li><a href="https://blog.ideawand.com/2020/08/01/go-gc-tuning-practice-1/">GOGC 调优</a></li>
</ul>
<h3 id="100-docker-和-k8s-资源分配对并发性能的影响">100 Docker 和 K8s 资源分配对并发性能的影响</h3>
<p>引用 <code>http://github.com/uber-go/automaxprocs</code> 自动设置 GOPROMAX</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>The Seven Levels of Busy</title>
      <link>https://ynikl.github.io/posts/the-seven-levels-of-busy/</link>
      <pubDate>Mon, 08 May 2023 19:52:59 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/the-seven-levels-of-busy/</guid>
      <description>生活的忙碌可以分成七个层次。
大家可以对照一下，自己属于哪个层次？
第 1 级：一点不忙。
时间很自由，怎么安排都可以，没有一定要去完成的事项，周末想睡多久就多久。
第 2 级：有一些小事。
你记得有一些事要做。这些事情是合理的事项，没有截止期，但是你知道这些事迟早要做。
第 3 级：有一些重要的事。
你有必须要做的事情，需要及时跟踪，不能拖延，你会时刻提醒自己这些事情。
第 4 级：日程排满了。
你的日程排满了，不得不经常问自己&amp;quot;什么事情更重要？&amp;quot;，以便决定先做哪些事，后做哪些事。
你没有计划外的时间，不过你还能控制日程。
第 5 级：生活出现混乱。
你的事情在工作时间做不完，你开始加班了。
你经常因为事情来不及，而对别人说&amp;quot;对不起&amp;quot;。那些事情并没有被你放弃，只是你不得不赶时间，有些事情执行变得草率。
第 6 级：任务做不完。
你需要做的事情，超过了你安排日程的能力。即使放弃某些事情，你依然做不完剩下的事情。
你的工作时间大大延长，影响到正常生活。你感到非常疲劳。
第 7 级：日子过不下去。
各种任务塞满了你醒着的每一分钟。吃饭和其他生活必需的事情，都是抽时间来做。你忙起来的时候，甚至饭也没时间吃。
你不写日程安排了，因为根本没有时间做计划，每个小时情况都在发生变化。
你走路也心不在焉，常常觉得要崩溃，日子过不下去了。
来源: 阮一峰周报</description>
      <content:encoded><![CDATA[<p>生活的忙碌可以分成七个层次。</p>
<p>大家可以对照一下，自己属于哪个层次？</p>
<p>第 1 级：一点不忙。</p>
<p>时间很自由，怎么安排都可以，没有一定要去完成的事项，周末想睡多久就多久。</p>
<p>第 2 级：有一些小事。</p>
<p>你记得有一些事要做。这些事情是合理的事项，没有截止期，但是你知道这些事迟早要做。</p>
<p>第 3 级：有一些重要的事。</p>
<p>你有必须要做的事情，需要及时跟踪，不能拖延，你会时刻提醒自己这些事情。</p>
<p>第 4 级：日程排满了。</p>
<p>你的日程排满了，不得不经常问自己&quot;什么事情更重要？&quot;，以便决定先做哪些事，后做哪些事。</p>
<p>你没有计划外的时间，不过你还能控制日程。</p>
<p>第 5 级：生活出现混乱。</p>
<p>你的事情在工作时间做不完，你开始加班了。</p>
<p>你经常因为事情来不及，而对别人说&quot;对不起&quot;。那些事情并没有被你放弃，只是你不得不赶时间，有些事情执行变得草率。</p>
<p>第 6 级：任务做不完。</p>
<p>你需要做的事情，超过了你安排日程的能力。即使放弃某些事情，你依然做不完剩下的事情。</p>
<p>你的工作时间大大延长，影响到正常生活。你感到非常疲劳。</p>
<p>第 7 级：日子过不下去。</p>
<p>各种任务塞满了你醒着的每一分钟。吃饭和其他生活必需的事情，都是抽时间来做。你忙起来的时候，甚至饭也没时间吃。</p>
<p>你不写日程安排了，因为根本没有时间做计划，每个小时情况都在发生变化。</p>
<p>你走路也心不在焉，常常觉得要崩溃，日子过不下去了。</p>
<p><a href="http://www.ruanyifeng.com/blog/2023/05/weekly-issue-253.html">来源: 阮一峰周报</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>记最近换出租房的经验教训</title>
      <link>https://ynikl.github.io/posts/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/</link>
      <pubDate>Thu, 27 Apr 2023 22:41:16 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/%E7%A7%9F%E6%88%BF%E6%97%A5%E8%AE%B0/</guid>
      <description>记最近换出租房的经验教训 换房租不到两个月 这次是从厦门的岛外海沧湾公园, 搬到软件园二期内, 望海公寓.
我的考虑如下:
我可以把通勤的时间, 节省下来, 将时间放在提升自己技术能力上. 我可以在园内附近随便找一个健身房, 这样子也很方便 中午我可以回到宿舍, 自己烹煮健康的午餐 可以避免我在海沧的停车不方便, 已经开车的话, 需要双边缴交停车费. 导致我后悔住在那边的原因:
我并没有办法把时间投放在提升自己的技术能力上, 让自己一直待在同一个地方我自己 的内心会非常的难受. 时间不经意流失了, 原先我在地铁上还可以保持着, 客观的阅读量. 附近的健身房质量偏低, 都比较拥挤, 价格不合适. 让我不太想去练, 只能跑回原来的 健身房, 导致我需要一个小时的通勤健身成本, 开车到一个较远的健身房. 中午的午饭做腻了, 已经不太想在自己做了 居住的空间变小了, 不上不下, 回到卧室之后也不知道干什么 外部环境比较差, 当我不想在公司, 不想在宿舍的时候, 附近没有可以提供我消遣的地方 租金高昂 总结一下让我搬出来原因
通勤(包括往返健身房) 居住的环境 周边的环境 租金 我个人认为再次挑选租房的因素 居住环境 喜欢繁华的地区, 还是比较偏远幽静的小区(个人比较喜欢偏远的地区) 房间的大小, 要在房间里面做什么(个人没有玩游戏的需求, 一般会想房里面舒服地, 办公 或者阅读, 如果房间太小, 你就会什么事情都不想干, 就想躺在床上玩手机.) 阳光, hhh, 大家好像都喜欢阳光好的房间 房子内部 空调的能耗等级, 这个觉得了你夏天的好过程度 盥洗盆的水龙头是否有热水, 这个决定了你能否快乐的洗漱 (我现在已经离不开热水了) 通勤 上班的通勤方式, 你能接受的通勤时间. 我对通勤时间有着极大的忍受程度.</description>
      <content:encoded><![CDATA[<h1 id="记最近换出租房的经验教训">记最近换出租房的经验教训</h1>
<h2 id="换房租不到两个月">换房租不到两个月</h2>
<p>这次是从厦门的岛外海沧湾公园, 搬到软件园二期内, 望海公寓.</p>
<p>我的考虑如下:</p>
<ol>
<li>我可以把通勤的时间, 节省下来, 将时间放在提升自己技术能力上.</li>
<li>我可以在园内附近随便找一个健身房, 这样子也很方便</li>
<li>中午我可以回到宿舍, 自己烹煮健康的午餐</li>
<li>可以避免我在海沧的停车不方便, 已经开车的话, 需要双边缴交停车费.</li>
</ol>
<p>导致我后悔住在那边的原因:</p>
<ul>
<li>我并没有办法把时间投放在提升自己的技术能力上, 让自己一直待在同一个地方我自己
的内心会非常的难受.</li>
<li>时间不经意流失了, 原先我在地铁上还可以保持着, 客观的阅读量.</li>
<li>附近的健身房质量偏低, 都比较拥挤, 价格不合适. 让我不太想去练, 只能跑回原来的
健身房, 导致我需要一个小时的通勤健身成本, 开车到一个较远的健身房.</li>
<li>中午的午饭做腻了, 已经不太想在自己做了</li>
<li>居住的空间变小了, 不上不下, 回到卧室之后也不知道干什么</li>
<li>外部环境比较差, 当我不想在公司, 不想在宿舍的时候, 附近没有可以提供我消遣的地方</li>
<li>租金高昂</li>
</ul>
<p>总结一下让我搬出来原因</p>
<ul>
<li>通勤(包括往返健身房)</li>
<li>居住的环境</li>
<li>周边的环境</li>
<li>租金</li>
</ul>
<h2 id="我个人认为再次挑选租房的因素">我个人认为再次挑选租房的因素</h2>
<h3 id="居住环境">居住环境</h3>
<ul>
<li>喜欢繁华的地区, 还是比较偏远幽静的小区(个人比较喜欢偏远的地区)</li>
<li>房间的大小, 要在房间里面做什么(个人没有玩游戏的需求, 一般会想房里面舒服地, 办公
或者阅读, 如果房间太小, 你就会什么事情都不想干, 就想躺在床上玩手机.)</li>
<li>阳光, hhh, 大家好像都喜欢阳光好的房间</li>
</ul>
<h3 id="房子内部">房子内部</h3>
<ul>
<li>空调的能耗等级, 这个觉得了你夏天的好过程度</li>
<li>盥洗盆的水龙头是否有热水, 这个决定了你能否快乐的洗漱 (我现在已经离不开热水了)</li>
</ul>
<h3 id="通勤">通勤</h3>
<ul>
<li>上班的通勤方式, 你能接受的通勤时间. 我对通勤时间有着极大的忍受程度. (我已经习惯
在地铁上阅读书籍, 我会把这段时间当作 reading time. 目前单程通勤1.5h)</li>
<li>你生活必须的目的地的通勤, 比如, 咖啡馆, 健身房, 图书馆, 或者商场之类的. 考虑进去.</li>
</ul>
<h3 id="租金">租金</h3>
<ul>
<li>考虑自己收入和租房预算</li>
<li>如果车的话, 还需考虑停车位的费用</li>
</ul>
<h3 id="其他">其他</h3>
<ul>
<li>地区政策, 厦门比较特殊岛内不能骑摩托车, 而我最近又疯狂迷恋上骑摩托车.</li>
<li>有没有方便的停车棚 (停你的自行车, 摩托车, 电动车)</li>
</ul>
<h2 id="对我自己未来居住环境的展望">对我自己未来居住环境的展望</h2>
<ul>
<li>停车棚, 可以让我小摩托不用风吹雨淋</li>
<li>有个车库, 可以自己动手摆弄摩托车</li>
<li>有一个停车位, 方便停放小车</li>
<li>方便去健身房</li>
<li>有一个大阳台</li>
<li>附近人少</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql 分区</title>
      <link>https://ynikl.github.io/blog/mysql-partition/</link>
      <pubDate>Thu, 27 Apr 2023 16:16:48 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/mysql-partition/</guid>
      <description>可以解决什么问题 表太大, 无法全部放入内存中 表有热点数据, 其他均是历史数据 分区更容易维护, 批量删除,修复 可以跨多个硬件设备 减少单个索引互斥访问 独立备份和恢复分区 主要目的就是对表, 进行一个粗粒度的过滤;
原理 将一个表在物理上分层多个更小的部分, 但是在逻辑上, 仍是只有一个表.
执行 SQL 时, 可以通过合适的过滤今天, 过滤掉那边不需要查询的分区, 以此提高性能.
支持类型为: 水平分区, 不支持垂直分区;
分区的数据操作流程 先打开并锁住所有的分区底层表, 过滤掉多余的分区. 再进行操作.
分区类型 range list hash key 创建分区时, 分区的列, 必须是主键或者唯一索引的一部分
1 2 3 4 5 6 7 8 9 create table t1 ( col1 int null, col2 int null, col3 int null, unique key(col1, col2, col3) ) partitionby hash(col3) partitions 4; Range 创建分区</description>
      <content:encoded><![CDATA[<h2 id="可以解决什么问题">可以解决什么问题</h2>
<ul>
<li>表太大, 无法全部放入内存中</li>
<li>表有热点数据, 其他均是历史数据</li>
<li>分区更容易维护, 批量删除,修复</li>
<li>可以跨多个硬件设备</li>
<li>减少单个索引互斥访问</li>
<li>独立备份和恢复分区</li>
</ul>
<p>主要目的就是对表, 进行一个粗粒度的过滤;</p>
<h2 id="原理">原理</h2>
<p>将一个表在物理上分层多个更小的部分, 但是在逻辑上, 仍是只有一个表.</p>
<p>执行 SQL 时, 可以通过合适的过滤今天, 过滤掉那边不需要查询的分区, 以此提高性能.</p>
<p>支持类型为: 水平分区, 不支持垂直分区;</p>
<h3 id="分区的数据操作流程">分区的数据操作流程</h3>
<p>先打开并锁住所有的分区底层表, 过滤掉多余的分区. 再进行操作.</p>
<h2 id="分区类型">分区类型</h2>
<ul>
<li>range</li>
<li>list</li>
<li>hash</li>
<li>key</li>
</ul>
<p>创建分区时, 分区的列, 必须是主键或者唯一索引的一部分</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">create table t1 (
</span></span><span class="line"><span class="cl">col1 int null,
</span></span><span class="line"><span class="cl">col2 int null, 
</span></span><span class="line"><span class="cl">col3 int null,
</span></span><span class="line"><span class="cl">unique key(col1, col2, col3)
</span></span><span class="line"><span class="cl">)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">partitionby hash(col3)
</span></span><span class="line"><span class="cl">partitions 4;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="range">Range</h3>
<p>创建分区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">create table t (
</span></span><span class="line"><span class="cl">id int) 
</span></span><span class="line"><span class="cl">partition by range (id)(
</span></span><span class="line"><span class="cl">partition p0 values less than (10),
</span></span><span class="line"><span class="cl">partition p1 values less than (20));
</span></span></code></pre></td></tr></table>
</div>
</div><p>增加 maxvalue 分区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">alter table t add partition ( partition p2 value less than maxvalue);
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建分区后, 表就会变成多个 ibd 文件组成, 查看详情:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">select * from information_schema.PARTITIONS where table_schema=databese() and 
</span></span><span class="line"><span class="cl">table_name = &#39;t&#39;;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="list">LIST</h3>
<p>与 range 类似, 离散版</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">create table t (
</span></span><span class="line"><span class="cl">a int, 
</span></span><span class="line"><span class="cl">b int) engine=innodb
</span></span><span class="line"><span class="cl">partition by list(b)(
</span></span><span class="line"><span class="cl">partion p0 values in (1,3,5,7,9),
</span></span><span class="line"><span class="cl">partion p1 values in (0,2,4,5,8)
</span></span><span class="line"><span class="cl">);
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="hash">HASH</h3>
<p>HASH 分区的目的是将数据均分地分布到各个分区中, 保证分区的数据量都是一样的.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">create table t_hash(
</span></span><span class="line"><span class="cl">a int,
</span></span><span class="line"><span class="cl">b datetime) engine=innodb
</span></span><span class="line"><span class="cl">partition by hash (YEAR(b))
</span></span><span class="line"><span class="cl">partitions 4
</span></span></code></pre></td></tr></table>
</div>
</div><p>还支持 LINEAR HASH</p>
<h3 id="key">KEY</h3>
<p>与HASH类似, HASH 使用用户定义的函数分区, KEY 使用 MySQL 的函数进行区分</p>
<h3 id="columns">COLUMNS</h3>
<p>以上四种分区方法都是需要对整型进行操作.</p>
<p>RANGE 和 LIST 的进化, columns 可以直接对非整型数据进行分区.</p>
<h3 id="子分区">子分区</h3>
<p>处理超大的表时, 可以在分区下方, 在继续划分子分区.</p>
<h3 id="null-值">Null 值</h3>
<p>Mysql 把 null 视为小于任何一个非 null 值.</p>
<ul>
<li>range 下所有的 null 都会被划分在最左分区.</li>
<li>list 需要显示指明那个分区存放 null 值</li>
<li>hash 和 key 都是等于0值. 最左分区.</li>
</ul>
<h3 id="性能">性能</h3>
<p>数据场景分两种, OLTP, OLAP</p>
<h4 id="olap">OLAP</h4>
<p>在 OLAP 下, 需要频繁扫面大表, 可以通过对应搜索字段进行分区, 直接过滤掉无需扫描的分区.</p>
<h4 id="oltp">OLTP</h4>
<p>获取的数据量较小, 一般是通过索引获取几条记录. B+树的索引, 一般需要2-3次IO</p>
<h3 id="分区列与索引列不匹配">分区列与索引列不匹配</h3>
<p>如果检索的字段或者索引, 没有在分区字段上, 每个分区都会有独立的索引, 就会导致每个分区都需要进行索引检索.
导致IO的次数增长, 导致查询变慢. (1000万条数据, 10个分区话, 就会需要 10 * (2或3次)IO)</p>
<h3 id="查看-partition-是否开启">查看 Partition 是否开启</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql&gt; SELECT
</span></span><span class="line"><span class="cl">    -&gt;     PLUGIN_NAME as Name,
</span></span><span class="line"><span class="cl">    -&gt;     PLUGIN_VERSION as Version,
</span></span><span class="line"><span class="cl">    -&gt;     PLUGIN_STATUS as Status
</span></span><span class="line"><span class="cl">    -&gt; FROM INFORMATION_SCHEMA.PLUGINS
</span></span><span class="line"><span class="cl">    -&gt; WHERE PLUGIN_TYPE=&#39;STORAGE ENGINE&#39;;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">+--------------------+---------+--------+
</span></span><span class="line"><span class="cl">| [Name](Name)               | Version | Status |
</span></span><span class="line"><span class="cl">+--------------------+---------+--------+
</span></span><span class="line"><span class="cl">| binlog             | 1.0     | ACTIVE |
</span></span><span class="line"><span class="cl">| CSV                | 1.0     | ACTIVE |
</span></span><span class="line"><span class="cl">| MEMORY             | 1.0     | ACTIVE |
</span></span><span class="line"><span class="cl">| MRG_MYISAM         | 1.0     | ACTIVE |
</span></span><span class="line"><span class="cl">| MyISAM             | 1.0     | ACTIVE |
</span></span><span class="line"><span class="cl">| PERFORMANCE_SCHEMA | 0.1     | ACTIVE |
</span></span><span class="line"><span class="cl">| BLACKHOLE          | 1.0     | ACTIVE |
</span></span><span class="line"><span class="cl">| ARCHIVE            | 3.0     | ACTIVE |
</span></span><span class="line"><span class="cl">| InnoDB             | 5.7     | ACTIVE |
</span></span><span class="line"><span class="cl">| partition          | 1.0     | ACTIVE |
</span></span><span class="line"><span class="cl">+--------------------+---------+--------+
</span></span><span class="line"><span class="cl">10 rows in set (0.00 sec)
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">information_schema</span><span class="p">.</span><span class="n">PARTITIONS</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="使用优化">使用优化</h2>
<p>访问分区表的时候, 需要在 where 条件后面增加一个分区列, 让优化器过滤分区.</p>
<p>Mysql 无法根据表达式进行过滤, 与索引一致, 只能通过值进行过滤.</p>
<h2 id="参考">参考</h2>
<ul>
<li>高性能的MySQL (第三版)</li>
<li>MySQL 技术内幕: InnoDB存储引擎</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>投资中最简单的事</title>
      <link>https://ynikl.github.io/books/the-simple-things-in-investment/</link>
      <pubDate>Thu, 06 Apr 2023 10:00:36 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/the-simple-things-in-investment/</guid>
      <description>概括 这本书只浅浅地读了前一半, 总体感觉知识面是铺的很全的, 但是由于本人相关知识匮乏. 很多内容没有能够吸收, 先暂时浅读一半. 搁置.
投资要投那些行业集中度高的行业, 局势清晰, 回报高. 比如白色家电. 投资要投有定价权的企业, 如茅台. 上一点也是这个理 必须区分清楚“赌赢了”和“赌对了”是两回事 书摘 不可否认，每个投资人都有自己的能力边界和局限性，但只要认识到了局限性的存在，就可以在一定程度上摆脱它的制约
长期牛股 什么行业易出长期牛股？行业集中度持续提高的行业。因为这样的行业有门槛，有先发优势，后浪没法让前浪死在沙滩上，易出大牛股。相反，如果行业越来越分散，说明行业门槛不高，既有的领先者没有足够深的护城河来阻止追赶者抢夺其市场份额，这种行业一般是城头变幻大王旗，各领风骚两三年
好公司的两个标准 一是它做的事情别人做不了；二是它做的事情自己可以重复做。前者是门槛，决定利润率的高低和趋势；后者是成长的可复制性，决定销售增速
如果二者不可兼得，宁要有门槛的低增长（可持续），也不要没门槛的高增长（不可持续）。门槛是现有的，好把握；成长是将来的，难预测。
互联网的本质是“人生人”，优势在于能以极低成本服务无数客户，规模效应体现在“人多”，二八现象不明显，是典型的散户经济，得散户者得天下
银行业的本质是“钱生钱”，规模效应体现在“钱多”，80%的业务来自20%的客户，二八现象显著，得大户者得天下，而且那20%的大客户是需要线下的高端服务的，这就是网络银行至今在欧美日韩都没有很成功的案例的重要原因
新兴行业讲的是需求快速成长的事，不必纠结于供给。而传统行业则只有控制供给，企业利润才能快速增长
乔治·索罗斯说：“凡事总有盛极而衰的时候，大好之后便是大坏。”约翰·邓普顿说：“要做拍卖会上唯一的出价者。”查理·芒格说：“倒过来想，一定要倒过来想。”卡尔·伊坎说：“买别人不买的东西，在没人买的时候买。”巴菲特说：“别人恐惧时我贪婪，别人贪婪时我恐惧
不接下跌的飞刀
。估值高的股票本身估值下调的空间大，加上这类股票的未来增长预期同样存在巨大下调空间，因此这种“戴维斯双杀”导致的下跌一般持续时间长而且幅度大，刚开始暴跌时不宜逆向投资
最后，看股价暴跌本身是否会导致公司的基本面进一步恶化，即是否有索罗斯所说的反身性。贝尔斯登和雷曼的股价下跌直接引发了债券评级的下降以及交易对手追加保证金的要求，这种负反馈带来的连锁反应就不适合逆向投资
对于灾难的发生，每个人都很难过，但是投资决策不应该加入感情的因素。
A股的情绪波动容易走极端，因此“人多的地方不去”是至理名言
作为投资者，我们能分辨清楚的就是市场的错误定价在哪个板块以及错误的程度有多大，然后远离被高估的板块，买入被低估的公司。至于市场要等多久才会进行纠错，纠错前会不会把这种错误定价进一步扩大，就不是能够预测的了
在大多数时候，真理在大多数人手里；在少数时候，真理在少数人手里。如何区别这两种情况呢？一般说来，趋势的初期和末期，就是真理在少数人手里的时候
买早了还得熬得住，这是逆向投资者的必备素质。投资者必须明白一个道理，市场中没有人能够卖在最高点、买在最低点
由此可见，流动性一旦收得紧了，很多东西的价格就会撑不住，其中的道理很简单：所有的价格其实本质上都是一种货币现象，就是说你的资金跟你所有东西的价格之和其实是一致的
右侧投资 常有人说，在A股做价值投资难，概念股满天飞，好公司没人要，便宜的股票买入后往往变得更便宜
公司有四种：好的、平庸的、烂的、看不懂的；股票也有四种：被低估的、合理的、被高估的、估不准的。人的知识、时间、精力都是有限的，因此看不懂的公司占了一大半
所谓的投资，就是牢牢抓住这个定价权。就像茅台，整天在涨价，日子太好过了，怎么提价都有人买，为什么呢？就是有这个定价权
选股票，一定是先选行业。就像买房子，一定是先看社区，社区不行，房子再漂亮也不行
我认为现在市场价格波动的风险比较大，但是本金永久性丧失的风险不大。因为市盈率在10倍，我觉得是中国的低点
同一件事，看多者和看空者往往作截然不同的解释——你看到的是你想看到的。
两个卖鞋的人到了光脚岛。悲观者说，这里人不穿鞋，卖鞋根本没市场。乐观者说，这里人没鞋穿，卖鞋市场巨大。短期看来，悲观者是对的，因为短期内要改变岛民的穿鞋习惯是很难的。长期看来，乐观者是对的，因为岛民迟早会认识到穿鞋比光脚舒服。同一事情两种解读，往往是考虑的时间跨度不同
所有的社会学规律都有反例，股市中更是如此。股市中的任何规律、方法只能提高你的成功率，没有百战百胜的灵丹妙药。我说吸烟有害身体健康，你说你三舅爷是个大烟枪但活了99岁。我说低估值价值股平均跑赢高估值成长股，你说你买的那个100倍市盈率的成长股已经涨了5倍了。我说的是规律，你说的是个例。咱俩都对，只是我对得更有代表性一些
正如乔尔·格林布拉特（Joel Greenblatt）所说，第一，价值投资是有效的；第二，价值投资不是每年都有效；第二点是第一点的保证
在建立研究方法之前，必须区分清楚“赌赢了”和“赌对了”是两回事
我认为彼得·林奇说得对，他说当有人告诉你“A公司是下一个B公司”的时候，第一要把A卖掉，第二要把B也卖掉。因为第一，A永远不会成为B；第二，B已经被当作成功的代名词，说明它的优点可能已经体现在现在的股价中了
客户彻底放弃了他们，因为机构客户最不能忍受的就是基金经理的风格飘移
这说明在季报公布出来的业绩中，成长股很容易低于预期，而价值股很容易超出预期，因为未来不会有乐观者想象的那么好，也不会有悲观者想象的那么差
公司的品质好坏，关键是看能不能具有定价权。并不是说消费品就好，投资品就不好，关键还是在于有没有定价权。
对品质的判断，第二个要注意的是差异化竞争和同质化竞争的区别
我认为做一个证券分析师就很有先发优势。做10年之后，和新进来的人相比，你的市场影响力、在行业内的人脉、对行业的理解是完全不一样的，这是个好行业。像外国的券商研究所里有60多岁了还在做分析师的人，也做得很快乐。但是，做程序员就不一定是一个好行业，可能3年就需要学一种新的计算机语言，除非你转型做产品经理。中国的很多行业就是这样，总是有后浪不断去推前浪，最后把前浪拍死在沙滩上。这样的行业就很难受。
对行业格局的分析和对公司核心竞争力的理解是“道”，财务分析只是“术”，但是后者对前者起着验证和把关的作用。
最后钱都被平台赚走了，内容公司只是为他人作嫁衣裳
比如说高端酒是得品牌者得天下，中低端酒得渠道者得天下。中低端酒的品牌忠诚度没有那么高，就看谁的渠道铺得更广，管理得更精细
国家给的寡头垄断（例如公用事业）往往伴随着价格管制，长期投资回报一般不会太高。只有市场竞争、行业洗牌后产生的寡头垄断才有定价权</description>
      <content:encoded><![CDATA[<h2 id="概括">概括</h2>
<p>这本书只浅浅地读了前一半, 总体感觉知识面是铺的很全的, 但是由于本人相关知识匮乏.
很多内容没有能够吸收, 先暂时浅读一半. 搁置.</p>
<ol>
<li>投资要投那些行业集中度高的行业, 局势清晰, 回报高. 比如白色家电.</li>
<li>投资要投有定价权的企业, 如茅台. 上一点也是这个理</li>
<li>必须区分清楚“赌赢了”和“赌对了”是两回事</li>
</ol>
<h2 id="书摘">书摘</h2>
<p>不可否认，每个投资人都有自己的能力边界和局限性，但只要认识到了局限性的存在，就可以在一定程度上摆脱它的制约</p>
<p>长期牛股 什么行业易出长期牛股？行业集中度持续提高的行业。因为这样的行业有门槛，有先发优势，后浪没法让前浪死在沙滩上，易出大牛股。相反，如果行业越来越分散，说明行业门槛不高，既有的领先者没有足够深的护城河来阻止追赶者抢夺其市场份额，这种行业一般是城头变幻大王旗，各领风骚两三年</p>
<p>好公司的两个标准 一是它做的事情别人做不了；二是它做的事情自己可以重复做。前者是门槛，决定利润率的高低和趋势；后者是成长的可复制性，决定销售增速</p>
<p>如果二者不可兼得，宁要有门槛的低增长（可持续），也不要没门槛的高增长（不可持续）。门槛是现有的，好把握；成长是将来的，难预测。</p>
<p>互联网的本质是“人生人”，优势在于能以极低成本服务无数客户，规模效应体现在“人多”，二八现象不明显，是典型的散户经济，得散户者得天下</p>
<p>银行业的本质是“钱生钱”，规模效应体现在“钱多”，80%的业务来自20%的客户，二八现象显著，得大户者得天下，而且那20%的大客户是需要线下的高端服务的，这就是网络银行至今在欧美日韩都没有很成功的案例的重要原因</p>
<p>新兴行业讲的是需求快速成长的事，不必纠结于供给。而传统行业则只有控制供给，企业利润才能快速增长</p>
<p>乔治·索罗斯说：“凡事总有盛极而衰的时候，大好之后便是大坏。”约翰·邓普顿说：“要做拍卖会上唯一的出价者。”查理·芒格说：“倒过来想，一定要倒过来想。”卡尔·伊坎说：“买别人不买的东西，在没人买的时候买。”巴菲特说：“别人恐惧时我贪婪，别人贪婪时我恐惧</p>
<p>不接下跌的飞刀</p>
<p>。估值高的股票本身估值下调的空间大，加上这类股票的未来增长预期同样存在巨大下调空间，因此这种“戴维斯双杀”导致的下跌一般持续时间长而且幅度大，刚开始暴跌时不宜逆向投资</p>
<p>最后，看股价暴跌本身是否会导致公司的基本面进一步恶化，即是否有索罗斯所说的反身性。贝尔斯登和雷曼的股价下跌直接引发了债券评级的下降以及交易对手追加保证金的要求，这种负反馈带来的连锁反应就不适合逆向投资</p>
<p>对于灾难的发生，每个人都很难过，但是投资决策不应该加入感情的因素。</p>
<p>A股的情绪波动容易走极端，因此“人多的地方不去”是至理名言</p>
<p>作为投资者，我们能分辨清楚的就是市场的错误定价在哪个板块以及错误的程度有多大，然后远离被高估的板块，买入被低估的公司。至于市场要等多久才会进行纠错，纠错前会不会把这种错误定价进一步扩大，就不是能够预测的了</p>
<p>在大多数时候，真理在大多数人手里；在少数时候，真理在少数人手里。如何区别这两种情况呢？一般说来，趋势的初期和末期，就是真理在少数人手里的时候</p>
<p>买早了还得熬得住，这是逆向投资者的必备素质。投资者必须明白一个道理，市场中没有人能够卖在最高点、买在最低点</p>
<p>由此可见，流动性一旦收得紧了，很多东西的价格就会撑不住，其中的道理很简单：所有的价格其实本质上都是一种货币现象，就是说你的资金跟你所有东西的价格之和其实是一致的</p>
<p>右侧投资 常有人说，在A股做价值投资难，概念股满天飞，好公司没人要，便宜的股票买入后往往变得更便宜</p>
<p>公司有四种：好的、平庸的、烂的、看不懂的；股票也有四种：被低估的、合理的、被高估的、估不准的。人的知识、时间、精力都是有限的，因此看不懂的公司占了一大半</p>
<p>所谓的投资，就是牢牢抓住这个定价权。就像茅台，整天在涨价，日子太好过了，怎么提价都有人买，为什么呢？就是有这个定价权</p>
<p>选股票，一定是先选行业。就像买房子，一定是先看社区，社区不行，房子再漂亮也不行</p>
<p>我认为现在市场价格波动的风险比较大，但是本金永久性丧失的风险不大。因为市盈率在10倍，我觉得是中国的低点</p>
<p>同一件事，看多者和看空者往往作截然不同的解释——你看到的是你想看到的。</p>
<p>两个卖鞋的人到了光脚岛。悲观者说，这里人不穿鞋，卖鞋根本没市场。乐观者说，这里人没鞋穿，卖鞋市场巨大。短期看来，悲观者是对的，因为短期内要改变岛民的穿鞋习惯是很难的。长期看来，乐观者是对的，因为岛民迟早会认识到穿鞋比光脚舒服。同一事情两种解读，往往是考虑的时间跨度不同</p>
<p>所有的社会学规律都有反例，股市中更是如此。股市中的任何规律、方法只能提高你的成功率，没有百战百胜的灵丹妙药。我说吸烟有害身体健康，你说你三舅爷是个大烟枪但活了99岁。我说低估值价值股平均跑赢高估值成长股，你说你买的那个100倍市盈率的成长股已经涨了5倍了。我说的是规律，你说的是个例。咱俩都对，只是我对得更有代表性一些</p>
<p>正如乔尔·格林布拉特（Joel Greenblatt）所说，第一，价值投资是有效的；第二，价值投资不是每年都有效；第二点是第一点的保证</p>
<p>在建立研究方法之前，必须区分清楚“赌赢了”和“赌对了”是两回事</p>
<p>我认为彼得·林奇说得对，他说当有人告诉你“A公司是下一个B公司”的时候，第一要把A卖掉，第二要把B也卖掉。因为第一，A永远不会成为B；第二，B已经被当作成功的代名词，说明它的优点可能已经体现在现在的股价中了</p>
<p>客户彻底放弃了他们，因为机构客户最不能忍受的就是基金经理的风格飘移</p>
<p>这说明在季报公布出来的业绩中，成长股很容易低于预期，而价值股很容易超出预期，因为未来不会有乐观者想象的那么好，也不会有悲观者想象的那么差</p>
<p>公司的品质好坏，关键是看能不能具有定价权。并不是说消费品就好，投资品就不好，关键还是在于有没有定价权。</p>
<p>对品质的判断，第二个要注意的是差异化竞争和同质化竞争的区别</p>
<p>我认为做一个证券分析师就很有先发优势。做10年之后，和新进来的人相比，你的市场影响力、在行业内的人脉、对行业的理解是完全不一样的，这是个好行业。像外国的券商研究所里有60多岁了还在做分析师的人，也做得很快乐。但是，做程序员就不一定是一个好行业，可能3年就需要学一种新的计算机语言，除非你转型做产品经理。中国的很多行业就是这样，总是有后浪不断去推前浪，最后把前浪拍死在沙滩上。这样的行业就很难受。</p>
<p>对行业格局的分析和对公司核心竞争力的理解是“道”，财务分析只是“术”，但是后者对前者起着验证和把关的作用。</p>
<p>最后钱都被平台赚走了，内容公司只是为他人作嫁衣裳</p>
<p>比如说高端酒是得品牌者得天下，中低端酒得渠道者得天下。中低端酒的品牌忠诚度没有那么高，就看谁的渠道铺得更广，管理得更精细</p>
<p>国家给的寡头垄断（例如公用事业）往往伴随着价格管制，长期投资回报一般不会太高。只有市场竞争、行业洗牌后产生的寡头垄断才有定价权</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2023 04 02</title>
      <link>https://ynikl.github.io/weekly/2023-04-02/</link>
      <pubDate>Thu, 06 Apr 2023 08:45:08 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/weekly/2023-04-02/</guid>
      <description>SQL 对某字段去重， 且取最新的一条数据 在SQL中，可以使用子查询和MAX函数来对某字段去重，并取最新的一条数据。以下是示例代码：
1 2 3 4 5 6 7 SELECT t1.* FROM table_name t1 INNER JOIN ( SELECT MAX(column1) AS max_column1 FROM table_name GROUP BY column2 ) t2 ON t1.column1 = t2.max_column1; 在上面的代码中，首先使用子查询和MAX函数，取出每个column2字段的最大值，然后将结果与原表进行INNER JOIN操作，得到最新的一条数据。 需要注意的是，如果需要根据多个字段进行去重和排序，可以在子查询中指定多个字段，并在INNER JOIN操作中使用多个字段进行连接。如果需要查询的字段比较多，可以使用通配符*来代替所有字段。 总之，在SQL中可以使用子查询和MAX函数来对某字段去重，并取最新的一条数据。需要指定需要查询的表名、字段名和排序方式，以及使用INNER JOIN操作进行连接。
查看是否用重复数据 1 SELECT name, COUNT(*) c FROM table GROUP BY name HAVING c &amp;gt; 1; mysql inner, left, right, full join https://stackoverflow.com/a/28719292
t+1 场景是什么意思 t+1场景通常指的是预测未来某个时间点的情况，即在当前时刻t，预测下一个时间点t+1的情况。这个概念在很多领域都有应用，例如金融、经济、物流、天气预报等等。 在金融领域，t+1场景通常指的是预测未来某个时间点的股票价格、汇率、利率等等。例如，如果当前时刻是2021年1月1日，那么预测2021年1月2日某个股票的价格就是一个t+1场景。 在物流领域，t+1场景通常指的是预测未来某个时间点的货物运输情况，例如预测某个包裹在下一个时间点是否能够按时到达目的地。 在人工智能和机器学习领域，t+1场景通常指的是使用历史数据来预测未来某个时间点的情况，例如预测明天的气温、下一个小时的交通流量等等。这个过程通常需要使用时间序列分析、回归分析等技术来处理。 总之，t+1场景是一个非常常见的概念，可以用于预测未来某个时间点的情况，帮助人们做出更好的决策。
湖仓能力 “湖仓能力”通常指的是企业在数据仓库（Data Warehouse）方面的能力，即构建和管理大规模数据仓库的能力。数据仓库是一个用于存储和管理企业数据的系统，它可以集成来自不同数据源的数据，并对这些数据进行处理、分析和挖掘，以帮助企业做出更好的决策。 “湖仓”是数据仓库的一种类型，它是近年来兴起的一种新型数据仓库，与传统的关系型数据仓库（RDBMS）不同，湖仓采用了分布式、非关系型的架构，可以处理更加海量和复杂的数据，例如半结构化数据、文本数据、图像数据等等。湖仓通常采用了Hadoop、Spark、Hive、Presto等开源技术来构建和管理。 因此，“湖仓能力”通常指企业在构建和管理大规模、分布式、非关系型的数据仓库方面的能力，包括数据的采集、清洗、存储、处理、分析、挖掘等等。对于现代企业来说，湖仓能力已经成为了一项非常重要的核心竞争力，可以帮助企业更好地理解和应对市场变化，提高决策的准确性和效率。</description>
      <content:encoded><![CDATA[<h3 id="sql-对某字段去重-且取最新的一条数据">SQL 对某字段去重， 且取最新的一条数据</h3>
<p>在SQL中，可以使用子查询和MAX函数来对某字段去重，并取最新的一条数据。以下是示例代码：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">SELECT t1.*
</span></span><span class="line"><span class="cl">FROM table_name t1
</span></span><span class="line"><span class="cl">INNER JOIN (
</span></span><span class="line"><span class="cl">    SELECT MAX(column1) AS max_column1
</span></span><span class="line"><span class="cl">    FROM table_name
</span></span><span class="line"><span class="cl">    GROUP BY column2
</span></span><span class="line"><span class="cl">) t2 ON t1.column1 = t2.max_column1;
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的代码中，首先使用子查询和MAX函数，取出每个column2字段的最大值，然后将结果与原表进行INNER JOIN操作，得到最新的一条数据。
需要注意的是，如果需要根据多个字段进行去重和排序，可以在子查询中指定多个字段，并在INNER JOIN操作中使用多个字段进行连接。如果需要查询的字段比较多，可以使用通配符*来代替所有字段。
总之，在SQL中可以使用子查询和MAX函数来对某字段去重，并取最新的一条数据。需要指定需要查询的表名、字段名和排序方式，以及使用INNER JOIN操作进行连接。</p>
<h3 id="查看是否用重复数据">查看是否用重复数据</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">SELECT name, COUNT(*) c FROM table GROUP BY name HAVING c &gt; 1;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="mysql-inner-left-right-full-join">mysql inner, left, right, full join</h3>
<p><a href="https://stackoverflow.com/a/28719292">https://stackoverflow.com/a/28719292</a></p>
<h3 id="t1-场景是什么意思">t+1 场景是什么意思</h3>
<p><code>t+1</code>场景通常指的是预测未来某个时间点的情况，即在当前时刻<code>t</code>，预测下一个时间点<code>t+1</code>的情况。这个概念在很多领域都有应用，例如金融、经济、物流、天气预报等等。
在金融领域，<code>t+1</code>场景通常指的是预测未来某个时间点的股票价格、汇率、利率等等。例如，如果当前时刻是2021年1月1日，那么预测2021年1月2日某个股票的价格就是一个<code>t+1</code>场景。
在物流领域，<code>t+1</code>场景通常指的是预测未来某个时间点的货物运输情况，例如预测某个包裹在下一个时间点是否能够按时到达目的地。
在人工智能和机器学习领域，<code>t+1</code>场景通常指的是使用历史数据来预测未来某个时间点的情况，例如预测明天的气温、下一个小时的交通流量等等。这个过程通常需要使用时间序列分析、回归分析等技术来处理。
总之，<code>t+1</code>场景是一个非常常见的概念，可以用于预测未来某个时间点的情况，帮助人们做出更好的决策。</p>
<h3 id="湖仓能力">湖仓能力</h3>
<p>“湖仓能力”通常指的是企业在数据仓库（Data Warehouse）方面的能力，即构建和管理大规模数据仓库的能力。数据仓库是一个用于存储和管理企业数据的系统，它可以集成来自不同数据源的数据，并对这些数据进行处理、分析和挖掘，以帮助企业做出更好的决策。
“湖仓”是数据仓库的一种类型，它是近年来兴起的一种新型数据仓库，与传统的关系型数据仓库（RDBMS）不同，湖仓采用了分布式、非关系型的架构，可以处理更加海量和复杂的数据，例如半结构化数据、文本数据、图像数据等等。湖仓通常采用了Hadoop、Spark、Hive、Presto等开源技术来构建和管理。
因此，“湖仓能力”通常指企业在构建和管理大规模、分布式、非关系型的数据仓库方面的能力，包括数据的采集、清洗、存储、处理、分析、挖掘等等。对于现代企业来说，湖仓能力已经成为了一项非常重要的核心竞争力，可以帮助企业更好地理解和应对市场变化，提高决策的准确性和效率。</p>
<h3 id="jwt">JWT</h3>
<p><code>header . payload . secret </code></p>
<p>header 和 payload 都是可以使用 base64 进行解密, 获取其中的 json 信息, 是公开的.
secret 是使用header中的 加密算法 对<code>header+payload+secret</code>进行计算, 验证jwt信息没有被修改过.</p>
<p><a href="https://jwt.io/introduction">https://jwt.io/introduction</a></p>
<h3 id="jwt-1">jwt</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">HMACSHA256(
</span></span><span class="line"><span class="cl">  base64UrlEncode(header) + &#34;.&#34; +
</span></span><span class="line"><span class="cl">  base64UrlEncode(payload),
</span></span><span class="line"><span class="cl">  your-256-bit-secret
</span></span><span class="line"><span class="cl">)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="replace-into">replace into</h3>
<p>replace into 跟 insert 功能类似，不同点在于：replace into 首先尝试插入数据到表中， 1. 如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据。 2. 否则，直接插入新数据。
要注意的是：插入数据的表必须有主键或者是唯一索引！否则的话，replace into 会直接插入数据，这将导致表中出现重复的数据。</p>
<h3 id="golang-避免多次打印同一个错误">golang 避免多次打印同一个错误</h3>
<blockquote>
<p>打印错误也是一种错误的处理方式. 所有, 要么选择打印错误, 要么选择向上抛出错误.
不要两者同时.</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>2023 03 26</title>
      <link>https://ynikl.github.io/weekly/2023-03-26/</link>
      <pubDate>Thu, 06 Apr 2023 08:41:54 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/weekly/2023-03-26/</guid>
      <description>golang 泛型: type parameters interface 定义一系列类型 type constraint ~string [s [] E, E any] type inferene 官方泛型介绍
判断时间是否重叠 startA &amp;lt; endB and endA &amp;gt; startB stackoverflow
python -m python -m 是 Python 命令行工具中的一个选项，用于执行 Python 模块
pypi 名称 Python Package Index , python 的包的目录
拥有多个小项目对公司成本的影响 扎克伯格 的裁员信
&amp;ldquo;人们很容易认为，只要一个项目产生的价值超过其直接成本，它就是正收益的。 但是，任何项目都需要一个主管，我们要么提拔一个工程师，要么从另一个项目挑选一个人，让其负责该项目。这两种情况都分散了人才，并且创造出了更多的管理层。 如果项目继续发展，整个团队也许分散到多个楼层或多个办公室，这让沟通变得更加困难。 我们还需要为项目配备更多的笔记本电脑和其他资源，这些更多的工程师还会导致雇佣更多的 IT 人员、HR 人员和招聘人员。 随着团队越来越大，效率不断降低，反应变迟钝了。它也许会与另一个团队的工作重叠，或者本应使用现有基础架构时却构建了一个定制系统。 总之，那些低优先级项目对公司重要性不大，却带来复杂的间接成本，很容易低估它们。&amp;rdquo;
AES Advanced Encryption Standard 当前最流行的对称加密
wikipeida
golang http 请求转化成 curl 可以方便地将 http.Request 转化成可直接输出成字符串的 curl 对象</description>
      <content:encoded><![CDATA[<h3 id="golang-泛型">golang 泛型:</h3>
<ol>
<li>type parameters</li>
<li>interface 定义一系列类型</li>
<li><code>type constraint</code></li>
<li>~string</li>
<li><code>[s [] E, E any]</code></li>
<li>type inferene</li>
</ol>
<p><a href="https://go.dev/blog/intro-generics">官方泛型介绍</a></p>
<h3 id="判断时间是否重叠">判断时间是否重叠</h3>
<p>startA &lt; endB and endA &gt; startB
<a href="https://stackoverflow.com/a/325964">stackoverflow</a></p>
<h3 id="python--m">python -m</h3>
<p><code>python -m</code> 是 Python 命令行工具中的一个选项，用于执行 Python 模块</p>
<p>pypi 名称 Python Package Index , python 的包的目录</p>
<h3 id="拥有多个小项目对公司成本的影响">拥有多个小项目对公司成本的影响</h3>
<p>扎克伯格 的裁员信</p>
<blockquote>
<p>&ldquo;人们很容易认为，只要一个项目产生的价值超过其直接成本，它就是正收益的。
但是，任何项目都需要一个主管，我们要么提拔一个工程师，要么从另一个项目挑选一个人，让其负责该项目。这两种情况都分散了人才，并且创造出了更多的管理层。
如果项目继续发展，整个团队也许分散到多个楼层或多个办公室，这让沟通变得更加困难。
我们还需要为项目配备更多的笔记本电脑和其他资源，这些更多的工程师还会导致雇佣更多的 IT 人员、HR 人员和招聘人员。
随着团队越来越大，效率不断降低，反应变迟钝了。它也许会与另一个团队的工作重叠，或者本应使用现有基础架构时却构建了一个定制系统。
总之，那些低优先级项目对公司重要性不大，却带来复杂的间接成本，很容易低估它们。&rdquo;</p>
</blockquote>
<h3 id="aes">AES</h3>
<p>Advanced Encryption Standard 当前最流行的对称加密</p>
<p><a href="https://zh.wikipedia.org/wiki/%E9%AB%98%E7%BA%A7%E5%8A%A0%E5%AF%86%E6%A0%87%E5%87%86">wikipeida</a></p>
<h3 id="golang-http-请求转化成-curl">golang http 请求转化成 curl</h3>
<p>可以方便地将 http.Request 转化成可直接输出成字符串的 curl 对象</p>
<p><a href="https://github.com/moul/http2curl">http2curl</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>30年后, 你拿什么养活自己</title>
      <link>https://ynikl.github.io/books/30-year-after/</link>
      <pubDate>Sat, 25 Mar 2023 22:31:54 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/30-year-after/</guid>
      <description>总结 要重视自己没有退休金的未来生活, 现在总是不敢去认真对待未来, 总是天真地认为未来的 一切都变好的.
进行资金投资的时候不能简单地求稳, 需要根据自己目标的年化率选择合适的投资方式, 不 然可能年物价上涨的都跑不过, 导致购买力下降
开发自己的能力潜能, 提高自己的年薪是打工人最好提升收入的方式.
要对未来有明确的规划, 对一些专项事务, 准备目标基金, 比如孩子结婚, 购置房产.
整理和弄清自己的财务状况, 量入为出, 尽量缩进不必要的开支.
书摘 “假设你现在30岁，计划在55岁退休，终老年龄80岁。目前城市基本生活费和医疗保险支出的最基本消费是1500元/月，暂考虑4%的通货膨胀率，25年后，要维持目前的生活水平，需要4000元/月。25年的退休生活至少需要4000元/月×12月×25年=120万元，如果加上旅游、休闲支出按月消费最基本的1000元计算，还将增加80万元，总共200万元。200万，这只是一个人的费用，夫妻双方费用需求总和保守估计也将超过400万元”
“养老金是国家为保障国民在丧失劳动能力时，即在残疾或晚年状态下也能享有基本生活权利的制度”
“这15年的零用钱都是孩子们给的，拿零用钱都得看他们脸色，我哪敢再向他们开口要钱请朋友吃饭……”
“以前常听老人说“过了40岁就该处处花钱了”，这句话果然没错。尽管收入有增加，但是支出的增长速度更快，所以人生收支变成负数的时期就是从40岁中期开始的。再加上45岁后还要面临退休的问题，收入不保的可能性大大增加”
“想到自己以前没有做好人生的理财规划，总是漫无目标地过着安逸的生活，天真地以为“以后总有办法解决”，不禁埋怨起自己来”
“不是有句话说，当你觉得太迟的时候，其实正是最早的一刻”
“但是每个人必须做的就是为目标资金做准备，为此即便要放弃目前的一部分支出和财产，也要毫不犹豫予以舍弃”
“掌握自己目前的净资产搞清自己每月收支状况推算自己的劳动时间设定自己期望的退休生活标准持续为退休生活进行投资”
“人们觉得只要有利息产生，储蓄额上升了，资产也会随之增加，其实这只不过是人们的一种错觉，因为即使储蓄额上升，但如果物价也一同上涨，购买力还是不会发生任何变化，到最后顶多也只能保本，并没有形成增值”
“掌握自己目前的净资产搞清自己每月收支状况推算自己的劳动时间设定自己期望的退休生活标准持续为退休生活进行投资”
“在估算储蓄额度时，有两件事要注意。首先，要适当控制支出；其次，要不断通过努力来增加收入。此外，在估算今后生活所需的支出费用时，不仅要将现在的支出计算在内，退休后的预计支出也要包括在内。每月花多少生活费是一目了然的，但子女教育费和结婚费用，以及有可能是大额投入的医疗费也同样不能忽视”
“企业出现赤字会影响企业稳定，家庭也是一样，只有家庭的财务结构搭建得十分扎实，才可以指望家庭经济出现增长。为此我们要审视家庭的财务状况，必要的话要进行结构调整，减少不必要的支出，将只产生费用的资产果断处理掉，只保留能够带来收益的资产。结构不佳的财务状况就好像一艘有破洞的船一样，如果钱一直流出去，那赚再多的钱也没用。但是要注意，家庭资产的结构调整不是小俊兄一人的事，必须和夫人共同商议后再做决定。”
“像我们这样的上班族要想提高收入，首选方式是提高年薪。为了达到这个目的，光是干好本职工作是不够的，还要倾注更大的努力专注于自我潜能开发。我们不是经常见到因为英语能力不足而失去晋升机会或更好工作岗位的现实例子吗？只有拥有实力，年薪才有可能提高。上班族年薪拿到好几十万或几百万的故事离我们并不遥远，有的就发生在我们身边……据统计，大部分想成为富翁的人并不指望通过工作来致富，而是梦想着通过理财来成为富翁，这听起来是不是很滑稽？”
“为了更有效地发挥家庭账簿的作用，一定要有个比较的标准。每月需要建立预算，并时常拿这个预算与实际支出情况作比较，此外需要注意一点，预算必须将节约目标与实际情况合理地结合在一起，没有节约目标或目标脱离现实，这样的预算就不具任何意义”
“今后，比起资金的募集，如何更有效地通过运作让资金增值将会成为整个社会关注的焦点。储蓄的时代正在转变成为投资的时代，但问题是很多人至今没有看到社会的这种变化，仍然固守着自己亘古不变的储蓄观念。”
“如果因为担心失败而干脆放弃投资，这样的企业不会再成长，最终逃脱不了被市场淘汰的命运。”
“如果想通过25年的储蓄来为25年的退休生活筹集资金，考虑到物价等因素的存在，即使把现在一半的收入都存进去也还是不够。归根结底我们的一生中必须有一段时期要通过承担风险来提高收入，我们要趁自己还年轻、还有稳定收入的时候来承担风险。在自己还有固定收入的时候，如果因为投资出现亏损，我们还可以一直等待获利那一天的到来，并且还可以通过节约和储蓄来弥补亏损的部分。但是等上了年纪没有固定收入后，你身上的钱都是用来维持生计的，资金上稍微出一点问题就会给你的人生带来致命的打击。”
“我认为基金投资的成功原则有五个，三个核心原则和两个附属原则，三个核心原则为‘挑选优良基金’、‘分散投资’和‘长期投资’，此外的两个原则是‘找到符合自己的投资取向’和‘积极听取专家的意见’。”
“比方说按照4.5％的利率（税后为3.8%）进行一个25年期的定期储蓄，最后的结果会如何？虽然25年后能安全地获得利息，但是这不能称之为安全的投资。还记得我们之前提到过的物价因素吧，如果年平均物价上涨率超过3.8%该怎么办？因利息而带来的资产增值效果被物价的上涨所抵消，资产购买力反而减少，假设物价年平均上涨率为5%，25年后物价上涨了3.4倍，与之相反，资产增值仅为2.5倍（按复利计算），资产（金额）虽然增长，但实际购买力反而下降25%，这就等于是说存了二十多年的钱，先别指望资产增加，事实上连本金都赔了21%，这样一种投资当然不能算作安全的投资。在筹集退休生活资金时，不考虑物价上涨因素，而一味关注本金额度的保障，这么做实际上没有任何意义。”
“我们活在这世上需要应对两个最大的危险，一个是过早死去的危险，另一个是活得太长的危险，”
“思凡所说的要应对太早死亡的危险，指的是人寿保险吗？我也买了这种保险，是在第一个孩子出生时买的，现在已经是第6年了。”“没错。一家之主本来就对家人负有经济上的抚养义务，而且这种抚养义务不是只有在活着的时候，即便不幸身故，也应该为家人做好准备”
“在计算费用时最好将固定支出和浮动支出分开计算。固定支出为住房贷款偿还费用、汽车分期付款、保险费、公共教育费、税金等一些固定发生的费用，这些是不可能按自己意愿进行调节的。与之相反，浮动支出则是像伙食费、课外教育费、零用钱、文化生活费、服装费等可以根据自身的选择来进行调节的费用，要想确保一定的储蓄能力靠的就是对这些费用的调节。”
“很多人都会和钱小俊一样感受到生活的冷酷，于是乎不少人选择了逃避，干脆就不管不问自己的财务状况，但如果不想自己的晚年陷入悲惨境地，不想等到老了之后再去面对，最好还是现在正视自己的财务问题。”</description>
      <content:encoded><![CDATA[<h2 id="总结">总结</h2>
<p>要重视自己没有退休金的未来生活, 现在总是不敢去认真对待未来, 总是天真地认为未来的
一切都变好的.</p>
<p>进行资金投资的时候不能简单地求稳, 需要根据自己目标的年化率选择合适的投资方式, 不
然可能年物价上涨的都跑不过, 导致购买力下降</p>
<p>开发自己的能力潜能, 提高自己的年薪是打工人最好提升收入的方式.</p>
<p>要对未来有明确的规划, 对一些专项事务, 准备目标基金, 比如孩子结婚, 购置房产.</p>
<p>整理和弄清自己的财务状况, 量入为出, 尽量缩进不必要的开支.</p>
<h2 id="书摘">书摘</h2>
<blockquote>
<p>“假设你现在30岁，计划在55岁退休，终老年龄80岁。目前城市基本生活费和医疗保险支出的最基本消费是1500元/月，暂考虑4%的通货膨胀率，25年后，要维持目前的生活水平，需要4000元/月。25年的退休生活至少需要4000元/月×12月×25年=120万元，如果加上旅游、休闲支出按月消费最基本的1000元计算，还将增加80万元，总共200万元。200万，这只是一个人的费用，夫妻双方费用需求总和保守估计也将超过400万元”</p>
</blockquote>
<blockquote>
<p>“养老金是国家为保障国民在丧失劳动能力时，即在残疾或晚年状态下也能享有基本生活权利的制度”</p>
</blockquote>
<blockquote>
<p>“这15年的零用钱都是孩子们给的，拿零用钱都得看他们脸色，我哪敢再向他们开口要钱请朋友吃饭……”</p>
</blockquote>
<blockquote>
<p>“以前常听老人说“过了40岁就该处处花钱了”，这句话果然没错。尽管收入有增加，但是支出的增长速度更快，所以人生收支变成负数的时期就是从40岁中期开始的。再加上45岁后还要面临退休的问题，收入不保的可能性大大增加”</p>
</blockquote>
<blockquote>
<p>“想到自己以前没有做好人生的理财规划，总是漫无目标地过着安逸的生活，天真地以为“以后总有办法解决”，不禁埋怨起自己来”</p>
</blockquote>
<blockquote>
<p>“不是有句话说，当你觉得太迟的时候，其实正是最早的一刻”</p>
</blockquote>
<blockquote>
<p>“但是每个人必须做的就是为目标资金做准备，为此即便要放弃目前的一部分支出和财产，也要毫不犹豫予以舍弃”</p>
</blockquote>
<blockquote>
<p>“掌握自己目前的净资产搞清自己每月收支状况推算自己的劳动时间设定自己期望的退休生活标准持续为退休生活进行投资”</p>
</blockquote>
<blockquote>
<p>“人们觉得只要有利息产生，储蓄额上升了，资产也会随之增加，其实这只不过是人们的一种错觉，因为即使储蓄额上升，但如果物价也一同上涨，购买力还是不会发生任何变化，到最后顶多也只能保本，并没有形成增值”</p>
</blockquote>
<blockquote>
<p>“掌握自己目前的净资产搞清自己每月收支状况推算自己的劳动时间设定自己期望的退休生活标准持续为退休生活进行投资”</p>
</blockquote>
<blockquote>
<p>“在估算储蓄额度时，有两件事要注意。首先，要适当控制支出；其次，要不断通过努力来增加收入。此外，在估算今后生活所需的支出费用时，不仅要将现在的支出计算在内，退休后的预计支出也要包括在内。每月花多少生活费是一目了然的，但子女教育费和结婚费用，以及有可能是大额投入的医疗费也同样不能忽视”</p>
</blockquote>
<blockquote>
<p>“企业出现赤字会影响企业稳定，家庭也是一样，只有家庭的财务结构搭建得十分扎实，才可以指望家庭经济出现增长。为此我们要审视家庭的财务状况，必要的话要进行结构调整，减少不必要的支出，将只产生费用的资产果断处理掉，只保留能够带来收益的资产。结构不佳的财务状况就好像一艘有破洞的船一样，如果钱一直流出去，那赚再多的钱也没用。但是要注意，家庭资产的结构调整不是小俊兄一人的事，必须和夫人共同商议后再做决定。”</p>
</blockquote>
<blockquote>
<p>“像我们这样的上班族要想提高收入，首选方式是提高年薪。为了达到这个目的，光是干好本职工作是不够的，还要倾注更大的努力专注于自我潜能开发。我们不是经常见到因为英语能力不足而失去晋升机会或更好工作岗位的现实例子吗？只有拥有实力，年薪才有可能提高。上班族年薪拿到好几十万或几百万的故事离我们并不遥远，有的就发生在我们身边……据统计，大部分想成为富翁的人并不指望通过工作来致富，而是梦想着通过理财来成为富翁，这听起来是不是很滑稽？”</p>
</blockquote>
<blockquote>
<p>“为了更有效地发挥家庭账簿的作用，一定要有个比较的标准。每月需要建立预算，并时常拿这个预算与实际支出情况作比较，此外需要注意一点，预算必须将节约目标与实际情况合理地结合在一起，没有节约目标或目标脱离现实，这样的预算就不具任何意义”</p>
</blockquote>
<blockquote>
<p>“今后，比起资金的募集，如何更有效地通过运作让资金增值将会成为整个社会关注的焦点。储蓄的时代正在转变成为投资的时代，但问题是很多人至今没有看到社会的这种变化，仍然固守着自己亘古不变的储蓄观念。”</p>
</blockquote>
<blockquote>
<p>“如果因为担心失败而干脆放弃投资，这样的企业不会再成长，最终逃脱不了被市场淘汰的命运。”</p>
</blockquote>
<blockquote>
<p>“如果想通过25年的储蓄来为25年的退休生活筹集资金，考虑到物价等因素的存在，即使把现在一半的收入都存进去也还是不够。归根结底我们的一生中必须有一段时期要通过承担风险来提高收入，我们要趁自己还年轻、还有稳定收入的时候来承担风险。在自己还有固定收入的时候，如果因为投资出现亏损，我们还可以一直等待获利那一天的到来，并且还可以通过节约和储蓄来弥补亏损的部分。但是等上了年纪没有固定收入后，你身上的钱都是用来维持生计的，资金上稍微出一点问题就会给你的人生带来致命的打击。”</p>
</blockquote>
<blockquote>
<p>“我认为基金投资的成功原则有五个，三个核心原则和两个附属原则，三个核心原则为‘挑选优良基金’、‘分散投资’和‘长期投资’，此外的两个原则是‘找到符合自己的投资取向’和‘积极听取专家的意见’。”</p>
</blockquote>
<blockquote>
<p>“比方说按照4.5％的利率（税后为3.8%）进行一个25年期的定期储蓄，最后的结果会如何？虽然25年后能安全地获得利息，但是这不能称之为安全的投资。还记得我们之前提到过的物价因素吧，如果年平均物价上涨率超过3.8%该怎么办？因利息而带来的资产增值效果被物价的上涨所抵消，资产购买力反而减少，假设物价年平均上涨率为5%，25年后物价上涨了3.4倍，与之相反，资产增值仅为2.5倍（按复利计算），资产（金额）虽然增长，但实际购买力反而下降25%，这就等于是说存了二十多年的钱，先别指望资产增加，事实上连本金都赔了21%，这样一种投资当然不能算作安全的投资。在筹集退休生活资金时，不考虑物价上涨因素，而一味关注本金额度的保障，这么做实际上没有任何意义。”</p>
</blockquote>
<blockquote>
<p>“我们活在这世上需要应对两个最大的危险，一个是过早死去的危险，另一个是活得太长的危险，”</p>
</blockquote>
<blockquote>
<p>“思凡所说的要应对太早死亡的危险，指的是人寿保险吗？我也买了这种保险，是在第一个孩子出生时买的，现在已经是第6年了。”“没错。一家之主本来就对家人负有经济上的抚养义务，而且这种抚养义务不是只有在活着的时候，即便不幸身故，也应该为家人做好准备”</p>
</blockquote>
<blockquote>
<p>“在计算费用时最好将固定支出和浮动支出分开计算。固定支出为住房贷款偿还费用、汽车分期付款、保险费、公共教育费、税金等一些固定发生的费用，这些是不可能按自己意愿进行调节的。与之相反，浮动支出则是像伙食费、课外教育费、零用钱、文化生活费、服装费等可以根据自身的选择来进行调节的费用，要想确保一定的储蓄能力靠的就是对这些费用的调节。”</p>
</blockquote>
<blockquote>
<p>“很多人都会和钱小俊一样感受到生活的冷酷，于是乎不少人选择了逃避，干脆就不管不问自己的财务状况，但如果不想自己的晚年陷入悲惨境地，不想等到老了之后再去面对，最好还是现在正视自己的财务问题。”</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>人类简史</title>
      <link>https://ynikl.github.io/books/a-brief-history-of-humankind/</link>
      <pubDate>Sat, 25 Mar 2023 22:05:11 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/a-brief-history-of-humankind/</guid>
      <description>人类简史 总结 人类进化历史上有三次革命 认知革命: 人类通过共同的虚拟故事(信仰,部落等)开始了大规模的合作, 认知革命让人类脱离了生物学的进化路程.
农业革命: 人类部落人口数量开始爆发性增长, 人类第一次开始不得不相互胁迫进入更糟糕的生活, 开始了长期的农业劳作(工作时间远大于采集时期). 人口爆发增加就需要更大的虚拟故事来进行合作, 出现了城镇, 国家, 宗教.
科学革命: 人类开始承认自己无知, 用数据和实现代替原先用神话来掩饰不知道的问题.
虚拟故事 包括现在&amp;quot;人人平等&amp;quot; 也只是因为我们现在社会需要这种解释, 大家愿意相信这样子的虚拟故事.
我们相信某种秩序，并非因为它是客观的现实，而是因为相信它可以让人提升合作效率、打造更美好的社会。这种由想象所建构的秩序绝非邪恶的阴谋或是无用的空谈，而是唯一能让大群人类合作的救命仙丹。但也别忘了，汉谟拉比也可以用同样的逻辑来捍卫他的阶级原则：“我知道所谓上等人、平民和奴隶在本质上其实并没有什么不同。但如果我们这么相信，就能创造出一个稳定繁荣的社会。”
国家保证个人财产是神圣不可侵犯的, 是因为国家需要吸引外来投资和让人民有努力工作劲头.
资本主义 在新的资本主义教条里，最神圣的开宗明义第一条就是：“生产的利润，必须再投资于提高产量。
资本是指投入的生产的资金, 而财富是指固定不动的资金
收获 农业革命之后人类开始违背自己的生物学进化规则, 开始长期拱背在农田里工作, 久坐办公室之前.
十字军东征是因为欧洲贵族的信奉冲突(认知失调)导致的, 即信奉天主教,有遵守骑士精神.
一级混沌 不会因为受到预测而发生改变(比如, 天气), 二级混沌会
金钱是最成功的人类共同想象
社会性的贫穷，指的是某些人掌握了机会，却不愿意释出给他人；
完全自由的市场可能会导致资本家通过垄断或者串通打击劳工
由于人类产能上升, 现在社会鼓吹新型的&amp;quot;消费大众&amp;quot;
现在&amp;quot;独立&amp;quot;, &amp;ldquo;平等&amp;rdquo;, &amp;ldquo;自由&amp;quot;的思潮盛行, 让每个人都有自己的, 社群和家庭的凝聚力下降, 让我们每个人都感到更加的孤独.
如果出现的长生不老的药物, 可能就会引起世界强烈的愤怒和焦虑, 现在让穷人自己安慰的唯一理由, 就是死亡是完全公平的.
尼采
只要有了活下去的理由，几乎什么都能够忍受。生活有意义，就算在困境中也能甘之如饴；生活无意义，就算在顺境中也度日如年。
在科学角度, 人生没有意义. 意义都是我们自己赋予, 比较中世纪多做好事期待来世. 人们生活在自己的臆想之中就会过得很幸福.
吉尔伽美什计划是旨在大幅提升人体机能，预防和治疗人类疑难疾病，从而大幅度的增长人类寿命的一项人体改造计划，最终走向可能导致超级人类的出现，有人预测在2050年左右会出现长生之人。
书摘 在历史的路上，有三大重要革命：大约7万年前，“认知革命”（Cognitive Revolution）让历史正式启动。大约12000年前，“农业革命”（Agricultural Revolution）让历史加速发展。而到了大约不过是500年前，“科学革命”（Scientific Revolution）可以说是让历史画下句点而另创新局。
生物学家把所有生物划分成不同的“物种”。而所谓属于同一物种，就是它们会彼此交配，能够产出下一代。
从同一个祖先演化而来的不同物种，会属于同一个“属”（genus）。
同一科的所有成员，都能追溯到某个最早的雄性或雌性祖先。
在欧洲和西亚的人类成了“Homo neanderthalensis”，意为“来自尼安德谷（Neander Valley）的人”，一般简称为“尼安德特人”（Neanderthals）。比起我们这种“智人”，尼安德特人更为魁梧，肌肉也更发达，非常适应西方的欧亚大陆在冰河时期的寒冷气候。</description>
      <content:encoded><![CDATA[<h1 id="人类简史httpsbookdoubancomsubject25985021"><a href="https://book.douban.com/subject/25985021/">人类简史</a></h1>
<h2 id="总结">总结</h2>
<h3 id="人类进化历史上有三次革命">人类进化历史上有三次革命</h3>
<p>认知革命: 人类通过共同的虚拟故事(信仰,部落等)开始了大规模的合作, 认知革命让人类脱离了生物学的进化路程.</p>
<p>农业革命: 人类部落人口数量开始爆发性增长, 人类第一次开始不得不相互胁迫进入更糟糕的生活, 开始了长期的农业劳作(工作时间远大于采集时期). 人口爆发增加就需要更大的虚拟故事来进行合作, 出现了城镇, 国家, 宗教.</p>
<p>科学革命: 人类开始承认自己无知, 用数据和实现代替原先用神话来掩饰不知道的问题.</p>
<h3 id="虚拟故事">虚拟故事</h3>
<p>包括现在&quot;人人平等&quot; 也只是因为我们现在社会需要这种解释, 大家愿意相信这样子的虚拟故事.</p>
<blockquote>
<p>我们相信某种秩序，并非因为它是客观的现实，而是因为相信它可以让人提升合作效率、打造更美好的社会。这种由想象所建构的秩序绝非邪恶的阴谋或是无用的空谈，而是唯一能让大群人类合作的救命仙丹。但也别忘了，汉谟拉比也可以用同样的逻辑来捍卫他的阶级原则：“我知道所谓上等人、平民和奴隶在本质上其实并没有什么不同。但如果我们这么相信，就能创造出一个稳定繁荣的社会。”</p>
</blockquote>
<p>国家保证个人财产是神圣不可侵犯的, 是因为国家需要吸引外来投资和让人民有努力工作劲头.</p>
<h3 id="资本主义">资本主义</h3>
<blockquote>
<p>在新的资本主义教条里，最神圣的开宗明义第一条就是：“生产的利润，必须再投资于提高产量。</p>
</blockquote>
<p>资本是指投入的生产的资金, 而财富是指固定不动的资金</p>
<h2 id="收获">收获</h2>
<p>农业革命之后人类开始违背自己的生物学进化规则, 开始长期拱背在农田里工作, 久坐办公室之前.</p>
<p>十字军东征是因为欧洲贵族的信奉冲突(认知失调)导致的, 即信奉天主教,有遵守骑士精神.</p>
<p>一级混沌 不会因为受到预测而发生改变(比如, 天气), 二级混沌会</p>
<p>金钱是最成功的人类共同想象</p>
<p>社会性的贫穷，指的是某些人掌握了机会，却不愿意释出给他人；</p>
<p>完全自由的市场可能会导致资本家通过垄断或者串通打击劳工</p>
<p>由于人类产能上升, 现在社会鼓吹新型的&quot;消费大众&quot;</p>
<p>现在&quot;独立&quot;, &ldquo;平等&rdquo;, &ldquo;自由&quot;的思潮盛行, 让每个人都有自己的, 社群和家庭的凝聚力下降, 让我们每个人都感到更加的孤独.</p>
<p>如果出现的长生不老的药物, 可能就会引起世界强烈的愤怒和焦虑, 现在让穷人自己安慰的唯一理由, 就是死亡是完全公平的.</p>
<p>尼采</p>
<blockquote>
<p>只要有了活下去的理由，几乎什么都能够忍受。生活有意义，就算在困境中也能甘之如饴；生活无意义，就算在顺境中也度日如年。</p>
</blockquote>
<p>在科学角度, 人生没有意义. 意义都是我们自己赋予, 比较中世纪多做好事期待来世. 人们生活在自己的臆想之中就会过得很幸福.</p>
<p>吉尔伽美什计划是旨在大幅提升人体机能，预防和治疗人类疑难疾病，从而大幅度的增长人类寿命的一项人体改造计划，最终走向可能导致超级人类的出现，有人预测在2050年左右会出现长生之人。</p>
<h2 id="书摘">书摘</h2>
<blockquote>
<p>在历史的路上，有三大重要革命：大约7万年前，“认知革命”（Cognitive Revolution）让历史正式启动。大约12000年前，“农业革命”（Agricultural Revolution）让历史加速发展。而到了大约不过是500年前，“科学革命”（Scientific Revolution）可以说是让历史画下句点而另创新局。</p>
</blockquote>
<blockquote>
<p>生物学家把所有生物划分成不同的“物种”。而所谓属于同一物种，就是它们会彼此交配，能够产出下一代。</p>
</blockquote>
<blockquote>
<p>从同一个祖先演化而来的不同物种，会属于同一个“属”（genus）。</p>
</blockquote>
<blockquote>
<p>同一科的所有成员，都能追溯到某个最早的雄性或雌性祖先。</p>
</blockquote>
<blockquote>
<p>在欧洲和西亚的人类成了“Homo neanderthalensis”，意为“来自尼安德谷（Neander Valley）的人”，一般简称为“尼安德特人”（Neanderthals）。比起我们这种“智人”，尼安德特人更为魁梧，肌肉也更发达，非常适应西方的欧亚大陆在冰河时期的寒冷气候。</p>
</blockquote>
<blockquote>
<p>在欧洲和西亚的人类成了“Homo neanderthalensis”，意为“来自尼安德谷（Neander Valley）的人”，一般简称为“尼安德特人”（Neanderthals）。比起我们这种“智人”，尼安德特人更为魁梧，肌肉也更发达，非常适应西方的欧亚大陆在冰河时期的寒冷气候。至于在东方的亚洲，住的则是“Homo erectus”（直立人），一共存续了将近200万年，是目前所知存续最久的人类物种，而我们智人看来也很难打破这项纪录。</p>
</blockquote>
<blockquote>
<p>至于在印度尼西亚的爪哇岛，则住着“Homo soloensis”（梭罗人，拉丁文意为“来自梭罗谷的人”），</p>
</blockquote>
<blockquote>
<p>科学家把这种独特的人种称为“Homo floresiensis”（弗洛里斯人），</p>
</blockquote>
<blockquote>
<p>因为大脑较大，远古人类付出的代价有两种：首先是得花更多时间寻找食物，其次是肌肉退化萎缩。</p>
</blockquote>
<blockquote>
<p>这位母亲就更有机会渡过难关，未来也可能再生下更多孩子。于是，自然选择（natural selection，又译“天择”或“自然淘汰”）就让生产开始提前。</p>
</blockquote>
<blockquote>
<p>所以，想养孩子，就需要其他家族成员和邻居持续提供协助。要养活一个小孩，得靠全部落共同的努力。</p>
</blockquote>
<blockquote>
<p>黑猩猩要咀嚼生肉，每天得花上五个小时，但人类吃的是熟食，每天花上一小时就够。</p>
</blockquote>
<blockquote>
<p>而且还有铁证证明他们会照顾病人和弱者。（考古学家从尼安德特人的遗骸发现，有些人有严重的身体残疾，但活了相当大的岁数，可见有亲属提供照料。）</p>
</blockquote>
<blockquote>
<p>最近数十年来，替代理论一直是这个领域的大致共识，这项理论不只背后的考古证据更可靠，政治上也更为正确（如果说现代人类族群各有明显基因差异，几乎可说就是打开了种族主义的潘多拉盒子，而科学家可没这打算）。</p>
</blockquote>
<blockquote>
<p>就证明混种繁衍理论至少有部分正确。但这也不是说替代理论完全错误。毕竟，尼安德特人和丹尼索瓦人的基因仍然只占了现代人基因组的一小部分，</p>
</blockquote>
<blockquote>
<p>人类的社会本能也和黑猩猩没有什么不同，只适用于比较亲近的小团体。等到这个团体过大，社交秩序就会崩坏，使团体分裂。</p>
</blockquote>
<blockquote>
<p>或者古老的部落，任何大规模人类合作的根基，都在于某种只存在于集体想象中的虚构故事。例如教会的根基就在于宗教故事。像是两个天主教信徒，就算从未谋面，还是能够一起参加十字军东征或是一起筹措资金盖起医院，原因就在于他们同样相信神化身为肉体、让自己被钉在十字架上救赎我们的罪。所谓的国家，也是立基于国家故事。两名互不认识的塞尔维亚人，只要都相信塞尔维亚国家主体、国土、国旗确实存在，就可能冒着生命危险拯救彼此。至于司法制度，也是立基于法律故事。从没见过对方的两位律师，还是能同心协力为另一位完全陌生的人辩护，只因为他们都相信法律、正义、人权确实存在。（当然，他们也相信付的律师费确实存在。）</p>
</blockquote>
<blockquote>
<p>标致公司只是我们的一个集体想象，这种想象在法律上称为“法律拟制”（legal fiction）。像是公司，我们没办法明确指着它，它不是一个实体对象，而是以一种法律实体的方式存在。</p>
</blockquote>
<blockquote>
<p>然而，所谓“想象的现实”指的是某件事人人都相信，而且只要这项共同的信念仍然存在，力量就足以影响世界。</p>
</blockquote>
<blockquote>
<p>于是，认知革命正是历史从生物学中脱离而独立存在的起点。</p>
</blockquote>
<blockquote>
<p>认知革命之后，我们要解释智人的发展，依赖的主要工具就不再是生物学理论，而改用历史叙事。</p>
</blockquote>
<blockquote>
<p>我们的饮食习惯、冲突和性欲之所以是现在的样貌，正是因为我们还保留着狩猎采集者的头脑，但所处的却是工业化之后的环境，</p>
</blockquote>
<blockquote>
<p>例如只要肯挑水或是当个生产线的工人，就能活下来，并把自己那些平庸无奇的基因传下去。 采集者不只深深了解自己周遭的动物、植物和各种物品，也很了解自己的身体和感官世界。</p>
</blockquote>
<blockquote>
<p>例如只要肯挑水或是当个生产线的工人，就能活下来，并把自己那些平庸无奇的基因传下去。</p>
</blockquote>
<blockquote>
<p>而等到农业和工业时代开展，人类开始能靠着别人的技能生存下来，就算是低能的人也开始有了生存空间。例如只要肯挑水或是当个生产线的工人，就能活下来，并把自己那些平庸无奇的基因传下去。</p>
</blockquote>
<blockquote>
<p>在现代的富裕社会，平均每周的工时是40~45小时，发展中国家则是60甚至80小时；但如果是狩猎采集者，就算住在最贫瘠的地区（像是卡拉哈里沙漠），平均每周也只需要工作35~45小时。他们大概只需要每三天打猎一次，每天采集3~6小时。</p>
</blockquote>
<blockquote>
<p>采集者之所以能够免受饥饿或营养不良的困扰，秘诀就在于多样化的饮食。相较之下，之后农民的饮食往往种类极少，而且不均衡。</p>
</blockquote>
<blockquote>
<p>智人的第一波殖民正是整个动物界最大也最快速的一场生态浩劫。其中受创最深的是那些大型、毛茸茸的动物。</p>
</blockquote>
<blockquote>
<p>从采集走向农业的转变，始于大约公元前9500年~公元前8500年，发源于土耳其东南部、伊朗西部和地中海东部的丘陵地带。</p>
</blockquote>
<blockquote>
<p>即使到了今天，虽然人类有着种种先进科技，但食物热量超过90%的来源仍然是来自人类祖先在公元前9500年到公元前3500年间驯化的植物：小麦、稻米、玉米、马铃薯、小米和大麦。</p>
</blockquote>
<blockquote>
<p>在我们远古祖先所狩猎采集的成千上万物种中，适合农牧的只有极少数几种。这几种物种只生长在特定的地方，而这些地方也正是农业革命的起源地。</p>
</blockquote>
<blockquote>
<p>真正的主要嫌疑人，就是那极少数的植物物种，其中包括小麦、稻米和马铃薯。人类以为自己驯化了植物，但其实是植物驯化了智人。</p>
</blockquote>
<blockquote>
<p>新的农业活动得花上大把时间，人类就只能被迫永久定居在麦田旁边。这彻底改变了人类的生活方式。其实不是我们驯化了小麦，而是小麦驯化了我们。“</p>
</blockquote>
<blockquote>
<p>智人的身体演化目的并不是为了从事这些活动，我们适应的活动是爬爬果树、追追瞪羚，而不是弯腰清石块、努力挑水桶。于是，人类的脊椎、膝盖、脖子和脚底就得付出代价。研究古代骨骼发现，人类进到农业时代后出现了大量疾病，</p>
</blockquote>
<blockquote>
<p>小麦的影响就十分深远。种植小麦，每单位土地就能提供</p>
</blockquote>
<blockquote>
<p>对于个人来说，小麦根本算不上给了什么。但对于智人这个物种整体来说，小麦的影响就十分深远。种植小麦，每单位土地就能提供更多食物，于是智人的数量也呈指数成长。</p>
</blockquote>
<blockquote>
<p>人类就像许多哺乳动物一样，自然有荷尔蒙和遗传机制来控制生育数。营养充足的时候，女性比较早进入青春期，成功怀孕的概率也比较高。而在土地贫瘠、营养不足的时候，女性进入青春期要来得晚，生育能力也下降。</p>
</blockquote>
<blockquote>
<p>于是，种种想让生活变得轻松的努力，反而给人带来无穷的麻烦；而且这可不是史上的最后一次。就算今天，仍然如此。有多少年轻的大学毕业生投身大企业、从事各种劳心劳力的工作，发誓要努力赚钱，好在35岁就退休，去从事他们真正有兴趣的事业？但等他们到了35岁，却发现自己背着巨额贷款，要付子女的学费，要养在高级住宅区的豪宅，每家得有两部车，而且觉得生活里不能没有高级红酒和国外的假期。他们该怎么做？他们会放下一切，回去野外采果子挖树根吗？当然不可能，</p>
</blockquote>
<blockquote>
<p>等到习惯某种奢侈品，就开始认为这是天经地义。接着就是一种依赖。最后，生活中就再也不能没有这种奢侈品了。</p>
</blockquote>
<blockquote>
<p>然而，农业革命要成功，并不需要某个地区的所有部落都无异议通过。一切都只从“一个部落”开始。不论是在中东还是中美洲，只要有一个部落定居下来、开始耕作，走向农业的趋势就已经无法抗拒。由于农业可促成人口迅速增长，通常农业部落光靠人数就已经大胜采集部落。这时，采集部落只剩两种选择，第一是逃跑，放任自己的猎场成为农场和牧场；第二就是拿起锄头，自己加入农业的行列。无论</p>
</blockquote>
<blockquote>
<p>然而，农业革命要成功，并不需要某个地区的所有部落都无异议通过。一切都只从“一个部落”开始。不论是在中东还是中美洲，只要有一个部落定居下来、开始耕作，走向农业的趋势就已经无法抗拒。由于农业可促成人口迅速增长，通常农业部落光靠人数就已经大胜采集部落。这时，采集部落只剩两种选择，第一是逃跑，放任自己的猎场成为农场和牧场；第二就是拿起锄头，自己加入农业的行列。无论哪种选择，都代表旧的生活方式注定将要凋零。</p>
</blockquote>
<blockquote>
<p>我们从农业革命能学到的最重要一课，很可能就是物种演化上的成功并不代表个体的幸福。</p>
</blockquote>
<blockquote>
<p>而在农业革命之后，“未来”的重要性被提到史上新高。农民不仅时时刻刻都得想着未来，还几乎可以说是为了未来在服务。农业经济是以生产的季节周期为基础，经过很多个月耕作，再来到相对较短的收成高峰期。</p>
</blockquote>
<blockquote>
<p>历史只告诉了我们极少数的人在做些什么，而其他绝大多数人的生活就是不停挑水耕田。</p>
</blockquote>
<blockquote>
<p>南斯拉夫在1991年的资源完全足以养活所有国民，但依旧解体并引发可怕的浴血战争。</p>
</blockquote>
<blockquote>
<p>虚构的故事是怎么支撑着整个帝国？我们已经讨论过一个这样的例子：标致公司。现在我们可以来看看另外两个史上最有名的虚构故事：第一个是大约在公元前1776年的《汉谟拉比法典》，这可以说是几十万古巴比伦人的合作手册；第二个是公元1776年的美国《独立宣言》，这可以说是现代数亿美国人的合作手册。</p>
</blockquote>
<blockquote>
<p>对我们来说，听到要把人分成“上等人”或“平民”，大概都会同意这只是一种想象。但其实，即使说的是“人人平等”，也只是虚构的概念。到底所谓人人平等是什么？除了想象中之外，有没有什么客观的事实可以说我们人人平等？人类彼此在生物学上都相等吗？从生物学的角度，</p>
</blockquote>
<blockquote>
<p>我们相信某种秩序，并非因为它是客观的现实，而是因为相信它可以让人提升合作效率、打造更美好的社会。这种由想象所建构的秩序绝非邪恶的阴谋或是无用的空谈，而是唯一能让大群人类合作的救命仙丹。但也别忘了，汉谟拉比也可以用同样的逻辑来捍卫他的阶级原则：“我知道所谓上等人、平民和奴隶在本质上其实并没有什么不同。但如果我们这么相信，就能创造出一个稳定繁荣的社会。”</p>
</blockquote>
<blockquote>
<p>创立犬儒学派的希腊哲学家第欧根尼（Diogenes），</p>
</blockquote>
<blockquote>
<p>像是今天大多数西方人都相信个人主义，认为每个人都是独立的个体，有独立的价值，而不受他人看法的影响。</p>
</blockquote>
<blockquote>
<p>浪漫主义告诉我们，为了要尽量发挥潜力，就必须尽量累积不同的经验。必须体会不同的情感，尝试不同的关系，品尝不同的美食，还必须学会欣赏不同风格的音乐。而其中最好的一种办法，就是摆脱日常生活及工作，远离熟悉的环境，前往遥远的国度，好亲身“体验”不同的文化、气味、美食和规范。</p>
</blockquote>
<blockquote>
<p>而这也正是文字对人类历史所造成最重要的影响：它逐渐改变了人类思维和看待这个世界的方式。过去的自由连接、整体思考，已经转变为分割思考、官僚制度。</p>
</blockquote>
<blockquote>
<p>然而历史的铁则告诉我们，每一种由想象建构出来的秩序，都绝不会承认自己出于想象和虚构，而会大谈自己是自然、必然的结果。</p>
</blockquote>
<blockquote>
<p>大多数社会政治阶级制度其实都没有逻辑或生物学的基础，不过就是由历史的偶然事件引起，再用虚构的故事延续壮大。这正是历史值得研究的一个很好的理由。</p>
</blockquote>
<blockquote>
<p>天生自然的生物学，可能性几乎无穷无尽。然而，文化却要求必须实现某些可能性，而又封闭了其他可能性。例如女性天生能生小孩，但在某些文化里，女性却是非生不可。</p>
</blockquote>
<blockquote>
<p>文化总会说，它只是禁止“不自然的事”。但从生物学的角度来看，这世界上根本没有什么是不自然的。只要有可能发生的事，就是自然。真正完全“不自然”的事，是指违背了自然规律，但这种事情根本就不会存在，所以也没有禁止的必要。</p>
</blockquote>
<blockquote>
<p>事实上，许多人认知的“自然”和“不自然”并不是生物学的概念，而是基督教神学的概念。神学上所谓的“自然”，指的是“符合创造自然的神的旨意”。基督教神学家认为，上帝创造了人的身体，并且让每个肢体和器官都有特定的目的。如果我们使用肢体和器官的方式符合上帝的设想，那就是个“自然”的活动；如果不符合上帝设想的方式，就成了“不自然”。然而，演化本来就没有唯一的目的。器官的演化没有唯一的目的，而器官的使用方式也不断在变化。</p>
</blockquote>
<blockquote>
<p>每个文化背后虚构的故事，都有些男人应该要符合的角色（像是搞政治）、拥有的权利（像是投票权），以及负起的义务（像是服兵役）。</p>
</blockquote>
<blockquote>
<p>学者为了把概念讲清楚，通常把生物学上的区分称为“性”（sex），而文化上的区分称为“性别”（gender）。“</p>
</blockquote>
<blockquote>
<p>更重要的是，就人类整体来说，体力和社会权力本来就没有直接关联。</p>
</blockquote>
<blockquote>
<p>正由于雌性需要外部帮助，所以它们更需要发展社交技巧，学习如何合作，给予彼此抚慰。于是，它们建构起了全为雌性的社会网络，帮助彼此养育后代。而这个时候，雄性动物还是继续把时间花在彼此战斗争胜，所以社交技巧和社会关系依旧低落。于是，在倭黑猩猩和大象的社会中，便是由互相合作的雌性组成强大的网络，主导全局，至于以自我为中心而又不合作的雄性，只能滚到一边去。</p>
</blockquote>
<blockquote>
<p>现在我们已经清楚看到，父权制度其实并没有生物学上的基础，而只是基于毫无根据的虚构概念。</p>
</blockquote>
<blockquote>
<p>农业革命之后，人类社会规模变得更大、更复杂，而维系社会秩序的虚构故事也更为细致完整。人类几乎从出生到死亡都被种种虚构的故事和概念围绕，让他们以特定的方式思考，以特定的标准行事，想要特定的东西，也遵守特定的规范。就是这样，让数百万计的陌生人能遵照着这种人造而非天生的直觉，合作无间。这种人造的直觉就是“文化”。</p>
</blockquote>
<blockquote>
<p>如果是物理学的法则，绝不会有不一致的例外情形，但既然这些是人类自己想象创造出的秩序，内部就会有各式各样的矛盾。文化一直想弭平这些矛盾，因此就会促成改变。</p>
</blockquote>
<blockquote>
<p>中世纪欧洲的贵族既信奉天主教，又要遵守骑士精神。</p>
</blockquote>
<blockquote>
<p>这种价值观的矛盾从来没办法完全解决，但是欧洲的贵族、教士、平民试图处理这些问题的时候，他们的文化也就随之改变。其中一次试着处理，结果就是引发了十字军东征。对于这些骑士来说，东征既能展现武力上的长材，也能展现宗教上的虔敬，可以说是一石二鸟。同样的矛盾也带来了种种骑士修会的成立，像是圣殿骑士团（Templar）和僧侣骑士团（Hospitaller），想让基督教和骑士理想更是合为一体。中世纪艺术和文学也常谈到这种矛盾，像是亚瑟王与圣杯的传奇便是一例。</p>
</blockquote>
<blockquote>
<p>自从法国大革命之后，全球人民逐渐同意“自由”和“平等”都是基本的价值观。然而这两者根本就互相抵触！想要确保“平等”，就得限制住那些较突出的人；而要人人都能“自由”，也就必然影响所有人的平等。</p>
</blockquote>
<blockquote>
<p>就算到了现代美国，政治还是摆脱不了这种矛盾。民主党人希望社会更加平等，就算为了协助老弱病残必须增税也在所不惜。但这样一来，岂不是违反了民众支配收入的自由？如果我想把钱拿来供小孩读大学，为什么政府可以逼我非买健康保险不可？</p>
</blockquote>
<blockquote>
<p>认知失调（cognitive dissonance）</p>
</blockquote>
<blockquote>
<p>不管是贝壳还是美元，它们的价值都只存在于我们共同的想象之中。</p>
</blockquote>
<blockquote>
<p>经济学家已经提出现成的答案。在贸易连接两个区域的时候，只要是能够运送的货品，就会受到供需力量的影响，让价格达到平衡。</p>
</blockquote>
<blockquote>
<p>但在金钱和帝国之外，宗教正是第三种让人类统一的力量。正因为所有的社会秩序和阶级都只是想象的产物，所以它们也十分脆弱，而且社会规模越大，反而就越脆弱。</p>
</blockquote>
<blockquote>
<p>宗教必须同时具备“普世特质”和“推广特质”。</p>
</blockquote>
<blockquote>
<p>因应这种需求，多神教（polytheistic）信仰便应运而生。（polytheistic为希腊文，poly=多，theos=神）这些宗教认为世界是由一群神威浩荡的神灵控制，有的掌管生育，有的掌管雨水，有的掌管战争</p>
</blockquote>
<blockquote>
<p>多神论认为主宰世界的最高权力不带有任何私心或偏见，因此对于人类各种世俗的欲望、担心和忧虑毫不在意。</p>
</blockquote>
<blockquote>
<p>而天主教徒认为，虽然信仰是必要的，但光这样还不够。要进入天国，信徒还必须参加教堂礼拜，而且要多行善事。这点让新教徒无法接受，认为这样形同交易，对于神的爱和伟大是种贬抑。如果进不进天堂必须取决于自己的善行，岂不是放大了自己的重要性，而且暗示基督在十字架上为人类受的苦以及神对人类的爱都还不够？</p>
</blockquote>
<blockquote>
<p>正如古罗马帝国的主神是朱庇特、阿兹特克帝国的主神是维齐洛波奇特利，每个基督宗教国家也有自己的守护圣人，协助解决困难、赢得战争。</p>
</blockquote>
<blockquote>
<p>到了2014年，世界政治基本上仍是各行其政，但国家的独立性正在迅速消失。没有任何国家能够行使真正独立的经济政策，任意发动战争，甚至连国家内政也无法完全独立决定。</p>
</blockquote>
<blockquote>
<p>心灵专注在“我现在是什么感受？”，而不是问：“为什么是我？”这种境界很难达到，但并非不可能。</p>
</blockquote>
<blockquote>
<p>之：痛苦来自欲望；要从痛苦中解脱，就要放下欲望；而要放下欲望，就必须训练心智，体验事物的本质。</p>
</blockquote>
<blockquote>
<p>此外，佛教的几个教派也随着时间发展出满天诸佛菩萨。诸佛菩萨是人也非人，他们已经能够达到涅槃、解脱痛苦，但为了解脱和帮助还在轮回中的芸芸众生，倒驾慈航重入世间。所以，佛教徒崇拜的并不是神祇，而是这些已经开悟而尚未成佛的人，除了希望他们协助达到涅槃的境界，也希望他们帮忙处理一些世俗的问题。于是，我们就看到整个东亚有许多佛菩萨得负责降雨、医病，甚至还得保佑杀敌求胜，而信众也虔心祈祷，为他们焚香，献上各色鲜花、稻米和甜品。</p>
</blockquote>
<blockquote>
<p>人文主义对“人性”的定义，大致上分成三种对立的教派。今天最重要的人文主义学派就是自由人文主义，它认为人性就在于每个个人的自我特质，因此个人自由也就变得神圣不可侵犯。</p>
</blockquote>
<blockquote>
<p>而“如何”和“为何”之间有何不同？描述“如何”的时候，是要重建一连串从一点导致另一点的事件顺序。至于要解释“为何”的时候，则是要找出因果关系，看看究竟为什么发生的是这一连串的事件，而不是另一连串的事件。</p>
</blockquote>
<blockquote>
<p>但如果对某个时期只是一知半解，就很容易受到结果影响，只看到那些最后成真的可能性。于是，他们就用后见之明来解释着为什么现在的结果无法避免。</p>
</blockquote>
<blockquote>
<p>事后看来无可避免的事，在当时看来总是毫不明显。</p>
</blockquote>
<blockquote>
<p>特别要强调的是，那些在当代看来最不可能发生的事，常常就是最后成真的事。</p>
</blockquote>
<blockquote>
<p>至于二级混沌系统，指的是“会受到预测的影响而改变”，因此就永远无法准确预测。</p>
</blockquote>
<blockquote>
<p>一级混沌指的是“不会因为预测而改变”。例如天气就属于一级混沌系统。</p>
</blockquote>
<blockquote>
<p>我们之所以研究历史，不是为了要知道未来，而是要拓展视野，要了解现在的种种绝非“自然”，也并非无可避免。未来的可能性远超过我们的想象。</p>
</blockquote>
<blockquote>
<p>对于像是伊斯兰教、基督教、佛教、儒教这些前现代知识体系来说，它们假设世上所有重要的事情都已经为人或为神所知。这些全知者可能是某些伟大的神、某个全能的神或是某些过去的智者，通过经典或口传，将这些智慧传给后人。而对于平民百姓而言，重点就是要钻研这些古籍和传统，正确加以理解，就能获得知识。</p>
</blockquote>
<blockquote>
<p>现代科学愿意承认自己的无知，就让它比所有先前的知识体系更具活力、更有弹性，也更有求知欲。</p>
</blockquote>
<blockquote>
<p>收集各种实证观察（可以用感官感受到的），并以数学工具整理。</p>
</blockquote>
<blockquote>
<p>科学家一般公认，没有任何一种理论百分之百正确。因此，用“真实”与否来为知识评分并不妥当。真正的考验就是实用性。能让我们做出新东西来的，就是知识。</p>
</blockquote>
<blockquote>
<p>1）社会性的贫穷，指的是某些人掌握了机会，却不愿意释出给他人；（2）生物性的贫穷，指的是因为缺乏食物和住所，而使人的生存受到威胁。</p>
</blockquote>
<blockquote>
<p>正因为资源有限，我们就必须回答像是“什么更重要”和“怎样才算花得适当”这种问题。但这些都不是科学问题。</p>
</blockquote>
<blockquote>
<p>总之，科学研究一定得和某些宗教或意识形态联手，才有蓬勃发展的可能。</p>
</blockquote>
<blockquote>
<p>之所以法国和美国能够很快跟上英国的脚步，是因为他们本来就和英国共享一套最重要的故事和社会结构。而中国和波斯总是追赶不及，则是因为整个关于社会的想法和组织就是不同。</p>
</blockquote>
<blockquote>
<p>中国和波斯其实并不缺乏制作蒸汽机的科技（当时要照抄或是购买都完全不成问题），他们缺少的是西方的价值观、故事、司法系统和社会政治结构，这些在西方花了数个世纪才形成及成熟，就算想要照抄，也无法在一夕之间内化。之所以法国和美国能够很快跟上英国的脚步，是因为他们本来就和英国共享一套最重要的故事和社会结构。而中国和波斯总是追赶不及，则是因为整个关于社会的想法和组织就是不同。</p>
</blockquote>
<blockquote>
<p>这里真正的关键因素在于，不管是想寻找植物的植物学家还是想寻找殖民地的海军军官，都有一种共同的心态。他们共同的出发点就是承认无知，都会说“我不知道那里有什么”。于是，他们都觉得有走出去、寻找新发现的必要。</p>
</blockquote>
<blockquote>
<p>发现美洲，对于科学革命是一大奠基事件。这不但让欧洲人知道实际的观察比过去的传统更重要，而且想征服美洲的欲望也让欧洲人开始求知若渴。</p>
</blockquote>
<blockquote>
<p>发现美洲，对于科学革命是一大奠基事件。这不但让欧洲人知道实际的观察比过去的传统更重要，而且想征服美洲的欲望也让欧洲人开始求知若渴。他们如果真想控制这片广大的新领地，就一定得收集所有相关地理、气候、植物、动物、语言、文化、历史的庞大数据。在这些时候，不管是基督教《圣经》、过时的地理书籍或是古老的口传知识，都无用武之地。</p>
</blockquote>
<blockquote>
<p>人类发展出“信用”这种金钱概念，代表着目前还不存在、只存在于想象中的货品。正是“信用”的概念，让我们能够预支未来、打造现在。</p>
</blockquote>
<blockquote>
<p>所谓的“进步”，是在承认我们的无知之后，认为只要投资进行研究，一切就能变得更好。这个想法很快地就应用到了经济上。只要是相信“进步”的人，就会相信各种地理发现、科技发明和组织发展，能够提升人类生产、贸易和财富的总量。</p>
</blockquote>
<blockquote>
<p>在《国富论》的第一卷第八章，亚当·斯密提出了以下的创新论述：如果地主、织工或鞋匠赚得的利润高于养家糊口基本所需，就会雇用更多助手，好进一步提高自己的利润。利润越高，能雇的助手也越多。由此可见，民间企业的获利正是社会整体财富和繁荣的基础。</p>
</blockquote>
<blockquote>
<p>人类全体财富的基础，就在于希望增加个人利润的自私心理。这一点可以说是人类历史上最革命性的概念，而且还不只是从经济的角度，也包括道德和政治的角度。他其实告诉我们：贪婪是好的，而且我们让自己过得好的时候，不只是自己得利，还能让他人受益。“利己”就是“利他”。</p>
</blockquote>
<blockquote>
<p>在新的资本主义教条里，最神圣的开宗明义第一条就是：“生产的利润，必须再投资于提高产量。”</p>
</blockquote>
<blockquote>
<p>所以，亚当·斯密不断强调的是“利润增加时，地主或织工就会雇用更多助手”，而不是说“利润增加时，守财奴就把钱全部藏得死死的，只有算钱的时候才拿出来”。现代资本主义经济的一大重点，就在于出现了一种新的道德标准：应该把利润拿出来，继续投资生产。</p>
</blockquote>
<blockquote>
<p>资本主义之名正是由此而来。所谓的“资本主义”（Capitalism），认为“资本”（capital）与“财富”（wealth）有所不同。资本指的是投入生产的各种金钱、物品和资源。而财富指的则是那些埋在地下或是浪费在非生产性活动的金钱、物品和资源。例如，如果有位法老王，把所有的资源拿来盖了一座不具生产力的金字塔，他并不是资本主义者。某个海盗劫掠了一条西班牙运宝船，把一整箱闪闪发光的金币埋到加勒比海的某座小岛上，他也不是个资本主义者。但如果是某个辛勤工作的工厂工人，把收入的一部分拿去投资股票，他就算是个资本主义者。</p>
</blockquote>
<blockquote>
<p>因为连他们都意识到，如果他们想让自己的钱不被抢走，而且能创造更多的财富，就最好到真正能够实行法治、尊重私有财产制的地方，例如荷兰。 就是像这样的事，让西班牙国王逐渐失去了投资者的信任，而荷兰商人则赢得了他们的信心。</p>
</blockquote>
<blockquote>
<p>密西西比泡沫可以说是史上最惨烈的一次金融崩溃。法国王室的金融体系一直没能真正走出这场重大的打击。</p>
</blockquote>
<blockquote>
<p>讲到国家如何为资本家服务，最恶名昭彰的例子就是中英第一次鸦片战争（</p>
</blockquote>
<blockquote>
<p>资本和政治这两者的紧密相拥，对信贷市场有深远的影响。一个市场究竟能得到多少信贷，不能只看经济因素（例如发现新的油田、发明新的机器），而也得考虑政治事件的影响，例如政权更迭或是采取了更积极的外交政策。诺瓦里诺战役之后，英国资本家投资高风险海外交易的意愿就更高了。</p>
</blockquote>
<blockquote>
<p>信用评级代表的是国家清偿债务的可能性。除了纯粹的经济数据外，也会考虑政治、社会甚至文化因素。就算是拥有丰富石油蕴藏量的产油国，如果政府专制、司法腐败，信用评级通常也不高。这么一来，因为难以取得必要资金开发石油资源，很可能这个国家就只能这样坐在金矿上穷困度日。与此相对的是，如果某个国家虽然缺少自然资源，却有自由的政府、和平的环境，以及公正的司法系统，它就可能得到较高的信用评级。这样一来，就能以低廉的代价取得相当的资金，撑起良好的教育体系、发展出蓬勃的全新高科技产业。</p>
</blockquote>
<blockquote>
<p>然而，如果讲到最极端的情况，相信自由市场的概念其实就像相信圣诞老人一样天真。这世界上根本不可能有完全不受政治影响的市场。</p>
</blockquote>
<blockquote>
<p>如果真的是完全自由的市场，没有国王或神职人员来监督，贪婪的资本家就能够通过垄断或串通来打击劳工。例如，假设某个国家只有一家制鞋厂或是所有制鞋厂都合谋同时降低工资，劳工就无法用换工作的方式来保护自己。</p>
</blockquote>
<blockquote>
<p>更可怕的是，老板还可能用劳动偿债甚至奴隶制度来限制劳工的自由。在中世纪结束的时候，基督教欧洲几乎完全没有奴隶制度的现象。但到了现代早期，欧洲资本主义兴起，大西洋奴隶贸易也应运而生。奴隶贸易这场灾难的罪魁祸首并不是暴君或是种族主义者，而是不受限制的市场力量。</p>
</blockquote>
<blockquote>
<p>还有一个更大的问题，就是我们不知道如何进行能量间的转换。</p>
</blockquote>
<blockquote>
<p>因为所有能量转换只能靠人类和动物的身体，当时几乎所有人类活动靠的就是肌肉的力量。</p>
</blockquote>
<blockquote>
<p>蒸汽机种类繁多，但有一个共同的原则：燃烧某种燃料（例如煤），再用产生的热将水煮沸，产生蒸汽。接着蒸汽推动活塞、让活塞移动，而连接到活塞的任何装置也就跟着移动。这么一来，热能便转换为动能了！</p>
</blockquote>
<blockquote>
<p>另一项重要发明是内燃机，仅仅花了不到一个世代的时间，就彻底改革了人类的运输，也让石油变成一种液体的政治权力。</p>
</blockquote>
<blockquote>
<p>工业革命的核心，其实就是能源转换的革命。我们已经一再看到，我们能使用的能源其实无穷无尽。讲得更精确，唯一的限制只在于我们的无知。每隔几十年，我们就能找到新的能源来源，所以人类能用的能源总量其实在不断增加。</p>
</blockquote>
<blockquote>
<p>大西洋奴隶贸易并非出于对非洲人的仇恨，而现代畜牧业也同样不是出于对动物的仇恨。这两者背后共同的推手，就是冷漠。大多数人，在生产或是消费各种奶、蛋、肉类的时候，都很少想到提供这些食物的鸡、牛或猪。就算有些人真的想过，也常认为这些动物真的和机器没什么两样，没有感觉、没有情绪，并不会感受到痛苦。</p>
</blockquote>
<blockquote>
<p>正是因为农业释放出了数十亿的人力，由工厂和办公室吸纳，才开始像雪崩一样有各种新产品倾泻而出。比起以前，人类生产出更多钢铁，制作出更多服装，兴建出更多建筑，还制造出令人瞠目结舌、超出想象的各种产品，像是灯泡、手机、数码相机和洗碗机。人类有史以来第一次，生产超出了需求。也是因为如此，产生了一个全新的问题：谁要来买这些产品？</p>
</blockquote>
<blockquote>
<p>虽然智人已经越来越不受自然的摆布，但却越来越受到现代产业和政府的支配。</p>
</blockquote>
<blockquote>
<p>有人病了，由家庭来照顾。有人老了，由家庭来赡养，而子女就是最好的退休基金。有人过世，孤儿就由大家庭其他成员照顾。</p>
</blockquote>
<blockquote>
<p>然而，要解放个人是有代价的。现在许多人都悲叹着家庭和社群功能不再、觉得疏离，而且感觉冷漠的国家和市场对我们造成许多威胁。如果组成国家和市场的是一个又一个孤单的个人，而不是关系紧密的家庭或社群，要干预个人生活也就容易得多。现代高楼公寓，所有人各自锁在自己家里，连每户该付多少清洁费都无法达成共识，又怎么可能一起站出来抵抗国家机器？</p>
</blockquote>
<blockquote>
<p>经过数百万年的演化，人类的生活和思考方式都预设自己属于社群。但仅仅过了两个世纪，我们就成了互相疏远的个人。这可以说是文化力量的最佳证明。</p>
</blockquote>
<blockquote>
<p>现代所兴起的两大想象社群，就是“民族”和“消费大众”。</p>
</blockquote>
<blockquote>
<p>因此，想要定义现代社会的特色为何，就像要问变色龙究竟是什么颜色一样。我们唯一可以确定的特色，就是它会不断改变。</p>
</blockquote>
<blockquote>
<p>更重要的是，我们比较容易体会个人的辛酸，而不是人类整体的苦难。</p>
</blockquote>
<blockquote>
<p>现在有的是真正的和平，而不只是没有战争。对于大多数的政体来说，都没有什么合理可信的情况会在一年之内导致全面开战。</p>
</blockquote>
<blockquote>
<p>如果说有个最高诺贝尔和平奖，应该把奖颁给罗伯特·奥本海默以及和他一起研发出原子弹的同事。有了核武器之后，超级大国之间如果再开战，无异等于集体自杀。因此，想要武力征服全球也成了不可能的任务。</p>
</blockquote>
<blockquote>
<p>然而，这种进步论却可能有些问题。正如我们所见，新的倾向、行为和技能不一定会让生活过得更好。像是人类在农业革命学会了农耕畜牧，提升了人类整体形塑环境的力量，但对许多个人而言，生活反而变得更为艰苦。</p>
</blockquote>
<blockquote>
<p>一般对于快乐普遍接受的定义是“主观感到幸福”。依照这个观点，快乐是种个人内在的感受，可能是因为当下直接的快感，或是对于长期生活方式的满足。</p>
</blockquote>
<blockquote>
<p>目前有一项耐人寻味的结论：金钱确实会带来快乐，但是有一定限度，超过限度之后的效果就不那么明显。所以，对于在经济阶层底层的人来说，确实是钱越多就越快乐。</p>
</blockquote>
<blockquote>
<p>虽然过去两个世纪间人类在物质条件上有了大幅改善，但因为家庭崩溃、社会失调，所以两者的作用很可能互相抵消。如果真是如此，现在的人并不见得比1800年更快乐。甚至是我们现在如此看重的“自由”，也可能是让我们不那么快乐的原因。虽然我们可以自己选择另一半、选择朋友、选择邻居，但他们也可以选择离开我们。现代社会每个人都拥有了前所未有的自由，能够决定自己要走哪条路，但也让我们越来越难真正信守承诺、不离不弃。于是，社群和家庭的凝聚力下降而解体，这个世界让我们感到越来越孤独。</p>
</blockquote>
<blockquote>
<p>如果说快乐要由期望来决定，那么我们社会的两大支柱（大众媒体和广告业）很有可能正在不知不觉地让全球越来越不开心。</p>
</blockquote>
<blockquote>
<p>那些无力负担这些医学奇迹的人（也就是绝大多数人），一定会愤怒到无以复加。纵观历史，穷人和受压迫者之所以还能自我安慰，就是因为死亡是唯一完全公平的事。不论再富有、权力再大，人也难逃一死。光是想到自己得死，但有钱人居然能长生不老，就会让穷人怒火中烧、不可遏抑。</p>
</blockquote>
<blockquote>
<p>这么一来，就算是长生不老也可能会导致不满。假设科学找出了能够医治所有疾疾的万灵丹，加上有效抗老疗程和再生治疗，能够让人永葆青春，那么，最可能发生的事，就是整个世界感到空前的愤怒和焦虑。</p>
</blockquote>
<blockquote>
<p>但人体的内部生化系统似乎就是对快乐多有限制，只会维持在恒定的水平。快乐这件事不适用于自然选择的原则，如果是个快乐的孤独隐士，对上两位整天焦虑的爸妈，前者会绝种，而后者却能把基因再传下去。快乐或痛苦在演化过程里的作用，就只在于鼓励或阻挡生存和繁衍。</p>
</blockquote>
<blockquote>
<p>举例来说，演化就把快感当成奖赏，鼓励男性和女性发生性行为、将自己的基因传下去。如果性交没有高潮，大概很多男性就不会那么热衷。但同时，演化也确保高潮得迅速退去。如果性高潮永续不退，可以想象男性会非常开心，但连觅食的动力都没了，最后死于饥饿，而且也不会有兴趣再去找下一位能够繁衍后代的女性。</p>
</blockquote>
<blockquote>
<p>让我们用古代中国农夫和现代香港企业家为例。假设我们这位古代农夫住在没有暖气的小土屋里，旁边就是猪圈；企业家住在拥有各种最新科技的豪宅，窗口就能俯瞰南海的浩瀚海景。直觉上，我们会觉得企业家想必比农民更快乐。然而，快乐是在脑子里决定的，而大脑根本不管土屋或豪宅、猪圈或南海，只管血清素的浓度。所以，农夫盖完了他的土屋之后，大脑神经元分泌血清素，让浓度到达X。而在现代，企业家还完最后一笔豪宅房贷之后，大脑神经元也分泌出差不多数量的血清素，并且也让浓度差不多到达X。对大脑来说，它完全不知道豪宅要比土屋舒适太多，它只知道现在的血清素浓度是X。所以，这位企业家快乐的程度，并不会比那位足以当他高高高高高祖父的农夫来得高。</p>
</blockquote>
<blockquote>
<p>背后有一项基本生物学假设：“快乐等于快感”。</p>
</blockquote>
<blockquote>
<p>如果真要计算哪些时刻令人开心，哪些时候叫人无聊，就单纯的数字来说，养小孩可说是非常不愉快的事。很多时候，养小孩就是要换尿布、洗碗、处理他们的哭闹和脾气，这些都算是没人想做的苦差事。然而，大多数家长都说孩子是他们快乐</p>
</blockquote>
<blockquote>
<p>让我们以养小孩为例。卡尼曼发现，如果真要计算哪些时刻令人开心，哪些时候叫人无聊，就单纯的数字来说，养小孩可说是非常不愉快的事。很多时候，养小孩就是要换尿布、洗碗、处理他们的哭闹和脾气，这些都算是没人想做的苦差事。然而，大多数家长都说孩子是他们快乐的主要来源。难道这些人都是脑子有问题吗？</p>
</blockquote>
<blockquote>
<p>正如尼采所言，只要有了活下去的理由，几乎什么都能够忍受。生活有意义，就算在困境中也能甘之如饴；生活无意义，就算在顺境中也度日如年。</p>
</blockquote>
<blockquote>
<p>所以，我们的中世纪祖先会感到快乐，就只是因为他们有着对来世的集体错觉，因而感觉生命充满意义吗？没错！只要没人去戳破他们的幻想，又为什么要不开心呢？从我们所知的纯粹科学角度来看，人类的生命本来就完全没有意义。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>2023 03 19</title>
      <link>https://ynikl.github.io/weekly/2023-03-19/</link>
      <pubDate>Mon, 20 Mar 2023 08:35:32 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/weekly/2023-03-19/</guid>
      <description>0314 wrap error
Adding additional context to an error Marking an error as a specific error fmt.Errorf(&amp;quot;%w&amp;quot;, err)
1 bar error -&amp;gt; Wrap error -&amp;gt; fmt.wrapError { bar error } 原先被包裹的 err, 仍保持可用状态 fmt.Error(&amp;quot;%v&amp;quot;,err)变成 string, 原 Err 已经无法追溯
spew 将变量数据格式化输出
可以批量传入参数spew.Sdump(var1, var2, var3) 可以通过 spew.NewDefaultConfig 独立一份特定参数的输出实例 也可以通过 spew.Config 修改包变量, 将配置覆盖整个包 As, Is
As 提供具体错误类型匹配, 对应自定义的某种错误类型结构体. 仅会对比错误错误链的第一个自定义错误类型是否匹配 Is 提供具体的某一个实例错误类型匹配. 会递归遍历是否匹配 </description>
      <content:encoded><![CDATA[<h2 id="0314">0314</h2>
<p>wrap error</p>
<ul>
<li>Adding additional context to an error</li>
<li>Marking an error as a specific error</li>
</ul>
<p><code>fmt.Errorf(&quot;%w&quot;, err)</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">bar error -&gt; Wrap error -&gt; fmt.wrapError { bar error }
</span></span></code></pre></td></tr></table>
</div>
</div><p>原先被包裹的 err, 仍保持可用状态
<code>fmt.Error(&quot;%v&quot;,err)</code>变成 string, 原 Err 已经无法追溯</p>
<p><a href="https://github.com/davecgh/go-spew">spew</a>
将变量数据格式化输出</p>
<ul>
<li>可以批量传入参数<code>spew.Sdump(var1, var2, var3)</code></li>
<li>可以通过 <code>spew.NewDefaultConfig</code> 独立一份特定参数的输出实例</li>
<li>也可以通过 <code>spew.Config</code> 修改包变量, 将配置覆盖整个包</li>
</ul>
<p>As, Is</p>
<ul>
<li>As 提供具体错误类型匹配, 对应自定义的某种错误类型结构体. 仅会对比错误错误链的第一个自定义错误类型是否匹配</li>
<li>Is 提供具体的某一个实例错误类型匹配. 会递归遍历是否匹配</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>2023 03 12, 周记</title>
      <link>https://ynikl.github.io/weekly/2023-03-12/</link>
      <pubDate>Wed, 15 Mar 2023 08:58:05 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/weekly/2023-03-12/</guid>
      <description>0307 mysql 创建 utf8md4 数据库
1 CREATE DATABASE `test` DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci ; mysql utf8mb4 是 utf8的超集，兼容4字节的 unicode (Emoji)
https://www.jianshu.com/p/2b8629af8000
mysql 5.7.32-log 在 varchar(255) 创建索引失败，max key length is 767 bytes. 767字节/4字节每字符 = 191 字符。 须修改为 varchar(191) https://help.aliyun.com/document_detail/41707.html
查看已经合并的分支
1 2 3 4 git branch --merged #删除 git branch --merged | egrep -v &amp;#34;(^\*|master|dev|stage)&amp;#34; | xargs git branch -d vifm : za 显示隐藏文件
1 2 3 za: Toggle showing hidden files zo: Show hidden files zm: Hide hidden files https://codeyarns.</description>
      <content:encoded><![CDATA[<h2 id="0307">0307</h2>
<p>mysql 创建 utf8md4 数据库</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">DATABASE</span><span class="w"> </span><span class="o">`</span><span class="n">test</span><span class="o">`</span><span class="w">  </span><span class="k">DEFAULT</span><span class="w"> </span><span class="nb">CHARACTER</span><span class="w"> </span><span class="k">SET</span><span class="w"> </span><span class="n">utf8mb4</span><span class="w"> </span><span class="k">COLLATE</span><span class="w"> </span><span class="n">utf8mb4_unicode_ci</span><span class="w"> </span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>mysql utf8mb4 是 utf8的超集，兼容4字节的 unicode (Emoji)</p>
<p><a href="https://www.jianshu.com/p/2b8629af8000">https://www.jianshu.com/p/2b8629af8000</a></p>
<p>mysql 5.7.32-log 在 <code>varchar(255)</code> 创建索引失败，<code>max key length is 767 bytes.</code> 767字节/4字节每字符 = 191 字符。 须修改为 <code>varchar(191)</code>
<a href="https://help.aliyun.com/document_detail/41707.html">https://help.aliyun.com/document_detail/41707.html</a></p>
<p>查看已经合并的分支</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git branch --merged
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">#删除
</span></span><span class="line"><span class="cl">git branch --merged | egrep -v &#34;(^\*|master|dev|stage)&#34; | xargs git branch -d
</span></span></code></pre></td></tr></table>
</div>
</div><p>vifm : za 显示隐藏文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">za: Toggle showing hidden files
</span></span><span class="line"><span class="cl">zo: Show hidden files
</span></span><span class="line"><span class="cl">zm: Hide hidden files
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://codeyarns.com/tech/2014-09-10-how-to-show-hidden-files-in-vifm.html#gsc.tab=0">https://codeyarns.com/tech/2014-09-10-how-to-show-hidden-files-in-vifm.html#gsc.tab=0</a></p>
<p>Unicodde 是字符集 &ndash; 支持的所有字符的合集
Utf-8 是编码规则，代表 8 位一组表示 Unicode 字符的格式，使用 1 - 4 个字节来表示字符。</p>
<blockquote>
<p>We should understand the distinction between a charset and an encoding:</p>
<ul>
<li>A charset, as the name suggests, is a set of characters. For example, the Unicode charset contains 2^21 characters.</li>
<li>An encoding is the translation of a character’s list in binary. For example, UTF- 8 is an encoding standard capable of encoding all the Unicode characters in a variable number of bytes (from 1 to 4 bytes).</li>
</ul>
</blockquote>
<p>ChatGPT 是OpenAI 研发的一种生成式聊天机器人，可以理解人类的问题并提供答案， 对搜索引擎业务有着巨大的挑战
<a href="https://youtu.be/zNRvAMJOfAI">小Lin说 ChatGPT</a></p>
<p>感受太阳发热，其实是电磁波碰撞到物体产生的热量。 太阳如果是核聚变的化，太阳表面温度不好解释。 等离子体宇宙论，解释太阳拥有的日冕就是类似与闪电之类的东西，据说NASA太阳表面可能是27度。
<a href="https://youtu.be/Ep803Xiso5E">老高说 太阳</a></p>
<h2 id="0309">0309</h2>
<p>查看数据库表的大小</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="n">use</span><span class="w"> </span><span class="n">information_schema</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">select</span><span class="w"> </span><span class="n">concat</span><span class="p">(</span><span class="n">round</span><span class="p">(</span><span class="k">sum</span><span class="p">(</span><span class="n">data_length</span><span class="o">/</span><span class="mi">1024</span><span class="o">/</span><span class="mi">1024</span><span class="p">),</span><span class="mi">2</span><span class="p">),</span><span class="s1">&#39;MB&#39;</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="k">data</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">tables</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">table_schema</span><span class="o">=</span><span class="s1">&#39;database_name&#39;</span><span class="w"> </span><span class="k">and</span><span class="w"> </span><span class="k">table_name</span><span class="o">=</span><span class="s1">&#39;table_name&#39;</span><span class="p">;</span><span class="w"> 
</span></span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://www.51cto.com/article/641931.html">https://www.51cto.com/article/641931.html</a></p>
<p>varchar(50)
其中 50 在Mysql 5.1 版本之后代表的是字符长度， 以前代表的是字节长度</p>
<p>使用 varchat(50) 和直接使用 varchar(255) 存储的区别
空间占用基本一致</p>
<ol>
<li>一般情况下255和50占用的空间大小是一致的。但如果是一utf8 可能会255超过255bytes 会需要2个bytes 标记变成
性能影响越小越优</li>
<li>255 会消耗更大的查询中间表的空间大小。</li>
<li>索引长度的大小的限制， InnoDB 限制为 3072bytes， 255长度无法建立索引</li>
<li>过大的字符长度可能会脱离数据页存储。
<a href="https://dba.stackexchange.com/a/76470">https://dba.stackexchange.com/a/76470</a></li>
</ol>
<h2 id="反思总结">反思总结</h2>
<p>逃避</p>
<p>当项目组的整个团队配合出问题的时候 &ndash; 工作开始不顺心, 没有想着怎么去解决, 团队的
矛盾, 而是在想着换工作</p>
<p>傲慢</p>
<p>喝酒敬酒的时候就很随意</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>你为什么而工作</title>
      <link>https://ynikl.github.io/books/why-we-work/</link>
      <pubDate>Thu, 09 Feb 2023 09:02:40 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/why-we-work/</guid>
      <description>总结 现状 国富论中的分工合作, 把每个人的工作都进行了细化, 每个人都只能聚焦到眼前的一点点事情. 提升了增体生产效率. 人们失去对增体工作流程的感知, 更加不容易感受到工作所带来的成就感. 不能感知到自己的工作给别人带去了什么.
“一个人把金属线拉长，另一个人将它拉直，第三个人将其切断，第四个人将它削尖，第五个人将顶端切磨好跟头部相接……我曾经目睹过只雇用十位工人的这种小型生产工厂……他们一天最多能生产48 000枚大头针，但如果不采用分工合作的方式，而是由一个人来完成所有工序，那么他们每个人连20枚都完成不了。”
改善 个人: 发现自己的工作的能给别人带来什么, 寻找自己工作的意义. 自己如何看待一份工作是自己决定的. 是工作, 还是职业, 还是使命.
企业:
对员工提供保障, 充分的薪资 分配工作保留充分的自主性 一个充满价值感的工作环境 文摘 “对于那些从工作中获得成就感的人，他们将工作当成事业来经营，并且沉浸其中，尽管并不总是这种状态，但毫无疑问，工作对于他们来说至关重要。对这些人来说，工作中充满挑战，而正是这种挑战性，迫使他们远离舒适和懈怠，不断磨炼和提升自我”
“认为自己从工作中获取了某种掌控感，他们在工作中努力地锻炼自身的自主性和判断力，并借此不断提高自己的工作技能和专业水准。他们孜孜不倦地学习新东西，无论是作为员工还是作为个体的人，都能持续不断地获取自身的发展。”
“从事工作也是出于社交的需要。工作中个体常常作为团队成员一起完成任务，即使是独立工作或工作闲暇时，仍然有许多与他人打交道的社交机会。”
“有时是因为个人从事的工作非常有意义。他们的工作可能正在改变着世界，让他人的生活变得更加美好，更加有意义”
“事实上，当我们谈论一个人是因为钱而工作时，我们并不仅仅是在客观描述，而是夹杂了批判的情感在内”
“流程化的工作方式意味着除了钱之外，他们真的找不到促使其工作的其他理由”
“工作助力个人的成长和发展、工作中被上级和同事欣赏和褒扬、工作中他人尊重和赞同自己的意见和看法、感觉自己所做的工作意义重大、在工作中可以结交好友。所有这些回答都是调查中收集到的反馈。然而，对于绝大多数的职场人士来说，工作更像是无奈之举，他们也并没有积极向上的工作动力。为什么会出现这种情况”
“长期以来我们一直信奉着一项经济准则，而这项准则也被诸多心理学理论所支持，那就是如果你想让他人替你做事，无论是员工、学生、政府官员，还是你自己的孩子，你都得让他们“有所得”，因为人们做事情是因为“有利可图”
国富论
“想过尽可能舒适的生活是每个人的天性，如果一个人从事某项繁重工作和他不做所获得的报酬没有任何差别的话，那么他就会粗心马虎地应付差事，而政府也默认这种行事原则。”
“一个人把金属线拉长，另一个人将它拉直，第三个人将其切断，第四个人将它削尖，第五个人将顶端切磨好跟头部相接……我曾经目睹过只雇用十位工人的这种小型生产工厂……他们一天最多能生产48 000枚大头针，但如果不采用分工合作的方式，而是由一个人来完成所有工序，那么他们每个人连20枚都完成不了。”
“你或许会问为什么会有人愿意在亚当·斯密所描写的大头针工厂中年复一年日复一日地做着将针头和针组合在一起这种简单重复的工作。对此，亚当·斯密给出的回答是：“人们当然并不享受大头针工厂中的这种工作，但他们同样也不愿意在其他任何地方工作。”
“人们愿意工作的唯一原因是工作所带来的报酬。只要能够获得令人满意的报酬，工作内容便无关紧要。”
良好的工作环境是可以影响在其中的员工的心态
“说人类是未完成进化的动物。他指的是所谓人类的天性，很大一部分是周围社会环境的产物，这本身便是人类的天性。这部分人类天性更多是被“创造”出来的，而不是被“发现”的”
流水线的工作导致了员工的自主权利被削减
“流水线分工所带来的一个重要但常被人忽略的后果便是将工作的掌控权从员工的手中转移到了那些管理流水线的主管们手中”
“一种观点认为，我们大多数人相信只有某些种类的工作才会让人觉得充满挑战具有意义，能提供不断学习和成长的机会。如果我们坚守这种观点的话，那么这类好工作可能只属于少数人，如律师、医生、银行家、教师、软件开发人员、公司首席执行官等。对于其他人来说，工作就是“饭碗”。情况就是如此，对你我亦然”
“另一种观点则认为，每一种工作都有可能让人获得满足感。但问题在于常规化、流水线式的工作更容易带来稳定的生产效率”
工作 -&amp;gt; 职业 -&amp;gt; 使命
“正如劳动心理学研究专家皮特所指出的那样，为了让我们对自己的工作满意，我们有必要给自己从事的工作赋予意义” “当人们将自己做的事情仅仅当成一份养家糊口的“工作”来看待的时候，人们很难从工作中获得自主性，也很难从中获取成就感。当人们将工作仅仅看作为了生存必须要做的事情时，人们只在乎报酬，如果其他工作能提供更高的报酬，那么他们随时可能换工作。他们迫不及待地想要退休，也并不鼓励和希望他们的朋友或孩子像他们那样，重蹈他们的覆辙。这种现象也正是亚当·斯密关于工作的观点的具体体现” “当人们将从事的工作视为“使命”时，他们的满意度和成就感是最高的。对这些人来说，工作是生命中最重要的一部分，他们愿意将自己奉献给工作，工作彰显了他们生存的意义，他们深信自己的工作能让世界变得更加美好”
员工的使命感
“如果工作中缺少自主性、意义和满意度，工作具有的“使命感”就会减少，从事这项工作的满意度也会下降，员工也不会把这份工作做得很好”
“其实，你不一定非要在一个救死扶伤的组织内工作，以寻求工作的意义和目标。你只需要找一份能提高人们生活质量的工作就行。”
工作的成就感
“仅仅因为目睹了他们的努力给他人带来的幸福，他们的工作效率便提高了两倍。这就是赋予工作的意义后产生的巨大能量。”
“亚当·斯密描述的那些在大头针工厂中工作的工人也应该试图在内心告诉自己，自己做的事情是有意义和有追求的。也就是说，并不需要耗费太多，就能将几乎任何一份工作变得富有意义。这样做不仅对职工有好处，对服务的客户和员工所在的组织都是有益处的。”
提供完善的工作保障，这些有助于提高员工的忠诚度和信任度。 团队自我管理，分散决策权，给予员工很高的自主权和自我管理权。这同样也能提高员工对组织的信任，同时也减少了管理监督员工的人力成本。 提供给员工高于行业标准的薪酬，让员工觉得自己很有价值。但他们并不怎么依靠个人激励机制去诱导员工努力工作。当公司盈利时，所有的员工都参与利润分成。员工和公司是一个完整的“利益团体”。 完善的培训体系。无论是新员工，还是老员工，都经过系统专业的培训。这种对员工的培训是公司的一种投资形式，同样有利于培养员工的忠诚和信任。长期系统的培训也让员工不断面临新的挑战，不断提高自己的技能。普费弗还对各国的培训时长进行了对比，同样是汽车行业，日本对刚入职的新员工的平均培训时长为364个小时，欧洲是178个小时，而美国只有21个小时。 评估职工的表现，但不过度评估。公司相信员工会努力工作，也相信员工在接受足够的培训后都会成功。 极力强调公司的目标和愿景，并非首席执行官一时兴起的想法，而是将公司的使命渗透至公司上上下下的具体实践中。” “正如普费弗教授所描述的，应对竞争压力的下意识反应——裁员、加强对员工的管理和监视、催促员工加快进度等举措只会不断降低工作效率和员工的工作满意度，让情况变得更加糟糕”
“她的核心观点是当人们处于一种积极向上的情绪状态中时，他们更富有想象力和创造力，他们具有弗雷德里克松所称的“更加宽广和具有建设性的与世界互动的方式”。相反，当人们处于一种消极负面的情绪状态中时，他们更容易变得保守，想坐享其成，时时担心出错或把事情弄砸。危险让我们的视野变得更加狭窄”
现行的比较盛行的措施
“有两套规范的理论用于管理那些对工作不感兴趣的员工，一个是物质激励（工资），另一个是对流水线工作的严密监视，正所谓胡萝卜加大棒。令人惊奇的是，杰弗里·普费弗认为这两种方法对员工工作满意度都有负面效应。但是这两种方法是企业最先采用的，它们不仅让后勤工作人员和流水线上的工人无法拥有令他们满意的工作，同时由于这两种方法不断受到公司高层人员的青睐，因而在这两种方法的管理下，任何工作都有可能被毁掉，成为糟糕的工作。”
如果原先是通过道德进行约束(接送儿童迟到), 变成了通过罚款约束, 就上升到了金钱的交易的层面, 交了罚款就理所应当地迟到了.</description>
      <content:encoded><![CDATA[<h2 id="总结">总结</h2>
<h3 id="现状">现状</h3>
<p>国富论中的分工合作, 把每个人的工作都进行了细化, 每个人都只能聚焦到眼前的一点点事情. 提升了增体生产效率. 人们失去对增体工作流程的感知, 更加不容易感受到工作所带来的成就感. 不能感知到自己的工作给别人带去了什么.</p>
<blockquote>
<p>“一个人把金属线拉长，另一个人将它拉直，第三个人将其切断，第四个人将它削尖，第五个人将顶端切磨好跟头部相接……我曾经目睹过只雇用十位工人的这种小型生产工厂……他们一天最多能生产48 000枚大头针，但如果不采用分工合作的方式，而是由一个人来完成所有工序，那么他们每个人连20枚都完成不了。”</p>
</blockquote>
<h2 id="改善">改善</h2>
<p>个人:
发现自己的工作的能给别人带来什么, 寻找自己工作的意义. 自己如何看待一份工作是自己决定的. 是工作, 还是职业, 还是使命.</p>
<p>企业:</p>
<ol>
<li>对员工提供保障, 充分的薪资</li>
<li>分配工作保留充分的自主性</li>
<li>一个充满价值感的工作环境</li>
</ol>
<h2 id="文摘">文摘</h2>
<blockquote>
<p>“对于那些从工作中获得成就感的人，他们将工作当成事业来经营，并且沉浸其中，尽管并不总是这种状态，但毫无疑问，工作对于他们来说至关重要。对这些人来说，工作中充满挑战，而正是这种挑战性，迫使他们远离舒适和懈怠，不断磨炼和提升自我”</p>
</blockquote>
<blockquote>
<p>“认为自己从工作中获取了某种掌控感，他们在工作中努力地锻炼自身的自主性和判断力，并借此不断提高自己的工作技能和专业水准。他们孜孜不倦地学习新东西，无论是作为员工还是作为个体的人，都能持续不断地获取自身的发展。”</p>
</blockquote>
<blockquote>
<p>“从事工作也是出于社交的需要。工作中个体常常作为团队成员一起完成任务，即使是独立工作或工作闲暇时，仍然有许多与他人打交道的社交机会。”</p>
</blockquote>
<blockquote>
<p>“有时是因为个人从事的工作非常有意义。他们的工作可能正在改变着世界，让他人的生活变得更加美好，更加有意义”</p>
</blockquote>
<blockquote>
<p>“事实上，当我们谈论一个人是因为钱而工作时，我们并不仅仅是在客观描述，而是夹杂了批判的情感在内”</p>
</blockquote>
<blockquote>
<p>“流程化的工作方式意味着除了钱之外，他们真的找不到促使其工作的其他理由”</p>
</blockquote>
<blockquote>
<p>“工作助力个人的成长和发展、工作中被上级和同事欣赏和褒扬、工作中他人尊重和赞同自己的意见和看法、感觉自己所做的工作意义重大、在工作中可以结交好友。所有这些回答都是调查中收集到的反馈。然而，对于绝大多数的职场人士来说，工作更像是无奈之举，他们也并没有积极向上的工作动力。为什么会出现这种情况”</p>
</blockquote>
<blockquote>
<p>“长期以来我们一直信奉着一项经济准则，而这项准则也被诸多心理学理论所支持，那就是如果你想让他人替你做事，无论是员工、学生、政府官员，还是你自己的孩子，你都得让他们“有所得”，因为人们做事情是因为“有利可图”</p>
</blockquote>
<p>国富论</p>
<blockquote>
<p>“想过尽可能舒适的生活是每个人的天性，如果一个人从事某项繁重工作和他不做所获得的报酬没有任何差别的话，那么他就会粗心马虎地应付差事，而政府也默认这种行事原则。”</p>
</blockquote>
<blockquote>
<p>“一个人把金属线拉长，另一个人将它拉直，第三个人将其切断，第四个人将它削尖，第五个人将顶端切磨好跟头部相接……我曾经目睹过只雇用十位工人的这种小型生产工厂……他们一天最多能生产48 000枚大头针，但如果不采用分工合作的方式，而是由一个人来完成所有工序，那么他们每个人连20枚都完成不了。”</p>
</blockquote>
<blockquote>
<p>“你或许会问为什么会有人愿意在亚当·斯密所描写的大头针工厂中年复一年日复一日地做着将针头和针组合在一起这种简单重复的工作。对此，亚当·斯密给出的回答是：“人们当然并不享受大头针工厂中的这种工作，但他们同样也不愿意在其他任何地方工作。”</p>
</blockquote>
<blockquote>
<p>“人们愿意工作的唯一原因是工作所带来的报酬。只要能够获得令人满意的报酬，工作内容便无关紧要。”</p>
</blockquote>
<p>良好的工作环境是可以影响在其中的员工的心态</p>
<blockquote>
<p>“说人类是未完成进化的动物。他指的是所谓人类的天性，很大一部分是周围社会环境的产物，这本身便是人类的天性。这部分人类天性更多是被“创造”出来的，而不是被“发现”的”</p>
</blockquote>
<p>流水线的工作导致了员工的自主权利被削减</p>
<blockquote>
<p>“流水线分工所带来的一个重要但常被人忽略的后果便是将工作的掌控权从员工的手中转移到了那些管理流水线的主管们手中”</p>
</blockquote>
<blockquote>
<p>“一种观点认为，我们大多数人相信只有某些种类的工作才会让人觉得充满挑战具有意义，能提供不断学习和成长的机会。如果我们坚守这种观点的话，那么这类好工作可能只属于少数人，如律师、医生、银行家、教师、软件开发人员、公司首席执行官等。对于其他人来说，工作就是“饭碗”。情况就是如此，对你我亦然”</p>
</blockquote>
<blockquote>
<p>“另一种观点则认为，每一种工作都有可能让人获得满足感。但问题在于常规化、流水线式的工作更容易带来稳定的生产效率”</p>
</blockquote>
<p>工作 -&gt; 职业 -&gt; 使命</p>
<blockquote>
<p>“正如劳动心理学研究专家皮特所指出的那样，为了让我们对自己的工作满意，我们有必要给自己从事的工作赋予意义”
“当人们将自己做的事情仅仅当成一份养家糊口的“工作”来看待的时候，人们很难从工作中获得自主性，也很难从中获取成就感。当人们将工作仅仅看作为了生存必须要做的事情时，人们只在乎报酬，如果其他工作能提供更高的报酬，那么他们随时可能换工作。他们迫不及待地想要退休，也并不鼓励和希望他们的朋友或孩子像他们那样，重蹈他们的覆辙。这种现象也正是亚当·斯密关于工作的观点的具体体现”
“当人们将从事的工作视为“使命”时，他们的满意度和成就感是最高的。对这些人来说，工作是生命中最重要的一部分，他们愿意将自己奉献给工作，工作彰显了他们生存的意义，他们深信自己的工作能让世界变得更加美好”</p>
</blockquote>
<p>员工的使命感</p>
<blockquote>
<p>“如果工作中缺少自主性、意义和满意度，工作具有的“使命感”就会减少，从事这项工作的满意度也会下降，员工也不会把这份工作做得很好”</p>
</blockquote>
<blockquote>
<p>“其实，你不一定非要在一个救死扶伤的组织内工作，以寻求工作的意义和目标。你只需要找一份能提高人们生活质量的工作就行。”</p>
</blockquote>
<p>工作的成就感</p>
<blockquote>
<p>“仅仅因为目睹了他们的努力给他人带来的幸福，他们的工作效率便提高了两倍。这就是赋予工作的意义后产生的巨大能量。”</p>
</blockquote>
<blockquote>
<p>“亚当·斯密描述的那些在大头针工厂中工作的工人也应该试图在内心告诉自己，自己做的事情是有意义和有追求的。也就是说，并不需要耗费太多，就能将几乎任何一份工作变得富有意义。这样做不仅对职工有好处，对服务的客户和员工所在的组织都是有益处的。”</p>
</blockquote>
<blockquote>
<ol>
<li>提供完善的工作保障，这些有助于提高员工的忠诚度和信任度。</li>
<li>团队自我管理，分散决策权，给予员工很高的自主权和自我管理权。这同样也能提高员工对组织的信任，同时也减少了管理监督员工的人力成本。</li>
<li>提供给员工高于行业标准的薪酬，让员工觉得自己很有价值。但他们并不怎么依靠个人激励机制去诱导员工努力工作。当公司盈利时，所有的员工都参与利润分成。员工和公司是一个完整的“利益团体”。</li>
<li>完善的培训体系。无论是新员工，还是老员工，都经过系统专业的培训。这种对员工的培训是公司的一种投资形式，同样有利于培养员工的忠诚和信任。长期系统的培训也让员工不断面临新的挑战，不断提高自己的技能。普费弗还对各国的培训时长进行了对比，同样是汽车行业，日本对刚入职的新员工的平均培训时长为364个小时，欧洲是178个小时，而美国只有21个小时。</li>
<li>评估职工的表现，但不过度评估。公司相信员工会努力工作，也相信员工在接受足够的培训后都会成功。</li>
<li>极力强调公司的目标和愿景，并非首席执行官一时兴起的想法，而是将公司的使命渗透至公司上上下下的具体实践中。”</li>
</ol>
</blockquote>
<blockquote>
<p>“正如普费弗教授所描述的，应对竞争压力的下意识反应——裁员、加强对员工的管理和监视、催促员工加快进度等举措只会不断降低工作效率和员工的工作满意度，让情况变得更加糟糕”</p>
</blockquote>
<blockquote>
<p>“她的核心观点是当人们处于一种积极向上的情绪状态中时，他们更富有想象力和创造力，他们具有弗雷德里克松所称的“更加宽广和具有建设性的与世界互动的方式”。相反，当人们处于一种消极负面的情绪状态中时，他们更容易变得保守，想坐享其成，时时担心出错或把事情弄砸。危险让我们的视野变得更加狭窄”</p>
</blockquote>
<p>现行的比较盛行的措施</p>
<blockquote>
<p>“有两套规范的理论用于管理那些对工作不感兴趣的员工，一个是物质激励（工资），另一个是对流水线工作的严密监视，正所谓胡萝卜加大棒。令人惊奇的是，杰弗里·普费弗认为这两种方法对员工工作满意度都有负面效应。但是这两种方法是企业最先采用的，它们不仅让后勤工作人员和流水线上的工人无法拥有令他们满意的工作，同时由于这两种方法不断受到公司高层人员的青睐，因而在这两种方法的管理下，任何工作都有可能被毁掉，成为糟糕的工作。”</p>
</blockquote>
<p>如果原先是通过道德进行约束(接送儿童迟到), 变成了通过罚款约束, 就上升到了金钱的交易的层面, 交了罚款就理所应当地迟到了. 但是, 这个也要看对象的素质程度 &ndash; 修养以及金钱能力.</p>
<blockquote>
<p>“但是当日托护理中心的家长们又多一个理由（罚款）准时接人的时候，这第二项理由反而削弱了第一项理由（准时接人是理所当然的事情）。当受访的瑞士民众面临是否将核废料垃圾站设立在所在社区这个问题时，仅有一个理由（公民的义务）的情况下，他们同意的比例竟然远高于有两个理由的时候（公民的义务和高额的补偿金）。由此可见，动机并不是多多益善，有时候动机越多，反而会相互削弱。”</p>
</blockquote>
<blockquote>
<p>“你的[[金钱答谢]]会潜意识地提醒人们他们正在进行的是一笔买卖，而非社会互助行为。酬谢金的出现，会让他们不自觉地衡量自己就此所付出的时间和劳力是否“物有所值”，而当别人只是希望他们帮一下忙时，他们是从来不会考虑值不值这个问题的。因此，在这里，社会动机和经济动机是对抗性而非互补性的”</p>
</blockquote>
<p>在行动条论只制定更加详细的条例.</p>
<blockquote>
<p>“详细的条例和规则或许将有助于合同更加“完善”，但如果循着这个方向发展，必然有损于医生、律师、教师甚至护理人员提供的服务质量”</p>
</blockquote>
<blockquote>
<p>“因此工作的单调无聊是无法用薪酬来弥补的。其实更有可能的是，员工们已经安于并顺从这种生活现状了，工作对于他们来说毫无意义，只是一项苦差事而已”</p>
</blockquote>
<blockquote>
<p>“正如经济学家弗雷德·赫希四十年前所说：“写在合同中的越多，你能期望的就越少；写下得越多，你能期望的信任就越少。”</p>
</blockquote>
<blockquote>
<p>“科学的实质便是一场关于理论与实践的持久对话”</p>
</blockquote>
<blockquote>
<p>“至少在社会科学中，提出理论并不受限于事实，而是通过加强理论来重塑现实。你可以先铺设好人行小道，然后通过围禁草地来强制人们必须经由人行小道行走。”</p>
</blockquote>
<blockquote>
<p>“对发现和发明进行区分是至关重要的，并不仅仅因为它影响人们从中赚多少钱。无论是科学家还是其他人，当人们有所发现时，我们并不会问这项发现是否应该存在。换句话说，尽管发现的内容有时会涉及道德层面，但发现本身并不存在道德维度”</p>
</blockquote>
<p>思想观点对我的影响也是巨大的</p>
<blockquote>
<p>“当提及科学的现代影响时，大多数人自然想到的是诸如智能手机和核磁共振扫描这样的技术。但是除了创造“物”的技术外，科学也创造“观点”——关于我们如何理解世界、如何在世界生存的观点，而这些观点将会对我们的思想和行为产生巨大的影响”</p>
</blockquote>
<blockquote>
<p>“由此可见，我们或许认为自己与众不同，不俗气，会关心钱之外的其他事情，但是反过来，我们却很容易认为其他人工作完全是出于金钱的考虑”</p>
</blockquote>
<p>你说我是个恶人, 那我便干脆做一个恶人罢了</p>
<blockquote>
<p>“实际上，“自我实现预言”是对一种情境的错误定义，在这种情境下，一种新的行为表现的出现使得原来错误的观点变成正确的”</p>
</blockquote>
<blockquote>
<p>“皮格马利翁效应”。简而言之，罗森塔尔和雅各布森认为，给某些学生贴上“更有前途”这样类似的标签会导致老师改变对这些孩子的教育方式，进而促进预言的实现。这一发现对心理学和教育学都产生了深远的影响”</p>
</blockquote>
<blockquote>
<p>“意识形态对人们行为的影响很大程度上取决于这套意识形态渗入人们所处文化中的深度、广度和显著度”</p>
</blockquote>
<blockquote>
<p>“如果我们设计的工作环境能够让员工从中找到意义，那么我们就能培育出注重工作意义的人性来。”</p>
</blockquote>
<blockquote>
<p>“我们曾经错失良机，很大程度上是因为意识形态告诉我们，人们都是不愿意工作的”</p>
</blockquote>
<blockquote>
<p>“我之所以关注工作的结构以及工作环境，是因为我相信在一个认为工作毫无意义的极端环境中，个体无法真正发挥出自己的聪明才智”</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>周一清晨的领导课</title>
      <link>https://ynikl.github.io/books/monday-morning-mentoring/</link>
      <pubDate>Sat, 28 Jan 2023 23:42:27 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/monday-morning-mentoring/</guid>
      <description>承担责任 承担责任, 把目光聚焦于未来, 解决问题
与承担责任截然相反的是，把某人或某件事作为导致你所面临的问题的责备对象。当 然，总会有某人或某事是应当受责备的，但真正的领导者只会花时间来解决问题，而不是责 备别人。
“当你横加责备时，你的注意力集中在过去。如果你承担了责任，你才会将眼光投向未 来。杰夫，无论如何，只有在你承担了所有的责任之后，你才能做好计划来达到自己的目标。
“我想让你明白的第一个道理是，你应当控制自己来应对环境。如果你不再责备——甚 至避免这个词从你的口中说出来，你就会积极做出某些改变了。”
和 [[books/ShowYourWork]] 这中表达的意思一样, 思想和计划需要落到文字
“你到家后把这些都写在这个笔记本上。”托尼向我建议，“记住，当你把这些都写下来 时，你便做出了实施的承诺。如果你只是口头上告诉我你想做什么，就不会对你构成约束。”
明确团队的使命 明确团队的目标, 我们是一个怎么样的团队, 我们要做完成什么事情. 确保大家对目标的理解是一致的, 大家都清楚自己职责事情的优先级. 也需要让上级知道当前团队的目标. 上下一致, 齐心协力.
我建议你花时间你管理下属一样来管理一下你的老板。搞清楚她对你有什么样的期 望，告诉你对她有什么样的期望。你知道她的要事是什么吗?她知道你的要事是什么吗?也 许你们应该谈一谈，要想完成你的首要事务，就要弄清楚你们双方应当如何彼此协助
如果员工有离职的意向, 就要反思是不是自己出了问题, 团队出了问题
下属们一般不会因为这些原因而离职。他们 之所以离开，是因为上司不能令他们满意。在炒公司鱿鱼之前，他们已经先炒了上司的鱿鱼。 我不是说这是你们公司中的实际情况，我的意思是说，在多数情况下，老板是员工离职的主 要原因。
避免管理黑洞 逃离信息差, 与下属保持联系.
管理黑洞, 让团队感到困惑的事情
让团队感到迷惑的某些事情， 成了令许多经理掉下去的陷阱，”他说，“我把它称为‘管理黑洞’，这里的事与表面看上去 的有所不同。此外，有时人们总免不了要陷入管理黑洞。
团队的组成
大多数团队包含三种类型的雇员。有些是超级明星——富有经 验和学识，想在岗位上发挥最佳作用的人。有些是中层星——他们也许还不具备超级明星所 拥有的经验，或者也许以前他们是超级明星，由于某些原因，现在失去了争第一的动力;最 后一种我称之为流星:他们尽量逃避责任，希望担子越轻越好。 “在典型的团队中，有 30%的超级明星，50%的中层星，20%的流星。
坚持正确 制定原则 &amp;ndash; 正确的事情, 当你对问题感到困惑的时候, 就参考你原则, 你就知道你应该怎么做.
如果现在你没有一套行为准则或业绩标准的话，就很难知道怎样做才是对的。就目前 情况看这个不成问题&amp;hellip;&amp;hellip;至少从你的话来判断，这不是什么问题。 “当你陷入危机时——就像你现在的境况似的——就很难判断什么是‘对的’。我发现 最佳决策一般都是在发生危机之前做出的。你可以想清楚些，权衡一下两者的利弊
忽视问题是在拿自己正直的口碑冒险。如果你不再正直，你就不能建立以及保持别人 对你的信任——这是人际关系的根本所在
就像想树立一个正确的企业文化, 如果坚定想要建立[[企业文化]], 那么任何违反企业文化的人都应该被开除 (不管这是一位多么优秀的员工)
雇佣合适的员工 寻找合适的员工, &amp;ldquo;合适&amp;rdquo; 可以有很多种定义, 不同处事风格, 不同的个性的团队成员, 都会给团队带来不一样的色彩</description>
      <content:encoded><![CDATA[<h2 id="承担责任">承担责任</h2>
<p>承担责任, 把目光聚焦于未来, 解决问题</p>
<blockquote>
<p>与承担责任截然相反的是，把某人或某件事作为导致你所面临的问题的责备对象。当 然，总会有某人或某事是应当受责备的，但真正的领导者只会花时间来解决问题，而不是责 备别人。</p>
<p>“当你横加责备时，你的注意力集中在过去。如果你承担了责任，你才会将眼光投向未 来。杰夫，无论如何，只有在你承担了所有的责任之后，你才能做好计划来达到自己的目标。</p>
<p>“我想让你明白的第一个道理是，你应当控制自己来应对环境。如果你不再责备——甚 至避免这个词从你的口中说出来，你就会积极做出某些改变了。”</p>
</blockquote>
<p>和 [[books/ShowYourWork]] 这中表达的意思一样, 思想和计划需要落到文字</p>
<blockquote>
<p>“你到家后把这些都写在这个笔记本上。”托尼向我建议，“记住，当你把这些都写下来 时，你便做出了实施的承诺。如果你只是口头上告诉我你想做什么，就不会对你构成约束。”</p>
</blockquote>
<h2 id="明确团队的使命">明确团队的使命</h2>
<p>明确团队的目标, 我们是一个怎么样的团队, 我们要做完成什么事情. 确保大家对目标的理解是一致的, 大家都清楚自己职责事情的优先级. 也需要让上级知道当前团队的目标. 上下一致, 齐心协力.</p>
<blockquote>
<p>我建议你花时间你管理下属一样来管理一下你的老板。搞清楚她对你有什么样的期 望，告诉你对她有什么样的期望。你知道她的要事是什么吗?她知道你的要事是什么吗?也 许你们应该谈一谈，要想完成你的首要事务，就要弄清楚你们双方应当如何彼此协助</p>
</blockquote>
<p>如果员工有离职的意向, 就要反思是不是自己出了问题, 团队出了问题</p>
<blockquote>
<p>下属们一般不会因为这些原因而离职。他们 之所以离开，是因为上司不能令他们满意。在炒公司鱿鱼之前，他们已经先炒了上司的鱿鱼。 我不是说这是你们公司中的实际情况，我的意思是说，在多数情况下，老板是员工离职的主 要原因。</p>
</blockquote>
<h2 id="避免管理黑洞">避免管理黑洞</h2>
<p>逃离信息差, 与下属保持联系.</p>
<p>管理黑洞, 让团队感到困惑的事情</p>
<blockquote>
<p>让团队感到迷惑的某些事情， 成了令许多经理掉下去的陷阱，”他说，“我把它称为‘管理黑洞’，这里的事与表面看上去 的有所不同。此外，有时人们总免不了要陷入管理黑洞。</p>
</blockquote>
<p>团队的组成</p>
<blockquote>
<p>大多数团队包含三种类型的雇员。有些是超级明星——富有经 验和学识，想在岗位上发挥最佳作用的人。有些是中层星——他们也许还不具备超级明星所 拥有的经验，或者也许以前他们是超级明星，由于某些原因，现在失去了争第一的动力;最 后一种我称之为流星:他们尽量逃避责任，希望担子越轻越好。
“在典型的团队中，有 30%的超级明星，50%的中层星，20%的流星。</p>
</blockquote>
<h2 id="坚持正确">坚持正确</h2>
<p>制定原则 &ndash; 正确的事情, 当你对问题感到困惑的时候, 就参考你原则, 你就知道你应该怎么做.</p>
<blockquote>
<p>如果现在你没有一套行为准则或业绩标准的话，就很难知道怎样做才是对的。就目前 情况看这个不成问题&hellip;&hellip;至少从你的话来判断，这不是什么问题。
“当你陷入危机时——就像你现在的境况似的——就很难判断什么是‘对的’。我发现 最佳决策一般都是在发生危机之前做出的。你可以想清楚些，权衡一下两者的利弊</p>
</blockquote>
<blockquote>
<p>忽视问题是在拿自己正直的口碑冒险。如果你不再正直，你就不能建立以及保持别人 对你的信任——这是人际关系的根本所在</p>
</blockquote>
<p>就像想树立一个正确的企业文化, 如果坚定想要建立[[企业文化]], 那么任何违反企业文化的人都应该被开除 (不管这是一位多么优秀的员工)</p>
<h2 id="雇佣合适的员工">雇佣合适的员工</h2>
<p>寻找合适的员工, &ldquo;合适&rdquo; 可以有很多种定义, 不同处事风格, 不同的个性的团队成员, 都会给团队带来不一样的色彩</p>
<blockquote>
<p>公司中最重大的问题是，团队由不合适的员工组成。事实上，比起团队中都是不合适 的员工来说，竞争者对你造成的危害要小多了。
“作为领导者，重要的任务是要雇佣合适的员工。如果都是没有的、效率不高的员工， 你就不可能有强大的、有效率的团队。
“杰夫，现在你有个大好的机会。由于三个职位空缺，你可以借机改变团队的风格。通 过挑选合适的员工，你可以增加员工的多样性、想出新的主意、增添团队的活力。”</p>
</blockquote>
<p>所以, 人不好招是没有错的. 但是, 还是不能因为人不好招, 而过度放低门槛.</p>
<blockquote>
<p>你要做的决策要不就是精挑细选、管理起来很轻松，要不就是轻松招聘、管理起来很 困难的。我可以保证，你是最佳选择是把时间花在前一种方案上，这样招聘到了合适的员工 后，管理就会变成一种享受。</p>
</blockquote>
<blockquote>
<p>面试中，还有人会犯感情用事的错误。空缺的职位让你费时费力，你想快点填补。带 着这种感情，你会速战速决地选择并非很合适的人。我建议你让金或人力资源部的其他人帮 帮忙——他们不会怀有你这样的感情。</p>
</blockquote>
<h2 id="提升效率">提升效率</h2>
<p>端正对待自己时间的态度</p>
<blockquote>
<p>安排时间是你自 己的责任。如果你没时间做重要的事情，只有你自己才能解决这相问题你的团队要靠你来统 筹规划，包括解决你的个人问题</p>
</blockquote>
<blockquote>
<p>关于充分利用时间，我知道的办法只有两种:或者少做事，或者加快工作节奏，除此 之外别无选择。</p>
</blockquote>
<p>记录自己的时间花费, 减少被干扰的次数, 避免无意义会议, 集中处理某部分&quot;杂事&quot; .</p>
<blockquote>
<p>首先你要搞清楚，现在你的时间都花在什么地方。如果想改进，就要知道哪里需要改进。</p>
</blockquote>
<h2 id="提升团队满意度">提升团队满意度</h2>
<p>需要明确自己的对某一位团队成员的期待.</p>
<blockquote>
<p>在解雇更多的人之前，我需要明确自己的期望，还要完善对员工的培训</p>
</blockquote>
<p>团队的力量大于你个人的力量. 团队更加重要</p>
<blockquote>
<p>1.作为领导者，我的业绩是团队共同努力的结果。员工们需要你——你是重要人物。然 而，你的成功是下属的功劳，并非完全源于你自身的努力。
2.你对团队的需要甚于团队对你的需要。有要误会了我的意思——你与员工彼此都离不 开彼此都离不开对方，但团队中 17 位员工的贡献加在一起，比你一个人的贡献更大。</p>
</blockquote>
<p>提升团队成员的满意</p>
<ol>
<li>薪资, 简单且快速的方法, 但是很容易褪去</li>
<li>明确团队成员的目标,  提升工作的满意度</li>
<li>反馈和知道成员.</li>
<li>让成员知道你在意他们, 重视他们.</li>
<li>团队的凝聚力, 大家成为团队的一员.</li>
</ol>
<h2 id="保持学习">保持学习</h2>
<p>我们的天性, 就是喜欢舒服的过日子</p>
<blockquote>
<p>他们早上一睁眼，就开始重复前一天的生活 ——因为他们因此而觉得舒适——直到退休为止</p>
</blockquote>
<p>保持学习</p>
<blockquote>
<p>“你要想出人头地，就不能放任自己躺在舒适地带上自鸣得意。你要追求进步。为了发 挥潜力，你要迈出舒适在带，走入‘学习地带’</p>
</blockquote>
<p>学习的三个阶段: 阅读, 倾听(向他人学习), 分享</p>
<blockquote>
<p>学习地带中有三个‘房间’。第一个房间是阅览室
第二个房间是倾听室。你知道吗?经理们失败的主要原因在于他们骄傲自大、过于自 负、麻木不仁
学习中的第三个房间是给予室。我深深感到，如果不回报，就不会成功。”托尼接着 说道，</p>
</blockquote>
<p>制定明确的目标, 并落成文字
人们为什么没有制定目标</p>
<blockquote>
<p>第一，因为人闪不知道订立目标的重要性。我所知道的每项伟大的成就都开始于一纸 目标。
第二，大部分人不知道该如何制定目标, 书写会让你对目标更为明确。
第三，有时人们因为害怕失败而不敢订立目标。
第四，为了达到目标，人们必须脱离舒适地带。许多人不敢这样做。因为这意味着需 要学习新技术。</p>
</blockquote>
<p>乐观地面对生活</p>
<blockquote>
<p>生活中有很多事情都与生活态度，如何面对生活 带来的苦恼有关。生活是美好的——即使境况恶化时也依然如此。要保持乐观自信。这会有 助于你创造崭新的生活。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>The Power of Habit</title>
      <link>https://ynikl.github.io/books/the-power-of-habit/</link>
      <pubDate>Sat, 28 Jan 2023 13:14:06 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/the-power-of-habit/</guid>
      <description>习惯的力量 什么是习惯 习惯是我们可以不假思索就会完成的一系列动作, 是我们在生物进化过程的中的产物. 由 暗示, 行为, 奖励 三步组成. 我们接受到某种暗示, 潜意识开始渴望获得奖励, 不由自主地开始了习惯行为, 并内心渴望着得到奖励.
“科学家说习惯之所以出现，是因为大脑一直在寻找可以省力的方式”
“第一步，存在着一个暗示，能让大脑进入某种自动行为模式，并决定使用哪种习惯。第二步，存在一个惯常行为，这可以是身体、思维或情感方面的。第三步则是奖赏，这让你的大脑辨别出是否应该记下这个回路，以备将来之用”
“习惯从来都不会消失，它们已经被嵌入了大脑的结构中，而这对我们来说是莫大的优势，因为如果我们每次放完假后都要重新学习如何开车，那可就太糟糕了”
“这种心理的基础是两条基本规律： 第一，找出一种简单又明显的暗示。 第二，清楚地说明有哪些奖赏。”
用 白速得 牙膏的广告, 展示了利用人们习惯的影响, 让大家渴望得到一口漂亮的牙齿, 养成刷牙的习惯.
“看看“白速得”吧。他发现了一种暗示——垢膜，以及一个奖赏——漂亮的牙齿，这使千百万人开始了每天的固定活动——刷牙”
“这解释了为什么习惯如此强大：它们能够创造出神经渴求。在大部分时间里，这些渴求是逐渐产生的，而我们确实没有意识到它们的存在，所以往往看不到它们的影响”
大家如果把手机的震动关闭了, 那可能就不会再有去查看手机的冲动了.
“换言之，如果有人关了震动，也就是消除了暗示，那么大家可能就会一直工作，而不会想去查看未读消息）。”
对奖励的渴望 “92%的参与者说他们习惯性锻炼是因为这让他们“感觉很好”，他们变得越来越期盼并渴求运动时产生的内啡肽和其他神经化学物质。在另一组人中，67%的人说锻炼让他们有一种“成就感”，他们从追踪自己的运动表现中渴求一种经常出现的胜利感。这种自我奖赏足够让体育活动变成一种习惯。”
“暗示加上奖赏本身并不足以让新习惯长期持续。只有你的大脑开始预期奖赏，渴求内啡肽的分泌或成就感时，你才会自觉地在每天早上绑好跑鞋鞋带。而暗示除了能够触发惯常行为，还必须能够触发人对即将到来的奖赏的渴求”
“他们创造了渴求感，让消费者产生了所有东西在有亮闪闪的外观的同时，也有好闻的味道的欲望，这让纺必适在市场上大卖”
“消费者需要一些信号告诉他们这种产品是有效的，我们可以随意调整牙膏的口感，可以是蓝莓味、绿茶味，而只要有那种凉丝丝的刺激感，大家就觉得牙齿刷干净了。这种刺激感并不会让牙膏的效果更好，但可以说服大家牙膏有效。”
“是渴求在驱动着习惯。找到触发渴求的方式让创造新习惯变得更容易。现在是这样，100年之前也是如此。每天晚上，数百万人在刷牙，就是为了获得那种刺激感。每天早上，数百万人穿上跑鞋，就是想获得他们渴求的大量内啡肽。等他们回到家，打扫了厨房或卧室后，有些人又会喷点儿纺必适来满足自己对那种气味的渴求”
习惯是可以改变的 “习惯是一种分为三个步骤的回路，由暗示、惯常行为和奖赏组成，邓吉想做的只是调整中间那个步骤，即惯常行为。根据经验，他知道如果新行为模式的开头和结尾存在一个人熟悉的东西，那么就更容易说服这个人接受新的行为模式。”
习惯是可以替代的.
“这就是黄金法则；如果你用同样的暗示，提供同样的奖赏，你就可以换掉惯常行为，改变自己的习惯。如果暗示和奖赏不变，几乎所有的习惯都是可以被改变的。”
匿名戒酒会通过自我反省和倾诉, 寻找自己形成习惯的内心的渴求的真正因素
这个项目要找的是哪些渴求感在驱使着你的习惯回路。通常来说，喝醉本身并不属于渴求。酗酒者之所以想喝酒，是因为酒让他们能逃避现实，放松心情，又有人陪伴，而且缓解焦虑，情感也得到释放。或许他们想喝杯鸡尾酒来忘记烦心事，但并不一定想“买醉”。酒精的物理作用往往是嗜酒成瘾这个习惯回路中最次要的奖赏之一。
暗示和奖赏不变, 替换掉中间的行为, 我们就可以改变习惯
“旧的暗示和对奖赏的渴求仍在那里，随时准备反击。只有当酗酒者养成了利用以前的暗示和让他们感到熟悉进而有宽慰感的新的惯常行为时，他们才能永久戒酒。”
“这种让病人描述引发他们习惯性行为的暗示的做法，叫做意识训练，正如匿名戒酒互助社坚持让酗酒者找出酗酒的暗示，这是相反习惯训练的第一步”
更深层次的信仰达成, 也是说是一种精神上的奖励
“研究人员发现，起作用的并不是上帝，而是信仰本身。一旦人们学会信仰某种东西，这种信仰就会扩展到生活的其他方面，直到他们开始相信自己能改变。信仰是将改造过的习惯回路变成永久性行为的要素。”
在做之前, 我们要对自己有信心
“但我们的确知道，为了永久改变习惯，人们必须相信改变是可能的”
如果只是一刀斩断习惯, 那么过程将会是痛苦的
“如果你想减肥，就应了解自己的习惯，看看为什么每天休息时，自己都会离开办公桌去吃点心？然后，每到休息时，就找朋友去散步，或到他们办公桌那里闲聊，而不是去咖啡厅，或者加入一个跟踪减肥过程的小组，还可以找一个跟你一样，想在手边放一些苹果而不是薯片的伙伴” “事实一目了然：如果你想改变一个习惯，你必须找另一个惯常行为替代”
企业习惯 在商业上, 一家公司的习惯, 就可以说是这家公司的核心价值观, 就是企业文化. 真正的企业价值是需要所有人都有着一致的认可才行, 当我们在工作上遇到一些有疑惑的事情, 我们可以不假思索地参考我们的企业习惯去处理事情, 这种才能说明, 我们的企业文化有真正的落地.
“一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，它们就是“核心习惯”，影响着人们的工作、饮食、玩乐、消费和沟通方式。核心习惯能启动一个进程，久而久之将改变一切。”
“个人有习惯；组织则有惯例”</description>
      <content:encoded><![CDATA[<h1 id="习惯的力量httpsbookdoubancomsubject20507212"><a href="https://book.douban.com/subject/20507212/">习惯的力量</a></h1>
<h2 id="什么是习惯">什么是习惯</h2>
<p>习惯是我们可以不假思索就会完成的一系列动作, 是我们在生物进化过程的中的产物.  由 暗示, 行为, 奖励 三步组成. 我们接受到某种暗示, 潜意识开始渴望获得奖励, 不由自主地开始了习惯行为, 并内心渴望着得到奖励.</p>
<blockquote>
<p>“科学家说习惯之所以出现，是因为大脑一直在寻找可以省力的方式”</p>
</blockquote>
<blockquote>
<p>“第一步，存在着一个暗示，能让大脑进入某种自动行为模式，并决定使用哪种习惯。第二步，存在一个惯常行为，这可以是身体、思维或情感方面的。第三步则是奖赏，这让你的大脑辨别出是否应该记下这个回路，以备将来之用”</p>
</blockquote>
<blockquote>
<p>“习惯从来都不会消失，它们已经被嵌入了大脑的结构中，而这对我们来说是莫大的优势，因为如果我们每次放完假后都要重新学习如何开车，那可就太糟糕了”</p>
</blockquote>
<blockquote>
</blockquote>
<p>“这种心理的基础是两条基本规律：
第一，找出一种简单又明显的暗示。
第二，清楚地说明有哪些奖赏。”</p>
<p>用 白速得 牙膏的广告, 展示了利用人们习惯的影响, 让大家渴望得到一口漂亮的牙齿, 养成刷牙的习惯.</p>
<blockquote>
<p>“看看“白速得”吧。他发现了一种暗示——垢膜，以及一个奖赏——漂亮的牙齿，这使千百万人开始了每天的固定活动——刷牙”</p>
</blockquote>
<blockquote>
<p>“这解释了为什么习惯如此强大：它们能够创造出神经渴求。在大部分时间里，这些渴求是逐渐产生的，而我们确实没有意识到它们的存在，所以往往看不到它们的影响”</p>
</blockquote>
<p>大家如果把手机的震动关闭了, 那可能就不会再有去查看手机的冲动了.</p>
<blockquote>
<p>“换言之，如果有人关了震动，也就是消除了暗示，那么大家可能就会一直工作，而不会想去查看未读消息）。”</p>
</blockquote>
<h3 id="对奖励的渴望">对奖励的渴望</h3>
<blockquote>
<p>“92%的参与者说他们习惯性锻炼是因为这让他们“感觉很好”，他们变得越来越期盼并渴求运动时产生的内啡肽和其他神经化学物质。在另一组人中，67%的人说锻炼让他们有一种“成就感”，他们从追踪自己的运动表现中渴求一种经常出现的胜利感。这种自我奖赏足够让体育活动变成一种习惯。”</p>
</blockquote>
<blockquote>
<p>“暗示加上奖赏本身并不足以让新习惯长期持续。只有你的大脑开始预期奖赏，渴求内啡肽的分泌或成就感时，你才会自觉地在每天早上绑好跑鞋鞋带。而暗示除了能够触发惯常行为，还必须能够触发人对即将到来的奖赏的渴求”</p>
</blockquote>
<blockquote>
<p>“他们创造了渴求感，让消费者产生了所有东西在有亮闪闪的外观的同时，也有好闻的味道的欲望，这让纺必适在市场上大卖”</p>
</blockquote>
<blockquote>
<p>“消费者需要一些信号告诉他们这种产品是有效的，我们可以随意调整牙膏的口感，可以是蓝莓味、绿茶味，而只要有那种凉丝丝的刺激感，大家就觉得牙齿刷干净了。这种刺激感并不会让牙膏的效果更好，但可以说服大家牙膏有效。”</p>
</blockquote>
<blockquote>
<p>“是渴求在驱动着习惯。找到触发渴求的方式让创造新习惯变得更容易。现在是这样，100年之前也是如此。每天晚上，数百万人在刷牙，就是为了获得那种刺激感。每天早上，数百万人穿上跑鞋，就是想获得他们渴求的大量内啡肽。等他们回到家，打扫了厨房或卧室后，有些人又会喷点儿纺必适来满足自己对那种气味的渴求”</p>
</blockquote>
<h3 id="习惯是可以改变的">习惯是可以改变的</h3>
<blockquote>
<p>“习惯是一种分为三个步骤的回路，由暗示、惯常行为和奖赏组成，邓吉想做的只是调整中间那个步骤，即惯常行为。根据经验，他知道如果新行为模式的开头和结尾存在一个人熟悉的东西，那么就更容易说服这个人接受新的行为模式。”</p>
</blockquote>
<p>习惯是可以替代的.</p>
<blockquote>
<p>“这就是黄金法则；如果你用同样的暗示，提供同样的奖赏，你就可以换掉惯常行为，改变自己的习惯。如果暗示和奖赏不变，几乎所有的习惯都是可以被改变的。”</p>
</blockquote>
<p>匿名戒酒会通过自我反省和倾诉, 寻找自己形成习惯的内心的渴求的真正因素</p>
<blockquote>
<p>这个项目要找的是哪些渴求感在驱使着你的习惯回路。通常来说，喝醉本身并不属于渴求。酗酒者之所以想喝酒，是因为酒让他们能逃避现实，放松心情，又有人陪伴，而且缓解焦虑，情感也得到释放。或许他们想喝杯鸡尾酒来忘记烦心事，但并不一定想“买醉”。酒精的物理作用往往是嗜酒成瘾这个习惯回路中最次要的奖赏之一。</p>
</blockquote>
<p>暗示和奖赏不变, 替换掉中间的行为, 我们就可以改变习惯</p>
<blockquote>
<p>“旧的暗示和对奖赏的渴求仍在那里，随时准备反击。只有当酗酒者养成了利用以前的暗示和让他们感到熟悉进而有宽慰感的新的惯常行为时，他们才能永久戒酒。”</p>
</blockquote>
<blockquote>
<p>“这种让病人描述引发他们习惯性行为的暗示的做法，叫做意识训练，正如匿名戒酒互助社坚持让酗酒者找出酗酒的暗示，这是相反习惯训练的第一步”</p>
</blockquote>
<p>更深层次的信仰达成, 也是说是一种精神上的奖励</p>
<blockquote>
<p>“研究人员发现，起作用的并不是上帝，而是信仰本身。一旦人们学会信仰某种东西，这种信仰就会扩展到生活的其他方面，直到他们开始相信自己能改变。信仰是将改造过的习惯回路变成永久性行为的要素。”</p>
</blockquote>
<p>在做之前, 我们要对自己有信心</p>
<blockquote>
<p>“但我们的确知道，为了永久改变习惯，人们必须相信改变是可能的”</p>
</blockquote>
<p>如果只是一刀斩断习惯, 那么过程将会是痛苦的</p>
<blockquote>
<p>“如果你想减肥，就应了解自己的习惯，看看为什么每天休息时，自己都会离开办公桌去吃点心？然后，每到休息时，就找朋友去散步，或到他们办公桌那里闲聊，而不是去咖啡厅，或者加入一个跟踪减肥过程的小组，还可以找一个跟你一样，想在手边放一些苹果而不是薯片的伙伴”
“事实一目了然：如果你想改变一个习惯，你必须找另一个惯常行为替代”</p>
</blockquote>
<h2 id="企业习惯">企业习惯</h2>
<p>在商业上, 一家公司的习惯, 就可以说是这家公司的核心价值观, 就是企业文化.  真正的企业价值是需要所有人都有着一致的认可才行, 当我们在工作上遇到一些有疑惑的事情, 我们可以不假思索地参考我们的企业习惯去处理事情, 这种才能说明, 我们的企业文化有真正的落地.</p>
<blockquote>
<p>“一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，它们就是“核心习惯”，影响着人们的工作、饮食、玩乐、消费和沟通方式。核心习惯能启动一个进程，久而久之将改变一切。”</p>
</blockquote>
<blockquote>
<p>“个人有习惯；组织则有惯例”</p>
</blockquote>
<p>当早上起来我们把被子折好之后, 看着整齐的床铺, 我们会得到 &ldquo;今天将是美好的一天的暗示&rdquo;</p>
<blockquote>
<p>“当人们开始养成运动的习惯时，即使是一周一次的运动，他们也会不知不觉改变其他与之无关的行为模式”
“每天早上整理床铺，与更高的工作效率、更强的幸福感以及控制预算能力有关”</p>
</blockquote>
<blockquote>
<p>“小成功是关键习惯引起广泛变化这个过程的一部分。大量的研究表明，小成功在实现胜利过程中，有着巨大的影响力”</p>
</blockquote>
<blockquote>
<p>“这就是核心习惯推动广泛变化的最后一种方法：建立能融入新价值观的文化。核心习惯会让艰难的抉择变得容易，比如说开除高层人员这种抉择，因为破坏企业文化的人就得离开。”</p>
</blockquote>
<blockquote>
<p>“核心习惯之所以能改变我们，是因为它能创造出各种文化，让我们清楚地看到那些在抉择困难或者感到茫然的时候很可能被忘记的价值”</p>
</blockquote>
<blockquote>
<p>“，“大部分企业行为可以被理解为企业过去的一般习惯和战略方向的外在反映”</p>
</blockquote>
<h2 id="意志力">意志力</h2>
<p>意志力是一种能量, 会被消耗殆尽的</p>
<blockquote>
<p>“由于之前消耗了一些意志力去抵御饼干的诱惑，那些人就成了容易退出的阵营当中的一员。”姆拉文向我解释道，“从那次试验之后，我们又作了超过200次的研究，结论都是相同的。意志力不是一种技能，而是一种力量，就如同你手臂和大腿中肌肉的力量，用力过猛会感到疲累，肌肉剩余的力量就不足以供给其他活动。”</p>
</blockquote>
<p>意志力是一种能量, 也是可以通过训练得到提高.</p>
<blockquote>
<p>“他们限制垃圾食品的摄入，在工作学习的时候也更有效率。这就像体育锻炼研究中所说的，如果人们在生活的某一方面加强了自己的意志力量，比如体育运动和理财项目，那么这种力量会进入到他们的饮食习惯和工作中。一旦意志力得到加强，它就会延伸到生活的方方面面。”
“来自达特茅斯学院的致力于意志力研究的学者托德·希瑟顿说：“当你学会强迫自己参与体育锻炼，或者开始做家庭作业，只吃沙拉不吃汉堡的时候，你的思维正在改变。当学会控制自己的冲动时，人们就在进步。他们将学会如何在诱惑面前分散注意力。而且一旦你形成了意志力锻炼的习惯，你的大脑就会驾轻就熟地帮助你专注于你的目标。”</p>
</blockquote>
<p>当我们觉得做一件事情, 我们没有认同感, 我们就更加需要使用意志力去强迫我们自己去做这件事.</p>
<blockquote>
<p>“，“当被要求去做一些需要自我克制的事情时，如果参与者认为这是个选择或者因为可以帮助别人而让自己开心，那用到的意志力就会少很多。如果他们感到自己没有自主权，只是单纯地接受命令，他们意志力消耗的速度就会加快。”在这个例子中，学生都忽视了饼干，但当这些学生感觉自己被当成工具对待时，他们的意志力消耗得就会更快。”</p>
</blockquote>
<h2 id="抓住逆境-调整习惯">抓住逆境, 调整习惯</h2>
<p>一家医院因为遇到了发生了重大医疗事故, 大家就需要做出妥协, 有利于企业调整企业的习惯</p>
<blockquote>
<p>“有时候人们需要逆境的鞭策，而医院的这些负面影响就是巨大的逆境，它给了我们一个机会来重新审视这一切。”</p>
</blockquote>
<blockquote>
<p>“医生和护士们不愿意拍摄自己的手术过程，也不愿意其他医院的医护人员指指点点。但是一旦危机笼罩了整所医院，每个人都愿意做出一些改变”</p>
</blockquote>
<blockquote>
<p>“优秀的领导者会抓住危机来重塑组织习惯”</p>
</blockquote>
<blockquote>
<p>“但明智的领导者会寻求危机甚至创造危机感，并让大家都有需要改变的感觉，直到最后所有人都作好准备来彻底改变他们以往习惯的行为模式”</p>
</blockquote>
<h2 id="消费者的习惯">消费者的习惯</h2>
<blockquote>
<p>“有时候，顾客就像是一种被消费习惯支配的生物，他们会自动重复过去的行为，很少考虑到当前的目标”</p>
</blockquote>
<p>利用[[大数据]], 来构建消费的人群画像, 分析消费者的习惯, 促进消费的进一步消费</p>
<blockquote>
<p>“波尔告诉我：“我们将这种分析称为‘为客人画像’，我们对某位顾客了解得越多，就越能猜测出他的购买模式”</p>
</blockquote>
<blockquote>
<p>“当消费者遭遇到人生的重大事件时，他们的消费习惯更容易发生改变”</p>
</blockquote>
<h3 id="习惯影响社会运动">习惯影响社会运动</h3>
<blockquote>
<p>“运动的持续在于运动领袖让参与者形成了新的习惯，树立了新的认同感和主人翁感。”</p>
</blockquote>
<blockquote>
<p>“社会学家认为，通常来说，物以类聚，人以群分。我们的好朋友当中会有一些比较有钱，一些比较贫穷，还有一些是来自其他种族，但总体上说，与我们关系最深厚的朋友，往往是那些性情与我们相近、收入与我们相当，并且与我们有共同背景的人。”</p>
</blockquote>
<blockquote>
<p>“如果你忽视邻里间的义务感，如果你对社群的既定模式不屑一顾，你很可能失去你的社会地位。你会危及自己获得很多社群福利的资格，比如你没法参加乡村俱乐部、校友会或者教会，而这些正是你社群福利的前提。”</p>
</blockquote>
<p>人与人之间联系, 可以分为强联系和弱联系</p>
<blockquote>
<p>“这种习惯来自朋友的期望和普通熟人的同伴压力。所以，不管他们有过怎样的犹豫，最终他们还是会登上去密西西比的班车”</p>
</blockquote>
<blockquote>
<p>“社区中弱联系的力量将所有人联合了起来。在这种环境下，如果你不加入抵制，那你就是异类”</p>
</blockquote>
<blockquote>
<p>“通过引导人们的社会习惯来传教，比如民权运动就是一个很好的模仿对象。麦加兰夫在他的一本书中写道：“固定的目标是让整个社会，也就是所有人皈依基督教，或者让大部分人皈依，这样才可以使个人的社会生活不会受到破坏。”</p>
</blockquote>
<blockquote>
<p>“运动并不是因为大家突然作了同样的决定而出现的。他们依靠的社会习惯模式一开始是作为友谊的习惯存在的，在社群习惯中成长，并由改变参与者自我感的新习惯维系”</p>
</blockquote>
<h3 id="改变自己">改变自己</h3>
<blockquote>
<p>“不过，要想改变习惯，那就必须有决心去改。你必须有意识地去努力寻找驱动着你的习惯每天发生的暗示和奖赏，并且找到它们的替代品。”</p>
</blockquote>
<blockquote>
<p>“如果你相信你可以改变，如果你将其变成一种习惯，那么改变就是真实可行的。这就是习惯的真正力量：你的选择决定了你的习惯。一旦做出选择，并且成了自发行为，”</p>
</blockquote>
<blockquote>
<p>习惯记录笔记</p>
<p>“你在哪？（坐在我的办工桌前）
现在几点？（下午3点36分）
你的情绪怎样？（觉得无聊）
周围有谁？（空无一人）
在买饼干的冲动之前，你做了什么？（我回复了一封电子邮件）”</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Okr 2023</title>
      <link>https://ynikl.github.io/neo/okr-2023/</link>
      <pubDate>Thu, 05 Jan 2023 20:12:10 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/neo/okr-2023/</guid>
      <description>2023 OKR 在生活上, 让时间过得更加有计划性, 持续增加自己的知识储备. 在精神上, 塑造更加坚毅的内心, 输出更多的自我表达. 在工作上, 抓住机遇, 开始打造自己的技术护城河, 争取到一次涨薪. 2023 年加油.
深化打造技术护城河
音视频处理入门 精通 Golang 语言 扩展自己知识认知, 提升自我象形.
每个月 4-5 本书籍的阅读量. 35 cm 的臂维, 肚子没有赘肉. 迈出自己的圈子
完成20次开心的朋友聚会. 达成两场旅游. January O: 加深 Golang 技术
golang 100 Mistake go gorm 学习 go gin 学习 go context go 泛型 O: 算法与数据结构入门
算法数据结构资料汇总, 以及学习计划安排 算法4 完成5章精读 总结:
中间调整目标转向学习视频的编码技术, 下次配合更新OKR目标
聚会次数完成 +=2
阅读 5
February O: 加深 Golang 技术
golang 100 Mistake go 单元测试技能 O: 视频技能入门</description>
      <content:encoded><![CDATA[<h1 id="2023-okr">2023 OKR</h1>
<p>在生活上, 让时间过得更加有计划性, 持续增加自己的知识储备.
在精神上, 塑造更加坚毅的内心,  输出更多的自我表达.
在工作上, 抓住机遇, 开始打造自己的技术护城河, 争取到一次涨薪.
2023 年加油.</p>
<p>深化打造技术护城河</p>
<ul>
<li><input disabled="" type="checkbox"> 音视频处理入门</li>
<li><input disabled="" type="checkbox"> 精通 Golang 语言</li>
</ul>
<p>扩展自己知识认知, 提升自我象形.</p>
<ul>
<li><input disabled="" type="checkbox"> 每个月 4-5 本书籍的阅读量.</li>
<li><input disabled="" type="checkbox"> 35 cm 的臂维, 肚子没有赘肉.</li>
</ul>
<p>迈出自己的圈子</p>
<ul>
<li><input disabled="" type="checkbox"> 完成20次开心的朋友聚会.</li>
<li><input disabled="" type="checkbox"> 达成两场旅游.</li>
</ul>
<h2 id="january">January</h2>
<p>O: 加深 Golang 技术</p>
<ul>
<li><input disabled="" type="checkbox"> golang 100 Mistake</li>
<li><input checked="" disabled="" type="checkbox"> go gorm 学习</li>
<li><input checked="" disabled="" type="checkbox"> go gin 学习</li>
<li><input disabled="" type="checkbox"> go context</li>
<li><input checked="" disabled="" type="checkbox"> go 泛型</li>
</ul>
<p>O: 算法与数据结构入门</p>
<ul>
<li><input disabled="" type="checkbox"> 算法数据结构资料汇总, 以及学习计划安排</li>
<li><input disabled="" type="checkbox"> 算法4 完成5章精读</li>
</ul>
<p>总结:</p>
<p>中间调整目标转向学习视频的编码技术, 下次配合更新OKR目标</p>
<p>聚会次数完成 +=2</p>
<p>阅读 5</p>
<h2 id="february">February</h2>
<p>O: 加深 Golang 技术</p>
<ul>
<li><input disabled="" type="checkbox"> golang 100 Mistake</li>
<li><input disabled="" type="checkbox"> go 单元测试技能</li>
</ul>
<p>O: 视频技能入门</p>
<p><del>业务上完成视频产品接入</del></p>
<p><del>一本相关技术书籍完成</del></p>
<p>Adjust1: 业务发展调整, 功能承接失败, 但是以视频开发方向暂时不变</p>
<ul>
<li><input disabled="" type="checkbox"> C++ Prime Plus 1/2</li>
<li><input disabled="" type="checkbox"> 大数据相关基础知识入门</li>
</ul>
<p>Adjust2: AI 排班问题暴露, 需要加强关注</p>
<p>~~ AI 排班代码完成通读 ~~</p>
<ul>
<li><input disabled="" type="checkbox"> 人工智能入门</li>
</ul>
<p>O: 算法与数据结构入门</p>
<ul>
<li><input disabled="" type="checkbox"> 算法数据结构资料汇总, 以及学习计划安排</li>
</ul>
<h2 id="march">March</h2>
<p>反思原先各有OKR制定目标比较分散, 任务较多不贴合实际. 缩减一下任务量, 本月以收缩 golang 相关技能为主</p>
<p>O: 加深 Golang 技术</p>
<ul>
<li><input disabled="" type="checkbox"> Golang 100 Mistake</li>
<li><input disabled="" type="checkbox"> Go 单元测试技能</li>
<li><input disabled="" type="checkbox"> gorm 学习</li>
<li><input disabled="" type="checkbox"> golang 100 Mistake interface 设计思路</li>
</ul>
<p>O: 拓展技能</p>
<ul>
<li><input disabled="" type="checkbox"> 大数据相关基础知识入门</li>
</ul>
<p>O: 算法与数据结构入门</p>
<ul>
<li><input disabled="" type="checkbox"> 算法数据结构资料汇总, 制定学习计划</li>
</ul>
<h2 id="may">May</h2>
<p>追求内心与工作的平衡</p>
<p>O: 加深 Golang 技术</p>
<ul>
<li><input disabled="" type="checkbox"> Golang 100 Mistake</li>
<li><input disabled="" type="checkbox"> Go 单元测试技能</li>
<li><input disabled="" type="checkbox"> gorm 学习</li>
<li><input disabled="" type="checkbox"> golang 100 Mistake interface 设计思路</li>
</ul>
<p>O: 走出去</p>
<ul>
<li><input disabled="" type="checkbox"> 骑行1000km</li>
</ul>
<p>O: 思考副业计划</p>
<ul>
<li><input disabled="" type="checkbox"> 列出3个初步发副业方案计划</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>202301</title>
      <link>https://ynikl.github.io/notes/202301/</link>
      <pubDate>Thu, 05 Jan 2023 14:04:07 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/notes/202301/</guid>
      <description>&amp;ldquo;与其担心宏观经济，不如关注自己。你对自己生活的影响，往往比宏观经济对你的影响大得多。&amp;rdquo;
不要 过度 自己是否会被裁员, 而是要聚焦自己目标的, 提升自己的能力, 抵抗宏观经济问题.
阮一峰网络日志
世界最大对冲基金&amp;quot;桥水基金&amp;quot;创始人达里奥，说过一句话，可以用在这里：&amp;ldquo;如果你忧心忡忡，那是不必要的；如果你毫不担心，那么你需要担心。&amp;rdquo;
要保持担忧, 但更要聚焦于自己</description>
      <content:encoded><![CDATA[<blockquote>
<p>&ldquo;与其担心宏观经济，不如关注自己。你对自己生活的影响，往往比宏观经济对你的影响大得多。&rdquo;</p>
</blockquote>
<p>不要 <strong>过度</strong> 自己是否会被裁员, 而是要聚焦自己目标的, 提升自己的能力, 抵抗宏观经济问题.</p>
<p><a href="https://www.ruanyifeng.com/blog/2022/09/weekly-issue-223.html">阮一峰网络日志</a></p>
<blockquote>
<p>世界最大对冲基金&quot;桥水基金&quot;创始人达里奥，说过一句话，可以用在这里：&ldquo;如果你忧心忡忡，那是不必要的；如果你毫不担心，那么你需要担心。&rdquo;</p>
</blockquote>
<p>要保持担忧, 但更要聚焦于自己</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang Gin</title>
      <link>https://ynikl.github.io/blog/golang-gin/</link>
      <pubDate>Sun, 01 Jan 2023 22:08:25 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-gin/</guid>
      <description>Golang Gin 框架的使用和理解 框架代码地址
中间的几个关键对象 Engine RouterGroup HandlerFunc Context Engine gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过New()或者Default()创建
New 不带任何中间件 Default 会带 logger 和 recover 通过 Engine.Use() 添加中间件到Engine的RouterGroup
Engine.Run 启动, 并绑定到参数的地址
RouterGroup 1 2 3 4 5 6 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 用于存储中间件的处理方法 &amp;ndash; 存储再 HandlersChain 里面, 即[]HandlerFunc
真正的路由地址存储在engine.trees &amp;ndash; 路由树, 检索请求地址和对应处理方法.
Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址. 目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树. 也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.</description>
      <content:encoded><![CDATA[<h1 id="golang-gin-框架的使用和理解">Golang Gin 框架的使用和理解</h1>
<p><a href="https://github.com/gin-gonic/gin">框架代码地址</a></p>
<h2 id="中间的几个关键对象">中间的几个关键对象</h2>
<ul>
<li>Engine</li>
<li>RouterGroup</li>
<li>HandlerFunc</li>
<li>Context</li>
</ul>
<h3 id="engine">Engine</h3>
<p>gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过<code>New()</code>或者<code>Default()</code>创建</p>
<ul>
<li><code>New</code> 不带任何中间件</li>
<li><code>Default</code> 会带 <code>logger</code> 和 <code>recover</code></li>
</ul>
<p>通过 <code>Engine.Use()</code> 添加中间件到Engine的<code>RouterGroup</code></p>
<p><code>Engine.Run</code> 启动, 并绑定到参数的地址</p>
<h3 id="routergroup">RouterGroup</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type RouterGroup struct {
</span></span><span class="line"><span class="cl">	Handlers HandlersChain
</span></span><span class="line"><span class="cl">	basePath string
</span></span><span class="line"><span class="cl">	engine   *Engine
</span></span><span class="line"><span class="cl">	root     bool
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>用于存储中间件的处理方法 &ndash; 存储再 <code>HandlersChain</code> 里面, 即<code>[]HandlerFunc</code></p>
<p>真正的路由地址存储在<code>engine.trees</code> &ndash; 路由树, 检索请求地址和对应处理方法.</p>
<p>Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址.
目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树.
也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes {
</span></span><span class="line"><span class="cl">	absolutePath := group.calculateAbsolutePath(relativePath)
</span></span><span class="line"><span class="cl">	handlers = group.combineHandlers(handlers)
</span></span><span class="line"><span class="cl">	group.engine.addRoute(httpMethod, absolutePath, handlers)
</span></span><span class="line"><span class="cl">	return group.returnObj()
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注册路由之前, 先将当前的 http 处理方法, 与当前中间件配置合并, 再添加到engine.</p>
<h4 id="routergroup-1">RouterGroup</h4>
<p><code>RouterGroup.Group</code>	创建一个新的 <code>RouterGroup</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">group</span> <span class="o">*</span><span class="nx">RouterGroup</span><span class="p">)</span> <span class="nf">Group</span><span class="p">(</span><span class="nx">relativePath</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handlers</span> <span class="o">...</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="o">*</span><span class="nx">RouterGroup</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RouterGroup</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Handlers</span><span class="p">:</span> <span class="nx">group</span><span class="p">.</span><span class="nf">combineHandlers</span><span class="p">(</span><span class="nx">handlers</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">basePath</span><span class="p">:</span> <span class="nx">group</span><span class="p">.</span><span class="nf">calculateAbsolutePath</span><span class="p">(</span><span class="nx">relativePath</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">:</span>   <span class="nx">group</span><span class="p">.</span><span class="nx">engine</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建新的 Group  时候,也会继承旧的 Group, 原先已经设置的 middleware. gin 框架不支持移除中间件的操作，所以在上层设置的中间件的时候一定要确保是公共 common 的</p>
<p>相似的路由捆绑在一块, 路由组写法, 可以做绑定相同中间件处理.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// Simple group: v1
</span></span><span class="line"><span class="cl">v1 := router.Group(&#34;/v1&#34;)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  v1.POST(&#34;/login&#34;, loginEndpoint)
</span></span><span class="line"><span class="cl">  v1.POST(&#34;/submit&#34;, submitEndpoint)
</span></span><span class="line"><span class="cl">  v1.POST(&#34;/read&#34;, readEndpoint)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>中间的花括号只起美化代码作用, 非必需</p>
<h3 id="handlerfunc">HandlerFunc</h3>
<p>中间件和请求处理方法的函数签名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Context</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>处理请求的时候, HandlerFunc 执行完毕 &ndash; 代表该请求处理结束</p>
<h3 id="context">Context</h3>
<p>gin 自己实现的 Context 结构</p>
<ul>
<li>在中间件中传递参数</li>
<li>控制调用流程</li>
<li>获取参数</li>
<li>返回结果</li>
</ul>
<p>Context 结构的重要组成部分介绍</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 存储URL 参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Params</span>   <span class="nx">Params</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 写入请求的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Writer</span>    <span class="nx">ResponseWriter</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 请求的所有处理方法集合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">handlers</span> <span class="nx">HandlersChain</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 当前执行到第几个方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">index</span>    <span class="kt">int8</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 存储流转于中间件的参数式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Keys</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">any</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="在中间件中传递参数">在中间件中传递参数</h4>
<ul>
<li><code>context.Get</code></li>
<li><code>context.Set</code> 两个方法在中间件中传递参数</li>
</ul>
<h4 id="流程控制">流程控制</h4>
<ul>
<li><code>context.Next()</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">&lt;</span> <span class="nb">int8</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="p">](</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将当前代码执行点移交到下一个 <code>HandlerFunc</code> 具体流程看, <a href="#Middleware">Middleware</a></p>
<h4 id="获取参数">获取参数</h4>
<ul>
<li><code>context.Param()</code> 获取 Query Param 的字符串参数</li>
<li><code>context.Query()</code></li>
<li><code>context.QueryMap()</code> 或者 <code>context.PostFormMap</code> 获取 map 的参数</li>
<li><code>context.Bind</code> 将参数包含query参数和body参数解析之后, 反序列化到传入的结构体.
tag <code>binding:&quot;required&quot;</code> 如果没有对应参数会报错</li>
</ul>
<h4 id="调用结束">调用结束</h4>
<ul>
<li><code>conetxt.JSON</code> 以json的形式, 返回结果
举个例子: 如果是json的的化就是 <code>jsonBinding</code> 进行反序列化</li>
<li>报错 500 <code>context.AbortWithStatus()</code></li>
</ul>
<h4 id="cookie-操作">Cookie 操作</h4>
<ul>
<li><code>context.Cookie()</code></li>
<li><code>context.SetCookie()</code></li>
</ul>
<h3 id="middleware">Middleware</h3>
<p>符合 <a href="#HandlerFunc">HandlerFunc</a> 签名的函数. 就可以<code>Engine.Use</code>注册层路由. 路由设置
的处理函数, 在本质上可以称为中间件.</p>
<ol>
<li>gin 会按照 routegroup <code>Use</code> 中间件的先后顺序存储到路由表中</li>
<li>接收请求, 依次执行注册时设置的所有中间件函数.</li>
</ol>
<h4 id="next">Next</h4>
<p>调用流程图:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">middleware 1
</span></span><span class="line"><span class="cl">| - doing m1 work
</span></span><span class="line"><span class="cl">| - call Context.Next()
</span></span><span class="line"><span class="cl">|     - call middleware 2
</span></span><span class="line"><span class="cl">|       - doing m2 work
</span></span><span class="line"><span class="cl">|       - call Context.Next()
</span></span><span class="line"><span class="cl">|         - call middleware 3
</span></span><span class="line"><span class="cl">|         - - done m3
</span></span><span class="line"><span class="cl">|       - continue m2 work
</span></span><span class="line"><span class="cl">|     - - done m2 work
</span></span><span class="line"><span class="cl">| - coninue m1 work
</span></span><span class="line"><span class="cl">| - done 
</span></span><span class="line"><span class="cl">finish
</span></span></code></pre></td></tr></table>
</div>
</div><p>当调研 <code>Context.Next()</code> 时会调用下一个中间函数, 当下一个函数执行完成之后, 执行
代码会返回到原先调用 <code>Context.Next()</code>的地方 &ndash; 递归</p>
<h4 id="abort">Abort</h4>
<p>中间处理时可以调用 <code>Context.Abort()</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Abort</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="nx">abortIndex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>会将函数调用链的index指向一个超大整数 &ndash; 放弃后面所有的处理函数, 但是 <strong>调用Abort后, 同一个函数接下的代码还会继续执行</strong></p>
<h4 id="小demo">小demo</h4>
<p><a href="https://gist.github.com/ynikl/20b603bfd743d2540d482939ac87d133">demo</a></p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">m1</span><span class="p">,</span> <span class="nx">m2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/greet&#34;</span><span class="p">,</span> <span class="nx">m3</span><span class="p">,</span> <span class="nx">greet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/abort&#34;</span><span class="p">,</span> <span class="nx">abort</span><span class="p">,</span> <span class="nx">m3</span><span class="p">,</span> <span class="nx">greet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">m1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;before m1 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;after m1 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">m2</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\tbefore m2 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\tafter m2 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">m3</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\tbefore m3 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\tafter m3 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">abort</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\t\tbefore abort&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Abort</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\t\tafter abort&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\t\t\thow are you doing?&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s">&#34;great&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接口 <code>/greet</code> 的输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">before m1 next
</span></span><span class="line"><span class="cl">        before m2 next
</span></span><span class="line"><span class="cl">                before m3 next
</span></span><span class="line"><span class="cl">                                how are you doing?
</span></span><span class="line"><span class="cl">                after m3 next
</span></span><span class="line"><span class="cl">        after m2 next
</span></span><span class="line"><span class="cl">after m1 next
</span></span></code></pre></td></tr></table>
</div>
</div><p>接口 <code>/abort</code> 的数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">before m1 next
</span></span><span class="line"><span class="cl">        before m2 next
</span></span><span class="line"><span class="cl">                        before abort
</span></span><span class="line"><span class="cl">                        after abort
</span></span><span class="line"><span class="cl">        after m2 next
</span></span><span class="line"><span class="cl">after m1 next
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="其他">其他</h3>
<p>gin.H</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 常用于 engine.JSON() 时返回 json 数据
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="几个问题">几个问题</h2>
<h3 id="gin-的-context-有什么作用和怎么用">Gin 的 context 有什么作用和怎么用?</h3>
<p>context 是 Gin 代码请求流转的核心, 存储处理请求的所有必须参数</p>
<p>基本的使用方法:</p>
<ol>
<li>需要知道如何获取参数 &ndash; <code>Bind</code> 或者 <code>Param</code> 方法</li>
<li>控制处理函数流程 &ndash; <code>Next</code> 或者 <code>Abort</code> 方法</li>
<li>返回结果 &ndash; <code>JSON</code></li>
</ol>
<h3 id="gin-的整体框架流程是怎么样的-从接受到一个请求再到返回请求中间的流程">Gin 的整体框架流程是怎么样的? 从接受到一个请求再到返回请求中间的流程?</h3>
<p>请求的注册入口, <code>Engine.ServeHTTP</code></p>
<p>整体流程</p>
<ol>
<li>存储路由路径和注册的处理函数到&quot;路由树&quot; &ndash; <code>nodetree</code></li>
<li>接收请求</li>
<li>根据接收到的请求地址, 从路由树中取出注册的函数, 组成<code>HandlerChain</code> 函数处理链</li>
<li>把函数处理链赋值到<code>gin.Context</code>中</li>
<li>由<code>gin.Context</code>开始依次调用注册处理函数, 所以函数遍历完成, 处理结束</li>
<li>通过<code>gin.Context.Writer</code>写入http请求结果</li>
<li>请求结束</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>工程能力阶梯分析</title>
      <link>https://ynikl.github.io/posts/my-engineeringladders/</link>
      <pubDate>Thu, 22 Dec 2022 11:38:36 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/my-engineeringladders/</guid>
      <description>工程师能力阶梯
自我能力分析</description>
      <content:encoded><![CDATA[<p><a href="https://github.com/jorgef/engineeringladders">工程师能力阶梯</a></p>
<p><img loading="lazy" src="https://s2.loli.net/2022/12/22/e7WUb6jY859TrsC.png" alt="原图"  />
</p>
<p>自我能力分析</p>
<p><img loading="lazy" src="https://s2.loli.net/2022/12/22/tNIgMAXcFoOdRSW.png" alt="我当前的能力分析"  />
</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql 快速备份数据</title>
      <link>https://ynikl.github.io/blog/mysql-quick-backup-data/</link>
      <pubDate>Tue, 20 Dec 2022 10:55:10 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/mysql-quick-backup-data/</guid>
      <description>1 2 CREATE TABLE dbto.table_name like dbfrom.table_name; insert into dbto.table_name select * from dbfrom.table_name; 原文</description>
      <content:encoded><![CDATA[<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CREATE TABLE dbto.table_name like dbfrom.table_name;
</span></span><span class="line"><span class="cl">insert into  dbto.table_name select * from dbfrom.table_name;
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://stackoverflow.com/a/63457341/9992963">原文</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang 是否需要为每个请求 New 一个 Client</title>
      <link>https://ynikl.github.io/blog/golang-client-reuse/</link>
      <pubDate>Mon, 19 Dec 2022 15:35:53 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-client-reuse/</guid>
      <description>背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致下游的 nginx 的连接数暴涨.
问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client
探索 在 StackOverflow 发现的相关答案
How to release http.Client in Go?
给的答案是建议复用 Client
The Client&amp;rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
http.Client 的结构体
1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time.</description>
      <content:encoded><![CDATA[<h2 id="背景">背景</h2>
<p>在改动旧代码的时候把, 一个使用全局 <code>http.Client</code> 的代码弄成了每一个请求会新 New
一个 <code>http.Client</code> 导致下游的 nginx 的连接数暴涨.</p>
<h2 id="问题">问题</h2>
<p>处理多个请求的时候, 是否需要为每个请求 New 一个 Client</p>
<h2 id="探索">探索</h2>
<p>在 StackOverflow 发现的相关答案</p>
<p><a href="https://stackoverflow.com/a/36688970/9992963">How to release http.Client in Go?</a></p>
<p>给的答案是建议复用 <code>Client</code></p>
<blockquote>
<p>The Client&rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.</p>
</blockquote>
<p>http.Client 的结构体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type Client struct {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	Transport RoundTripper
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	CheckRedirect func(req *Request, via []*Request) error
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	Jar CookieJar
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	Timeout time.Duration
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>RoundTripper</code> 中实现了连接复用的逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type RoundTripper interface {
</span></span><span class="line"><span class="cl">	RoundTrip(*Request) (*Response, error)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>中定义了 <code>RoundTrip</code> 方法, 提供客户端请求的时候调用.</p>
<p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=1;bpt=1;l=512?q=%2Fnet%2Fhttp%2Ftransport.go&amp;ss=go%2Fgo">调用地址</a></p>
<p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;l=95?q=%2Fnet%2Fhttp%2Ftransport.go&amp;ss=go%2Fgo">查看一下 Golang Transport 的基本实现</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type Transport struct {
</span></span><span class="line"><span class="cl">	idleMu       sync.Mutex
</span></span><span class="line"><span class="cl">	closeIdle    bool                                // user has requested to close all idle conns
</span></span><span class="line"><span class="cl">	idleConn     map[connectMethodKey][]*persistConn // most recently used at end
</span></span><span class="line"><span class="cl">	idleConnWait map[connectMethodKey]wantConnQueue  // waiting getConns
</span></span><span class="line"><span class="cl">	idleLRU      connLRU
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	connsPerHostMu   sync.Mutex
</span></span><span class="line"><span class="cl">	connsPerHost     map[connectMethodKey]int
</span></span><span class="line"><span class="cl">	connsPerHostWait map[connectMethodKey]wantConnQueue // waiting getConns
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	// 还有其他字段略
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>结构体中间有很多连接存储相关的字段.</p>
<p>在 http 请求调用 Transport 中间有一个关键方法 <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;bpv=1;bpt=1;l=1338">getConn</a> 获取一个连接</p>
<p>方法声明一个想要的连接地址, <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=1b2ad1d815ea8967c49b32d848b2992d0c588d88;l=1194">wantConn</a> 推入到 <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=0;bpt=1;l=1422">queueForDial</a></p>
<p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=1;bpt=1;l=1422">QueueForDial 方法</a>会判断时候<code>connsPerHost</code> 中间是否有当前的请求的缓存连接</p>
<ul>
<li>如果有直接拿来重复使用</li>
<li>如果没有, 就需要重新进行拨号</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	w.beforeDial()
</span></span><span class="line"><span class="cl">	if t.MaxConnsPerHost &lt;= 0 {
</span></span><span class="line"><span class="cl">		go t.dialConnFor(w)
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	t.connsPerHostMu.Lock()
</span></span><span class="line"><span class="cl">	defer t.connsPerHostMu.Unlock()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if n := t.connsPerHost[w.key]; n &lt; t.MaxConnsPerHost {
</span></span><span class="line"><span class="cl">		if t.connsPerHost == nil {
</span></span><span class="line"><span class="cl">			t.connsPerHost = make(map[connectMethodKey]int)
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		t.connsPerHost[w.key] = n + 1
</span></span><span class="line"><span class="cl">		go t.dialConnFor(w)
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if t.connsPerHostWait == nil {
</span></span><span class="line"><span class="cl">		t.connsPerHostWait = make(map[connectMethodKey]wantConnQueue)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	q := t.connsPerHostWait[w.key]
</span></span><span class="line"><span class="cl">	q.cleanFront()
</span></span><span class="line"><span class="cl">	q.pushBack(w)
</span></span><span class="line"><span class="cl">	t.connsPerHostWait[w.key] = q
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="结论">结论</h2>
<p>重复使用 http.Client 可以达到 TCP 连接复用的效果</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>查看 Linux 的负载情况</title>
      <link>https://ynikl.github.io/blog/linux-server-device-info/</link>
      <pubDate>Fri, 16 Dec 2022 14:31:33 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/linux-server-device-info/</guid>
      <description>查看负载 系统平均负载
1 uptime 那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。 如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。
查看内存信息 1 free -h 查看 cpu 型号
1 cat /proc/cpuinfo | grep &amp;#39;physical id&amp;#39; | sort | uniq | wc -l 核数
1 cat /proc/cpuinfo |grep &amp;#34;cores&amp;#34;|uniq|awk &amp;#39;{print $4}&amp;#39; 参考文章 https://www.eet-china.com/mp/a87720.html https://colobu.com/2019/02/22/how-to-find-cpu-cores-in-linux/ https://wangchujiang.com/linux-command/c/uptime.html </description>
      <content:encoded><![CDATA[<h2 id="查看负载">查看负载</h2>
<p>系统平均负载</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">uptime
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。
如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。</p>
</blockquote>
<h2 id="查看内存信息">查看内存信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">free -h
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="查看-cpu">查看 cpu</h2>
<p>型号</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cat /proc/cpuinfo | grep &#39;physical id&#39; | sort | uniq | wc -l
</span></span></code></pre></td></tr></table>
</div>
</div><p>核数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cat /proc/cpuinfo |grep &#34;cores&#34;|uniq|awk &#39;{print $4}&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://www.eet-china.com/mp/a87720.html">https://www.eet-china.com/mp/a87720.html</a></li>
<li><a href="https://colobu.com/2019/02/22/how-to-find-cpu-cores-in-linux/">https://colobu.com/2019/02/22/how-to-find-cpu-cores-in-linux/</a></li>
<li><a href="https://wangchujiang.com/linux-command/c/uptime.html">https://wangchujiang.com/linux-command/c/uptime.html</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Git 查看文件指定范围的修改记录</title>
      <link>https://ynikl.github.io/blog/git-view-change-log-in-specifie-line/</link>
      <pubDate>Mon, 12 Dec 2022 15:29:36 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/git-view-change-log-in-specifie-line/</guid>
      <description>查看一个文件指定范围内的所有修改记录
1 git log -p -2 -L1081,+5:&amp;#39;hello/world.go&amp;#39; -p -2 或者 --patch -2
往前展示两个 commit 的 diff . 在 git 中 commit 和 patch 是同一个意思参考下文.
git commands patching
A few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches.
-L 语法 -L&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;:&amp;lt;file&amp;gt;, -L:&amp;lt;funcname&amp;gt;:&amp;lt;file&amp;gt;
限制指定查看范围.</description>
      <content:encoded><![CDATA[<p>查看一个文件指定范围内的所有修改记录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git log -p -2 -L1081,+5:&#39;hello/world.go&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>-p -2</code> 或者 <code>--patch -2</code></p>
<p>往前展示两个 commit 的 diff . 在 git 中 commit 和 patch 是同一个意思参考下文.</p>
<p><a href="https://git-scm.com/book/en/v2/Appendix-C:-Git-Commands-Patching">git commands patching</a></p>
<blockquote>
<p>A few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches.</p>
</blockquote>
<p><code>-L</code> 语法
<code>-L&lt;start&gt;,&lt;end&gt;:&lt;file&gt;, -L:&lt;funcname&gt;:&lt;file&gt;</code></p>
<p>限制指定查看范围.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>202212</title>
      <link>https://ynikl.github.io/notes/202212/</link>
      <pubDate>Fri, 09 Dec 2022 14:04:07 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/notes/202212/</guid>
      <description>5 代码整洁结构 内部不应该依赖外部, 业务逻辑的实现, 不应该依赖于框架
20 1917
Down to Gehenna or up to the Throne, He travels the fastest who travles alone
小狗钱钱
真正的勇敢是在感到最恐惧的时候, 你依然在往前走.
曹大博客
政府/企业对事故的管理一般有一套“事前-事中-事后”的分析框架，可以作为我们处理事故的很好的参考。在开始分析之前，要先简单了解一下这个框架： 所谓事前，就是做事情之前应该有统筹的规划，考虑可能出现的问题和困难，最好提前做实验验证下，以保证在真实现场不出问题，或者即使出现问题也有应对方案，不至于手忙脚乱、大动干戈。 所谓事中，就是做事情的过程中对事前规划的事情进行执行，以及记录过程中出现的问题；整个事中起着承前启后的作用，上对事前的规划进行验证，下对事后的总结反思进行铺垫。 所谓事后，就是做事情结束后对整个事情进行总结反思、问题分类和根因分析等。追踪并确认所有的问题有效进行了解决和应对，以确保下次不会再犯之前同样的错误。
22 工程师能力阶梯
Eleanor Roosevelt
Great minds discuss ideas（伟人谈论想法）
Average minds discuss events （ 普通人谈论事件）
Small minds discuss people（ 庸人谈论他人）</description>
      <content:encoded><![CDATA[<h2 id="5">5</h2>
<h3 id="代码整洁结构httpswwwartacodecompostgolangtemplate"><a href="https://www.artacode.com/post/golang/template/">代码整洁结构</a></h3>
<p>内部不应该依赖外部, <strong>业务逻辑的实现, 不应该依赖于框架</strong></p>
<h2 id="20">20</h2>
<p>1917</p>
<blockquote>
<p>Down to Gehenna or up to the Throne, He travels the fastest who travles alone</p>
</blockquote>
<p>小狗钱钱</p>
<blockquote>
<p>真正的勇敢是在感到最恐惧的时候, 你依然在往前走.</p>
</blockquote>
<p>曹大博客</p>
<blockquote>
<p>政府/企业对事故的管理一般有一套“事前-事中-事后”的分析框架，可以作为我们处理事故的很好的参考。在开始分析之前，要先简单了解一下这个框架：
所谓事前，就是做事情之前应该有统筹的规划，考虑可能出现的问题和困难，最好提前做实验验证下，以保证在真实现场不出问题，或者即使出现问题也有应对方案，不至于手忙脚乱、大动干戈。
所谓事中，就是做事情的过程中对事前规划的事情进行执行，以及记录过程中出现的问题；整个事中起着承前启后的作用，上对事前的规划进行验证，下对事后的总结反思进行铺垫。
所谓事后，就是做事情结束后对整个事情进行总结反思、问题分类和根因分析等。追踪并确认所有的问题有效进行了解决和应对，以确保下次不会再犯之前同样的错误。</p>
</blockquote>
<h2 id="22">22</h2>
<p><a href="https://github.com/jorgef/engineeringladders">工程师能力阶梯</a></p>
<p>Eleanor Roosevelt</p>
<blockquote>
<p>Great minds discuss ideas（伟人谈论想法）<br>
Average minds discuss events （ 普通人谈论事件）<br>
Small minds discuss people（ 庸人谈论他人）</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>代码整洁架构</title>
      <link>https://ynikl.github.io/blog/clean-architectrue/</link>
      <pubDate>Mon, 05 Dec 2022 09:21:02 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/clean-architectrue/</guid>
      <description>代码整洁架构
核心思想 最重要的是依赖顺序需要内收 &amp;ndash; 业务逻辑不能依赖框架
分层 简单分层四层
Entities Use Cases Interface Adapters Framework and Drivers Entity 实体抽象层 我的理解应该是在公司业务, 或者项目领域上对于业务模型的抽象. 不容易改变 (除非公司 业务, 或者项目方向改变). 应该是与 领域驱动设计 不谋而合
Use Cases 使用场景层 业务使用场景, 应该是存放相关不同业务场景的具体实现流程
Interface Adapters 接口转化器层 负责 Use Cases 数据 与外部使用数据转换器实现.
比较特别的例子, 将 Use Cases 产生的数据与外部的 UI 表现层所需要的数据格式做转化.
Framework and Divers 数据库和框架层, 外部工具包接口依赖之类的.
依赖倒置 当遇到跨层依赖的时候, 内层需要引用到外层逻辑时: 比如, Use Case 要呈现 UI 数据结构 (Interface Adapters 层) 时, 不能直接引用 UI 层的数据模型.
而是, 通过依赖倒置. 将 UI 层的处理逻辑, 注入 Use Case 层进行处理, 实现目标.</description>
      <content:encoded><![CDATA[<p>代码整洁架构</p>
<h2 id="核心思想">核心思想</h2>
<p>最重要的是依赖顺序需要内收 &ndash; 业务逻辑不能依赖框架</p>
<h2 id="分层">分层</h2>
<p>简单分层四层</p>
<ul>
<li>Entities</li>
<li>Use Cases</li>
<li>Interface Adapters</li>
<li>Framework and Drivers</li>
</ul>
<h3 id="entity-实体抽象层">Entity 实体抽象层</h3>
<p>我的理解应该是在公司业务, 或者项目领域上对于业务模型的抽象. 不容易改变 (除非公司
业务, 或者项目方向改变). 应该是与 <em>领域驱动设计</em> 不谋而合</p>
<h3 id="use-cases-使用场景层">Use Cases 使用场景层</h3>
<p>业务使用场景, 应该是存放相关不同业务场景的具体实现流程</p>
<h3 id="interface-adapters-接口转化器层">Interface Adapters 接口转化器层</h3>
<p>负责 Use Cases 数据 与外部使用数据转换器实现.</p>
<p>比较特别的例子, 将 Use Cases 产生的数据与外部的 UI 表现层所需要的数据格式做转化.</p>
<h3 id="framework-and-divers">Framework and Divers</h3>
<p>数据库和框架层, 外部工具包接口依赖之类的.</p>
<h2 id="依赖倒置">依赖倒置</h2>
<p>当遇到跨层依赖的时候, 内层需要引用到外层逻辑时: 比如, Use Case 要呈现 UI 数据结构
(Interface Adapters 层) 时, 不能直接引用 UI 层的数据模型.</p>
<p>而是, 通过依赖倒置. 将 UI 层的处理逻辑, 注入 Use Case 层进行处理, 实现目标.</p>
<h2 id="golang-整洁模板">golang 整洁模板</h2>
<p>引用自 <a href="https://github.com/evrone/go-clean-template">golang clean template</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">├─cmd 应用入口
</span></span><span class="line"><span class="cl">│  └─app
</span></span><span class="line"><span class="cl">├─config
</span></span><span class="line"><span class="cl">├─docs // 存放文档
</span></span><span class="line"><span class="cl">├─internal
</span></span><span class="line"><span class="cl">│  ├─app
</span></span><span class="line"><span class="cl">│  ├─controller // 控制器
</span></span><span class="line"><span class="cl">│  │  ├─amqp_rpc
</span></span><span class="line"><span class="cl">│  │  └─http
</span></span><span class="line"><span class="cl">│  │      └─v1
</span></span><span class="line"><span class="cl">│  ├─entity // 实体层
</span></span><span class="line"><span class="cl">│  ├─middleware // 中间件
</span></span><span class="line"><span class="cl">│  └─usecase
</span></span><span class="line"><span class="cl">│      ├─repo // 数据库操作
</span></span><span class="line"><span class="cl">│      └─webapi // RESTful API
</span></span><span class="line"><span class="cl">├─migrations
</span></span><span class="line"><span class="cl">├─pkg //以被外部程序安全导入的包
</span></span><span class="line"><span class="cl">│  ├─crypto
</span></span><span class="line"><span class="cl">│  ├─httpresponse
</span></span><span class="line"><span class="cl">│  ├─httpserver
</span></span><span class="line"><span class="cl">│  ├─logger
</span></span><span class="line"><span class="cl">│  ├─mysql
</span></span><span class="line"><span class="cl">│  ├─postgres
</span></span><span class="line"><span class="cl">│  ├─rabbitmq
</span></span><span class="line"><span class="cl">│  └─redis
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://www.artacode.com/post/golang/template/">结构架构介绍</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">the clean architecture</a></li>
<li><a href="https://github.com/evrone/go-clean-template">goang clean template</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>小狗钱钱</title>
      <link>https://ynikl.github.io/books/ein-hund-namens-money/</link>
      <pubDate>Sun, 27 Nov 2022 13:56:17 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/ein-hund-namens-money/</guid>
      <description>我为什么要读这本书? 检讨自己, 学习理财的相关知识
曾经读完了 穷爸爸富爸爸 在那一段时间内有开始理财的想法, 后续又随的物欲的上涨, 开始过度超前消费, 让自己陷入了债务危机
这本书怎样影响了我? 开始编写梦想日记和成功日记 理解了&amp;quot;鹅&amp;quot;的故事, 开始做储蓄, 划分支出 作为一个陷入&amp;quot;债务危机&amp;quot;的人的自救 72 小时定律: 决定做一件事情要在72个小时内完成 72 公式: 投资 / 年利率 = 本金翻一倍需要的年数; 通货膨胀价值减半需要的年数 书中的三句精华句子? “：“吉娅，你真的认真找过工作了吗？我是说，你有没有用一整个下午的时间来考虑如何挣到钱的问题呢？” &amp;ndash; 很多时候你觉得你思考过了, 但是你真的花费了足够的时间思考了吗? “他用一种恳切的目光望着我，说：“我生命中出现了最美好的东西，是因为我做了原本不敢做的事。” &amp;ndash; 确实如此, 要去尝试自己所不敢做的事情 总结本书 通俗易懂, 醍醐灌顶 陷入债务危机的人的自救方法
销毁信用支付: 信用支付会比现金消费花的钱更多 尽可能少偿还贷款: 避免再次借贷, 弥补空缺 偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费. 书摘 “可是，这正是许多没有钱的人爱犯的错误。他们总是有那么多紧急的事情要做，以至于没有时间来关注重要的事情。”
“钱钱对我点了点头，说：“困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟”
理解重要不紧急的事情
“很简单。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。” ”
陷入债务危机的人的自救方法
销毁信用支付: 信用支付会比现金消费花的钱更多 尽可能少偿还贷款: 避免再次借贷, 弥补空缺 偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费. “鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。”
“我叹道：“要在‘鹅’和愿望之间作取舍真难！” “你根本不用放弃任何一个。两件事可以同时进行。”金先生微笑着说，“比如你挣了10马克，那么你可以分配一下这笔钱，把其中的大部分存入银行，然后把一部分放入你的梦想储蓄罐，剩下的当作零花钱。”
“所有人都希望自己变得富有一些，只是有些人的这一愿望更为强烈，而有些人却假装自己满足于现在的生活。事实上，大多数人都希望自己更幸福、更成功，也想拥有更多的钱”
“可是假如我们缺钱的话，钱就会变得格外重要。你回想一下那次我们差点淹死在河里的情形，当时我们想的只是必须从河里爬上来，其他的一切都变得无关紧要了”
“中国的智者老子说过：‘天下难事，必作于易；天下大事，必作于细”
“第一，我建议你拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。”
“没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西”</description>
      <content:encoded><![CDATA[<h3 id="我为什么要读这本书">我为什么要读这本书?</h3>
<p>检讨自己, 学习理财的相关知识</p>
<p>曾经读完了 <em>穷爸爸富爸爸</em> 在那一段时间内有开始理财的想法, 后续又随的物欲的上涨,
开始过度超前消费, 让自己陷入了债务危机</p>
<h3 id="这本书怎样影响了我">这本书怎样影响了我?</h3>
<ul>
<li>开始编写梦想日记和成功日记</li>
<li>理解了&quot;鹅&quot;的故事, 开始做储蓄, 划分支出</li>
<li>作为一个陷入&quot;债务危机&quot;的人的自救</li>
<li>72 小时定律: 决定做一件事情要在72个小时内完成</li>
<li>72 公式: 投资 / 年利率 = 本金翻一倍需要的年数; 通货膨胀价值减半需要的年数</li>
</ul>
<h3 id="书中的三句精华句子">书中的三句精华句子?</h3>
<ul>
<li>“：“吉娅，你真的认真找过工作了吗？我是说，你有没有用一整个下午的时间来考虑如何挣到钱的问题呢？” &ndash; 很多时候你觉得你思考过了, 但是你真的花费了足够的时间思考了吗?</li>
<li>“他用一种恳切的目光望着我，说：“我生命中出现了最美好的东西，是因为我做了原本不敢做的事。” &ndash; 确实如此, 要去尝试自己所不敢做的事情</li>
<li></li>
</ul>
<h3 id="总结本书">总结本书</h3>
<ul>
<li>通俗易懂, 醍醐灌顶</li>
</ul>
<p>陷入债务危机的人的自救方法</p>
<ol>
<li>销毁信用支付: 信用支付会比现金消费花的钱更多</li>
<li>尽可能少偿还贷款: 避免再次借贷, 弥补空缺</li>
<li>偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费.</li>
</ol>
<h2 id="书摘">书摘</h2>
<p>“可是，这正是许多没有钱的人爱犯的错误。他们总是有那么多紧急的事情要做，以至于没有时间来关注重要的事情。”</p>
<p>“钱钱对我点了点头，说：“困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟”</p>
<p>理解重要不紧急的事情</p>
<p>“很简单。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。”
”</p>
<p>陷入债务危机的人的自救方法</p>
<ol>
<li>销毁信用支付: 信用支付会比现金消费花的钱更多</li>
<li>尽可能少偿还贷款: 避免再次借贷, 弥补空缺</li>
<li>偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费.</li>
</ol>
<p>“鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。”</p>
<p>“我叹道：“要在‘鹅’和愿望之间作取舍真难！”
“你根本不用放弃任何一个。两件事可以同时进行。”金先生微笑着说，“比如你挣了10马克，那么你可以分配一下这笔钱，把其中的大部分存入银行，然后把一部分放入你的梦想储蓄罐，剩下的当作零花钱。”</p>
<p>“所有人都希望自己变得富有一些，只是有些人的这一愿望更为强烈，而有些人却假装自己满足于现在的生活。事实上，大多数人都希望自己更幸福、更成功，也想拥有更多的钱”</p>
<p>“可是假如我们缺钱的话，钱就会变得格外重要。你回想一下那次我们差点淹死在河里的情形，当时我们想的只是必须从河里爬上来，其他的一切都变得无关紧要了”</p>
<p>“中国的智者老子说过：‘天下难事，必作于易；天下大事，必作于细”</p>
<p>“第一，我建议你拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。”</p>
<p>“没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西”</p>
<p>“但如果你的零花钱是现在的10倍的话，你的问题只会变得更加严重。因为我们的支出永远是随着我们的收入而增长的。”</p>
<p>“第一，为别人解决一个难题，那么你就能赚到许多钱；第二，把精力集中在你知道的、能做的和拥有的东西上。”</p>
<p>“：“吉娅，你真的认真找过工作了吗？我是说，你有没有用一整个下午的时间来考虑如何挣到钱的问题呢？”</p>
<p>“情况顺利的时候，人人都能挣到钱。只有在逆境中，一切才能见分晓。”</p>
<p>“可是有的时候，疯狂的念头确实比普通的小目标更容易实现。当你定下大目标的时候，就意味着你必须付出比别人多得多的努力。”</p>
<p>“假如我总是花光我的钱，那我就永远也得不到我的‘鹅’，所以我就总得为了赚钱而工作。而一旦我有了一只‘鹅’，我的钱就会自动为我工作了。”</p>
<p>“没有人能强迫你做你不愿意做的事情。只有你自己才能强迫自己去做。”</p>
<p>“他用一种恳切的目光望着我，说：“我生命中出现了最美好的东西，是因为我做了原本不敢做的事。”</p>
<p>“你就永远不会知道，给自己一些压力之后，你能够做到些什么。一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。这一点你千万不要忘记”</p>
<p>挑选基金</p>
<p>1．基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。
2．应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。
3．对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。</p>
<p>“它的名字叫72公式。”老太太讲解说，“你们直接用72除以你们投资的年利润百分比，得出的数字就是这笔钱翻一倍所要的年数”</p>
<p>“银行存折肯定不是保存钱的最合适的地方，金先生总是把银行存折叫作“吞钱机器”。”</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go 使用 runtime 包进行内存占用分析</title>
      <link>https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/</link>
      <pubDate>Fri, 18 Nov 2022 19:27:35 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/</guid>
      <description>使用场景 写个demo, 想查看一下程序内部的内存占用情况.
使用方法 主角 runtime 包
对象 MemStats 方法 ReadMemStats demo 展示
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(&amp;amp;m) // For info on each, see: https://golang.</description>
      <content:encoded><![CDATA[<h3 id="使用场景">使用场景</h3>
<p>写个demo, 想查看一下程序内部的内存占用情况.</p>
<h3 id="使用方法">使用方法</h3>
<p>主角 runtime 包</p>
<ul>
<li>对象 <code>MemStats</code></li>
<li>方法 <code>ReadMemStats</code></li>
</ul>
<p>demo 展示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// PrintMemUsage outputs the current, total and OS memory being used. As well as the number 
</span></span></span><span class="line"><span class="cl"><span class="c1">// of garage collection cycles completed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">PrintMemUsage</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bToMb</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">b</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">m</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">MemStats</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// For info on each, see: https://golang.org/pkg/runtime/#MemStats
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Alloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Alloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tTotalAlloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">TotalAlloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tSys = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Sys</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tNumGC = %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">NumGC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://gist.github.com/j33ty/79e8b736141be19687f565ea4c6f4226">代码出处</a></p>
<h3 id="解释">解释</h3>
<h4 id="readmemstats">ReadMemStats</h4>
<p><code>runtime.ReadMemStats</code> 方法会读取到内存分配器的当前时刻最新的内存分配数据, 并将
其填充到传入参数的<code>MemStats</code> 的变量中.</p>
<p>可以充当一个内存快照, 用于进行对比.</p>
<h4 id="memstats-字段">MemStats 字段</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MemStats</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 当前堆上对象的内存分配大小, 同HeapAlloc字段, 单位 bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Alloc</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 历史总的累计分配内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TotalAlloc</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从操作系统分配的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Sys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 记录指针索引性能, go 语言内部使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Lookups</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 堆上分配的对象数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Mallocs</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 堆上剩余的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Frees</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">HeapAlloc</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从操作系统分配的 堆 内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 未使用的空闲内存分片大小 spans
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapIdle</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用中的内存分片大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 回退的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapReleased</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 堆上分配的对象数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapObjects</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 栈上使用的内存片大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">StackInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从操作系统分配的栈的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">StackSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MSpanInuse is bytes of allocated mspan structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MSpanInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MSpanSys is bytes of memory obtained from the OS for mspan
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MSpanSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MCacheInuse is bytes of allocated mcache structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MCacheInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MCacheSys is bytes of memory obtained from the OS for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// mcache structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MCacheSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// BuckHashSys is bytes of memory in profiling bucket hash tables.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">BuckHashSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// GCSys is bytes of memory in garbage collection metadata.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">GCSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// OtherSys is bytes of memory in miscellaneous off-heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// runtime allocations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">OtherSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 在多大的堆内存时, 触发GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NextGC</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 上次GC 时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">LastGC</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PauseTotalNs is the cumulative nanoseconds in GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stop-the-world pauses since the program started.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// During a stop-the-world pause, all goroutines are paused
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// and only the garbage collector can run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PauseTotalNs</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PauseNs is a circular buffer of recent GC stop-the-world
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// pause times in nanoseconds.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// The most recent pause is at PauseNs[(NumGC+255)%256]. In
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// general, PauseNs[N%256] records the time paused in the most
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// recent N%256th GC cycle. There may be multiple pauses per
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// GC cycle; this is the sum of all pauses during a cycle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PauseNs</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PauseEnd is a circular buffer of recent GC pause end times,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// as nanoseconds since 1970 (the UNIX epoch).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This buffer is filled the same way as PauseNs. There may be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// multiple pauses per GC cycle; this records the end of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// last pause in a cycle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PauseEnd</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// GC 次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NumGC</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 手动调用 GC 的次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NumForcedGC</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// GC 使用的 CPU 时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">GCCPUFraction</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 可以GC,一直是true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">EnableGC</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// BySize reports per-size class allocation statistics.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// BySize[N] gives statistics for allocations of size S where
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// BySize[N-1].Size &lt; S ≤ BySize[N].Size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This does not report allocations larger than BySize[60].Size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">BySize</span> <span class="p">[</span><span class="mi">61</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Size is the maximum byte size of an object in this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// size class.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">Size</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Mallocs is the cumulative count of heap objects
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// allocated in this size class. The cumulative bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// of allocation is Size*Mallocs. The number of live
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// objects in this size class is Mallocs - Frees.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">Mallocs</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Frees is the cumulative count of heap objects freed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// in this size class.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">Frees</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://pkg.go.dev/runtime#MemStats">源码出处</a></p>
<h3 id="我用于分析-map-的-delete-操作占用内存">我用于分析 map 的 delete 操作占用内存</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span><span class="p">[</span><span class="s">&#34;a&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;make storage value&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mint</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mint</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 注意: 需要引用, 避免被提前回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mint</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// go run main.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Outpu:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 8192 MiB	TotalAlloc = 8192 MiB	Sys = 8464 MiB	NumGC = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 0 MiB	TotalAlloc = 8192 MiB	Sys = 8465 MiB	NumGC = 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// make storage value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 39168 MiB	TotalAlloc = 47360 MiB	Sys = 48898 MiB	NumGC = 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 39168 MiB	TotalAlloc = 47360 MiB	Sys = 48898 MiB	NumGC = 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 0 2048
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">PrintMemUsage</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bToMb</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">b</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">m</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">MemStats</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// For info on each, see: https://golang.org/pkg/runtime/#MemStats
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Alloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Alloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tTotalAlloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">TotalAlloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tSys = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Sys</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tNumGC = %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">NumGC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>分析结果得出, 如果在 map 中存储的 value, 如果是引用值的话, 占用的内存是被 GC 回收
的. 但是, 如果是值类型如简单的<code>int</code>是不会被回收的.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Asking the Right Questions</title>
      <link>https://ynikl.github.io/books/asking-the-right-questions/</link>
      <pubDate>Thu, 17 Nov 2022 22:53:21 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/asking-the-right-questions/</guid>
      <description>概括 我为什么要读这本书? 养成一个批判性的看待问题方式.
这本书怎样影响了我? 了解了一些常见的经典辩证错误, 比如: 人身攻击, 虚假两难, 完美解决方案 看待一个问题之前, 要想想这个问题, 关我什么事. 对于一些问题的论述会更加注意和小心 书中的三句精华句子? 一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？” 结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。 常见的谬论
人身攻击谬误（ad hominem fallacy）: 人身攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。 滑坡谬误: 指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件发生。 追求完美解决方案谬误: 指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种解决方案根本就不应该采用。 偷换概念谬误:一旦你看到一个关键词或短语在论证中不止一次出现，检查一下看看其意思有没有发生改变，如果意思发生改变，就要警惕偷换概念谬误。 权威谬误: 除非我们知道这些权威对这一论题拥有特别的专门知识，否则我们就要将这个理由视为谬误。这种类型的谬误叫做诉诸可疑权威谬误（appeal to questionable authority fallacy）。 虚假的两难选择: 世界上只有两种人——一种人表演，另一种人观看。” 要让这样的陈述成立，我们必须假设只有这两种选择，是不是这样呢？当然不是！作者创造了一种虚假的两难选择（false dilemma）。 乱扣帽子谬误: 当有人宣称他们发现了导致某个行为的原因，而实际上他们所做的不过是为这种行为起了个名字而已，我们要对这种乱扣帽子谬误[7]（explaining by naming fallacy）保持警惕。 循环论证谬误[1]（begging the question fauacy）。 错误类比谬误指有人提出一个类比，其中却存在重要而又相关的不同点。 过度简化因果关系谬误: 如果持论者不能考虑到各种原因的复杂性，他们就犯了过度简化因果关系谬误[1]（causal oversimplication fallacy）。 事后归因谬误[1]（全称为&amp;quot;post hoc, ergo propter hoc fallacy&amp;quot;，拉丁文的意思是“在这之后，所以是因为这个的谬误”。） 三句话总结本书 书摘 一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？”
小贴士：价值观指的是人们认为较有价值而没有明说出来的观点。它们树立了一定的行为准则，据此我们来衡量人类行为的品质高下。
一厢情愿的思维之所以常常挥之不去，是因为我们否认一切的思维方式常常出现。
描述性论题是指对过去、现在或将来的各种描述的精确与否提出的问题。
我们将这些问题称为规定性论题（prescriptive issues）。社会论争通常都属于规定性论题。
问一问“作者是在对什么事件进行回应”常常能帮你找出一篇文章的中心论题。
但是，当论题并没有直截了当地说出来时，最有效的方法就是先找准结论。很多情况下，在你能确认论题之前都得先找出结论来。
结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。
结论是作者或演说者希望你选择的目的地和终点站。接下来你所关心的是：基于支撑这一论断的所有材料，我该不该接受这个结论？</description>
      <content:encoded><![CDATA[<h2 id="概括">概括</h2>
<h3 id="我为什么要读这本书">我为什么要读这本书?</h3>
<p>养成一个批判性的看待问题方式.</p>
<h3 id="这本书怎样影响了我">这本书怎样影响了我?</h3>
<ul>
<li>了解了一些常见的经典辩证错误, 比如: 人身攻击, 虚假两难, 完美解决方案</li>
<li>看待一个问题之前, 要想想这个问题, 关我什么事.</li>
<li>对于一些问题的论述会更加注意和小心</li>
</ul>
<h3 id="书中的三句精华句子">书中的三句精华句子?</h3>
<ul>
<li>一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？”</li>
<li>结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。</li>
</ul>
<p>常见的谬论</p>
<ul>
<li>人身攻击谬误（ad hominem fallacy）: 人身攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。</li>
<li>滑坡谬误: 指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件发生。</li>
<li>追求完美解决方案谬误: 指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种解决方案根本就不应该采用。</li>
<li>偷换概念谬误:一旦你看到一个关键词或短语在论证中不止一次出现，检查一下看看其意思有没有发生改变，如果意思发生改变，就要警惕偷换概念谬误。</li>
<li>权威谬误:
除非我们知道这些权威对这一论题拥有特别的专门知识，否则我们就要将这个理由视为谬误。这种类型的谬误叫做诉诸可疑权威谬误（appeal to questionable authority fallacy）。</li>
<li>虚假的两难选择: 世界上只有两种人——一种人表演，另一种人观看。” 要让这样的陈述成立，我们必须假设只有这两种选择，是不是这样呢？当然不是！作者创造了一种虚假的两难选择（false dilemma）。</li>
<li>乱扣帽子谬误: 当有人宣称他们发现了导致某个行为的原因，而实际上他们所做的不过是为这种行为起了个名字而已，我们要对这种乱扣帽子谬误[7]（explaining by naming fallacy）保持警惕。</li>
<li>循环论证谬误[1]（begging the question fauacy）。</li>
<li>错误类比谬误指有人提出一个类比，其中却存在重要而又相关的不同点。</li>
<li>过度简化因果关系谬误:  如果持论者不能考虑到各种原因的复杂性，他们就犯了过度简化因果关系谬误[1]（causal oversimplication fallacy）。</li>
<li>事后归因谬误[1]（全称为&quot;post hoc, ergo propter hoc fallacy&quot;，拉丁文的意思是“在这之后，所以是因为这个的谬误”。）</li>
</ul>
<h3 id="三句话总结本书">三句话总结本书</h3>
<ul>
<li></li>
</ul>
<h2 id="书摘">书摘</h2>
<p>一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？”</p>
<p>小贴士：价值观指的是人们认为较有价值而没有明说出来的观点。它们树立了一定的行为准则，据此我们来衡量人类行为的品质高下。</p>
<p>一厢情愿的思维之所以常常挥之不去，是因为我们否认一切的思维方式常常出现。</p>
<p>描述性论题是指对过去、现在或将来的各种描述的精确与否提出的问题。</p>
<p>我们将这些问题称为规定性论题（prescriptive issues）。社会论争通常都属于规定性论题。</p>
<p>问一问“作者是在对什么事件进行回应”常常能帮你找出一篇文章的中心论题。</p>
<p>但是，当论题并没有直截了当地说出来时，最有效的方法就是先找准结论。很多情况下，在你能确认论题之前都得先找出结论来。</p>
<p>结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。</p>
<p>结论是作者或演说者希望你选择的目的地和终点站。接下来你所关心的是：基于支撑这一论断的所有材料，我该不该接受这个结论？</p>
<p>有没有一个清楚明确的论题，通常是区别作家成熟不成熟的一个重要标志。</p>
<p>如果你写作或者演说的目的是为了传达某个特定的结论，你的读者或听众就会尽力去寻找这一结论。老老实实地把结论说出来，而且说得清楚明白，其实也就是在帮助你的读者或听众。</p>
<p>请记住：只有当你找到支撑结论的理由时你才能判定一个结论的价值。</p>
<p>·论证必有其目的。</p>
<p>最后一点需要进一步加以强调和说明。心急火燎地去推进批判性思维并没有什么意义。</p>
<p>在规定性论证中，理由常常不是一般性的规定性陈述就是描述性的看法或原则。</p>
<p>相反，一个关心批判性思维的作者会考虑到可能存在的种种理由并掂量它们的分量，然后才会做出结论。</p>
<p>如果你的论题是利用当前时事来探究政治或社会问题，比如公立教育改革或反恐战争，那就应当从主要的新闻出版物着手。</p>
<p>我们在读书或听讲的时候，一定要强迫自己去寻找那些意思不明确的词或短语，否则你就会抓不住要领。</p>
<p>事实上，很多文献，如美国宪法，都是有意要显得模棱两可，这样这份文献才能与时俱进，其中的关键词如“自由”、“携带武器”的不同含义才能适应不断发展的现实需求。诚然，</p>
<p>因为有人要你接受他的结论，所以你只需要去寻找那些影响你接受其结论的词或短语。这样说来，你应该在理由和结论中寻找这些词或短语。</p>
<p>一个词或短语越抽象，人们越有可能对其做出多重解读。</p>
<p>第一个障碍是你自认为和作者表达的是同一个意思。</p>
<p>意义通常表现为下列三种方式：同义替换、举例说明以及我们通称的“具体标准定义”（</p>
<p>还有一种方法可以帮你发现这个词可能存在的其他含义，那就是尽量在脑海中想象这个词所代表的具体景象，如果你想象不出来，那你很可能就找到了一处重要的歧义。</p>
<p>那些激发强烈情感反应的术语被称为附加感情色彩的术语（loaded terms）。它们感动我们的能力大大超越了它们本身的描述性含义。</p>
<p>作为一个积极主动的学生，你有责任提出各种问题来消除歧义。但你的责任到此为止。作者和演说者才是努力要说服你接受某些观点的人。身为说客，他有责任回答你对可能存在的歧义的各种关心。 你没有义务来评价那些不明确的想法或选择。</p>
<p>我们把这些没有明说出来的想法称为假设（assumptions）。</p>
<p>人的价值观会影响他列举出的种种理由，因而也影响到他的结论。实际上，只有把这些价值观假设添加到推理中，他们的理由才能从逻辑上证实其结论。</p>
<p>当作者对于社会论争采取了一种立场，他们通常都会选择一种价值观而排斥另一种价值观，他们有价值优先或者价值倾向。</p>
<p>找到价值观假设一个比较好的起点就是检查一下作者的背景。</p>
<p>因此，要判断一个人的价值观假设，一个重要手段就是要注意他用来证实结论的各种理由，然后判断哪些价值取向会导致作者认为这些理由比其他理由更可取，</p>
<p>遇到有争议的主题，以这种方式说明价值观假设可以不断提醒自己作者放弃了什么，又得到了什么。</p>
<p>遇到有争议的主题，以这种方式说明价值观假设可以不断提醒自己作者放弃了什么，又得到了什么。尽量抵制住诱惑，不要一找到作者或演说者的价值观就过早地停止分析的过程。</p>
<p>任何一个想要进行论证的人都有必要提供一些解释，说明为什么你应该接受那个论证中暗含的特定的价值观假设。</p>
<p>价值取向需要有一定的正当理由，这样批判性思考的人才能加以考虑。一个价值取向需要有证实它的理由，正如任何一个结论都需要理由一样。</p>
<p>描述性假设（descriptive assumption）就是对这个世界过去、现在或未来是什么样的想法，而你应该记得，规定性的或者说价值观假设是关于这个世界应该是什么样的那些想法。</p>
<p>不断思考结论和理由之间存在的鸿沟。你为什么一开始就要寻找这些假设呢？因为你想让自己能判断理由在多大程度上证实结论。</p>
<p>批判性阅读和聆听的主要目标就在于判定结论的可接受程度或者价值大小。</p>
<p>所谓谬误，就是推理中的欺骗手段，作者有可能利用这个欺骗手段来说服你采纳其结论。</p>
<ul>
<li>人身攻击谬误（ad hominem fallacy）: 人身攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。</li>
<li>滑坡谬误: 指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件发生。</li>
<li>追求完美解决方案谬误: 指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种解决方案根本就不应该采用。</li>
<li>偷换概念谬误:一旦你看到一个关键词或短语在论证中不止一次出现，检查一下看看其意思有没有发生改变，如果意思发生改变，就要警惕偷换概念谬误。</li>
<li>权威谬误:
除非我们知道这些权威对这一论题拥有特别的专门知识，否则我们就要将这个理由视为谬误。这种类型的谬误叫做诉诸可疑权威谬误（appeal to questionable authority fallacy）。</li>
<li>虚假的两难选择: 世界上只有两种人——一种人表演，另一种人观看。” 要让这样的陈述成立，我们必须假设只有这两种选择，是不是这样呢？当然不是！作者创造了一种虚假的两难选择（false dilemma）。</li>
<li>乱扣帽子谬误: 当有人宣称他们发现了导致某个行为的原因，而实际上他们所做的不过是为这种行为起了个名字而已，我们要对这种乱扣帽子谬误[7]（explaining by naming fallacy）保持警惕。</li>
<li>循环论证谬误[1]（begging the question fauacy）。</li>
<li>错误类比谬误指有人提出一个类比，其中却存在重要而又相关的不同点。</li>
<li>过度简化因果关系谬误:  如果持论者不能考虑到各种原因的复杂性，他们就犯了过度简化因果关系谬误[1]（causal oversimplication fallacy）。</li>
<li>事后归因谬误[1]（全称为&quot;post hoc, ergo propter hoc fallacy&quot;，拉丁文的意思是“在这之后，所以是因为这个的谬误”。）</li>
</ul>
<p>当我们被要求解释为什么特定的行为会发生时，我们常常受到诱惑，想要隐藏我们对很多复杂因果关系的无知，干脆给那种行为贴上个标签或者套上个名字，然后我们错误地假设因为我们知道那个标签或名字，我们就知道事情的起因。</p>
<p>如果需要证据，但又没有看到证据，那么这个断言就是孤立论断（mere assertion），意思是它是一个没有用任何方式来加以证实的断言。</p>
<p>与其问一问它们是不是真的，我们宁愿问问它们是不是可靠。其实，我们想问的是：“我们可以依靠这样的看法吗？”</p>
<p>因为单一的个人经历，甚至是个人经历的总和，根本不足以构成一个有代表性的经历样本，个人经历常常会导致我们犯下以偏概全谬误[1]（hasty generalization fallacy）。</p>
<p>典型案例常常很有说服力，因为它们是那样具体生动而又细致感人，很容易就在我们的脑海里浮现出来。</p>
<p>引用具体当事人的这些说法都被称为当事人证词（personal testimonials）。</p>
<p>我们常常说眼见为实，这里则倒过来，相信什么就看得见什么！</p>
<p>引用另一家通讯社（如美联社）。这些引证给人一种支撑证据的幻象但是却绕过了一个最基本的问题：那个原始专家的断言到底有多大可信度？</p>
<p>观察者，不像特定的镜子，并不能给我们提供“纯粹”的观察。我们所“见”所说的都是经过一系列的价值观、偏见、态度和期望值过滤后剩下来的东西。</p>
<p>最后，调查本身所包含的很多偏见让它们变得更加可疑。其中两个最重要的偏见是措辞偏见（biased wording）和语境偏见（biased context）。</p>
<p>当我们因为朋友的极力推荐而选择买下一张CD，我们也是在以相同的方式进行推理。我们这样推理是因为我们彼此之间非常相像，喜欢或不喜欢的东西有很多都是相同的，</p>
<p>当类比用于设定谈话的语气时，识别它们就变得尤其重要。</p>
<p>过度情绪化的类比遮蔽了论证中的真正论题，而且阻碍了实质性的对话。尽量识别包含了重要的情感内涵意义的那些比较，这样做才能避免受这些类比的欺骗。</p>
<p>在寻找替代原因时，我们必须要记住，我们找出的任何一个单独的原因都极有可能是引起事件发生的其中一个原因，而不是其唯一的原因。</p>
<p>将因果关系和相关关系二者混淆起来，既可以理解，同时又异常危险。虽然原因确实先于结果出现，但先于结果出现的还有很多种其他因素，而其中很多不是引发结果的原因。</p>
<p>有一种常见的偏见就是基本归因错误（fundamental attribution error），在这种错误里，我们在解释他人的行为时普遍高估了个人倾向的重要性而低估了环境因素的作用。也就是说，我们喜欢把别人行为的动因看成是来自其内部因素的作用（他们个人的性格特点），而不是来自外部因素的作用（环境的力量）。</p>
<p>你应该时时刻刻向读者证明你并没有忽略其他可选的解释。也许随着你的研究的展开，你发现貌似言之成理的解释实际上并不能被证据所证明。</p>
<p>第一个策略就是尽量找到足够多的关于这些数据是如何采集的信息。</p>
<p>作者谈论的是平均数、中位数还是众数，将会产生很大的区别。</p>
<p>另一个重要的有可能缺失掉的信息类型是相对比较（relevant comparisons）。</p>
<p>因此，真正的自主思考需要我们坚持不懈地寻找作者到底隐瞒了什么信息，不论其是无心省略还是有意隐瞒。</p>
<p>我们从理由当中得出不同的结论是因为我们的背景各不相同，目标千差万别，这样我们在决定将理由和结论连起来的时候必然会被不同的假设所吸引。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>我的人生规划</title>
      <link>https://ynikl.github.io/neo/life/</link>
      <pubDate>Sun, 13 Nov 2022 07:09:37 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/neo/life/</guid>
      <description>我现在需要努力的方向
对于工作项目有帮助的技术, 提升技术的广度 深入学习计算机的基础, 比如: 计算机网络, 算法, 数据结构 保持一个健康的身体 (目前状态不错, 不需要担心) 我希望自己 技术能力
深度 广度 普世价值
极简主义 内心强大 文采斐然 身体健康
40的臂维 6 块腹肌 职业规划 定一个目标, 做程序员至少要干到 35 岁. 也就是还有7年的时间 &amp;ndash; 不许想失业问题, 努力 钻研技术.
既然, 还有7年的程序员职业生涯, 那么就还是要好好努力到底.
提升技术水平, 提高基础薪资水平 发展个人项目 再探索&amp;hellip; 2023 目标 努力挣更多的钱 深挖程序员的深度, 成为 以Golang为基础的编程专家
输出10篇高质量的技术文章 完成数据结构与算法的系统学习 掌握一门基础的前端页面开发技术 培养个人艺术情操 完成3次中远距离出游计划 完成50本书籍阅读 (22年完成49本) 撰写10篇非技术性文章 </description>
      <content:encoded><![CDATA[<p>我现在需要努力的方向</p>
<ul>
<li>对于工作项目有帮助的技术, 提升技术的广度</li>
<li>深入学习计算机的基础, 比如: 计算机网络, 算法, 数据结构</li>
<li>保持一个健康的身体 (目前状态不错, 不需要担心)</li>
</ul>
<h2 id="我希望自己">我希望自己</h2>
<ul>
<li>
<p>技术能力</p>
<ul>
<li>深度</li>
<li>广度</li>
</ul>
</li>
<li>
<p>普世价值</p>
<ul>
<li>极简主义</li>
<li>内心强大</li>
<li>文采斐然</li>
</ul>
</li>
<li>
<p>身体健康</p>
<ul>
<li>40的臂维</li>
<li>6 块腹肌</li>
</ul>
</li>
</ul>
<h2 id="职业规划">职业规划</h2>
<p>定一个目标, 做程序员至少要干到 35 岁. 也就是还有7年的时间 &ndash; 不许想失业问题, 努力
钻研技术.</p>
<blockquote>
<p>既然, 还有7年的程序员职业生涯, 那么就还是要好好努力到底.</p>
</blockquote>
<ol>
<li>提升技术水平, 提高基础薪资水平</li>
<li>发展个人项目</li>
<li>再探索&hellip;</li>
</ol>
<h2 id="2023-目标">2023 目标</h2>
<ol>
<li>努力挣更多的钱</li>
</ol>
<p>深挖程序员的深度, 成为 以Golang为基础的编程专家</p>
<ul>
<li>输出10篇高质量的技术文章</li>
<li>完成数据结构与算法的系统学习</li>
<li>掌握一门基础的前端页面开发技术</li>
</ul>
<ol start="2">
<li>培养个人艺术情操</li>
</ol>
<ul>
<li>完成3次中远距离出游计划</li>
<li>完成50本书籍阅读 (22年完成49本)</li>
<li>撰写10篇非技术性文章</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>202211</title>
      <link>https://ynikl.github.io/notes/202211/</link>
      <pubDate>Wed, 09 Nov 2022 14:04:07 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/notes/202211/</guid>
      <description>吾本乘兴而行，兴尽而返，何必见戴
&amp;ndash; 世说新语·任诞
我本来是乘着一时高兴而来，现在兴尽就返回家，为什么非得见到戴逵呢？</description>
      <content:encoded><![CDATA[<blockquote>
<p>吾本乘兴而行，兴尽而返，何必见戴<br>
&ndash; 世说新语·任诞</p>
</blockquote>
<p>我本来是乘着一时高兴而来，现在兴尽就返回家，为什么非得见到戴逵呢？</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux 文件系统简单操作流程</title>
      <link>https://ynikl.github.io/blog/linux-filesystem/</link>
      <pubDate>Sat, 05 Nov 2022 13:52:16 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/linux-filesystem/</guid>
      <description>文件系统原理 BIOS：启动主动运行的韧体，会认识第一个可启动的装置 MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序； 启动管理程序(boot loader)：一支可读取核心文件来运行的软件； 相关命令 查看磁盘信息 1 fdisk -l macOS
1 diskutil list 查看磁盘用量
1 df -h 查看文件大小
1 du -h 新磁盘的安装流程 对磁盘进行分割，以创建可用的 partition ； 对该 partition 进行格式化( format )，以创建系统可用的 filesystem； 在 Linux 系统上，需要创建挂载点 ( 亦即是目录 )，并将他挂载上来； 操作磁盘分区, fdisk 后面跟具体的物理磁盘
1 fdisk /dev/hdc 创建一个ext4文件系统
1 mkfs -t ext4 /dev/vdb1 挂载磁盘分区
1 2 mkdir /mnt/hdc6 mount /dev/hdc6 /mnt/hdc6 参考 Linux 磁盘与文件系统管理</description>
      <content:encoded><![CDATA[<h2 id="文件系统原理">文件系统原理</h2>
<ul>
<li>BIOS：启动主动运行的韧体，会认识第一个可启动的装置</li>
<li>MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序；</li>
<li>启动管理程序(boot loader)：一支可读取核心文件来运行的软件；</li>
</ul>
<h2 id="相关命令">相关命令</h2>
<h3 id="查看磁盘信息">查看磁盘信息</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">fdisk -l
</span></span></code></pre></td></tr></table>
</div>
</div><p>macOS</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">diskutil list
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看磁盘用量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">df -h
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看文件大小</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">du -h
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="新磁盘的安装流程">新磁盘的安装流程</h3>
<ol>
<li>对磁盘进行分割，以创建可用的 partition ；</li>
<li>对该 partition 进行格式化( format )，以创建系统可用的 filesystem；</li>
<li>在 Linux 系统上，需要创建挂载点 ( 亦即是目录 )，并将他挂载上来；</li>
</ol>
<p>操作磁盘分区, fdisk 后面跟具体的物理磁盘</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">fdisk /dev/hdc
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建一个ext4文件系统</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mkfs -t ext4 /dev/vdb1
</span></span></code></pre></td></tr></table>
</div>
</div><p>挂载磁盘分区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mkdir /mnt/hdc6
</span></span><span class="line"><span class="cl">mount /dev/hdc6 /mnt/hdc6
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="http://cn.linux.vbird.org/linux_basic/0230filesystem.php#filesys_1">Linux 磁盘与文件系统管理</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang Minimal Version Selection 意识流翻译(仅开头)</title>
      <link>https://ynikl.github.io/blog/golang-minimal-version-selection/</link>
      <pubDate>Tue, 01 Nov 2022 00:15:50 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-minimal-version-selection/</guid>
      <description>原文: Minimal Version Selection
意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.
翻译: Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list). 为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持 编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.
版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:
构建当前的编译列表 升级所有模块到各自对应的最新版本 升级一个模块到对应的版本 降级一个模块到对应的版本 最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进 行升级, 降级, 添加或者移除模块.
这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易 理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖 是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只 用了几行 go 的代码就是实现了.
最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵 守语义化版本: 向前兼容的版本使用小版本号, 不向前兼容的版本使用大版本号.
对应的四种列表操作:
构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份. 升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表 升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入 时如果如果已经存在, 就是仅保存最新的版本 降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标 模块版本之下 这些操作简单, 高效, 且容易实现</description>
      <content:encoded><![CDATA[<p>原文: <a href="https://research.swtch.com/vgo-mvs#low-fidelity_builds">Minimal Version Selection</a></p>
<p>意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.</p>
<h1 id="翻译">翻译:</h1>
<p>Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list).
为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持
编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.</p>
<p>版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:</p>
<ol>
<li>构建当前的编译列表</li>
<li>升级所有模块到各自对应的最新版本</li>
<li>升级一个模块到对应的版本</li>
<li>降级一个模块到对应的版本</li>
</ol>
<p>最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进
行升级, 降级, 添加或者移除模块.</p>
<p>这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易
理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖
是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只
用了几行 go 的代码就是实现了.</p>
<p>最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵
守<a href="https://research.swtch.com/vgo-import">语义化版本</a>: 向前兼容的版本使用小版本号,
不向前兼容的版本使用大版本号.</p>
<p>对应的四种列表操作:</p>
<ol>
<li>构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份.</li>
<li>升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表</li>
<li>升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入
时如果如果已经存在, 就是仅保存最新的版本</li>
<li>降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标
模块版本之下</li>
</ol>
<p>这些操作简单, 高效, 且容易实现</p>
<p><strong>剩余内容 略</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang 解决依赖包版本冲突</title>
      <link>https://ynikl.github.io/blog/golang-find-module-conflict/</link>
      <pubDate>Mon, 31 Oct 2022 08:26:33 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-find-module-conflict/</guid>
      <description>遇到了 grpc 不遵循语义版本, 导致不同版本包之间的冲突.
更新了目标的版本模块之后, 编译一下就发现原先项目引用的 gozero 框架报错了. 搜索一下 相关的关键词,就可以定位到问题是 grpc 搞的鬼.
再找到对应的兼容版本, 升级到对应的版本就可以了.
go 依赖版本选择 [golang 的最小版本选择]https://ynikl.github.io/blog/golang-minimal-version-selection/
大体意思:
会选择当前编译需要依赖包的最高版本(使用语义化版本)
寻找依赖的原因 go mod why
寻找自己项目引用某个包的 最短引用路径, 导致会引用目标包的
1 go mod why google.golang.org/grpc 输出目标包的引用依赖层级
1 2 3 4 5 6 ❯ go mod why google.golang.org/grpc # google.golang.org/grpc hello/world/test git.test.cn/company-open/rpc-pkgs google.golang.org/grpc go mod graph
可以打印出, 模块的依赖图
1 2 3 4 5 6 example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example.</description>
      <content:encoded><![CDATA[<p>遇到了 grpc 不遵循语义版本, 导致<a href="https://github.com/weaveworks/common/issues/239">不同版本包之间的冲突</a>.</p>
<p>更新了目标的版本模块之后, 编译一下就发现原先项目引用的 gozero 框架报错了. 搜索一下
相关的关键词,就可以定位到问题是 grpc 搞的鬼.</p>
<p>再找到对应的兼容版本, 升级到对应的版本就可以了.</p>
<h2 id="go-依赖版本选择">go 依赖版本选择</h2>
<p>[golang 的最小版本选择]https://ynikl.github.io/blog/golang-minimal-version-selection/</p>
<p>大体意思:</p>
<p>会选择当前编译需要依赖包的最高版本(使用语义化版本)</p>
<h2 id="寻找依赖的原因">寻找依赖的原因</h2>
<p><a href="https://go.dev/ref/mod#go-mod-why">go mod why</a></p>
<p>寻找自己项目引用某个包的 <strong>最短引用路径</strong>, 导致会引用目标包的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod why google.golang.org/grpc
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出目标包的引用依赖层级</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">❯ go mod why google.golang.org/grpc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># google.golang.org/grpc
</span></span><span class="line"><span class="cl">hello/world/test
</span></span><span class="line"><span class="cl">git.test.cn/company-open/rpc-pkgs
</span></span><span class="line"><span class="cl">google.golang.org/grpc
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://go.dev/ref/mod#go-mod-graph">go mod graph</a></p>
<p>可以打印出, 模块的依赖图</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">example.com/main example.com/a@v1.1.0
</span></span><span class="line"><span class="cl">example.com/main example.com/b@v1.2.0
</span></span><span class="line"><span class="cl">example.com/a@v1.1.0 example.com/b@v1.1.1
</span></span><span class="line"><span class="cl">example.com/a@v1.1.0 example.com/c@v1.3.0
</span></span><span class="line"><span class="cl">example.com/b@v1.1.0 example.com/c@v1.1.0
</span></span><span class="line"><span class="cl">example.com/b@v1.2.0 example.com/c@v1.2.0
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    
    <item>
      <title>Python 基本语法快速学习</title>
      <link>https://ynikl.github.io/blog/python-basic-quick/</link>
      <pubDate>Sun, 09 Oct 2022 17:34:39 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/python-basic-quick/</guid>
      <description>学习路径 数据结构 流程控制 代码组织 工程化 数据结构 strings int list tuple dictionary 如何查看一个基本的类型对象拥有的方法
1 2 3 name = &amp;#34;ada&amp;#34; dir(name) dir 获取对象的属性
字符串 1 name = &amp;#34;ada lovelace&amp;#34; 拼接, 用+
1 2 3 first_name = &amp;#34;ada&amp;#34; last_name = &amp;#34;lovelace&amp;#34; full_name = first_name + &amp;#34; &amp;#34; + last_name 声明字符串中 &#39;单引号和&amp;quot; 双引号没有区别, 可以用来相互替换 多行字串使用&#39;&#39;&#39;连续三个单引号或双引号声明 字符串格式化
format
1 2 3 &amp;gt;&amp;gt;&amp;gt; &amp;#39;Hey {name}, there is a 0x{errno:x} error!&amp;#39;.format( ... name=name, errno=errno) &amp;#39;Hey Bob, there is a 0xbadc0ffee error!</description>
      <content:encoded><![CDATA[<h2 id="学习路径">学习路径</h2>
<ul>
<li>数据结构</li>
<li>流程控制</li>
<li>代码组织</li>
<li>工程化</li>
</ul>
<h2 id="数据结构">数据结构</h2>
<ul>
<li>strings</li>
<li>int</li>
<li>list</li>
<li>tuple</li>
<li>dictionary</li>
</ul>
<p>如何查看一个基本的类型对象拥有的方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">name = &#34;ada&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">dir(name)
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>dir</code> 获取对象的属性</p>
<h3 id="字符串">字符串</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">name = &#34;ada lovelace&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>拼接, 用<code>+</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">first_name = &#34;ada&#34;
</span></span><span class="line"><span class="cl">last_name = &#34;lovelace&#34;
</span></span><span class="line"><span class="cl">full_name = first_name + &#34; &#34; + last_name
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>声明字符串中 <code>'</code>单引号和<code>&quot;</code> 双引号没有区别, 可以用来相互替换</li>
<li>多行字串使用<code>'''</code>连续三个单引号或双引号声明</li>
</ul>
<p>字符串格式化</p>
<p>format</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt;&gt;&gt; &#39;Hey {name}, there is a 0x{errno:x} error!&#39;.format(
</span></span><span class="line"><span class="cl">...     name=name, errno=errno)
</span></span><span class="line"><span class="cl">&#39;Hey Bob, there is a 0xbadc0ffee error!&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>&lsquo;f&rsquo;string 模版</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt;&gt;&gt; f&#39;Hello, {name}!&#39;
</span></span><span class="line"><span class="cl">&#39;Hello, Bob!&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="数字">数字</h3>
<ul>
<li>整数 : 不带小数点</li>
<li>浮点数 : 带小数点, 存在精度问题</li>
</ul>
<p>操作符</p>
<ul>
<li><code>+ - * \ %</code></li>
</ul>
<p>与字符串的转换:</p>
<ul>
<li><code>str()</code> 数字转化成字符串</li>
<li><code>int()</code> 字符串转化成整数</li>
<li><code>float()</code> 字符串转化成浮点数</li>
</ul>
<h3 id="逻辑">逻辑</h3>
<p>布尔值</p>
<ul>
<li>True</li>
<li>False</li>
</ul>
<p>与或非</p>
<ul>
<li>and</li>
<li>or</li>
<li>not</li>
</ul>
<p>比较</p>
<ul>
<li>==</li>
<li>!=</li>
<li>&lt;=</li>
<li>
<blockquote>
<p>=</p>
</blockquote>
</li>
<li>&lt;</li>
<li>
<blockquote>
</blockquote>
</li>
</ul>
<p>转化</p>
<ul>
<li><code>bool(1)</code> // True</li>
<li><code>bool(&quot;&quot;)</code> // False</li>
</ul>
<h3 id="列表">列表</h3>
<h4 id="创建">创建</h4>
<p>声明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">people</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;alice&#39;</span><span class="p">,</span> <span class="s1">&#39;fred&#39;</span><span class="p">,</span> <span class="s1">&#39;ian&#39;</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>range</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for i in range(1, 5):
</span></span><span class="line"><span class="cl">	print(i)
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">// 直接创建一个数组
</span></span><span class="line"><span class="cl">intList = list(range(1, 5)
</span></span></code></pre></td></tr></table>
</div>
</div><p>列表解析</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">squares = [ value * 2 for value in range(1, 11)]
</span></span></code></pre></td></tr></table>
</div>
</div><p>切片</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">newPeoples = people[:3]
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="操作">操作</h4>
<p>遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">person</span> <span class="ow">in</span> <span class="n">people</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nb">print</span><span class="p">(</span><span class="n">person</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="元组">元组</h3>
<p>创建</p>
<p>使用小括号创建, 创建之后内部值无法修改</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">aTuple = (1, 3, 5)
</span></span></code></pre></td></tr></table>
</div>
</div><p>遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for a in aTuple:
</span></span><span class="line"><span class="cl">	print(a)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="字典">字典</h3>
<p>声明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">peopleCity = { &#34;ian&#34;:&#34;xiamen&#34;, &#34;jinx&#34;:&#34;beijing&#34;}
</span></span></code></pre></td></tr></table>
</div>
</div><p>取值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">print(peopleCity[&#34;ian&#34;])
</span></span></code></pre></td></tr></table>
</div>
</div><p>存在修改, 不存在添加</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">peopleCity[&#34;newguy&#34;] = &#34;newcity&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>删除</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">del peopleCity[&#34;ian&#34;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for person, city in peopleCity.items():
</span></span><span class="line"><span class="cl">	print(person)
</span></span><span class="line"><span class="cl">	print(city)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="流程控制">流程控制</h2>
<h3 id="if">if</h3>
<p>if&hellip;else&hellip;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if True :
</span></span><span class="line"><span class="cl">	print(&#34;&#34;)
</span></span><span class="line"><span class="cl">elif True:
</span></span><span class="line"><span class="cl">	print(&#34;if if &#34;)
</span></span><span class="line"><span class="cl">else:
</span></span><span class="line"><span class="cl">	print(&#34;&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>判断是否在列表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if person in people: 
</span></span></code></pre></td></tr></table>
</div>
</div><p>判断列表是否为空</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if people :
</span></span><span class="line"><span class="cl">	print(&#34;not empty&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>以下略:</p>
<ul>
<li>while</li>
<li>break</li>
<li>continue</li>
</ul>
<h2 id="代码组织">代码组织</h2>
<h3 id="函数">函数</h3>
<h4 id="定义">定义</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def func_name():
</span></span><span class="line"><span class="cl">	print(&#34;function bdoy&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="普通形参">普通形参</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def greating(name, words):
</span></span><span class="line"><span class="cl">	...
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="关键字参数">关键字参数</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">greating(naem=&#39;ian&#39;, words=&#39;hello&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="默认值">默认值</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def greating(name, words=&#39;hello&#39;):
</span></span><span class="line"><span class="cl">	...
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="返回值">返回值</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def getMeFive():
</span></span><span class="line"><span class="cl">	return 5
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="可变参数">可变参数</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def make_pizza(*toppings):
</span></span><span class="line"><span class="cl">	...
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>*</code>表示可变参数, 内部生成一个元组传递到函数内部</p>
<h3 id="模块">模块</h3>
<p>模块为文件, 使用<code>import</code>导入模块, 假设有<code>hello.py</code>文件, 里有<code>greating</code>函数</p>
<h4 id="导入模块">导入模块</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import hello
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">hello.greating()
</span></span></code></pre></td></tr></table>
</div>
</div><p>不用写前缀</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from hello import *
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="导入函数">导入函数</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from hello import greating
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">greating()
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="别名">别名</h3>
<p>函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from hello import greating as gt
</span></span></code></pre></td></tr></table>
</div>
</div><p>模块</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import hello as ho
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="类">类</h3>
<p>面向对象</p>
<h4 id="声明">声明</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Dog():
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def __init__(self, name, age):
</span></span><span class="line"><span class="cl">		&#34;&#34;&#34;初始化属性name和age&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">		self.name = name
</span></span><span class="line"><span class="cl">		self.age = age 6
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">def sit(self):
</span></span><span class="line"><span class="cl">	&#34;&#34;&#34;模拟小狗被命令时蹲下&#34;&#34;&#34; 
</span></span><span class="line"><span class="cl">	print(self.name.title() + &#34; is now sitting.&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化函数 <code>__init___</code></p>
<p>指向自身引用 <code>self</code></p>
<h4 id="实例化">实例化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">my_dog = Dog(&#34;kiki&#34;, 3)
</span></span><span class="line"><span class="cl">my_dog.site()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 访问属性
</span></span><span class="line"><span class="cl">print(my_dog.name)
</span></span></code></pre></td></tr></table>
</div>
</div><p>访问不存在的属性, 会出错</p>
<h4 id="继承">继承</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Car():
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	def __init__(self):
</span></span></code></pre></td></tr></table>
</div>
</div><p>继承</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class ElectricCar(Car):
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	def __init__(self):
</span></span><span class="line"><span class="cl">		super().init()
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="从模块导入">从模块导入</h4>
<p>与导入方法一致</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from dog import Dog
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="工程化">工程化</h2>
<h3 id="文件">文件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">wiht open(filename) as file_obj:
</span></span></code></pre></td></tr></table>
</div>
</div><p>json 转存和加载</p>
<ul>
<li>json.dump</li>
<li>json.load</li>
</ul>
<h3 id="异常">异常</h3>
<p>捕获异常</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">try:
</span></span><span class="line"><span class="cl">	print(5/0)
</span></span><span class="line"><span class="cl">except ZeroDivisionError:
</span></span><span class="line"><span class="cl">	pass
</span></span><span class="line"><span class="cl">else:
</span></span><span class="line"><span class="cl">	...
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="单元测试">单元测试</h3>
<p>继承 <code>unittest</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ipmort unittest
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">calss NameTestCase(unittest.TestCase):
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	def test_func_name(self):
</span></span><span class="line"><span class="cl">		// self.assertEqual()
</span></span><span class="line"><span class="cl">		...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">unittest.main()
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    
    <item>
      <title>乐观锁和悲观锁</title>
      <link>https://ynikl.github.io/blog/cs-optimitic-concurrency-control/</link>
      <pubDate>Sun, 02 Oct 2022 14:05:43 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/cs-optimitic-concurrency-control/</guid>
      <description>乐观锁和悲观锁 首先, 乐观锁和悲观锁和本身并不是一种具体锁.
而是一种编程的并发控制思想. 原名应该叫做乐观并发控制(Optimistic concurrency control) 简称 OCC 和 悲观并发控制(Pessimistic Concurrency Control) 简称 PCC
什么是锁 维基百科对锁的定义
In computer science, a lock or mutex (from mutual exclusion) is a synchronization primitive: a mechanism that enforces limits on access to a resource when there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy, and with a variety of possible methods there exists multiple unique implementations for different applications.</description>
      <content:encoded><![CDATA[<h1 id="乐观锁和悲观锁">乐观锁和悲观锁</h1>
<p>首先, 乐观锁和悲观锁和本身并不是一种具体锁.</p>
<p>而是一种编程的并发控制思想.
原名应该叫做乐观并发控制(Optimistic concurrency control) 简称 OCC 和
悲观并发控制(Pessimistic Concurrency Control) 简称 PCC</p>
<h2 id="什么是锁">什么是锁</h2>
<p><a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">维基百科对锁的定义</a></p>
<blockquote>
<p>In computer science, a lock or mutex (from mutual exclusion) is a synchronization primitive: a mechanism that enforces limits on access to a resource when there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy, and with a variety of possible methods there exists multiple unique implementations for different applications.</p>
</blockquote>
<p>简单表述一下: 锁是一个同步原语, 是一种控制访问资源的线程的手段</p>
<h2 id="乐观锁">乐观锁</h2>
<p>乐观锁是对于要锁定的的访问资源或变量, 持有乐观的态度 &ndash; 即在自己访问该变量的时候,
不会有其他线程来访问该变量.</p>
<p>主要思想是在写入数据的时候, 对比一下, 当前变量的值是不是与自己取出来的时候是一致,
如果一致即表示着 <strong>数据没有被其他线程修改过</strong></p>
<p>有两种具体的策略</p>
<ul>
<li>版本号</li>
<li>CAS</li>
</ul>
<h3 id="版本号">版本号</h3>
<p>在每一次对加锁数据进行修改时候的, 对版本号进行增加操作. 当回写的数据时候判断版本号
是否一致.</p>
<p>如果保持一致, 才会继续进行操作.</p>
<h3 id="cas">CAS</h3>
<p>利用CPU硬件层面支持 &ndash; 比较和写入两步为原子性. 直接对当前值进行判断, 是与取出的数
据一致. 一致才继续进行操作.</p>
<p>利用CAS, 自增完成数字自增的<a href="https://en.wikipedia.org/wiki/Compare-and-swap#Example%20application:%20atomic%20adder">伪代码</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">function add(p: pointer to int, a: int) returns int
</span></span><span class="line"><span class="cl">    done ← false
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while not done
</span></span><span class="line"><span class="cl">        value ← *p  // Even this operation doesn&#39;t need to be atomic.
</span></span><span class="line"><span class="cl">        done ← cas(p, value, value + a)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return value + a
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果一直失败的话, cpu就会保持自旋 &ndash; 对cpu算力消耗较大, 直至成功.</p>
<h3 id="aba-问题">ABA 问题</h3>
<p>在乐观锁中, 如果值没有变化, 它的背后含义代表该值没有对其他线程修改过.</p>
<p>但是存在着这种情况.</p>
<ol>
<li>线程1, 取值 A</li>
<li>线程2, 取值 A</li>
<li>线程2, 修改 B 值 &ndash; 成功</li>
<li>线程2, 取值 B, 再修改成 A &ndash; 成功</li>
<li>线程1, 对比 A值, 一致</li>
</ol>
<p>修改的对象值已经被其他对象修改过, 但又被修改成旧的值. 对于 ABA 问题有没有危害,要
看具体的业务场景</p>
<p>如果使用版本号, 每一次修改值, 都增加版本号, 就可以避免该问题.</p>
<h2 id="悲观锁">悲观锁</h2>
<p>悲观锁, 认为自己取值之后, 一定会有其他线程过来修改自己取值的对象.
采取保守策略 &ndash; 直接对该数据进行锁定.</p>
<p>按对数据的锁定类型, 可以分成两种锁:</p>
<ul>
<li>互斥锁</li>
<li>读写锁</li>
</ul>
<h3 id="互斥锁">互斥锁</h3>
<p>对数据锁定期间, 不允许其他线程的访问 &ndash; 读取也不允许. 其他线程只能等待当前的线程
执行完毕</p>
<p>常见的即是各种语言自带的互斥锁.</p>
<h3 id="读写锁">读写锁</h3>
<p>数据锁定期间, 其他线程可以读取数据, 但是不能写入数据.</p>
<p>常见的也是各种语言的读写锁.</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000016611415">乐观锁、悲观锁，这一篇就够了！</a></li>
<li><a href="https://en.wikipedia.org/wiki/ABA_problem">ABA问题</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">锁的定义</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>高效程序员的45个习惯</title>
      <link>https://ynikl.github.io/books/practices_of_an_agile_developer/</link>
      <pubDate>Fri, 30 Sep 2022 13:41:00 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/practices_of_an_agile_developer/</guid>
      <description>我的总结 对于功能, 业务, 代码逻辑, 不要只停留在表面, 要进一步地去思考为什么 保持开放的心态, 尊重他人的意见, 勇于承认自己的&amp;quot;不知道&amp;quot;. 去思考他人为什么这么想 保持学习, 拥抱变化 有时间观念, 把控项目进度. 控制有规律的开发节奏, 不要让自己经常加班. 每天下班都能完成一天的任务. 让真正的软件用户做决策, 保持定期沟通, 让用户一直确认自己想要的东西 让工具替代人力, 实现自动化 控制代码质量, 简单, 清晰, 内聚 团队内部保持沟通 &amp;ndash; 站会, 及时反映变化. 遇到问题及时求救, 保持向上反馈. 不要辜负人家的预期 深入思考, 保持开发, 拥抱变化, 保持沟通, 注重质量, 保持学习, 自动化.
书本原文 深度思考问题
“拙劣的代码工人会这样不假思索地改完代码，然后快速转向下一个问题。 优秀的程序员会挖掘更深一层，尽力去理解为什么这里必须要加1，更重要的是，他会想明白会产生什么其他影响。”
“在一本流行的管理图书《第五项修炼》中，作者建议，在理解一个问题的时候，需要渐次地问5个以上的“为什么”。这听起来就像退回到了4岁，那时对一切都充满着好奇。它是很好的方式，进一步挖掘简单直白的答案，通过这个路线，设想就会更加接近事实真相。”
当你问“为什么”的时候，也许你会被反问：“为什么你问这个问题？”在提问之前，想好你提问的理由，这会有助于你问出恰当的问题。
保持开发, 承认自己的不知道
“这个，我不知道”是一个好的起点，应该由此进行更进一步的调查，而不应在此戛然结束。”
“如果你对答案不满意，那么看看你是否可以改变问题。”
“作为第1步的理解代码，往往是最难的。如果别人给你的代码很容易理解，接下来的工作就省心多了”
尊重他人的意见
“孤立非常危险，不要让开发人员完全孤立地编写代码（见第155页，习惯40）。如果团队成员花些时间阅读其他同事写的代码，他们就能确保代码是可读和可理解的，并且不会随意加入这些“+1或-1”的代码。阅读代码的频率越高越好。实行代码复审 ，不仅有助于代码更好理解，而且是发现bug最有效的方法之一。”
“用Les Brown的一句话说就是：“你不需要很出色才能起步，但是你必须起步才能变得很出色。”
“如果你是一个有远见的人，就一定要特别尊重别人的意见。你是一个掌舵者，一定要把握方向，深思熟虑，吸取各方的意见。”
保持学习
“谁会帮助你保持步伐前进呢？在一个企业化的社会中，只有一个人会为你负责——你自己。是否能跟上变化，完全取决于你自己”
“跟踪技术变化 。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯”
拥抱变化, 交付用户想要的软件
“敏捷的根本之一就是拥抱变化。既然变化是永恒的，你有可能一直使用相同的技术和工具吗？”
“真正的敌人是变化。软件开发如战争，形势的变化快速而又剧烈。固守昨天的计划而无视环境的变化会带来灾难。”
“不要在前期做大量的设计”并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事”
时间观念
“许多的敏捷技巧来源于时间盒——设定一个短时的期限，为任务设定不能延长的最终期限。你可以选择放弃其他方面的任务，但是最终期限是不变的。你可能不知道完成所有的任务需要多少个时间盒，但每个时间盒必须是短期的、有限的，并且要完成具体的目标”
“如果在你工作的时候没有一个固定的最终期限（例如一天的结束），就应该好好想想了。它会让你的工作有一个节奏，在每天下班的时候，提交所有的工作，开心地收工。这样，明天就能开始新的内容，解决下一系列难题”
“有人说，上帝发明了时间，就是为了防止所有事情同时发生。因此我们需要更具远见，保持不同的开发节奏，这样敏捷项目的所有事情就不会突然同时发生，也不会随机发生，时间也不会不可预知。”</description>
      <content:encoded><![CDATA[<h2 id="我的总结">我的总结</h2>
<ul>
<li>对于功能, 业务, 代码逻辑, 不要只停留在表面, 要进一步地去思考为什么</li>
<li>保持开放的心态, 尊重他人的意见, 勇于承认自己的&quot;不知道&quot;. 去思考他人为什么这么想</li>
<li>保持学习, 拥抱变化</li>
<li>有时间观念, 把控项目进度. 控制有规律的开发节奏, 不要让自己经常加班. 每天下班都能完成一天的任务.</li>
<li>让真正的软件用户做决策, 保持定期沟通, 让用户一直确认自己想要的东西</li>
<li>让工具替代人力, 实现自动化</li>
<li>控制代码质量, 简单, 清晰, 内聚</li>
<li>团队内部保持沟通 &ndash; 站会, 及时反映变化. 遇到问题及时求救, 保持向上反馈. 不要辜负人家的预期</li>
</ul>
<p>深入思考, 保持开发, 拥抱变化, 保持沟通, 注重质量, 保持学习, 自动化.</p>
<h2 id="书本原文">书本原文</h2>
<p>深度思考问题</p>
<blockquote>
<p>“拙劣的代码工人会这样不假思索地改完代码，然后快速转向下一个问题。
优秀的程序员会挖掘更深一层，尽力去理解为什么这里必须要加1，更重要的是，他会想明白会产生什么其他影响。”</p>
</blockquote>
<blockquote>
<p>“在一本流行的管理图书《第五项修炼》中，作者建议，在理解一个问题的时候，需要渐次地问5个以上的“为什么”。这听起来就像退回到了4岁，那时对一切都充满着好奇。它是很好的方式，进一步挖掘简单直白的答案，通过这个路线，设想就会更加接近事实真相。”</p>
</blockquote>
<blockquote>
<p>当你问“为什么”的时候，也许你会被反问：“为什么你问这个问题？”在提问之前，想好你提问的理由，这会有助于你问出恰当的问题。</p>
</blockquote>
<p>保持开发, 承认自己的不知道</p>
<blockquote>
<p>“这个，我不知道”是一个好的起点，应该由此进行更进一步的调查，而不应在此戛然结束。”</p>
</blockquote>
<blockquote>
<p>“如果你对答案不满意，那么看看你是否可以改变问题。”</p>
</blockquote>
<blockquote>
<p>“作为第1步的理解代码，往往是最难的。如果别人给你的代码很容易理解，接下来的工作就省心多了”</p>
</blockquote>
<p>尊重他人的意见</p>
<blockquote>
<p>“孤立非常危险，不要让开发人员完全孤立地编写代码（见第155页，习惯40）。如果团队成员花些时间阅读其他同事写的代码，他们就能确保代码是可读和可理解的，并且不会随意加入这些“+1或-1”的代码。阅读代码的频率越高越好。实行代码复审 ，不仅有助于代码更好理解，而且是发现bug最有效的方法之一。”</p>
</blockquote>
<blockquote>
<p>“用Les Brown的一句话说就是：“你不需要很出色才能起步，但是你必须起步才能变得很出色。”</p>
</blockquote>
<blockquote>
<p>“如果你是一个有远见的人，就一定要特别尊重别人的意见。你是一个掌舵者，一定要把握方向，深思熟虑，吸取各方的意见。”</p>
</blockquote>
<p>保持学习</p>
<blockquote>
<p>“谁会帮助你保持步伐前进呢？在一个企业化的社会中，只有一个人会为你负责——你自己。是否能跟上变化，完全取决于你自己”</p>
</blockquote>
<blockquote>
<p>“跟踪技术变化
。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯”</p>
</blockquote>
<p>拥抱变化, 交付用户想要的软件</p>
<blockquote>
<p>“敏捷的根本之一就是拥抱变化。既然变化是永恒的，你有可能一直使用相同的技术和工具吗？”</p>
</blockquote>
<blockquote>
<p>“真正的敌人是变化。软件开发如战争，形势的变化快速而又剧烈。固守昨天的计划而无视环境的变化会带来灾难。”</p>
</blockquote>
<blockquote>
<p>“不要在前期做大量的设计”并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事”</p>
</blockquote>
<p>时间观念</p>
<blockquote>
<p>“许多的敏捷技巧来源于时间盒——设定一个短时的期限，为任务设定不能延长的最终期限。你可以选择放弃其他方面的任务，但是最终期限是不变的。你可能不知道完成所有的任务需要多少个时间盒，但每个时间盒必须是短期的、有限的，并且要完成具体的目标”</p>
</blockquote>
<blockquote>
<p>“如果在你工作的时候没有一个固定的最终期限（例如一天的结束），就应该好好想想了。它会让你的工作有一个节奏，在每天下班的时候，提交所有的工作，开心地收工。这样，明天就能开始新的内容，解决下一系列难题”</p>
</blockquote>
<blockquote>
<p>“有人说，上帝发明了时间，就是为了防止所有事情同时发生。因此我们需要更具远见，保持不同的开发节奏，这样敏捷项目的所有事情就不会突然同时发生，也不会随机发生，时间也不会不可预知。”</p>
</blockquote>
<p>让真正的用户做决策</p>
<blockquote>
<p>“记录客户做出的决定，并注明原因。好记性不如烂笔头”</p>
</blockquote>
<blockquote>
<p>“不要随意假设低级别的问题不会影响他们的业务。如果能影响他们的业务，就是有价值的问题。”</p>
</blockquote>
<blockquote>
<p>“因而，你只有一个选择：要么现在就让用户做决定，要么现在就开始开发，迟些让用户决定，不过要付出较高的成本。如果你在开发阶段回避这些问题，就增加了风险，但是你要能越早解决这些问题，就越有可能避免繁重的重新设计和编码。甚至在接近项目最终期限的时候，也能避免与日俱增的时间压力。”</p>
</blockquote>
<blockquote>
<p>“开发者（及项目经理）能做的一个最重要的决定就是：判断哪些是自己决定不了的，应该让企业主做决定。你不需要自己给业务上的关键问题做决定。毕竟，那不是你的事情。如果遇到了一个问题，会影响到系统的行为或者如何使用系统，把这个问题告诉业务负责人”</p>
</blockquote>
<blockquote>
<p>“没有人的思想和观点可以及时冻结，特别是项目的客户。就算是他们已经告诉你想要的东西了，他们的期望和想法还是在不停地进化——特别是当他们在使用新系统的部分功能时，他们才开始意识到它的影响和可能发生的问题。这就是人的本性。”</p>
</blockquote>
<blockquote>
<p>“你生产出了他们曾经要求过的软件，但却不是他们现在真正想要的。那最后的结果就是：惊讶、震惊和失望，而不是满意。
”</p>
</blockquote>
<p>分析技术的利弊</p>
<blockquote>
<p>“每一门技术都会有优点和缺点，无论它是开源的还是商业产品、框架、工具或者语言，一定要清楚它的利弊。”</p>
</blockquote>
<p>控制迭代</p>
<blockquote>
<p>“迭代开发是，在小且重复的周期里，你完成各种开发任务：分析、设计、实现、测试和获得反馈，所以叫作迭代”</p>
</blockquote>
<blockquote>
<p>“每个工作日，每个团队成员会重新评估完成一个任务还需要多少小时。不管怎么样，只要所有任务的评估总和超过了一个迭代剩余的时间，那么任务就必须移到下一个迭代中开发”</p>
</blockquote>
<p>单元测试, 控制代码质量</p>
<blockquote>
<p>“单元测试能及时提供反馈 。你的代码会重复得到锻炼。但若修改或者重写了代码，测试用例就会检查你是否破坏了已有的功能。你可以快速得到反馈，并很容易地修复它们。</p>
</blockquote>
<blockquote>
<p>单元测试让你的代码更加健壮
。测试帮助你全面思考代码的行为，帮你练习正面、反面以及异常情况。</p>
</blockquote>
<blockquote>
<p>单元测试是有用的设计工具
。正如我们在实践20中谈论到的，单元测试有助于实现简单的、注重实效的设计。</p>
</blockquote>
<blockquote>
<p>单元测试是让你自信的后台
。你测试代码，了解它在各种不同条件下的行为。这会让你在面对新的任务、时间紧迫的巨大压力之下，找到自信。</p>
</blockquote>
<blockquote>
<p>单元测试是解决问题时的探测器
。单元测试就像是测试印制电路板的示波镜。当问题出现的时候，你可以快速地给代码发送一个脉冲信号。这为你提供[…]”</p>
</blockquote>
<blockquote>
<p>“如果不是真正需要它的时候，你就不应该实现这个功能。基于这一点，现在还没有足够的理由表示你需要Player
这个类”</p>
</blockquote>
<blockquote>
<p>“开发人员在完成任务时，可能会难以抵挡诱惑为节省时间而走“捷径”。然而，这些“捷径”往往只会推迟问题的爆发时间，而不是把它彻底解决掉”</p>
</blockquote>
<blockquote>
<p>“项目是以增量式方式进行开发的，写程序时也应该进行增量式编程</p>
</blockquote>
<blockquote>
<p>“源代码可以被读懂，不是因为其中的注释，而应该是由于它本身优雅而清晰——变量名运用正确、空格使用得当、逻辑分离清晰，以及表达式非常简洁。”</p>
</blockquote>
<blockquote>
<p>“这时要扪心自问，是不是真的需要用它，以及它将如何帮你解决眼前的问题。问问自己，是不是特定的问题强迫你使用这个解决方案。不要让自己被迫进行过分设计，也不要将代码过分复杂化。”</p>
</blockquote>
<blockquote>
<p>“内聚性用来评估一个组件（包、模块或配件）中成员的功能相关性。内聚程度高，表明各个成员共同完成了一个功能特性或是一组功能特性”</p>
</blockquote>
<p>成为自己产品的用户</p>
<blockquote>
<p>“很多成功的公司都是靠着“吃自己的狗食”活着。也就是说，如果要让你的产品尽可能地好，自己先要积极地使用它。”</p>
</blockquote>
<p>度量项目进度</p>
<blockquote>
<p>“所以，我们不应该去计算工作量完成的百分比，而应该测定还剩下多少工作量没有完成。如果你最初估计这个任务需要40个小时，在开发了35个小时之后，你认为还需要另外30个小时的工作。那就得到了很重要的度量结果（这里诚实非常重要，隐瞒真相毫无意义）。”</p>
</blockquote>
<blockquote>
<p>“奇怪的是，它花费的时间很可能要比最初估计时间长。没有关系，我们希望这能作为下一次的参考。在为下一个任务估计工作量时，可以根据这次经验调整评估。如果你低估了一个任务，评估是2天，它最后花费了6天，那么系数就是3。除非是异常情况，否则你应该对下次估计乘以系数3。你的评估会波动一段时间，有时候过低估计，有时候过高估计。但随着时间的推移，你的评估会与事实接近，你也会对任务所花费的时间有更清楚的认识。”</p>
</blockquote>
<p>团队合作</p>
<blockquote>
<p>“既然整个团队都是项目工作的一部分，我们希望实行代码集体所有制
（见第155页），以保证任何团队成员的缺席不会对项目造成影响”</p>
</blockquote>
<blockquote>
<p>“对于初学者来说，准备好后再共享代码才是有礼貌的做法（见第162页），这样才不会用未完成的工作来给团队成员造成麻烦。当准备好之后，我们应该与其他团队成员一起做代码复查</p>
</blockquote>
<blockquote>
<p>“坐着开的会议通常会持续更久，大部分人不喜欢站着进行长时间的谈话。”</p>
</blockquote>
<blockquote>
<p>“通常，立会都是在每个工作日的早些时候，且大家都在上班时举行。但是不要把它安排为上班后的第一件事。要让大家有机会从刚才混乱的交通状况中恢复状态，喝点咖啡，删除一些垃圾邮件什么的。要保证会议结束后有足够的时间，让大家在午餐之前做不少工作，同时也不要开始得过早，让每个人都巴不得赶紧结束会议，去喝点东西。一般来说，在大家到公司之后的半个小时到一个小时之内举行，是个不错的选择。”</p>
</blockquote>
<blockquote>
<p>“如果觉得立会是在浪费时间，那可能是大家还没有形成真正的团队意识。这并不是坏事，有利于针对问题进行改进。”</p>
</blockquote>
<blockquote>
<p>“当多人同时开发时，代码会被频繁地检查、重构以及维护。如果需要修复bug，任何一名开发人员都可以完成这项工作。同时有两个或两个以上的人，可以处理应用中不同部分的代码，可以让项目的日程安排也变得更为容易。”</p>
</blockquote>
<blockquote>
<p>“另一方面，知道别人将会接过自己的代码，就意味着自己要更守规矩。当知道别人在注意时，一定会更加小心。”</p>
</blockquote>
<p>费曼学习法</p>
<blockquote>
<p>“通过详细解释自己知道的东西，可以使自己的理解更深入。当别人提出问题时，也可以发现不同的角度。也许可以发现一些新技巧——听到一个声音这样告诉自己：“我以前还没有这样思考过这个问题”</p>
</blockquote>
<blockquote>
<p>“为团队成员在寻求帮助之前陷入某个问题的时间设定一个时限，一个小时应该是不错的选择”</p>
</blockquote>
<blockquote>
<p>“如果有人还是没有任何线索，那就给更多提示吧（或者甚至是答案）。如果有人提出来某些想法，不妨帮他们分析每种想法的优劣之处。如果有人给出的答案或解决方法更好，那就从中汲取经验，然后分享你的体会吧。这对双方来说都是极佳的学习经验。”</p>
</blockquote>
<blockquote>
<p>“用问题来回答问题，可以引导提问的人走上正确的道路。</p>
</blockquote>
<blockquote>
<p>如果有人真的陷入胶着状态，就不要折磨他们了。告诉他们答案，再解释为什么是这样。”</p>
</blockquote>
<blockquote>
<p>“同样的功能，不同开发人员的代码实现可能不同。差异并不意味着不好。除非你可以让某段代码明确变得更好，否则不要随意批评别人的代码。”</p>
</blockquote>
<p>及时向上反馈</p>
<blockquote>
<p>“及时通报进展与问题，有情况发生时，就不会让别人感到突然，而且他们也很愿意了解目前的进展状况。他们会知道何时应提供帮助，而且你也获得了他们的信任”</p>
</blockquote>
<blockquote>
<p>“接受一个任务，也就意味着做出了要准时交付的承诺”</p>
</blockquote>
<p>慢慢来</p>
<blockquote>
<p>“有句老话说得好：“你可以把马带到水边……但是你不能强迫它使用你最钟爱的代码编辑器。”
You can lead a horse to water, but you can make him drink.</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go  errgroup 的基本用法</title>
      <link>https://ynikl.github.io/blog/golang-errgroup/</link>
      <pubDate>Mon, 19 Sep 2022 09:19:31 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-errgroup/</guid>
      <description>实现并发控制 在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 channel 进行传入和传出.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { concurrencyNum := 10 limitCh := make(chan bool, concurrencyNum) wg := new(sync.WaitGroup) for i := 0; i &amp;lt; 100; i++ { limitCh &amp;lt;- true wg.Add(1) go func() { defer func() { &amp;lt;-limitCh wg.Done() }() time.Sleep(1 * time.Second) fmt.</description>
      <content:encoded><![CDATA[<h2 id="实现并发控制">实现并发控制</h2>
<p>在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 <code>channel</code>
进行传入和传出.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">concurrencyNum</span> <span class="o">:=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">limitCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">concurrencyNum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">limitCh</span> <span class="o">&lt;-</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="o">&lt;-</span><span class="nx">limitCh</span>
</span></span><span class="line"><span class="cl">				<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;do some things...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ok&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果如果中间运行代码有可能存在错误, 捕获错误. 有两种方法:</p>
<ul>
<li>声明一个 err channel 用于承接错误</li>
<li>声明一个外部 err 变量, 并通过互斥锁进行保护</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func main() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	concurrencyNum := 10
</span></span><span class="line"><span class="cl">	limitCh := make(chan bool, concurrencyNum)
</span></span><span class="line"><span class="cl">	errCh := make(chan error, concurrencyNum)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	var externalErr error
</span></span><span class="line"><span class="cl">	wg := new(sync.WaitGroup)
</span></span><span class="line"><span class="cl">	func() {
</span></span><span class="line"><span class="cl">		for i := 0; i &lt; 100; i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			select {
</span></span><span class="line"><span class="cl">			case err := &lt;-errCh:
</span></span><span class="line"><span class="cl">				externalErr = err
</span></span><span class="line"><span class="cl">				return
</span></span><span class="line"><span class="cl">			default:
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			wg.Add(1)
</span></span><span class="line"><span class="cl">			limitCh &lt;- true
</span></span><span class="line"><span class="cl">			go func() {
</span></span><span class="line"><span class="cl">				defer func() {
</span></span><span class="line"><span class="cl">					&lt;-limitCh
</span></span><span class="line"><span class="cl">					wg.Done()
</span></span><span class="line"><span class="cl">				}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				time.Sleep(1 * time.Second)
</span></span><span class="line"><span class="cl">				fmt.Println(&#34;do some things...&#34;)
</span></span><span class="line"><span class="cl">				if rand.Intn(5) == 1 {
</span></span><span class="line"><span class="cl">					err := errors.New(&#34;this is a error&#34;)
</span></span><span class="line"><span class="cl">					errCh &lt;- err
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">			}()
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	wg.Wait()
</span></span><span class="line"><span class="cl">	fmt.Println(&#34;ok&#34;)
</span></span><span class="line"><span class="cl">	fmt.Println(externalErr)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个地放都写这么多代码, 就有了重复的感觉. 本质上就两点:</p>
<ul>
<li>通过 channel 控制并发数</li>
<li>通过 waitgroup 保证所有的协程都执行完毕</li>
<li>通过另一个 errchannel 接受中间执行的错误</li>
</ul>
<h2 id="errgroup"><code>errgroup</code></h2>
<p>可以通过使用, 官方的拓展包 <code>errgroup</code> 更快实现</p>
<p>声明 errgroup</p>
<ul>
<li>普通声明 <code>new(errgroup.Group)</code></li>
<li>使用 context <code>errgroup.WithContext</code></li>
</ul>
<p>限制开启的协程数据</p>
<p><code>eg.SetLimit(goroutineNum)</code></p>
<p>开启协程</p>
<ul>
<li><code>eg.Go</code></li>
<li><code>eg.TryGo</code></li>
</ul>
<p>整体代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	eg := new(errgroup.Group)
</span></span><span class="line"><span class="cl">	eg.SetLimit(10)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for i := 0; i &lt; 100; i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		eg.Go(func() error {
</span></span><span class="line"><span class="cl">			time.Sleep(1 * time.Second)
</span></span><span class="line"><span class="cl">			fmt.Println(&#34;hello go&#34;)
</span></span><span class="line"><span class="cl">			return nil
</span></span><span class="line"><span class="cl">		})
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	err := eg.Wait()
</span></span><span class="line"><span class="cl">	fmt.Println(&#34;done&#34;, err)
</span></span></code></pre></td></tr></table>
</div>
</div><p>目前有个使用场景没办法满足:</p>
<p>就是没办法在开启协程之前, 知道原先已经执行的协程是否有发生错误.
如果有发生错误的. 就停止再继续开启协程.</p>
<p>可以通过添加一个 外部的 errChannel , 覆盖到上面的需求.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何查看 golang 编译之后调用的源码方法</title>
      <link>https://ynikl.github.io/blog/golang-get-assembly-fn/</link>
      <pubDate>Sun, 18 Sep 2022 21:37:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-get-assembly-fn/</guid>
      <description>在 golang 中查看源码是比较方便的. 可以直接到 官方包文档中直接查看文档和跳转到源码
但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成 什么底层方法了.
比如, 我知道一些make(map[int]bool)是怎么实现的.
这时候就需要一些方法了. 引用一下鸟窝大佬的文章 总结一下三种方法:
go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile 产生的汇编代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 0x001c 00028 (main.go:5)	FUNCDATA	$1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB) 0x001c 00028 (main.go:5)	FUNCDATA	$2, main.main.stkobj(SB) 0x001c 00028 (main.go:6)	STP	(ZR, ZR), main.</description>
      <content:encoded><![CDATA[<p>在 golang 中查看源码是比较方便的. 可以直接到 <a href="https://pkg.go.dev/">官方包文档</a>中直接查看文档和跳转到源码</p>
<p>但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成
什么底层方法了.</p>
<p>比如, 我知道一些<code>make(map[int]bool)</code>是怎么实现的.</p>
<p>这时候就需要一些方法了. 引用一下<a href="https://colobu.com/2018/12/29/get-assembly-output-for-go-programs/">鸟窝大佬的文章</a>
总结一下三种方法:</p>
<ul>
<li><code>go tool compile -N -l -S makemap.go</code></li>
<li><code>go tool compile -N -l -S makemap.go</code></li>
<li><code>go tool compile -N -l -S makemap.go</code></li>
</ul>
<p><code>go tool compile</code> 产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	0x001c 00028 (main.go:5)	FUNCDATA	$1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB)
</span></span><span class="line"><span class="cl">	0x001c 00028 (main.go:5)	FUNCDATA	$2, main.main.stkobj(SB)
</span></span><span class="line"><span class="cl">	0x001c 00028 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-48(SP)
</span></span><span class="line"><span class="cl">	0x0020 00032 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-32(SP)
</span></span><span class="line"><span class="cl">	0x0024 00036 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-16(SP)
</span></span><span class="line"><span class="cl">	0x0028 00040 (main.go:6)	MOVD	$type.map[int]bool(SB), R0
</span></span><span class="line"><span class="cl">	0x0030 00048 (main.go:6)	MOVD	$100, R1
</span></span><span class="line"><span class="cl">	0x0034 00052 (main.go:6)	MOVD	$main..autotmp_4-48(SP), R2
</span></span><span class="line"><span class="cl">	0x0038 00056 (main.go:6)	PCDATA	$1, ZR
</span></span><span class="line"><span class="cl">	0x0038 00056 (main.go:6)	CALL	runtime.makemap(SB)
</span></span><span class="line"><span class="cl">	0x003c 00060 (main.go:6)	MOVD	R0, main.mp-112(SP)
</span></span><span class="line"><span class="cl">	0x0040 00064 (main.go:7)	MOVD	R0, R1
</span></span><span class="line"><span class="cl">	0x0044 00068 (main.go:7)	MOVD	ZR, R2
</span></span><span class="line"><span class="cl">	0x0048 00072 (main.go:7)	MOVD	$type.map[int]bool(SB), R0
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>go tool objdump</code>产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  main.go:6		0x10008a734		a907ffff		STP (ZR, ZR), 120(RSP)			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a738		90000160		ADRP 180224(PC), R0			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a73c		91100000		ADD $1024, R0, R0			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a740		d2800c81		MOVD $100, R1				
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a744		910163e2		ADD $88, RSP, R2			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a748		97fe0522		CALL runtime.makemap(SB)		
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a74c		f90023e0		MOVD R0, 64(RSP)			
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>go build -gcflags -S</code> 产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mp_10-32(SP)
</span></span><span class="line"><span class="cl">        0x0024 00036 (/Users/ian/play/map/main.go:6)    STP     (ZR, ZR), main..autotmp_10-16(SP)
</span></span><span class="line"><span class="cl">        0x0028 00040 (/Users/ian/play/map/main.go:6)    MOVD    $type.map[int]bool(SB), R0
</span></span><span class="line"><span class="cl">        0x0030 00048 (/Users/ian/play/map/main.go:6)    MOVD    $100, R1
</span></span><span class="line"><span class="cl">        0x0034 00052 (/Users/ian/play/map/main.go:6)    MOVD    $main..autotmp_10-48(SP), R2
</span></span><span class="line"><span class="cl">        0x0038 00056 (/Users/ian/play/map/main.go:6)    PCDATA  $1, ZR
</span></span><span class="line"><span class="cl">        0x0038 00056 (/Users/ian/play/map/main.go:6)    CALL    runtime.makemap(SB)
</span></span><span class="line"><span class="cl">        0x003c 00060 (/Users/ian/play/map/main.go:6)    MOVD    R0, main.mp-72(SP)
</span></span></code></pre></td></tr></table>
</div>
</div><p>大同小异, 根据源代码的行号(<code>mian.go:6</code>) 都可以从代码中看到,
调用<code>call</code> 了<code>makemap</code> 这个方法</p>
<p>我们在到<a href="https://cs.opensource.google/go/go/+/master:src/runtime/map.go;l=283?q=makemap&amp;ss=go%2Fgo">源码</a>中, 找到<code>makemap</code>方法, 就可以查看对应的源码了</p>
<h2 id="参考">参考</h2>
<p><a href="https://colobu.com/2018/12/29/get-assembly-output-for-go-programs/">得到Go程序的汇编代码的方法</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Journal</title>
      <link>https://ynikl.github.io/journal/</link>
      <pubDate>Fri, 16 Sep 2022 13:26:28 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/journal/</guid>
      <description>开这个目录的目的:
是为了记录一些, 我日常读到的一些文章收获和心得.</description>
      <content:encoded><![CDATA[<p>开这个目录的目的:</p>
<p>是为了记录一些, 我日常读到的一些文章收获和心得.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Content Disposition</title>
      <link>https://ynikl.github.io/blog/http-content-disposition/</link>
      <pubDate>Sun, 04 Sep 2022 21:32:24 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/http-content-disposition/</guid>
      <description>Content-Disposition 常见是用在 http 请求的 Response 的 Header 头部.
告诉请求客户端(浏览器) 如何处理内容;
Content-Disposition是在 MIME 标准定义的. http 中的用法只是其中的一小部分.
语法参数 inline 会在浏览器内部显示
1 Content-Disposition: inline attachment 会被保存成文件
1 Content-Disposition: attachment 后面可以跟 filename, 值为预设文件名称, 中间使用;分号隔开.
1 Content-Disposition: attachment; filename=&amp;#34;filename.jpg&amp;#34; 拓展参数, 有两个文件名称参数可选
filename* filename filename* 采用了 RFC 5987 中规定的编码方式, 假如两个参数都使用 filename* 的优先级更高
RFC 5987 该提议最终还是引用 RFC 2231 中的编码方式. 下面简单介绍一下语法
*星号用于标记该同名参数是支持该编码语法的, 就如( filename* 之于 filename) &#39;单个逗号用于分割 字符集名称 , 语言, 文件名称 %百分号用于标记编码方式, 参考RFC 2047, 所以文件名中不能有% 1 filename*=us-ascii&amp;#39;en-us&amp;#39;This%20is%20%2A%2A%2Afun%2A%2A%2A 使用us-ascii编码, en-us英语</description>
      <content:encoded><![CDATA[<p><code>Content-Disposition</code> 常见是用在 http 请求的 Response 的 Header 头部.</p>
<p>告诉请求客户端(浏览器) 如何处理内容;</p>
<p><code>Content-Disposition</code>是在 MIME 标准定义的. http 中的用法只是其中的一小部分.</p>
<h2 id="语法参数">语法参数</h2>
<h3 id="inline">inline</h3>
<p>会在浏览器内部显示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: inline
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="attachment">attachment</h3>
<p>会被保存成文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: attachment
</span></span></code></pre></td></tr></table>
</div>
</div><p>后面可以跟 filename, 值为预设文件名称, 中间使用<code>;</code>分号隔开.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: attachment; filename=&#34;filename.jpg&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>拓展参数, 有两个文件名称参数可选</p>
<ul>
<li>filename*</li>
<li>filename</li>
</ul>
<p><code>filename*</code> 采用了 RFC 5987 中规定的编码方式,
假如两个参数都使用 <code>filename*</code> 的优先级更高</p>
<h4 id="rfc-5987">RFC 5987</h4>
<p>该提议最终还是引用 <a href="https://www.rfc-editor.org/rfc/rfc2231#section-4">RFC 2231</a>
中的编码方式. 下面简单介绍一下语法</p>
<ul>
<li><code>*</code>星号用于标记该同名参数是支持该编码语法的, 就如( <code>filename*</code> 之于 <code>filename</code>)</li>
<li><code>'</code>单个逗号用于分割 <strong>字符集名称</strong> , <strong>语言</strong>, <strong>文件名称</strong></li>
<li><code>%</code>百分号用于标记编码方式, 参考<a href="https://www.rfc-editor.org/rfc/rfc2047">RFC 2047</a>, 所以文件名中不能有<code>%</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">filename*=us-ascii&#39;en-us&#39;This%20is%20%2A%2A%2Afun%2A%2A%2A
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>us-ascii</code>编码, <code>en-us</code>英语</p>
<h2 id="问题-下载文件名称乱码">问题: 下载文件名称乱码</h2>
<p>根据上面的知识, 就可以解决有的浏览器下载文件时中文名称乱码.</p>
<ul>
<li>Http 返回设置<code>Content-Disposition</code>值</li>
<li>使用 RFC 2231 的文件名称方式, 制定编码<code>utf-8</code></li>
<li>将文件名称移除<code>%</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">disposition</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;attachment;filename*=utf-8&#39;&#39;%s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">.</span><span class="nf">QueryEscape</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition">MDN</a>
<a href="https://www.rfc-editor.org/rfc/rfc2231#section-4">RFC 2231</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>The Chinese Mayor</title>
      <link>https://ynikl.github.io/posts/the-chinese-mayor/</link>
      <pubDate>Tue, 30 Aug 2022 14:06:10 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/the-chinese-mayor/</guid>
      <description>豆瓣因为涉及敏感词不让写, 干脆就写到这里来 (我也没写啥不好的呀 QAQ).
真正的现实，都是充满着矛盾。对万事万物保持一颗敬畏的心.
一方面是平民老百姓承受着流离失所的痛苦，一方面他们又可以从老破房子住到新的高楼“不破不立”，改善环境。 既要看到痛苦，也要看到改善。看外该电影， 更加让我懂得，看待事情要怀着敬畏之心，事情都是有双面性的。
总得来说，还是觉得耿属于“好市长”，在中国经济飞速发展的过程中，为人民干实事，坚定自己的立场，倾听民声（市民赌在司令部门口申诉问题的场景给我印象极深）。</description>
      <content:encoded><![CDATA[<p>豆瓣因为涉及敏感词不让写, 干脆就写到这里来 (我也没写啥不好的呀 QAQ).</p>
<p>真正的现实，都是充满着矛盾。对万事万物保持一颗敬畏的心.</p>
<p>一方面是平民老百姓承受着流离失所的痛苦，一方面他们又可以从老破房子住到新的高楼“不破不立”，改善环境。
既要看到痛苦，也要看到改善。看外该电影， 更加让我懂得，看待事情要怀着敬畏之心，事情都是有双面性的。</p>
<p>总得来说，还是觉得耿属于“好市长”，在中国经济飞速发展的过程中，为人民干实事，坚定自己的立场，倾听民声（市民赌在司令部门口申诉问题的场景给我印象极深）。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>我与地坛</title>
      <link>https://ynikl.github.io/books/%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B/</link>
      <pubDate>Tue, 23 Aug 2022 13:25:15 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B/</guid>
      <description>概括 我为什么要读这本书? 我觉得生活挺无聊, 人生活着没有什么意义. 听说在这本书中会有人生的意义
这本书怎样影响了我? 看清楚自己之所以活着, 就如史铁生所说, 就是还想得到什么. 并不是如我嘴上所说的: &amp;ldquo;人生活着没什么意义&amp;rdquo; 打算更加大胆地去追求自己想要&amp;quot;得到&amp;quot;的东西 看清楚做某一件事情的意义 &amp;ndash; 不只是看重结果, 也要去看重过程 书中的三句精华句子? 可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望 只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。 世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。 上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。 此岸永远是残缺的，否则彼岸就要坍塌。 三句话总结本书 尊重不完美, 不要抱怨, 不断地去追求完美 看清楚自己想要得到什么 人生不能只看重目的, 要去享受这个过程. 书摘 在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。
树干上留着一只蝉蜕，寂寞如一间空屋；露水在草叶上滚动，聚集，压弯了草叶轰然坠地摔开万道金光。”“
上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。
剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。
看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。
就命运而言，休论公道。
其实总共只有三个问题交替着来骚扰我，来陪伴我。第一个是要不要去死，第二个是为什么活，第三个，我干吗要写作。
人为什么活着？因为人想活着，说到底是这么回事，人真正的名字叫做：欲望。
可我为什么还想活呢？因为你还想得到点儿什么，你觉得你还是可以得到点儿什么的，比如说爱情，比如说价值感之类，人真正的名字叫欲望。
结果你又发表了几篇，并且出了一点儿小名，可这时你越来越感到恐慌。我忽然觉得自己活得像个人质，刚刚有点儿像个人了却又过了头，
人都忍不住要为生存找一些牢靠的理由。你不担心你会枯竭了？我不知道，不过我想，活着的问题在死前是完不了的。
就算是三个月！我平白地相信这样一个期限。
多年以后才听一位无名的哲人说过：危卧病榻，难有无神论者。
但在命运的混沌之点，人自然会忽略着科学，向虚暝之中寄托一份虔敬的祈盼。
机会不在外面在心里，结婚的机会有可能在外边，可爱情的机会只能在心里
那位台湾作家三毛说得对：爱如禅，不能说不能说，一说就错。
别人告诉我，她昏迷前的最后一句话是：“我那个有病的儿子和我那个还未成年的女儿……”
砌墙盖房，不单为避风雨，因为大家都有些秘密，其次当然还有一些钱财。秘密，不信你去慢慢推想，它是趣味的爹娘。
千万别把运动和能量，以及和时空分割开来理解。我随即得了启发：也千万别把人和意义分割开来理解。不是人有欲望，而是人即欲望。
如今想来，分明就是为了一个“轻”字：珍宝转眼被处理成垃圾，一段生命轻得飘散了，没有了，以为是什么原来什么也不是，轻易、简单、灰飞烟灭。一段生命之轻，威胁了生命全面之重，惶茫往灵魂里渗透：是不是生命的所有段落都会落此下场啊？人的根本恐惧就在这个“轻”字上，比如歧视和漠视，比如嘲笑，比如穷人手里作废的股票，比如失恋和死亡。轻，最是可怕。
艰苦的生活需要希望，鲜活的生命需要爱情，数不完的日子和数不完的心事，都要诉说。
也许是因为人缺了什么就更喜欢什么吧，我的两条腿一动不能动，却是个体育迷。
上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。
我希望既有一个健美的躯体又有一个了悟人生意义的灵魂，我希望二者兼得。
难道我们不该对灵魂有了残疾的人，比对肢体有了残疾的人，给予更多的同情和爱吗？
既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？
有知识不能只是有对物的知识，而是得有对人的了悟。
我们也完全可以把你以后的生活设计得无比顺利，但这样下去我们是不是绕了一圈又回到那不祥的阴影中去了？你将再没有企盼了吗？再没有新的追求了吗？那么你的心路是不是又在荒芜，于是你的幸福感又要老化、萎缩、枯竭了呢？
只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。
一个只想（只想！）使过程精彩的人是无法被剥夺的，因为死神也无法将一个精彩的过程变成不精彩的过程，因为坏运也无法阻挡你去创造一个精彩的过程，相反你可以把死亡也变成一个精彩的过程，相反坏运更利于你去创造精彩的过程。
过程！对，生命的意义就在于你能创造这过程的美好与精彩，生命的价值就在于你能够镇静而又激动地欣赏这过程的美丽与悲壮。
有位大物理学家说过：“物理学不告诉我们世界是什么，而是告诉我们关于世界我们能够谈论什么。”
历史难免是一部御制经典，文学要弥补它，所以看重的是那些沉默的心魂。
佛嘛，心中无佛什么事都敢干。
丑弱的人和圆满的神之间，是信者永远的路。</description>
      <content:encoded><![CDATA[<h2 id="概括">概括</h2>
<h3 id="我为什么要读这本书">我为什么要读这本书?</h3>
<p>我觉得生活挺无聊, 人生活着没有什么意义. 听说在这本书中会有人生的意义</p>
<h3 id="这本书怎样影响了我">这本书怎样影响了我?</h3>
<ul>
<li>看清楚自己之所以活着, 就如史铁生所说, 就是还想得到什么. 并不是如我嘴上所说的: &ldquo;人生活着没什么意义&rdquo;</li>
<li>打算更加大胆地去追求自己想要&quot;得到&quot;的东西</li>
<li>看清楚做某一件事情的意义 &ndash; 不只是看重结果, 也要去看重过程</li>
</ul>
<h3 id="书中的三句精华句子">书中的三句精华句子?</h3>
<ul>
<li>可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望</li>
<li>只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。</li>
<li>世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。</li>
<li>上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。</li>
<li>此岸永远是残缺的，否则彼岸就要坍塌。</li>
</ul>
<h3 id="三句话总结本书">三句话总结本书</h3>
<ul>
<li>尊重不完美, 不要抱怨, 不断地去追求完美</li>
<li>看清楚自己想要得到什么</li>
<li>人生不能只看重目的, 要去享受这个过程.</li>
</ul>
<h2 id="书摘">书摘</h2>
<p>在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。</p>
<p>树干上留着一只蝉蜕，寂寞如一间空屋；露水在草叶上滚动，聚集，压弯了草叶轰然坠地摔开万道金光。”“</p>
<p>上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。</p>
<p>剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。</p>
<p>看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。</p>
<p>就命运而言，休论公道。</p>
<p>其实总共只有三个问题交替着来骚扰我，来陪伴我。第一个是要不要去死，第二个是为什么活，第三个，我干吗要写作。</p>
<p>人为什么活着？因为人想活着，说到底是这么回事，人真正的名字叫做：欲望。</p>
<p>可我为什么还想活呢？因为你还想得到点儿什么，你觉得你还是可以得到点儿什么的，比如说爱情，比如说价值感之类，人真正的名字叫欲望。</p>
<p>结果你又发表了几篇，并且出了一点儿小名，可这时你越来越感到恐慌。我忽然觉得自己活得像个人质，刚刚有点儿像个人了却又过了头，</p>
<p>人都忍不住要为生存找一些牢靠的理由。你不担心你会枯竭了？我不知道，不过我想，活着的问题在死前是完不了的。</p>
<p>就算是三个月！我平白地相信这样一个期限。</p>
<p>多年以后才听一位无名的哲人说过：危卧病榻，难有无神论者。</p>
<p>但在命运的混沌之点，人自然会忽略着科学，向虚暝之中寄托一份虔敬的祈盼。</p>
<p>机会不在外面在心里，结婚的机会有可能在外边，可爱情的机会只能在心里</p>
<p>那位台湾作家三毛说得对：爱如禅，不能说不能说，一说就错。</p>
<p>别人告诉我，她昏迷前的最后一句话是：“我那个有病的儿子和我那个还未成年的女儿……”</p>
<p>砌墙盖房，不单为避风雨，因为大家都有些秘密，其次当然还有一些钱财。秘密，不信你去慢慢推想，它是趣味的爹娘。</p>
<p>千万别把运动和能量，以及和时空分割开来理解。我随即得了启发：也千万别把人和意义分割开来理解。不是人有欲望，而是人即欲望。</p>
<p>如今想来，分明就是为了一个“轻”字：珍宝转眼被处理成垃圾，一段生命轻得飘散了，没有了，以为是什么原来什么也不是，轻易、简单、灰飞烟灭。一段生命之轻，威胁了生命全面之重，惶茫往灵魂里渗透：是不是生命的所有段落都会落此下场啊？人的根本恐惧就在这个“轻”字上，比如歧视和漠视，比如嘲笑，比如穷人手里作废的股票，比如失恋和死亡。轻，最是可怕。</p>
<p>艰苦的生活需要希望，鲜活的生命需要爱情，数不完的日子和数不完的心事，都要诉说。</p>
<p>也许是因为人缺了什么就更喜欢什么吧，我的两条腿一动不能动，却是个体育迷。</p>
<p>上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。</p>
<p>我希望既有一个健美的躯体又有一个了悟人生意义的灵魂，我希望二者兼得。</p>
<p>难道我们不该对灵魂有了残疾的人，比对肢体有了残疾的人，给予更多的同情和爱吗？</p>
<p>既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？</p>
<p>有知识不能只是有对物的知识，而是得有对人的了悟。</p>
<p>我们也完全可以把你以后的生活设计得无比顺利，但这样下去我们是不是绕了一圈又回到那不祥的阴影中去了？你将再没有企盼了吗？再没有新的追求了吗？那么你的心路是不是又在荒芜，于是你的幸福感又要老化、萎缩、枯竭了呢？</p>
<p>只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。</p>
<p>一个只想（只想！）使过程精彩的人是无法被剥夺的，因为死神也无法将一个精彩的过程变成不精彩的过程，因为坏运也无法阻挡你去创造一个精彩的过程，相反你可以把死亡也变成一个精彩的过程，相反坏运更利于你去创造精彩的过程。</p>
<p>过程！对，生命的意义就在于你能创造这过程的美好与精彩，生命的价值就在于你能够镇静而又激动地欣赏这过程的美丽与悲壮。</p>
<p>有位大物理学家说过：“物理学不告诉我们世界是什么，而是告诉我们关于世界我们能够谈论什么。”</p>
<p>历史难免是一部御制经典，文学要弥补它，所以看重的是那些沉默的心魂。</p>
<p>佛嘛，心中无佛什么事都敢干。</p>
<p>丑弱的人和圆满的神之间，是信者永远的路。</p>
<p>此岸永远是残缺的，否则彼岸就要坍塌。</p>
<p>历史，这两个字，可能包含着任何你想得到和想不到的危险，可能给你带来任何想得到和想不到的灾难。</p>
<p>那个年代的人都懂得，话说到这儿最好止步；历史，这两个字，可能包含着任何你想得到和想不到的危险，可能给你带来任何想得到和想不到的灾难。</p>
<p>家长们把“耐克”一类颠来倒去地看，说：“啥东西，值得这么贵？”他们不懂，春天是不能这样计算的。</p>
<p>大人们其实忘了，春天莫不如此，各位年轻时也是一样。</p>
<p>世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。</p>
<p>我想，那就不必再去地坛寻找安静，莫如在安静中寻找地坛。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>FFmpeg 基本使用</title>
      <link>https://ynikl.github.io/blog/ffmpeg-basics/</link>
      <pubDate>Fri, 19 Aug 2022 00:14:54 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/ffmpeg-basics/</guid>
      <description>最近接手公司一个视频相关项目, 也是使用ffmpeg工具. 需要快速了解下.
概念 码率, 帧率, 文件大小 帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.
interlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i progressive: 现代整页整页呈现, 描述单位p: 60p 码率(bit rate) :视频一秒中有多少位, 决定视频的质量
ABR: 平均码率 CBR: 常量码率 VBR: 动态码率 文件大小 = 视频文件 + 音频文件
视频文件 = 码率 * 时间(s) / 8 音频文件 = 码率 * 时间(s) / 8
文件格式 不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers) 可以存储声音或者视频数据.
相关缩写 encoding (E) decoding (D) video (V) audio (A) subtitles (S) 文件元数据 metadata 描述媒体文件自身的信息, 比如:</description>
      <content:encoded><![CDATA[<p>最近接手公司一个视频相关项目, 也是使用<code>ffmpeg</code>工具.  需要快速了解下.</p>
<h2 id="概念">概念</h2>
<h2 id="码率-帧率-文件大小">码率, 帧率, 文件大小</h2>
<p>帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.</p>
<ul>
<li>interlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i</li>
<li>progressive: 现代整页整页呈现, 描述单位p: 60p</li>
</ul>
<p>码率(bit rate) :视频一秒中有多少位, 决定视频的质量</p>
<ul>
<li>ABR: 平均码率</li>
<li>CBR: 常量码率</li>
<li>VBR: 动态码率</li>
</ul>
<p>文件大小 = 视频文件 + 音频文件</p>
<p>视频文件 =  码率 * 时间(s) / 8
音频文件 =  码率 * 时间(s) / 8</p>
<h3 id="文件格式">文件格式</h3>
<p>不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers)
可以存储声音或者视频数据.</p>
<h3 id="相关缩写">相关缩写</h3>
<ul>
<li>encoding (E)</li>
<li>decoding (D)</li>
<li>video (V)</li>
<li>audio (A)</li>
<li>subtitles (S)</li>
</ul>
<h3 id="文件元数据-metadata">文件元数据 metadata</h3>
<p>描述媒体文件自身的信息, 比如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Metadata:
</span></span><span class="line"><span class="cl">	publisher : Ninja Tune
</span></span><span class="line"><span class="cl">	track : 1
</span></span><span class="line"><span class="cl">	album : Ninja Tuna
</span></span><span class="line"><span class="cl">	artist : Mr. Scruff
</span></span><span class="line"><span class="cl">	album_artist : Mr. Scruff
</span></span><span class="line"><span class="cl">	title : Kalimba
</span></span><span class="line"><span class="cl">	genre : Electronic
</span></span><span class="line"><span class="cl">	composer : A. Carthy and A. Kingslow
</span></span><span class="line"><span class="cl">	date : 2008
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="声音">声音</h3>
<p>数字音频是通过对声音的模拟信息, 抽样且用数据信号表示.</p>
<p>音频使用 bit depths 来表示声音的解析度:</p>
<p>8bit, 12bit, 14bit &hellip;</p>
<p>声音的样本频率用 Hz 表示</p>
<p>8000Hz, 11025Hz, 16000Hz &hellip;</p>
<h3 id="ffmpeg-其他套件">FFmpeg 其他套件</h3>
<ul>
<li>ffplay 播放器</li>
<li>ffprobe 查看媒体文件的信息</li>
<li>ffserver 流服务器</li>
</ul>
<h2 id="使用">使用</h2>
<h3 id="通用参数">通用参数</h3>
<p><code>-i</code> 输入源, 可以是文件也可以是 url</p>
<p><code>-vf</code> option for video filters
<code>-af</code> option for audio filters.</p>
<p><code>-filter_complex</code> 当多个输入源的时候使用</p>
<p><code>-y</code> 输出文件会强制覆盖已经存在的文件</p>
<h3 id="帮助">帮助</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 查看支持格式
</span></span><span class="line"><span class="cl">ffmpeg -formats
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; 编解码器
</span></span><span class="line"><span class="cl">ffmpeg -codecs 
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="调整帧率">调整帧率</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.avi -r 30 output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="调整码率">调整码率</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.avi -b:v 1500k output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="缩放视频大小">缩放视频大小</h3>
<ul>
<li>s : w x h 参数 宽乘以高</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 缩小分辨率
</span></span><span class="line"><span class="cl">ffmpeg -i input.avi -s 640x480 output.avi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; 扩大分辨率
</span></span><span class="line"><span class="cl">ffmpeg -i input.mpg -vf scale=iw/PHI:ih/PHI output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="旋转-翻转">旋转, 翻转</h3>
<p>旋转</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i CMYK.avi -vf transpose=2 CMYK_transposed.avi
</span></span></code></pre></td></tr></table>
</div>
</div><p>竖直翻转</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i meta.mp4 -vf vflip output_flip.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="裁切">裁切</h3>
<p>裁切视频的画中画, 裁切视频的中心 1/2 的视频</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.avi -vf crop=iw/2:ih/2 output.avi
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="模糊化">模糊化</h3>
<p>模糊化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.mpg -vf boxblur=1.5:1 output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><p>锐化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input -vf unsharp output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="叠加">叠加</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="裁剪">裁剪</h3>
<p>获取一个时间段内的音频
<code>-t</code> 参数为秒</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.mp4 -t 180 output_3_min.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>--ss</code> 设置开始时间点 ( seek from start, 从视频开始过多少秒开始操作)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 直接截断开头3分钟
</span></span><span class="line"><span class="cl">ffmpeg -i input.mp4 -ss 180 output_without_start_3.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>截取某一段时间视频</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 截取第4分钟, 一分钟视频
</span></span><span class="line"><span class="cl">ffmpeg -i input.mp4 -ss 180 -t 60 clip_4th_min.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="图片操作">图片操作</h3>
<p>从视频中截取某一帧</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i videoclip.avi -ss 01:23:45 image.jpg
</span></span></code></pre></td></tr></table>
</div>
</div><p>翻转图片</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i orange.jpg -vf hflip orange_hflip.jpg
</span></span><span class="line"><span class="cl">ffmpeg -i orange.jpg -vf vflip orange_vflip.jpg
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; transpose [0, 1, 2, 3]
</span></span><span class="line"><span class="cl">ffmpeg -i image.png -vf transpose=1 image_rotated.png
</span></span></code></pre></td></tr></table>
</div>
</div><p>转换图片格式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i illustration.png illustration.jpg
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="格式转化">格式转化</h3>
<p>格式转化流程:</p>
<p>Demuxer (分解复用) : 将合成信号恢复成原本独立的信号数据
Decoder (解码器) : 解码
Encoder (编码器) : 编码
Muxer ( _ ): 将多个信号数据合并</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -y -i input.avi output.mp4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; 改变格式, 但不更改编解码方式
</span></span><span class="line"><span class="cl">ffmpeg -i input.avi -q 1 -c copy output.mov
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="混音">混音</h3>
<p>将两个声合成一个文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i demo.mp3 -i louder_sound.aac -filter_complex amix=inputs=2 sounds.wav
</span></span></code></pre></td></tr></table>
</div>
</div><p>加强耳机的立体声效果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i music.mp3 -af earwax -q 1 music_headphones.mp3
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li><em>FFmpeg Basics 2012 by Frantisek Korbel</em></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Redis 用于做分布式锁</title>
      <link>https://ynikl.github.io/blog/redis-do-distributed-lock/</link>
      <pubDate>Thu, 18 Aug 2022 12:18:53 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/redis-do-distributed-lock/</guid>
      <description>操作 演进 加锁后进程挂掉了 加锁成功之后, 进程挂掉了没有进行解锁操作. 导致进入死锁状态.
引入 expire 设置超时时长, 自动释放 key
1 2 3 4 5 6 7 8 &amp;gt; setnx lock:key true &amp;gt; OK &amp;gt; expire lock:key 5 &amp;#34; ... do something critical ... &amp;gt; del lock:codehole 加锁动作 到 expire 之间挂掉了 redis 2.8 之后支持 set 拓展指令
1 &amp;gt; set lock:key true ex 5 nx 加锁互斥锁, 并同时设置超时时长
执行超时, 被其他进程获取到了锁 加锁之后, 本身进程执行时间超过了预先设置的 expire 的时间. 就会导致锁被提前释放.
解决方案:
尽量不要用与锁住时间教长的任务, 尝试缩小锁定的&amp;quot;关键区域&amp;quot; 续锁 (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间 执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁 Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。 &amp;ndash; Redis深度历险</description>
      <content:encoded><![CDATA[<h2 id="操作">操作</h2>
<h2 id="演进">演进</h2>
<h3 id="加锁后进程挂掉了">加锁后进程挂掉了</h3>
<p>加锁成功之后, 进程挂掉了没有进行解锁操作.
导致进入死锁状态.</p>
<p>引入 <code>expire</code> 设置超时时长, 自动释放 key</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; setnx lock:key true 
</span></span><span class="line"><span class="cl">&gt; OK
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; expire lock:key 5 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; ... do something critical ... 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; del lock:codehole
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="加锁动作-到-expire-之间挂掉了">加锁动作 到 expire 之间挂掉了</h3>
<p>redis 2.8 之后支持 <code>set</code> 拓展指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; set lock:key true ex 5 nx
</span></span></code></pre></td></tr></table>
</div>
</div><p>加锁互斥锁, 并同时设置超时时长</p>
<h3 id="执行超时-被其他进程获取到了锁">执行超时, 被其他进程获取到了锁</h3>
<p>加锁之后, 本身进程执行时间超过了预先设置的 <code>expire</code> 的时间. 就会导致锁被提前释放.</p>
<p>解决方案:</p>
<ol>
<li>尽量不要用与锁住时间教长的任务, 尝试缩小锁定的&quot;关键区域&quot;</li>
<li><strong>续锁</strong> (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间</li>
</ol>
<h3 id="执行超时-被其他进程获取到了锁之后-超时进程误删其他进程的锁">执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁</h3>
<blockquote>
<p>Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。
&ndash; Redis深度历险</p>
</blockquote>
<p>解决方案: 给加锁的 key 设置随机数的value, 删除之前先匹配是否一致再删除</p>
<p>匹配和删除动作之间的原子性可以用 Lua 脚本保证</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="o">#</span> <span class="n">delifequals</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="n">redis.call</span><span class="p">(</span><span class="s2">&#34;get&#34;</span><span class="p">,</span><span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">	<span class="kr">return</span> <span class="n">redis.call</span><span class="p">(</span><span class="s2">&#34;del&#34;</span><span class="p">,</span><span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="kr">else</span>
</span></span><span class="line"><span class="cl">	<span class="kr">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="可重入锁">可重入锁</h3>
<p>利用线程的本地变量(Threadloacl), 维护锁的持有计数, 实现支持多次加锁, 多次解锁</p>
<h2 id="参考">参考</h2>
<ul>
<li><em>Redis 深度历险</em></li>
<li><a href="https://www.51cto.com/article/679902.html">阿里二面：Redis分布式锁过期了但业务还没有执行完，怎么办</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>CI/CD</title>
      <link>https://ynikl.github.io/blog/ci-cd/</link>
      <pubDate>Sun, 14 Aug 2022 15:27:33 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/ci-cd/</guid>
      <description>CI 自动化发布流程 可重复 可快速回滚 发布流程快速 在合并的时候可以对代码进行快速验证 CD 部署流程平台化 一键部署 总结 所谓的 CI/CD 就是通过自动化操作, 比如自动化测试, 自动化部署. 使用项目拥有快速上线的能力 &amp;ndash; 可以快速验证, 快速回滚, 快速发布.</description>
      <content:encoded><![CDATA[<h2 id="ci">CI</h2>
<ul>
<li>自动化发布流程</li>
<li>可重复</li>
<li>可快速回滚</li>
<li>发布流程快速</li>
<li>在合并的时候可以对代码进行快速验证</li>
</ul>
<h2 id="cd">CD</h2>
<ul>
<li>部署流程平台化</li>
<li>一键部署</li>
</ul>
<h2 id="总结">总结</h2>
<p>所谓的 CI/CD 就是通过自动化操作, 比如自动化测试, 自动化部署. 使用项目拥有快速上线的能力 &ndash; 可以快速验证, 快速回滚, 快速发布.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang Map 介绍</title>
      <link>https://ynikl.github.io/blog/golang-map/</link>
      <pubDate>Sat, 13 Aug 2022 14:14:30 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-map/</guid>
      <description>本想写一篇关于 golang 中 map 底层的文章， 但是发现已经了相当不错的文章 &amp;ndash; 字节跳动技术团队 - Golang 中 map 探究 这里只补充一下，缺少的 map 的删除操作
内部数据结构 初始化 map 是一个有&amp;quot;包含内容&amp;quot;的数据结构, 使用之前需要提前初始化, 即调用make
真正是调用源码是 runtime.makemap
获取数据 删除 源码地址
删除的关键代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Only clear key if there are pointers in it. // # 当 Key 是指针类型的时候会去清空指针 if t.key.ptrdata != 0 { if goarch.</description>
      <content:encoded><![CDATA[<p>本想写一篇关于 golang 中 map 底层的文章， 但是发现已经了相当不错的文章 &ndash;
<a href="https://mp.weixin.qq.com/s/UT8tydajjOUJkfc-Brcblw">字节跳动技术团队 - Golang 中 map 探究</a>
这里只补充一下，缺少的 map 的删除操作</p>
<h2 id="内部数据结构">内部数据结构</h2>
<h2 id="初始化">初始化</h2>
<p>map 是一个有&quot;包含内容&quot;的数据结构, 使用之前需要提前初始化, 即调用<code>make</code></p>
<p>真正是调用源码是 <a href="https://cs.opensource.google/go/go/+/master:src/runtime/map.go;l=283;bpv=1;bpt=1?q=makemap&amp;ss=go%2Fgo">runtime.makemap</a></p>
<h2 id="获取数据">获取数据</h2>
<h2 id="删除">删除</h2>
<p><a href="https://cs.opensource.google/go/go/+/master:src/runtime/map_fast64.go;drc=3e5c2c155645ebaed62e4481430c455045b0fff5;bpv=1;bpt=1;l=273?q=mapdelete_fast64&amp;ss=go%2Fgo">源码地址</a></p>
<p>删除的关键代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// Only clear key if there are pointers in it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// # 当 Key 是指针类型的时候会去清空指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// There are three ways to squeeze at one ore more 32 bit pointers into 64 bits.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// Just call memclrHasPointers instead of trying to handle all cases here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// # 当 Value 为指针类型的时候, 指针为空, 解除引用 -&gt; GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">			<span class="c1">// # 讲 hash 值标记为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">emptyOne</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述删除代码操作现象</p>
<ul>
<li>当<code>map</code>的<code>value</code>类型中包含引用类型, 删除对应的<code>key</code>之后, 经过GC就会释放占用的内存</li>
<li>当<code>map</code>的<code>value</code> 类型不包含引用类型, 删除对应的<code>key</code>之后, GC无法释放类型</li>
</ul>
<p>可以查看我自己的实验结果 {{}}</p>
https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/
<h2 id="扩容">扩容</h2>
<h2 id="参考">参考</h2>
<p><a href="https://mp.weixin.qq.com/s/UT8tydajjOUJkfc-Brcblw">Golang 中 map 探究</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>活着的意义</title>
      <link>https://ynikl.github.io/posts/the-meaning-of-living/</link>
      <pubDate>Tue, 09 Aug 2022 23:40:37 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/the-meaning-of-living/</guid>
      <description>我觉得人生活着没有意义，但是我又为什么还活着呢？今天， 刚好看到了史铁生的《我与地坛》里面给了我答案
可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望</description>
      <content:encoded><![CDATA[<p>我觉得人生活着没有意义，但是我又为什么还活着呢？今天， 刚好看到了史铁生的《我与地坛》里面给了我答案</p>
<blockquote>
<p>可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>巴菲特致股东的信</title>
      <link>https://ynikl.github.io/books/%E5%B7%B4%E8%8F%B2%E7%89%B9%E8%87%B4%E8%82%A1%E4%B8%9C%E7%9A%84%E4%BF%A1/</link>
      <pubDate>Mon, 08 Aug 2022 13:27:29 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/%E5%B7%B4%E8%8F%B2%E7%89%B9%E8%87%B4%E8%82%A1%E4%B8%9C%E7%9A%84%E4%BF%A1/</guid>
      <description>概括 我为什么要读这本书? Youtuber 推荐, 好奇金融相关的知识
这本书怎样影响了我? 不要轻易地去触碰股市, 直到我真正的理解它.
书中的三句精华句子? 一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力 他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误 活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。 三句话总结本书 投资的时候要看重的公司的内在价值而不是市场先生的报价 减少交易次数 努力地去看透事情的本质 书摘 笔记摘自
巴菲特致股东的信：投资者和公司高管教程（原书第4版）
【美】沃伦E.巴菲特
关于巴菲特一生的成功秘诀，已经有无数人做出了评价，我个人认为可以归结为八个字：与时俱进，良性循环
“与坏人打交道，做成一笔好生意，这样的事情，我从来没有遇见过。”巴菲特的这句名言令人深思
从别人的故事里，找到自己的人生启发，这就是读书的意义所在
广受尊重的投资家兼作家菲尔·费雪（即菲利普·费雪，Phil Fisher）曾经将公司吸引股东的策略比喻为餐馆吸引顾客的策略。 一家餐馆可以定位于特定的食客阶层——喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困惑，最终离开。
应该可以直接与公司CEO进行沟通，得到他现在和未来如何对企业进行估值的看法
如果我们对一只股票有良好的长期预期，那么短期的价格波动对我们来说毫无意义，除非有人报给我们一个非常有吸引力的价格。
芒格和我无法向你承诺结果。但我们可以保证，只要你是我们的合伙人，在任何时段，你的金融资产和我们自己的资产将完全保持一致的成长
为了达成目标，我们的首选是直接持有一系列多元化的企业，从中获得稳定的现金流和持续的高于市场平均水平的资本回报
从整体和长期来看，我们希望那些未体现的盈利，通过资本增值的形式体现在我们的内在价值里
巴菲特以及伯克希尔避免进行预测，因为这是一种糟糕的管理习惯，经常会导致管理人粉饰报表
但是任何短期的压力都不应以牺牲长期竞争力为代价
一场大会的毫无建树是由于参与股东们更在意自己在台上的表现，而不是关心公司运营的状况
在伯克希尔公司，我们通常会换位思考，设想如果我们自己处于股东的位置，应该得到什么样的信息，我们会从这样的角度向股东披露完整的报告
这种打假活动针对的目标是公司信息披露行为中的“选择性披露”，近些年来，这种选择性披露行为像癌症一样蔓延。的确，信息的选择性披露已经成为大型公司的一种标准化的行为
CEO们预测公司增长速度，是骗人的和危险的。当然，他们是被分析师和公司自己的投资者关系部门怂恿裹挟着这么做。但他们应该拒绝，因为这样预测多了会招致麻烦。
厨房里如果有蟑螂，绝不可能只有一只
在一个由一群和事佬组成的董事会里，不太可能会有人提出更换CEO的提议。同样，也不可能对CEO提议的公司并购活动提出质疑
毕竟，没有人会喜欢去洗外面租来的车
除了要维持独立性，董事们也必须具备丰富的商业经验，以股东利益为导向，以及在公司拥有真正的利益
在收购之前，他们就已是商界的管理明星，已经证明了自己在各自领域中的才华，我们的主要贡献就是让他们自由发挥天分，不给他们添乱
“如果我们雇用的都是比我们矮的人，我们将成为一家侏儒公司；但如果我们雇用的都是比我们高的人，我们会成为一家巨人公司。”
我们希望我们的经理人队伍考虑什么是重要的，而不是考虑什么被认为是重要的。
当投资的时候，我们将自己视为企业分析师——而不是市场分析师，不是宏观经济分析师，甚至不是证券分析师。
他说你应该将市场报价想象为一个名叫“市场先生”的人
如果你不懂得你的公司，不能比市场先生更准确地评估你的公司，你就不要参与这场游戏
就像人们打牌时说的：“如果玩了30分钟，你还不知道谁是倒霉蛋，有可能就是你。
一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力
有些人会在不同市场间倒手，意图赚取差价。你不必感到惊讶，从业者为此选了一个法语词汇：套利。
如果需要同时做很多事情，就像同时将很多烙铁放在火中，人们就必须花大量的时间，既要监控交易的过程，又要监控市场股价的波动。这不是芒格和我所想的生活模式。（如果只是为了赚钱而整天盯着股票行情，这种生活有什么意义可言？
在完全忽视股价的情况下，一家拥有子公司的母公司，如果子公司长期表现优异，母公司是不可能出售子公司的。“为什么要卖出？”CEO会问，“难道要我卖出皇冠上的宝石吗
应该评估是否在其预期的持股期间，其投资的税后收益总和（包括他卖出所得）会带给他至少在投资开始之初同等的购买力，加上合理的利率因素
一个视力平平的人，没有必要在干草堆里寻找绣花针。
我们的座右铭是：“如果你一开始就取得了成功，那么，不必再做测试。
很多大名鼎鼎的基金管理人现在关注的是其他基金管理人未来几天干什么，而不是关注企业未来几年干什么。对于他们而言，股票仅仅是游戏中的筹码，就像大富翁游戏中，如同顶针和熨斗一样的道具
我们的目标是发现那些价格合理的杰出公司，而不是价格便宜的平庸公司
最值得拥有的公司是，那些在一个一直延伸的时期周期里，可以不断利用增量资本获得很高回报率的公司
他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误
二级市场经常周期性地被大量傻瓜所主导，会持续设定一个“清算”价格。无论这个价格多么愚蠢，它是股票或债券持有者需要或希望卖出的价格，总是有这样的机会出现
无论什么样的天才或努力，有些事情总是需要时间。即便你能让九个女人同时怀孕，也不可能让她们在一个月的时间里生出小宝宝。）
但我更喜欢一个确定的良好结果，而不是一个期望的伟大结果。
在企业内部，有一种看不见的力量足以压倒一切，我们可以称其为“惯性驱使”或“机构强迫症”
如果我们在资产负债表上使用适当的负债，可以在安全的前提下增加一些盈利
信用就像氧气。此二者，在充足的时候，人们不会注意到它们的存在；当它们消失的时候，人们才会发现它们的重要性
当年花1美元可以买到的东西，今天要花7美元以上。因此，即便一个不用交税的机构，也必须在同期从债券上获得4.3%的年化利息收入，才能维持其购买力不变。如果这些机构的管理人将任何的利息部分视为“收入”的话，他们一定是在和自己开玩笑
即使在最混乱的经济环境中，美国国债也是唯一靠得住的流动性良好的投资对象
大多数人宁愿去死，也不愿意思考。很多人就是这样
巨大的负债可以让管理层前所未有地专注工作，就像在汽车方向盘上装一把匕首，可以提高司机的注意力一样
衍生品还可能造成连锁反应式的风险，因为很多保险公司或再保险公司将它们的风险分散给其他保险公司</description>
      <content:encoded><![CDATA[<h2 id="概括">概括</h2>
<h3 id="我为什么要读这本书">我为什么要读这本书?</h3>
<p>Youtuber 推荐, 好奇金融相关的知识</p>
<h3 id="这本书怎样影响了我">这本书怎样影响了我?</h3>
<p>不要轻易地去触碰股市, 直到我真正的理解它.</p>
<h3 id="书中的三句精华句子">书中的三句精华句子?</h3>
<ol>
<li>一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力</li>
<li>他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误</li>
<li>活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。</li>
</ol>
<h3 id="三句话总结本书">三句话总结本书</h3>
<ul>
<li>投资的时候要看重的公司的内在价值而不是市场先生的报价</li>
<li>减少交易次数</li>
<li>努力地去看透事情的本质</li>
</ul>
<h2 id="书摘">书摘</h2>
<p>笔记摘自</p>
<p>巴菲特致股东的信：投资者和公司高管教程（原书第4版）</p>
<p>【美】沃伦E.巴菲特</p>
<blockquote>
<p>关于巴菲特一生的成功秘诀，已经有无数人做出了评价，我个人认为可以归结为八个字：与时俱进，良性循环</p>
</blockquote>
<blockquote>
<p>“与坏人打交道，做成一笔好生意，这样的事情，我从来没有遇见过。”巴菲特的这句名言令人深思</p>
</blockquote>
<blockquote>
<p>从别人的故事里，找到自己的人生启发，这就是读书的意义所在</p>
</blockquote>
<blockquote>
<p>广受尊重的投资家兼作家菲尔·费雪（即菲利普·费雪，Phil Fisher）曾经将公司吸引股东的策略比喻为餐馆吸引顾客的策略。 一家餐馆可以定位于特定的食客阶层——喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困惑，最终离开。</p>
</blockquote>
<blockquote>
<p>应该可以直接与公司CEO进行沟通，得到他现在和未来如何对企业进行估值的看法</p>
</blockquote>
<blockquote>
<p>如果我们对一只股票有良好的长期预期，那么短期的价格波动对我们来说毫无意义，除非有人报给我们一个非常有吸引力的价格。</p>
</blockquote>
<blockquote>
<p>芒格和我无法向你承诺结果。但我们可以保证，只要你是我们的合伙人，在任何时段，你的金融资产和我们自己的资产将完全保持一致的成长</p>
</blockquote>
<blockquote>
<p>为了达成目标，我们的首选是直接持有一系列多元化的企业，从中获得稳定的现金流和持续的高于市场平均水平的资本回报</p>
</blockquote>
<blockquote>
<p>从整体和长期来看，我们希望那些未体现的盈利，通过资本增值的形式体现在我们的内在价值里</p>
</blockquote>
<blockquote>
<p>巴菲特以及伯克希尔避免进行预测，因为这是一种糟糕的管理习惯，经常会导致管理人粉饰报表</p>
</blockquote>
<blockquote>
<p>但是任何短期的压力都不应以牺牲长期竞争力为代价</p>
</blockquote>
<blockquote>
<p>一场大会的毫无建树是由于参与股东们更在意自己在台上的表现，而不是关心公司运营的状况</p>
</blockquote>
<blockquote>
<p>在伯克希尔公司，我们通常会换位思考，设想如果我们自己处于股东的位置，应该得到什么样的信息，我们会从这样的角度向股东披露完整的报告</p>
</blockquote>
<blockquote>
<p>这种打假活动针对的目标是公司信息披露行为中的“选择性披露”，近些年来，这种选择性披露行为像癌症一样蔓延。的确，信息的选择性披露已经成为大型公司的一种标准化的行为</p>
</blockquote>
<blockquote>
<p>CEO们预测公司增长速度，是骗人的和危险的。当然，他们是被分析师和公司自己的投资者关系部门怂恿裹挟着这么做。但他们应该拒绝，因为这样预测多了会招致麻烦。</p>
</blockquote>
<blockquote>
<p>厨房里如果有蟑螂，绝不可能只有一只</p>
</blockquote>
<blockquote>
<p>在一个由一群和事佬组成的董事会里，不太可能会有人提出更换CEO的提议。同样，也不可能对CEO提议的公司并购活动提出质疑</p>
</blockquote>
<blockquote>
<p>毕竟，没有人会喜欢去洗外面租来的车</p>
</blockquote>
<blockquote>
<p>除了要维持独立性，董事们也必须具备丰富的商业经验，以股东利益为导向，以及在公司拥有真正的利益</p>
</blockquote>
<blockquote>
<p>在收购之前，他们就已是商界的管理明星，已经证明了自己在各自领域中的才华，我们的主要贡献就是让他们自由发挥天分，不给他们添乱</p>
</blockquote>
<blockquote>
<p>“如果我们雇用的都是比我们矮的人，我们将成为一家侏儒公司；但如果我们雇用的都是比我们高的人，我们会成为一家巨人公司。”</p>
</blockquote>
<blockquote>
<p>我们希望我们的经理人队伍考虑什么是重要的，而不是考虑什么被认为是重要的。</p>
</blockquote>
<blockquote>
<p>当投资的时候，我们将自己视为企业分析师——而不是市场分析师，不是宏观经济分析师，甚至不是证券分析师。</p>
</blockquote>
<blockquote>
<p>他说你应该将市场报价想象为一个名叫“市场先生”的人</p>
</blockquote>
<blockquote>
<p>如果你不懂得你的公司，不能比市场先生更准确地评估你的公司，你就不要参与这场游戏</p>
</blockquote>
<blockquote>
<p>就像人们打牌时说的：“如果玩了30分钟，你还不知道谁是倒霉蛋，有可能就是你。</p>
</blockquote>
<blockquote>
<p>一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力</p>
</blockquote>
<blockquote>
<p>有些人会在不同市场间倒手，意图赚取差价。你不必感到惊讶，从业者为此选了一个法语词汇：套利。</p>
</blockquote>
<blockquote>
<p>如果需要同时做很多事情，就像同时将很多烙铁放在火中，人们就必须花大量的时间，既要监控交易的过程，又要监控市场股价的波动。这不是芒格和我所想的生活模式。（如果只是为了赚钱而整天盯着股票行情，这种生活有什么意义可言？</p>
</blockquote>
<blockquote>
<p>在完全忽视股价的情况下，一家拥有子公司的母公司，如果子公司长期表现优异，母公司是不可能出售子公司的。“为什么要卖出？”CEO会问，“难道要我卖出皇冠上的宝石吗</p>
</blockquote>
<blockquote>
<p>应该评估是否在其预期的持股期间，其投资的税后收益总和（包括他卖出所得）会带给他至少在投资开始之初同等的购买力，加上合理的利率因素</p>
</blockquote>
<blockquote>
<p>一个视力平平的人，没有必要在干草堆里寻找绣花针。</p>
</blockquote>
<blockquote>
<p>我们的座右铭是：“如果你一开始就取得了成功，那么，不必再做测试。</p>
</blockquote>
<blockquote>
<p>很多大名鼎鼎的基金管理人现在关注的是其他基金管理人未来几天干什么，而不是关注企业未来几年干什么。对于他们而言，股票仅仅是游戏中的筹码，就像大富翁游戏中，如同顶针和熨斗一样的道具</p>
</blockquote>
<blockquote>
<p>我们的目标是发现那些价格合理的杰出公司，而不是价格便宜的平庸公司</p>
</blockquote>
<blockquote>
<p>最值得拥有的公司是，那些在一个一直延伸的时期周期里，可以不断利用增量资本获得很高回报率的公司</p>
</blockquote>
<blockquote>
<p>他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误</p>
</blockquote>
<blockquote>
<p>二级市场经常周期性地被大量傻瓜所主导，会持续设定一个“清算”价格。无论这个价格多么愚蠢，它是股票或债券持有者需要或希望卖出的价格，总是有这样的机会出现</p>
</blockquote>
<blockquote>
<p>无论什么样的天才或努力，有些事情总是需要时间。即便你能让九个女人同时怀孕，也不可能让她们在一个月的时间里生出小宝宝。）</p>
</blockquote>
<blockquote>
<p>但我更喜欢一个确定的良好结果，而不是一个期望的伟大结果。</p>
</blockquote>
<blockquote>
<p>在企业内部，有一种看不见的力量足以压倒一切，我们可以称其为“惯性驱使”或“机构强迫症”</p>
</blockquote>
<blockquote>
<p>如果我们在资产负债表上使用适当的负债，可以在安全的前提下增加一些盈利</p>
</blockquote>
<blockquote>
<p>信用就像氧气。此二者，在充足的时候，人们不会注意到它们的存在；当它们消失的时候，人们才会发现它们的重要性</p>
</blockquote>
<blockquote>
<p>当年花1美元可以买到的东西，今天要花7美元以上。因此，即便一个不用交税的机构，也必须在同期从债券上获得4.3%的年化利息收入，才能维持其购买力不变。如果这些机构的管理人将任何的利息部分视为“收入”的话，他们一定是在和自己开玩笑</p>
</blockquote>
<blockquote>
<p>即使在最混乱的经济环境中，美国国债也是唯一靠得住的流动性良好的投资对象</p>
</blockquote>
<blockquote>
<p>大多数人宁愿去死，也不愿意思考。很多人就是这样</p>
</blockquote>
<blockquote>
<p>巨大的负债可以让管理层前所未有地专注工作，就像在汽车方向盘上装一把匕首，可以提高司机的注意力一样</p>
</blockquote>
<blockquote>
<p>衍生品还可能造成连锁反应式的风险，因为很多保险公司或再保险公司将它们的风险分散给其他保险公司</p>
</blockquote>
<blockquote>
<p>“世俗的智慧告诉我们，循规蹈矩的失败，可能比标新立异的成功，更有利于保全名声</p>
</blockquote>
<blockquote>
<p>这场愚蠢游戏的核心是，人们通常都认为房屋的价格肯定会随着时间而上升，任何的下降都是可以忽略不计的。这个前提几乎贯穿于任何房屋的交易行为和交易价格中</p>
</blockquote>
<blockquote>
<p>借贷者将钱借给那些以他们的收入根本还不起钱的人，借款者很愉快地签署这些合同。借贷双方都寄希望于“房价的上升”，以弥补这项“不可能完成的任务”所带来的缺口。</p>
</blockquote>
<p>.&gt; 但是，居住和使用应作为买房时的首要动机，而不应该将购房视作升值盈利或再融资的手段。同时，购房时应该考虑与收入相匹配，量力而行。</p>
<blockquote>
<p>投资者的整体回报，随着交易频率的上升而减少。</p>
</blockquote>
<blockquote>
<p>道琼斯在20世纪的100年中，从65.73点上升到11497.12点，相当于年化复合回报率5.3%（当然，投资者在此期间还能收到分红。）在接下来21世纪的100年中，为了达到同样的回报率，道琼斯指数必须——你需要深呼一口气——达到2011011.23点。也就是说，到21世纪末，道琼斯将以200万点收盘，但看看本世纪初的前六年，道琼斯指数几乎原地没动。</p>
</blockquote>
<blockquote>
<p>活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。这实际上是对股东们征收的重税，虽然只是一个人决定“换个位子”，虽然支付的对象是金融机构，而不是华盛顿</p>
</blockquote>
<blockquote>
<p>并不是所有的收益都是在同等的情况下创造的。在很多公司，尤其是那些具有高资产/利润比特征的公司里，通货膨胀会侵蚀财报中显示的部分甚至全部收益。这个会被通胀侵蚀的收益部分，我们称之为“受限定收益”，不能被用于派发红利，以利于公司保持其经济竞争地位。</p>
</blockquote>
<blockquote>
<p>如果再投资能获得高回报，就应该保留收益进行再投资；如果回报低下，就应该分红</p>
</blockquote>
<blockquote>
<p>除非它们经历了极其巨大的惊人的单位成长，杰出的公司一定会产生大量的富余现金。如果公司将这些收益投在那些回报低下的业务，公司的整体留存资本的表现可能依然会很卓越，因为，核心业务部分的回报非凡。这就像高尔夫比赛中，职业选手和业余选手的混合赛，即便队伍中的业余选手都是没有希望的笨蛋，但整个球队的表现还是不错，因为得分主要来源于其中的职业选手</p>
</blockquote>
<blockquote>
<p>如果一家公司的股票价格远低于其内在价值，通常在这个时候，回购最有意义</p>
</blockquote>
<blockquote>
<p>首先，一家公司有充足的现金以备运营和流动性之需；其次，股价远低于保守计算的内在价值</p>
</blockquote>
<blockquote>
<p>以及那些冲着分拆预期而来的买家，毫无疑问将会稀释现有股东群体的质量</p>
</blockquote>
<blockquote>
<p>过度活跃的股市是企业的扒手。</p>
</blockquote>
<blockquote>
<p>我们采取的方式就像一个人寻找合适的另一半一样：保持积极、兴趣、开放的心态，但不能着急</p>
</blockquote>
<blockquote>
<p>桑塔亚娜（Santayana）曾说：“当你忘却了目标，狂热会让你付出很多倍的努力</p>
</blockquote>
<blockquote>
<p>我们试图避免一些小动作——“如果一些事情不值得做，也就不值得做好。</p>
</blockquote>
<blockquote>
<p>诺亚法则：重要的是建造方舟，而不是预测大雨</p>
</blockquote>
<blockquote>
<p>我们喜欢与那些热爱自家公司的人做生意，而不仅仅是因为喜欢钱（虽然，我们也可以理解他为何喜欢）。当这种附加的情感存在时，它是一个信号，让人可以发现企业所具有的重要品质：不做假账，以产品为荣，尊重客户，以及一群忠诚的、有强烈方向感的人。与此相反的情况，也是真的。当</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql- 数据类型 - 数字</title>
      <link>https://ynikl.github.io/blog/mysql-data-type-numbers/</link>
      <pubDate>Sun, 31 Jul 2022 17:49:46 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/mysql-data-type-numbers/</guid>
      <description>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期和时间 空间 JSON 数字类型 整数类型 Interger 类型 存储大小 bytes 其他别名 TinyInt 1 bool, boolean = tinyint(1) SmallInt 2 MediumInt 3 Int 4 BigInt 8 int(M) 表示显示宽度, 最大显示宽度为(255), M 与存储空间的大小无关. 空间大小由具体类型决定.
如果具体数值达不到宽度, 左边就会用0值补齐至 M 位.
浮点 ( Floating-Point ) 类型 存储 补充 范围 Float 4 bytes 单精度 Double 8 bytes 双精度 Float(p) p 表示小数点后的精度位数
Float(M, D) Mysql 语法: M表示总显示位数, D表示小数点后个数 &amp;ndash; 由Mysql自己做约分处理. Mysql 8.0 后废弃该语法.
定点 ( Fixed-Point ) 用于需要准备保存字段数据, 如金钱相关字段.</description>
      <content:encoded><![CDATA[<h2 id="概览">概览</h2>
<p>Mysql 支持以下数据类型</p>
<ul>
<li>数字类型</li>
<li>串类型(字符和字节)</li>
<li>日期和时间</li>
<li>空间</li>
<li>JSON</li>
</ul>
<h2 id="数字类型">数字类型</h2>
<h3 id="整数类型-interger">整数类型 Interger</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小 bytes</th>
<th>其他别名</th>
</tr>
</thead>
<tbody>
<tr>
<td>TinyInt</td>
<td>1</td>
<td>bool, boolean = tinyint(1)</td>
</tr>
<tr>
<td>SmallInt</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>MediumInt</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>Int</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>BigInt</td>
<td>8</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>int(M) 表示显示宽度, 最大显示宽度为(255), M 与存储空间的大小无关. 空间大小由具体类型决定.</strong></p>
<p>如果具体数值达不到宽度, 左边就会用0值补齐至 M 位.</p>
<h3 id="浮点--floating-point-">浮点 ( Floating-Point )</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储</th>
<th>补充</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>Float</td>
<td>4 bytes</td>
<td>单精度</td>
<td></td>
</tr>
<tr>
<td>Double</td>
<td>8 bytes</td>
<td>双精度</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>Float(p)</code> p 表示小数点后的精度位数</p>
<p><code>Float(M, D)</code> Mysql 语法: M表示总显示位数, D表示小数点后个数 &ndash; 由Mysql自己做约分处理. Mysql 8.0 后废弃该语法.</p>
<h3 id="定点--fixed-point-">定点 ( Fixed-Point )</h3>
<p>用于需要准备保存字段数据, 如金钱相关字段.</p>
<p><code>Decimal(M, D)</code> 其中, M 表示字段中有效数据个数, D 表示小数点后个数</p>
<p>Decimal(5,2) 的精度为 <code>-999.99 - 999.99</code></p>
<h3 id="位--bit-value-">位 ( Bit-Value )</h3>
<p><code>BIT(M)</code> 用于存储位值, M范围(1-64), 当存储的数值小于 M, 会进行左边补0</p>
<p>example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql&gt; CREATE TABLE t (b BIT(8));
</span></span><span class="line"><span class="cl">mysql&gt; INSERT INTO t SET b = b&#39;11111111&#39;;
</span></span><span class="line"><span class="cl">mysql&gt; INSERT INTO t SET b = b&#39;1010&#39;;
</span></span><span class="line"><span class="cl">mysql&gt; INSERT INTO t SET b = b&#39;0101&#39;;
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql&gt; SELECT b+0, BIN(b), OCT(b), HEX(b) FROM t;
</span></span><span class="line"><span class="cl">+------+----------+--------+--------+
</span></span><span class="line"><span class="cl">| b+0  | BIN(b)   | OCT(b) | HEX(b) |
</span></span><span class="line"><span class="cl">+------+----------+--------+--------+
</span></span><span class="line"><span class="cl">|  255 | 11111111 | 377    | FF     |
</span></span><span class="line"><span class="cl">|   10 | 1010     | 12     | A      |
</span></span><span class="line"><span class="cl">|    5 | 101      | 5      | 5      |
</span></span><span class="line"><span class="cl">+------+----------+--------+--------+
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">Mysql 8.0 官方文档</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql- 数据类型 - 日期</title>
      <link>https://ynikl.github.io/blog/mysql-data-type-date/</link>
      <pubDate>Sun, 31 Jul 2022 17:49:46 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/mysql-data-type-date/</guid>
      <description>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期类型 空间 JSON 日期类型 Mysql 支持的数据类型
DATE TIME DATETIME TIMESTAMP YEAR Date 只存储日期数据, 不包含时间. YYYY-MM-DD, 范围是从 &amp;lsquo;1000-01-01&amp;rsquo; to &amp;lsquo;9999-12-31&amp;rsquo;
DateTime 存储日期, 也存储时间 &#39;YYYY-MM-DD hh:mm:ss&#39;
范围是从&#39;1000-01-01 00:00:00&amp;rsquo; to &amp;lsquo;9999-12-31 23:59:59&amp;rsquo;
TIMESTAMP 存储Unix时间戳数据 会受到服务器时区影响&amp;ndash; 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之 时区环境变量设置 范围 &amp;lsquo;1970-01-01 00:00:01&amp;rsquo; UTC to &amp;lsquo;2038-01-19 03:14:07&amp;rsquo; UTC.
相关函数:
FROM_UNIXTIME 把 Unix 时间戳转化成日期 UNIX_TIMESTAMP 把日期转化成 Unix 时间戳 YEAR 显示形式 YYYY, 可选显示位数YYYY(M)
默认4位显示 &amp;lsquo;1991&amp;rsquo; TIME 只有时间部分,没有日期部分 hh:mm:ss, 范围从 &amp;lsquo;-838:59:59&amp;rsquo; 到 &amp;lsquo;838:59:59&amp;rsquo;</description>
      <content:encoded><![CDATA[<h2 id="概览">概览</h2>
<p>Mysql 支持以下数据类型</p>
<ul>
<li>数字类型</li>
<li>串类型(字符和字节)</li>
<li>日期类型</li>
<li>空间</li>
<li>JSON</li>
</ul>
<h2 id="日期类型">日期类型</h2>
<p>Mysql 支持的数据类型</p>
<ul>
<li>DATE</li>
<li>TIME</li>
<li>DATETIME</li>
<li>TIMESTAMP</li>
<li>YEAR</li>
</ul>
<h3 id="date">Date</h3>
<p>只存储日期数据, 不包含时间. <code>YYYY-MM-DD</code>, 范围是从 &lsquo;1000-01-01&rsquo; to &lsquo;9999-12-31&rsquo;</p>
<h3 id="datetime">DateTime</h3>
<p>存储日期, 也存储时间 <code>'YYYY-MM-DD hh:mm:ss'</code></p>
<p>范围是从'1000-01-01 00:00:00&rsquo; to &lsquo;9999-12-31 23:59:59&rsquo;</p>
<h3 id="timestamp">TIMESTAMP</h3>
<ul>
<li>存储Unix时间戳数据</li>
<li>会受到服务器时区影响&ndash; 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_time_zone">时区环境变量设置</a></li>
</ul>
<p>范围 &lsquo;1970-01-01 00:00:01&rsquo; UTC to &lsquo;2038-01-19 03:14:07&rsquo; UTC.</p>
<p>相关函数:</p>
<ul>
<li>FROM_UNIXTIME 把 Unix 时间戳转化成日期</li>
<li>UNIX_TIMESTAMP 把日期转化成 Unix 时间戳</li>
</ul>
<h3 id="year">YEAR</h3>
<p>显示形式 <code>YYYY</code>, 可选显示位数<code>YYYY(M)</code></p>
<ul>
<li>默认4位显示 &lsquo;1991&rsquo;</li>
</ul>
<h3 id="time">TIME</h3>
<p>只有时间部分,没有日期部分 <code>hh:mm:ss</code>, 范围从 &lsquo;-838:59:59&rsquo; 到 &lsquo;838:59:59&rsquo;</p>
<h3 id="自动更新">自动更新</h3>
<p>DateTime 和 Timestamp 在 <strong>Mysql 8.0</strong>, 支持自动初始化和当数据更新时自动更新.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">ts</span><span class="w"> </span><span class="k">TIMESTAMP</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">UPDATE</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">dt</span><span class="w"> </span><span class="n">DATETIME</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">UPDATE</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="存储毫秒级别的时间">存储毫秒级别的时间</h3>
<p>支持存储毫秒级别的时间类型有:</p>
<ul>
<li>TIME</li>
<li>DATETIME</li>
<li>TIMESTAMP</li>
</ul>
<p>声明模式为 <code>type_name(fsp)</code>, fsp 为0-6, 表示小数点后个数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">fractest</span><span class="p">(</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="n">TIME</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="n">DATETIME</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="k">TIMESTAMP</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">VALUES</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="s1">&#39;17:51:04.777&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;2018-09-08 17:51:04.777&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;2018-09-08 17:51:04.777&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="存储空间">存储空间</h3>
<p>| 类型      | 大小    | 其他                 |
| Year      | 1 bytes |                      |
| DATE      | 3 bytes |                      |
| Time      | 3 bytes | 5.6.4 之后支持小数点 |
| Timestamp | 4 bytes | 同上                 |
| DateTime  | 8 bytes | 同上                 |</p>
<p>小数点精度的位数</p>
<p>| 0    | 0 bytes |
| 1,2  | 1 bytes |
| 3,4  | 2 bytes |
| 4,5  | 3 bytes |</p>
<h3 id="使用推荐">使用推荐</h3>
<p><em>高性能 Mysql</em> 里面总结 DateTime 和 Timestamp 的使用选择:</p>
<ul>
<li>非特殊情况, 尽量使用 timestamp, 因为空间效率更高.</li>
<li>Timestamp 不会存储时区, 而 Datetime 会存储时区</li>
<li>Timestamp 做为索引的话会更加轻量</li>
</ul>
<p>Timestamp 和 Int 的使用选择</p>
<ul>
<li>没有必要用 INT 存储, 保存时间戳. 因为没有任何收益.</li>
<li>Timestamp 可以支持数据变更时自动更新.</li>
</ul>
<h3 id="相关的一些函数">相关的一些函数</h3>
<ul>
<li>FROM_UNIXTIME 可以将 Unix 时间戳转化成日期</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">Mysql 8.0 官方文档</a>
<a href="https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html">Mysql date 内部数据结构</a>
[高性能 Mysql]</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>xorm 的 session 和 salve 的区别</title>
      <link>https://ynikl.github.io/blog/xorm-slave-newsseion/</link>
      <pubDate>Fri, 22 Jul 2022 19:08:05 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/xorm-slave-newsseion/</guid>
      <description>简单分析下xorm 里面 session 和 slave 里面 close 的代码
1 xorm.EngineGroup.Slave() Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用）） 如果这时候再调用 close 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。 如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 NewSsession 和 Close, 所以不在需要手动调用close 1 xorm.EngineGroup.NewSsession() 会返回一个xorm.Session对象, 对应我们数据库操作中的&amp;quot;会话事务&amp;quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交) 调用 close, 对清除 session 中未提交的事务和一些缓存的 sql 前置处理语句 对于普通 select 语句调不调用是没什么太大影响 (但是还是建议new之后调用close) </description>
      <content:encoded><![CDATA[<p>简单分析下xorm 里面 session 和 slave 里面 close 的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xorm.EngineGroup.Slave()
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用））</li>
<li>如果这时候再调用 <code>close</code> 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。</li>
<li>如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 <code>NewSsession</code> 和 <code>Close</code>, 所以不在需要手动调用<code>close</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xorm.EngineGroup.NewSsession()
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>会返回一个<code>xorm.Session</code>对象, 对应我们数据库操作中的&quot;会话事务&quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交)</li>
<li>调用 <code>close</code>, 对清除 session 中未提交的事务和一些缓存的 <code>sql</code> 前置处理语句</li>
<li>对于普通 <code>select</code> 语句调不调用是没什么太大影响 (但是还是建议<code>new</code>之后调用<code>close</code>)</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Make 的基本使用</title>
      <link>https://ynikl.github.io/blog/makefile-basic-use/</link>
      <pubDate>Sun, 10 Jul 2022 17:47:42 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/makefile-basic-use/</guid>
      <description>想自己整理一篇基本的 make 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.
阮一峰文章地址
如果不写 c, 主要理解就几个概念就可以使用了
target 可以用来当作想要执行的命令集的名称 .PHONY: 可以用来声明命令集名称 recipes 实际执行的命令集合 介绍一下我自己的应用场景 我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.
case 1: 简化本地编译和测试, 自动做 setup 和 teardown
当我想要尝试一下整个项目是否编译
1 2 3 4 .PHONY: build build: go build . rm -rf [PROJECT NAME] 使用上面的 makefile, 我就只需要 make build, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 build 一下
case 2: git 提交代码自动化操作
当我想要把我代码推送到, 测试分支, 进行集成测试
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .</description>
      <content:encoded><![CDATA[<p>想自己整理一篇基本的 <code>make</code> 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.</p>
<p><a href="https://www.ruanyifeng.com/blog/2015/02/make.html">阮一峰文章地址</a></p>
<p>如果不写 c, 主要理解就几个概念就可以使用了</p>
<ul>
<li>target 可以用来当作想要执行的命令集的名称</li>
<li>.PHONY:  可以用来声明命令集名称</li>
<li>recipes 实际执行的命令集合</li>
</ul>
<h2 id="介绍一下我自己的应用场景">介绍一下我自己的应用场景</h2>
<p>我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.</p>
<p>case 1: 简化本地编译和测试, 自动做 <code>setup</code> 和 <code>teardown</code></p>
<p>当我想要尝试一下整个项目是否编译</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">.</span><span class="nx">PHONY</span><span class="p">:</span> <span class="nx">build</span>
</span></span><span class="line"><span class="cl"><span class="nx">build</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">build</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rm</span> <span class="o">-</span><span class="nx">rf</span> <span class="p">[</span><span class="nx">PROJECT</span> <span class="nx">NAME</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用上面的 <code>makefile</code>, 我就只需要 <code>make build</code>, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 <code>build</code> 一下</p>
<p>case 2: git 提交代码自动化操作</p>
<p>当我想要把我代码推送到, 测试分支, 进行集成测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.PHONY: dev
</span></span><span class="line"><span class="cl">ProjectName=&#34;Your Project Name&#34;
</span></span><span class="line"><span class="cl">TargetBranch=&#34;Your want to merge branch&#34;
</span></span><span class="line"><span class="cl">CurBranch=$(shell git branch --show-current)
</span></span><span class="line"><span class="cl">dev:
</span></span><span class="line"><span class="cl">	go build .
</span></span><span class="line"><span class="cl">	rm -f $(ProjectName)
</span></span><span class="line"><span class="cl">	git add .
</span></span><span class="line"><span class="cl">	git commit -m $(msg)
</span></span><span class="line"><span class="cl">	git push
</span></span><span class="line"><span class="cl">	git checkout ${DevBranch}
</span></span><span class="line"><span class="cl">	git pull --rebase
</span></span><span class="line"><span class="cl">	git merge ${CurBranch} -m &#34;Merge branch &#39;${CurBranch}&#39; into ${DevBranch}&#34;
</span></span><span class="line"><span class="cl">	go build
</span></span><span class="line"><span class="cl">	rm -f $(ProjectName) 
</span></span><span class="line"><span class="cl">	git push
</span></span><span class="line"><span class="cl">	git checkout ${CurBranch}
</span></span></code></pre></td></tr></table>
</div>
</div><p>简化 git 的操作流程, 现在只需要<code>make dev</code>就可以完成, 还可以在合并之前和之后增加测试, 我自己目前知识简单的 <code>build</code> 下而已 QAQ.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>RabbitMQ 基本入门实践</title>
      <link>https://ynikl.github.io/blog/rabbitmq-learning-note/</link>
      <pubDate>Sat, 09 Jul 2022 16:43:26 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/rabbitmq-learning-note/</guid>
      <description>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.
介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件
消息中间件的作用
解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释
Producer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型
fanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:</description>
      <content:encoded><![CDATA[<p>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.</p>
<h2 id="介绍一下-rabbitmq">介绍一下 RabbitMQ</h2>
<p>Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件</p>
<p>消息中间件的作用</p>
<ul>
<li>解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性.</li>
<li>冗余存储: 保存失败的消息</li>
<li>拓展性</li>
<li>削峰</li>
<li>缓冲</li>
</ul>
<h3 id="结构">结构</h3>
<p>涉及的名词简单解释</p>
<ul>
<li>Producer</li>
<li>Consumer</li>
<li>Broker: 服务节点</li>
<li>Queue: 内存存储消息数据的对象</li>
<li>Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据<code>routingkey</code> 和 <code>bindingkey</code> 决定投递到哪个队列
<ul>
<li>RoutingKey: 生产消息提供<code>routingkey</code> 给交换器用于指定要投递的队列</li>
<li>BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来</li>
</ul>
</li>
<li>Connection: 客户端与 Broke 建立的 TCP 连接</li>
<li>Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接</li>
</ul>
<p>交换器的类型</p>
<ul>
<li>fanout : 投递到所有队列</li>
<li>direct: 投递到 <code>routingkey</code>  和 <code>bindingkey</code> 匹配的</li>
<li>topic: direct 的拓展, 支持模糊匹配</li>
<li>headers : 性能差, 少用</li>
</ul>
<p>消息投递流程:</p>
<ol>
<li>生产者连接到 Broker, 开启信道</li>
<li>生产者声明一个交换器</li>
<li>生产者声明一个队列</li>
<li>生产者通过路由键将交换器和队列绑定</li>
<li>生产者发送消息到 Broker</li>
<li>交换器根据接受对路由键匹配队列</li>
<li>投递到对应的消息队列</li>
<li>如果没有匹配的队列, 丢弃或者退回给生产者</li>
</ol>
<p>消费者接受消息流程:</p>
<ol>
<li>建立连接, 开启信道</li>
<li>消费者向 Broker 发起消息请求</li>
<li>Broker 回应并返回消息</li>
<li>消费者发送确认 (ack) 接受到消息</li>
<li>关闭信道</li>
<li>关闭连接</li>
</ol>
<h3 id="amqp">AMQP</h3>
<p>位于应用层的通信协议 ( 在 TCP 之上, 将数据填充到 TCP 中)</p>
<p>几个基础的协议定义的操作</p>
<ul>
<li>Protocal Header 0-9-1 指定协议</li>
<li>Connection.Start</li>
<li>Channel.Open</li>
<li>Basic.Publish 推送消息</li>
<li>Channel.Close</li>
<li>Connection.Close</li>
</ul>
<h2 id="部署">部署</h2>
<p>在你的机子上部署一个玩具吧</p>
<p>采用 docker 部署
<code>docker run -itd --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</code></p>
<p>进入管理页面
访问 http://127.0.0.1:15672/</p>
<p>登入
用户名: guest
密码: guest</p>
<p><a href="https://www.rabbitmq.com/configure.html#supported-environment-variables">更多默认配置</a></p>
<h2 id="管理">管理</h2>
<p>进入交互 shell
<code>docker exec -it rabbitmq bash</code></p>
<p>增加一个用户
<code>rabbitmqctl add_user ian ian1234</code></p>
<p>增加一个 vhost
<code>rabbitmqctl add_vhost playground</code></p>
<p>vhost是什么?
vhost (virtual host), 虚拟主机, 在实例间提供逻辑上的分离 &ndash; 实现数据隔离.
RabbitMQ 默认创建一个名为 &ldquo;/&rdquo; 的 vhost</p>
<p>查看 vhost
<code>rabbitmqctl list_vhosts</code></p>
<p>设置权限
<code>rabbitmqctl set_permissions --vhost playground ian &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></p>
<p><strong>amqp uri规则</strong>
<code>&quot;amqp://userName:password@ipAddress:portNumber/virtualHost&quot;</code>
根据我们上述的新增在用户和vhost, 可以得到uri:
<code>amqp://ian:ian1234@localhost:5672/playground</code>
5672为 rabbitmq的默认终端, 我们的 docker contain 需要把它映射到本机带端口</p>
<h2 id="实现生产者">实现生产者</h2>
<p>go 使用 <code>github.com/rabbitmq/amqp091-go</code> 包</p>
<p>根据上文的消息投递流程实现</p>
<p>连接到 broker</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">connectionUrl</span> <span class="o">:=</span> <span class="s">&#34;amqp://ian:ian1234@localhost:5672/playground&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">amqp</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">connectionUrl</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>打开 channel</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">ch</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Channel</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>声明一个交互器( 该步骤可以省略, 直接使用默认的 <code>direct</code>交换器)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">ExchangeDeclare</span><span class="p">(</span><span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="s">&#34;direct&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>声明一个队列</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">q</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">QueueDeclare</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将 Exchange 绑定到队列上 (如果声明交换器的步骤省略了, 该步骤也可以省略)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">QueueBind</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="s">&#34;hellokey&#34;</span><span class="p">,</span> <span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>发送消息 (如果没有声明交换器, 对应的参数直接传入空字符串<code>&quot;&quot;</code>, 会使用默认的 <code>direct</code> 交换器)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">Publish</span><span class="p">(</span><span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="s">&#34;hellokey&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">amqp</span><span class="p">.</span><span class="nx">Publishing</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ContentType</span><span class="p">:</span> <span class="s">&#34;text/plain&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Body</span><span class="p">:</span>        <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">body</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://github.com/ynikl/rabbitmq-demo/blob/main/cmd/producer/main.go">完整代码地址</a></p>
<p>登录到本地管理页面可以查看类似于下图, 有消息投递</p>
<p><img loading="lazy" src="/rabbitmq-producer-manager-pic-20220704.png" alt="生产消息成功"  />
</p>
<h2 id="实现消费者">实现消费者</h2>
<p>消费者相对于生产者就简单多了.
打开信道直接消费就可以了.</p>
<p>连接, 打开信道</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">connectionUrl</span> <span class="o">:=</span> <span class="s">&#34;amqp://ian:ian1234@localhost:5672/playground&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">amqp</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">connectionUrl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Channel</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>开始消费</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="c1">// msgsCh 是一个消息管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">msgsCh</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">Consume</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="s">&#34;consumer-name&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">msgsCh</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;received a message: &#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Body</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done, msg channel is closed&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/rabbitmq-receive-success-20220709.png" alt="消费成功"  />
</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.rabbitmq.com/tutorials/tutorial-one-go.html">官网 tutorial</a></li>
<li><a href="https://book.douban.com/subject/27591386/">RabbitMQ 实战指南</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Life Is Not Short</title>
      <link>https://ynikl.github.io/posts/life-is-not-short/</link>
      <pubDate>Fri, 01 Jul 2022 08:55:44 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/life-is-not-short/</guid>
      <description>The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.
life if not short</description>
      <content:encoded><![CDATA[<blockquote>
<p>The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.</p>
</blockquote>
<p><a href="https://dkb.show/post/life-is-not-short">life if not short</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>我理解的微服务 -- 读《微服务设计模式》总结</title>
      <link>https://ynikl.github.io/books/miscroservices-patterns/</link>
      <pubDate>Sun, 19 Jun 2022 22:20:56 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/miscroservices-patterns/</guid>
      <description>微服务是针对公司某一复杂业务程序实现的设计模式, 与巨石架构(Monolith)是相对的.
微服务对应的应该是公司业务能力层级上的拆分与设计, 为了减少业务之间的耦合而导致相互拖累, 在对外业务能力不变的情况下, 在应用内部将能力拆分成一些微小服务. 也可以理解为是对巨石架构进行&amp;quot;解耦&amp;quot;.
举个例子: 原先公司做的是一个外卖系统, 这个系统中可能包含了客户下单, 商家接单, 骑手配送等功能. 但是全部都打包在一个程序中. 发版时, 可能客户下单功能修改了功能, 导致商家没办法接单了. 或者商家接单功能实现的有问题, 导致整个应用程序挂掉, 现在用户下不了单, 骑手也没法接单, 整个公司的业务就瘫痪了. 然后, 在客户下单-商家接单-骑手配送这个大业务流程不变的情况下, 我们在外卖系统内部, 分成了多个服务, 各个服务之间使用 API 松耦合通信, 隔离影响. 比如, 客户下单服务, 专门处理客户下单这一业务, 并将生成的订单推送到消息代理 (如:kafka) 或直接推送给其他服务等, 它只要能保证完成它的职责即可. 后者, 就可以称之为 &amp;ldquo;微服务架构&amp;rdquo;. 当然, 这只是一个例子, 实际情况会更加复杂.
在&amp;laquo;微服务设计模式&amp;raquo; 中对微服务的定义:
将应用程序构建为松耦合, 可独立部署的一组服务
书中也对&amp;quot;微&amp;quot;的大小给了定义:
大小的定义为能够由小团队开发服务
不用刻意地去追求服务的大小. 微服务的落地, 往往就会伴随着, 组织结构和开发的流程的改变, 由不同的 小团队 独立负某一服务.
像我们现在如果提到微服务, 就经常也会提到一些微服务框架 go-zero, go-micro 或者基础设施 docker, k8s 或者工具 gRPC, prometheus 之类的.
像这种框架和组件之类的只是一种技术工具. 他们并不能定义微服务, 他们可能只是为了克服微服务架构设计带来的某一些缺陷, 或者与微服务结合可以发挥出更大的价值.</description>
      <content:encoded><![CDATA[<p>微服务是针对公司某一复杂业务程序实现的设计模式, 与巨石架构(Monolith)是相对的.</p>
<p>微服务对应的应该是公司业务能力层级上的拆分与设计, 为了减少业务之间的耦合而导致相互拖累, 在对外业务能力不变的情况下, 在应用内部将能力拆分成一些微小服务. 也可以理解为是对巨石架构进行&quot;解耦&quot;.</p>
<p>举个例子: 原先公司做的是一个外卖系统, 这个系统中可能包含了客户下单, 商家接单, 骑手配送等功能. 但是全部都打包在一个程序中. 发版时, 可能客户下单功能修改了功能, 导致商家没办法接单了. 或者商家接单功能实现的有问题, 导致整个应用程序挂掉, 现在用户下不了单, 骑手也没法接单, 整个公司的业务就瘫痪了. 然后, 在客户下单-商家接单-骑手配送这个大业务流程不变的情况下, 我们在外卖系统内部, 分成了多个服务, 各个服务之间使用 API 松耦合通信, 隔离影响. 比如, 客户下单服务, 专门处理客户下单这一业务, 并将生成的订单推送到消息代理 (如:kafka) 或直接推送给其他服务等, 它只要能保证完成它的职责即可. 后者, 就可以称之为 &ldquo;微服务架构&rdquo;. 当然, 这只是一个例子, 实际情况会更加复杂.</p>
<p>在&laquo;微服务设计模式&raquo; 中对微服务的定义:</p>
<blockquote>
<p>将应用程序构建为松耦合, 可独立部署的一组服务</p>
</blockquote>
<p>书中也对&quot;微&quot;的大小给了定义:</p>
<blockquote>
<p>大小的定义为能够由小团队开发服务</p>
</blockquote>
<p>不用刻意地去追求服务的大小. 微服务的落地, 往往就会伴随着, 组织结构和开发的流程的改变, 由不同的 <strong>小团队</strong> 独立负某一服务.</p>
<p>像我们现在如果提到微服务, 就经常也会提到一些微服务框架 go-zero, go-micro 或者基础设施 docker, k8s 或者工具 gRPC, prometheus 之类的.</p>
<p>像这种框架和组件之类的只是一种技术工具. 他们并不能定义微服务, 他们可能只是为了克服微服务架构设计带来的某一些缺陷, 或者与微服务结合可以发挥出更大的价值.</p>
<p>举个极端的例子: 在你后端业务完全不划分的情况下, 你甚至可以在 go-zero 的框架基础上, 将你公司所有的业务打包进一个应用程序, 用docker打包, 并部署在k8s环境中, 再通过 gRPC 与前端通信. 你用到了很多著名的名词技术, 但是你实现出来应用的是巨石架构还是微服务架构呢?</p>
<h2 id="参考">参考</h2>
<p><a href="https://book.douban.com/subject/33425123">微服务设计模式</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>什么是 &#34;胶水代码&#34;</title>
      <link>https://ynikl.github.io/blog/what-is-glue-code/</link>
      <pubDate>Sat, 18 Jun 2022 20:04:38 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/what-is-glue-code/</guid>
      <description>胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 连接 两个 不兼容 的组件, 或是两个不兼容的服务.
胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.
参考 Quora 回答 wiki</description>
      <content:encoded><![CDATA[<p>胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 <strong>连接</strong> 两个 <strong>不兼容</strong> 的组件, 或是两个不兼容的服务.</p>
<p>胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.</p>
<h2 id="参考">参考</h2>
<p><a href="https://www.quora.com/What-is-glue-code">Quora 回答</a>
<a href="https://en.wikipedia.org/wiki/Glue_code">wiki</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go中slice[i:j:k]第三个参数是做什么的</title>
      <link>https://ynikl.github.io/blog/golang-reslicing-slice/</link>
      <pubDate>Thu, 09 Jun 2022 23:52:30 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-reslicing-slice/</guid>
      <description>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.
简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:
1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:
array 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址
简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, &amp;ldquo;左闭右开原则&amp;rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即&amp;quot;cap(a) - low&amp;quot; low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt.</description>
      <content:encoded><![CDATA[<p>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.</p>
<h2 id="简单介绍-slice-的数据结构">简单介绍 slice 的数据结构</h2>
<p>首先, 介绍一下 golang 中切片的结构体:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type slice struct {
</span></span><span class="line"><span class="cl">	array unsafe.Pointer
</span></span><span class="line"><span class="cl">	len   int
</span></span><span class="line"><span class="cl">	cap   int
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>有三个字段:</p>
<ul>
<li>array 是切片所指向的底层数组数据</li>
<li>len 就是切片的长度</li>
<li>cap 即容量, 很明显</li>
</ul>
<p><a href="https://cs.opensource.google/go/go/+/master:src/runtime/slice.go;l=15?q=slice&amp;ss=go%2Fgo">源码地址</a></p>
<h2 id="简单版重切片-alowhigh">简单版重切片 <code>a[low:high]</code></h2>
<ul>
<li>接受切片中的开始下标和结束下标, &ldquo;左闭右开原则&rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值</li>
<li>新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即&quot;cap(a) - low&quot;</li>
<li>low 参数可以省略, 默认从 0 下标开始</li>
<li>high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [10]int{}
</span></span><span class="line"><span class="cl">oldSlice := a[:5]
</span></span><span class="line"><span class="cl">newSlice := a[2:4]
</span></span><span class="line"><span class="cl">fmt.Printf(&#34;b: len %d, cap %d, c: len %d, c:cap %d&#34;, len(b), cap(b), len(c), cap(c))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">输出:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b: len 5, cap 10, c: len 2, c:cap 8
</span></span></code></pre></td></tr></table>
</div>
</div><p>底层分配情况如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">底层数组       : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">旧切片容量: 10 : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">旧切片长度: 5  : [0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">新切片容量: 8  :     [0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">新切片长度: 2  :     [0 0]
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="完整版重切片-alowhighmax">完整版重切片 <code>a[low:high:max]</code></h2>
<p>完整版是为了补充简单版, 新切片会默认拥有从开始下标后的所有底层数组容量. 即新数组拥有修改全部数据底层能力 (<strong>重切片出来的不同切片, 在没有 append 操作触发重新分配底层数组的前提下, 指向的都是同一个数据, 修改数据相互可见</strong>)</p>
<ul>
<li>增加了 max 参数, 表示新切片可以获取到最大的原切片的容量大小.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [10]int{}
</span></span><span class="line"><span class="cl">oldSlice := a[:5]
</span></span><span class="line"><span class="cl">newSlice := a[2:4:6]
</span></span><span class="line"><span class="cl">fmt.Printf(&#34;b: len %d, cap %d, c: len %d, c:cap %d&#34;, len(b), cap(b), len(c), cap(c))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">输出:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b: len 5, cap 10, c: len 2, c:cap 4
</span></span></code></pre></td></tr></table>
</div>
</div><p>底层分配情况如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">底层数组       : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">旧切片容量:10  : [0 0 0 0 0 0 0 0 0 0] 
</span></span><span class="line"><span class="cl">旧切片长度:5   : [0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">新切片容量:4   :     [0 0 0 0] 
</span></span><span class="line"><span class="cl">新切片长度:2   :     [0 0]
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是, 如果 max 要求获取的容量大于旧数据容量. 可想而知, 那一定会 <code>panic</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[:</span><span class="mi">4</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">输出</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">panic</span><span class="p">:</span> <span class="nx">runtime</span> <span class="kt">error</span><span class="p">:</span> <span class="nx">slice</span> <span class="nx">bounds</span> <span class="nx">out</span> <span class="nx">of</span> <span class="k">range</span> <span class="p">[::</span><span class="mi">5</span><span class="p">]</span> <span class="nx">with</span> <span class="nx">capacity</span> <span class="mi">4</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以参数要求: <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/27938177/golang-slice-slicing-a-slice-with-sliceabc">stack overflow 问题1 简单版</a></li>
<li><a href="https://stackoverflow.com/questions/12768744/re-slicing-slices-in-golang/18911267#18911267">stack overflow 问题2 详细版</a></li>
<li><a href="https://go.dev/ref/spec#Slice_expressions">golang 官方文档</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>我们为何选择 XXX 技术方案</title>
      <link>https://ynikl.github.io/posts/thinking-choosing-tech/</link>
      <pubDate>Wed, 08 Jun 2022 20:15:26 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/thinking-choosing-tech/</guid>
      <description>一个完善的方案的需要考虑的三个方面
当前需求 理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。
结果上下文 好处：当前方案的好处，解决了什么 弊端: 什么是它不能解决的 问题：引入什么新的问题 与其他方案的关系 前导：当前方案是怎么演变出来。 后续：当前方案会引入什么新问题，有什么后续的解决方案 替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案 参考《微服务设计模式》的1.6.2&amp;quot;模式和模式语言&amp;quot;, 相对减少了模式关系中的泛化和特化。</description>
      <content:encoded><![CDATA[<p>一个完善的方案的需要考虑的三个方面</p>
<ol>
<li>当前需求</li>
</ol>
<p>理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。</p>
<ol start="2">
<li>结果上下文</li>
</ol>
<ul>
<li>好处：当前方案的好处，解决了什么</li>
<li>弊端: 什么是它不能解决的</li>
<li>问题：引入什么新的问题</li>
</ul>
<ol start="3">
<li>与其他方案的关系</li>
</ol>
<ul>
<li>前导：当前方案是怎么演变出来。</li>
<li>后续：当前方案会引入什么新问题，有什么后续的解决方案</li>
<li>替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案</li>
</ul>
<p>参考《微服务设计模式》的1.6.2&quot;模式和模式语言&quot;, 相对减少了模式关系中的泛化和特化。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>设计模式 -- 策略模式</title>
      <link>https://ynikl.github.io/blog/strategy-pattern/</link>
      <pubDate>Wed, 08 Jun 2022 19:50:42 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/strategy-pattern/</guid>
      <description>场景 在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.
比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.
分析 优点:
将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象 在不同策略之间划清界限 增加单独策略的可测试性 缺点:
后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动 会带来的问题:
可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力 总结:
在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).
实现流程 主要的思想, 我觉得还是 面向接口编程
分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(interface) 将算法或策略剥离成独立的策略对象, 并实现上述抽象接口 主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略&amp;quot;插入&amp;quot;(plugin)流程, 调用, 获取结果, ok. 参考 refactoringguru - strategy </description>
      <content:encoded><![CDATA[<h2 id="场景">场景</h2>
<p>在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.</p>
<p>比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.</p>
<h2 id="分析">分析</h2>
<p>优点:</p>
<ul>
<li>将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象</li>
<li>在不同策略之间划清界限</li>
<li>增加单独策略的可测试性</li>
</ul>
<p>缺点:</p>
<ul>
<li>后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动</li>
</ul>
<p>会带来的问题:</p>
<ul>
<li>可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力</li>
</ul>
<p>总结:</p>
<p>在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).</p>
<h2 id="实现流程">实现流程</h2>
<p>主要的思想, 我觉得还是 <strong>面向接口编程</strong></p>
<ol>
<li>分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(<strong>interface</strong>)</li>
<li>将算法或策略剥离成独立的策略对象, 并实现上述抽象接口</li>
<li>主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略&quot;插入&quot;(plugin)流程, 调用, 获取结果, ok.</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/strategy">refactoringguru - strategy</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linked List</title>
      <link>https://ynikl.github.io/dsa/linked-list/</link>
      <pubDate>Mon, 06 Jun 2022 19:18:31 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/dsa/linked-list/</guid>
      <description>链表的定义： wiki 百科给出定义:
In computer science, a linked list is a linear collection of data elemetns whose order is not given by their physical placement in memory. Instead, each element points to the next.
翻译一下：
一个线性表 每个元素会指向下一个元素的位置 链表的优缺点 优点:
不需要提前分配内存 在查找到元素位置的提前下，插入和删除动作是一个常量，即 O(1) 没有容量上限，可以自由扩容 缺点:
查询某个元素，需要从头开始遍历，即 O(n) 实现代码
单向链表 最普通的链表
双向链表 循环链表 </description>
      <content:encoded><![CDATA[<h2 id="链表的定义">链表的定义：</h2>
<p>wiki 百科给出定义:</p>
<blockquote>
<p>In computer science, a linked list is a linear collection of data elemetns whose order is not given by their physical placement in memory. Instead, each element points to the next.</p>
</blockquote>
<p>翻译一下：</p>
<ul>
<li>一个线性表</li>
<li>每个元素会指向下一个元素的位置</li>
</ul>
<h2 id="链表的优缺点">链表的优缺点</h2>
<p>优点:</p>
<ul>
<li>不需要提前分配内存</li>
<li>在查找到元素位置的提前下，插入和删除动作是一个常量，即 O(1)</li>
<li>没有容量上限，可以自由扩容</li>
</ul>
<p>缺点:</p>
<ul>
<li>查询某个元素，需要从头开始遍历，即 O(n)</li>
</ul>
<p><a href="https://github.com/ynikl/dsa/blob/main/linked-list.go">实现代码</a></p>
<h2 id="单向链表">单向链表</h2>
<p>最普通的链表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"></code></pre></td></tr></table>
</div>
</div><h2 id="双向链表">双向链表</h2>
<h2 id="循环链表">循环链表</h2>
]]></content:encoded>
    </item>
    
    <item>
      <title>基础数据结构列表</title>
      <link>https://ynikl.github.io/dsa/datastructures-list/</link>
      <pubDate>Sun, 05 Jun 2022 21:40:30 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/dsa/datastructures-list/</guid>
      <description>github code
非科班出身的我，有好几次尝试过跟着国外大学的课程重新学习计算机基础， 但是每次都是半途放弃了，这次尝试根据数据结构主题进行学习。
主流的数据结构类型
Linked List（链表） List （线性表） 2D Arrays Strings（串） Stack （栈） Queue（队列） Hash Table（哈希表） Heap （堆） Tree （树） Graphs（图） Binary Tree Binary Search Tree </description>
      <content:encoded><![CDATA[<p><a href="https://github.com/ynikl/dsa">github code</a></p>
<p>非科班出身的我，有好几次尝试过跟着国外大学的课程重新学习计算机基础，
但是每次都是半途放弃了，这次尝试根据数据结构主题进行学习。</p>
<p><strong>主流的数据结构类型</strong></p>
<ul>
<li><a href="">Linked List（链表）</a></li>
<li>List （线性表）</li>
<li>2D Arrays</li>
<li>Strings（串）</li>
<li>Stack （栈）</li>
<li>Queue（队列）</li>
<li>Hash Table（哈希表）</li>
<li>Heap （堆）</li>
<li>Tree （树）</li>
<li>Graphs（图）</li>
<li>Binary Tree</li>
<li>Binary Search Tree</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>计算机中的：大端和小端</title>
      <link>https://ynikl.github.io/blog/endianness/</link>
      <pubDate>Sat, 04 Jun 2022 00:19:23 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/endianness/</guid>
      <description>大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”
大端的优势是高位计算，和可读性 小端的优势的低位运算 各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。
以上是阅读阮一峰的博文-字节序探析：大端与小端的比较的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。
参考连接 阮一峰的博文-字节序探析：大端与小端的比较 </description>
      <content:encoded><![CDATA[<p>大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”</p>
<ul>
<li>大端的优势是高位计算，和可读性</li>
<li>小端的优势的低位运算</li>
</ul>
<p>各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。</p>
<p>以上是阅读<a href="https://www.ruanyinfeng.com/blog/2022/06/endianness-analysis.html">阮一峰的博文-字节序探析：大端与小端的比较</a>的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。</p>
<h2 id="参考连接">参考连接</h2>
<ul>
<li><a href="https://www.ruanyinfeng.com/blog/2022/06/endianness-analysis.html">阮一峰的博文-字节序探析：大端与小端的比较</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>小窥 Go 中的 Modules</title>
      <link>https://ynikl.github.io/blog/go-modules/</link>
      <pubDate>Fri, 03 Jun 2022 18:16:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/go-modules/</guid>
      <description>是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =&amp;gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 &amp;gt; cat go.</description>
      <content:encoded><![CDATA[<h2 id="是什么">是什么</h2>
<p>Modules （下文称为模块）是 Go 语言设计用来管理依赖包。</p>
<p>在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。</p>
<p>模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在<code>go.mod</code>文件中。</p>
<h3 id="gomod-文件">go.mod 文件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-v" data-lang="v"><span class="line"><span class="cl"><span class="kn">module</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">my</span><span class="o">/</span><span class="nv">thing</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">go</span> <span class="mf">1.12</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">require</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">other</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.0.2</span>
</span></span><span class="line"><span class="cl"><span class="nv">require</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">new</span><span class="o">/</span><span class="nv">thing</span><span class="o">/</span><span class="nv">v2</span> <span class="nv">v2</span><span class="mf">.3.4</span>
</span></span><span class="line"><span class="cl"><span class="nv">exclude</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">old</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.2.3</span>
</span></span><span class="line"><span class="cl"><span class="nv">replace</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">bad</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.4.5</span> <span class="o">=</span><span class="p">&gt;</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">good</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.4.5</span>
</span></span><span class="line"><span class="cl"><span class="nv">retract</span> <span class="p">[</span><span class="na">v1</span><span class="err">.</span><span class="na">9</span><span class="err">.</span><span class="na">0</span><span class="err">,</span> <span class="na">v1</span><span class="err">.</span><span class="na">9</span><span class="err">.</span><span class="na">5</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>文件中各行意思</p>
<ul>
<li>module 当前自己模块的名的完整路径</li>
<li>go 版本号</li>
<li>require 需要依赖的目标模块以及最小的版本号</li>
<li>exclude 排除目标模块的特定版本</li>
<li>replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块</li>
<li>retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况</li>
</ul>
<p><code>go.mod</code> 可以通过相关命令修改，也可以直接修改文件数据</p>
<h3 id="gosum-文件">go.sum 文件</h3>
<p>与<code>go.mod</code>经常在一起的会是一个<code>go.sum</code>文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; cat go.sum
</span></span><span class="line"><span class="cl">example.com/mod v1.0.0 h1:6Cz1EhbAk54HWaw6fhCpSPxWGjIMLuF9MlO4Ou568sQ=
</span></span><span class="line"><span class="cl">example.com/mod v1.0.0/go.mod h1:mgm3p5SY7FVOgVLVSXIYK9qk0umwLQLOG06xLpFUeTI=
</span></span></code></pre></td></tr></table>
</div>
</div><p>文件中以：模块路径 + 版本号 + hash算法名 + hash值 的组合写入</p>
<ul>
<li><code>example.com/mod</code> 是模块路径名</li>
<li>v1.0.0 是版本号，在第二行有是以<code>/go.mod</code>结尾，代表该 hash 值是对依赖模块本身的<code>go.mod</code>文件的 hash 值</li>
<li>h1: 代表使用的 hash 算法，代表 SHA-256</li>
<li>哈希值，没什么好说的了</li>
</ul>
<h3 id="module-cache">Module cache</h3>
<p>本地的目录，用户存放下载下来的的模块文件。</p>
<p>默认路径是在<code>$GOPAth/pkg/mod</code></p>
<p><a href="https://go.dev/ref/mod#module-cache">Module cache 文件夹详细说明</a></p>
<h3 id="语义化版本">语义化版本</h3>
<p>go 采用语义化版本 v1.18.1</p>
<p>一个模块的版本是不变的 —— 只要拉过一次模块，该模块就会存在缓存在<a href="https://proxy.golang.org/">Go 官方的模块服务</a>中，以后拉取改模块就会从官方的模块服务拉取，且该动作不可逆。</p>
<p>版本号 = &ldquo;v&rdquo; + 主版本号 + 小版本号 + 补丁号</p>
<ul>
<li>主版本号的增加后，小版本号和补丁号要重新置零。主版本号增加，代表该版本出现不向后兼容的改动。比如移除旧的包</li>
<li>小版本号增加后，补丁号重新置零。表示版本改动公共接口但是向后兼容的，比如增加一个函数</li>
<li>补丁号增加，表示该版本对公开接口没有改动。比如修改bug</li>
</ul>
<p>版本的后面可能还会增加一些提前发布的标识，比如 v1.18.1-beta v1.18.1-pre</p>
<p>当 go 的 模块没有声明发布版本的时候(比如拉取某分支做为模块)，go 就会自己生成 <a href="https://go.dev/ref/mod#pseudo-versions">伪版本</a>, 可以仅作了解。</p>
<p><strong>如果使用模块的版本号大于等于v2的时候，需要在引入包的后缀加上<code>/v2</code></strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import &#34;github.com/urfave/cli/v2&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="怎么用">怎么用</h2>
<h3 id="开启模块功能">开启模块功能</h3>
<p>模块功能的开启, 配置在环境变量<code>GO111MODULE</code></p>
<ul>
<li>=off, 忽略<code>GOPATH</code>路径下的<code>go.mod</code>文件，直接引用<code>GOPATH/src</code>中的包文件</li>
<li>=on，启用模块功能</li>
<li>=auto, 如果项目有<code>go.mod</code>文件启用，没有则是用<code>GOPATH</code>模式</li>
</ul>
<h3 id="常用命令快览">常用命令快览</h3>
<p><strong>go mod</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod init example.com/example/m1
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化当前文件夹，让其成为一个 module</p>
<p><strong>go get</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get -d example.com/example/m1@v1.2.3
</span></span></code></pre></td></tr></table>
</div>
</div><p>主要用法:修改当前项目的<code>go.mod</code>，引入新的依赖项目。</p>
<p><code>-d</code> 的标志，表示获取目标包之后，不进行本地编译或安装。Go 1.18 之后的默认行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get -d -u example.com/example/m1
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以用来升级依赖模块的版本，升级到最新版本。如果目标模块的新版的所依赖的其他模块也可能会一并升级。也可以指定版本<code>-u=patch</code></p>
<p>修改制定依赖版本的操作也可以通过制定后缀版本号实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get example.com/example/m1@v2.3.1
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>go mod edit</strong></p>
<p>通过指令修改<code>go.mod</code>文件，与直接修改<code>go.mod</code>效果一致</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod edit -replace example.com/a@v1.0.0=./a
</span></span></code></pre></td></tr></table>
</div>
</div><p>将某个模块引用指向本地。可以用来解决引用正在开发中，还没有发布过的模块</p>
<p><strong>go mod tidy</strong></p>
<p>根据项目的源码引用整理<code>go.mod</code>中的引用情况。添加缺少的依赖，或者移除冗余的依赖。</p>
<p><strong>go mod vendor</strong></p>
<p>将依赖一并放在自己项目的中，可以省去自己拉取依赖的很多麻烦，提高可用性。go 项目的根目录中的 vendor 文件夹就是用来干这个事的</p>
<p>将项目依赖移入<code>vendor</code>文件中，当存在了vendor文件夹，项目会使用vendor中的依赖。大于 1.14 版本需要指定参数<code>-mod=vendor</code>才会启用</p>
<p>本地修改之后模块版本之后需要，重新使用<code>go mod vendor</code>将新的依赖模块同步入<code>vendor</code>中。</p>
<p><strong>go mod verify</strong></p>
<p>用于检测模块再被下载之后入，模块中的代码是否有被修改过。</p>
<p>对源码文件的 hash，与当前文件的<code>go.sum</code>中的 hash 对比校验是否有被修改过。
如果<code>go.sum</code>中没有该模块的hash值，就会从<a href="https://sum.golang.org">checksum database</a> 中获取目标 hash 值。（除非设置了<code>GOPRIVATE</code>或者<code>GONOSUMDB</code>)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">❯ go mod verify
</span></span><span class="line"><span class="cl">github.com/ynikl/playmod v1.0.0: dir has been modified (/Users/ian/go/pkg/mod/github.com/ynikl/playmod@v1.0.0)
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述例子，源文件被我手动强制修改过，就会报错</p>
<p><strong>go mod why</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod why example.com/mod
</span></span></code></pre></td></tr></table>
</div>
</div><p>用于解释当前项目为什么会依赖某一个模块，输出项目对目标模块的依赖树图</p>
<p><strong>go list -m all</strong></p>
<p>可以用于输出当前项目依赖的所有模块</p>
<h3 id="mvs">MVS</h3>
<p><em>Minimal version selection</em>（MVS), 当引入的不同模块，又存在依赖与相同模块的（相同大版本，不同版本小版本）的时候。</p>
<p>在使用模块相关命令的时候，会选择所依赖的不同版本的中，构建项目所需要从最小版本。</p>
<p><img loading="lazy" src="mvs.png" alt="图片来源于官网"  />
</p>
<p>A.12 与 B1.2 分别需要 C1.3 和 C1.4 为了是项目能正常进行，需要使用 C1.4 版本</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://go.dev/ref/mod">官网Go Modules参考</a></li>
<li><a href="https://research.swtch.com/vgo-mvs">Minimal Version Seletion</a></li>
<li><a href="https://go.dev/blog/modules2019">官方介绍 Modules 博文</a></li>
<li><a href="https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#checksum-database">提议</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql 不支持事务嵌套</title>
      <link>https://ynikl.github.io/blog/mysql-nested-transactions/</link>
      <pubDate>Thu, 02 Jun 2022 16:16:58 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/mysql-nested-transactions/</guid>
      <description>mysql 在事务中再开启事务，前一个事务会被自动提交
stackoverflow</description>
      <content:encoded><![CDATA[<p>mysql 在事务中再开启事务，前一个事务会被自动提交</p>
<p><a href="https://stackoverflow.com/questions/1306869/are-nested-transactions-allowed-in-mysql">stackoverflow</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>并发与并行的区别</title>
      <link>https://ynikl.github.io/blog/concurrency-and-parallelism/</link>
      <pubDate>Tue, 31 May 2022 22:36:34 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/concurrency-and-parallelism/</guid>
      <description>举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。
并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构
并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。
Concurrency is not Parallelism by Rob Pike</description>
      <content:encoded><![CDATA[<p>举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。</p>
<p>并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构</p>
<p>并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。</p>
<p><a href="https://www.youtube.com/watch?v=oV9rvDllKEg&amp;list=WL&amp;index=5&amp;t=9s">Concurrency is not Parallelism by Rob Pike</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何做决定——遗憾最小化</title>
      <link>https://ynikl.github.io/posts/how-make-decisions/</link>
      <pubDate>Mon, 30 May 2022 19:17:51 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/how-make-decisions/</guid>
      <description>读Randy&amp;rsquo;s的博客遗憾最小化框架有感
在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定
做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾
Jeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。
Bezos的视频地址 Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁
Ask yourself: in 10 years from now, will you be proud of having done this? &amp;hellip; Do things that your future self will be proud, is my motto for the time being.</description>
      <content:encoded><![CDATA[<p>读Randy&rsquo;s的博客<a href="https://lutaonan.com/blog/regret-minimization-framework/">遗憾最小化框架</a>有感</p>
<p><em>在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定</em></p>
<p><strong>做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾</strong></p>
<blockquote>
<p>Jeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。</p>
</blockquote>
<p><a href="https://www.youtube.com/watch?v=jwG_qR6XmDQ&amp;ab_channel=MickyThompson">Bezos的视频地址</a>
Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁</p>
<blockquote>
<p>Ask yourself: in 10 years from now, will you be proud of having done this? &hellip; Do things that your future self will be proud, is my motto for the time being.</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go-互斥锁的实现</title>
      <link>https://ynikl.github.io/blog/golang-sync_mutex/</link>
      <pubDate>Sun, 29 May 2022 20:52:35 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-sync_mutex/</guid>
      <description>Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法
Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。
Mutex 实现了一个 sync.Locker 接口, 该接口只有两个方法
Lock Unlock Mutex 锁有几种状态
mutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量
mutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态</description>
      <content:encoded><![CDATA[<h2 id="mutex-数据结构">Mutex 数据结构</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">state</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sema</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Mutex 使用过之后是不可被拷贝的</li>
<li>state 等于 0 值的时候才是无锁的状态</li>
<li>sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。</li>
</ul>
<p>Mutex 对象总共有三个公开方法</p>
<ul>
<li>Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞</li>
<li>TryLock</li>
<li>Unlock 解除互斥锁， <strong>解锁未锁定的互斥锁会发生panic</strong></li>
</ul>
<p>Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。</p>
<p>Mutex 实现了一个 <code>sync.Locker</code> 接口, 该接口只有两个方法</p>
<ul>
<li>Lock</li>
<li>Unlock</li>
</ul>
<p>Mutex 锁有几种状态</p>
<ul>
<li>mutexLocked = 1 已经锁定</li>
<li>mutexWoken = 2  表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量</li>
<li>mutexStarving = 4 当前锁已经进入了饥饿状态</li>
</ul>
<p>其他常量</p>
<ul>
<li>mutexWaiterShift = 3 统计的等待在<code>Mutex.state</code>字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving）</li>
<li>starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms</li>
</ul>
<h2 id="mutex-锁的竞争方式">Mutex 锁的竞争方式</h2>
<p>Mutex 锁有两种状态</p>
<ul>
<li>正常模式 normal</li>
<li>饥饿模式 starvation</li>
</ul>
<p>正常模式下，等待获取的锁的协程遵循先进先出的原则。</p>
<p>但是，当释放锁的时候如果有新协程进入获取锁代码的时候。因为新入协程本身已经运行在CPU上了，所以有抢占锁的优势。由于阻塞在等待队列上的协程，竞争不过新入协程。当等待时间操作 1ms，就会触发饥饿模式。</p>
<p>饥饿模式，进行互斥锁解锁的协程直接的将锁的所有权直接已经给等待队列的第一个协程。新进协程被禁止抢占互斥锁。</p>
<p>在转移所有权的时候，如果满足一下任意条件，则进入正常模式：</p>
<ul>
<li>锁的等待者只剩最后一个</li>
<li>等待时间小于1ms</li>
</ul>
<p>正常模式有利于更好的性能，饥饿模式则避免出现“饿死”情况。</p>
<h2 id="mutex-的方法详解">Mutex 的方法详解</h2>
<h3 id="lock">Lock</h3>
<p>第一步，通过调用 atomic 的 CAS 操作，尝试加锁，如果成功加锁直接返回</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked)
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果第一步失败，则代表该锁已经被加过锁，锁定了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Mutex) lockSlow() {
</span></span><span class="line"><span class="cl">	// 当前协程的变量, 可以用于表示当前协程的状态
</span></span><span class="line"><span class="cl">	// 用于统计锁的等待时长，是否进入饥饿模式
</span></span><span class="line"><span class="cl">	var waitStartTime int64
</span></span><span class="line"><span class="cl">	starving := false // 当前协程是否处于饥饿
</span></span><span class="line"><span class="cl">	awoke := false // 是否处于唤醒
</span></span><span class="line"><span class="cl">	iter := 0 // 统计自旋次数
</span></span><span class="line"><span class="cl">	old := m.state
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		// 进入自旋的状态条件， **已经锁定** 且非饥饿状态。
</span></span><span class="line"><span class="cl">		if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
</span></span><span class="line"><span class="cl">			// 如果锁的状态 woken 字段未被标记， 将自身标记位唤醒，且将 Mutex 的 woken 位标记位1
</span></span><span class="line"><span class="cl">			// 当协程自己进入获取锁的第一候选人
</span></span><span class="line"><span class="cl">			if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
</span></span><span class="line"><span class="cl">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
</span></span><span class="line"><span class="cl">				awoke = true
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			runtime_doSpin()
</span></span><span class="line"><span class="cl">			// 控制自旋次数，大于4次之后不进入自旋状态
</span></span><span class="line"><span class="cl">			iter++
</span></span><span class="line"><span class="cl">			// 获取最新的状态
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">			continue
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 有可能，自旋自后已经解锁或者只是单纯不能自旋限制了。下面尝试通过 CAS 竞争锁。
</span></span><span class="line"><span class="cl">		// 新值用于设置新的状态
</span></span><span class="line"><span class="cl">		new := old
</span></span><span class="line"><span class="cl">		// 非饥饿状态才设置锁定
</span></span><span class="line"><span class="cl">		if old&amp;mutexStarving == 0 {
</span></span><span class="line"><span class="cl">			new |= mutexLocked
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if old&amp;(mutexLocked|mutexStarving) != 0 {
</span></span><span class="line"><span class="cl">			// 等待者加1
</span></span><span class="line"><span class="cl">			new += 1 &lt;&lt; mutexWaiterShift
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 当前协程是饥饿状态，尝试标记锁的新状态位饥饿状态。
</span></span><span class="line"><span class="cl">		if starving &amp;&amp; old&amp;mutexLocked != 0 {
</span></span><span class="line"><span class="cl">			new |= mutexStarving
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if awoke {
</span></span><span class="line"><span class="cl">			// The goroutine has been woken from sleep,
</span></span><span class="line"><span class="cl">			// so we need to reset the flag in either case.
</span></span><span class="line"><span class="cl">			if new&amp;mutexWoken == 0 {
</span></span><span class="line"><span class="cl">				// Mutex 的唤醒位被抢走，出现不一致。协程变量的唤醒位应该与 Mutex 的唤醒位一致
</span></span><span class="line"><span class="cl">				throw(&#34;sync: inconsistent mutex state&#34;)
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// 标志 锁的唤醒位为0
</span></span><span class="line"><span class="cl">			new &amp;^= mutexWoken
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// CAS 尝试, Mutex 状态没有被变更
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
</span></span><span class="line"><span class="cl">			// 非饥饿状态下，CAS 成功新的 new 字段中会有 mutexLocked 标记（在new下的第一个if）。当前协程获取到了互斥锁,
</span></span><span class="line"><span class="cl">			if old&amp;(mutexLocked|mutexStarving) == 0 {
</span></span><span class="line"><span class="cl">				break // locked the mutex with CAS
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// queueLifo 表示该协程是否为第一次获取锁。如果中间被唤醒过，这放在等待队列头部
</span></span><span class="line"><span class="cl">			queueLifo := waitStartTime != 0
</span></span><span class="line"><span class="cl">			if waitStartTime == 0 {
</span></span><span class="line"><span class="cl">				waitStartTime = runtime_nanotime()
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// 通过信号量，进入阻塞 
</span></span><span class="line"><span class="cl">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)
</span></span><span class="line"><span class="cl">			// 进入饥饿模式
</span></span><span class="line"><span class="cl">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">			// 当前是饥饿模式
</span></span><span class="line"><span class="cl">			if old&amp;mutexStarving != 0 {
</span></span><span class="line"><span class="cl">				// 如果当前锁的状态位饥饿模式，但是当前协程可以执行的当前行代码，代表当前协程已经被从阻塞中唤醒。
</span></span><span class="line"><span class="cl">				// 饥饿状态 + 被唤醒 =》当前锁已经已经到当前协程上
</span></span><span class="line"><span class="cl">				if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
</span></span><span class="line"><span class="cl">					// 检查状态一致
</span></span><span class="line"><span class="cl">					throw(&#34;sync: inconsistent mutex state&#34;)
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">				// 由当协程来设置最新的锁定状态
</span></span><span class="line"><span class="cl">				delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)
</span></span><span class="line"><span class="cl">				// 判断是否需要退出饥饿模式
</span></span><span class="line"><span class="cl">				if !starving || old&gt;&gt;mutexWaiterShift == 1 {
</span></span><span class="line"><span class="cl">					delta -= mutexStarving
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">				atomic.AddInt32(&amp;m.state, delta)
</span></span><span class="line"><span class="cl">				break
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// 当前是正常模式，通过CAS自由竞争锁。
</span></span><span class="line"><span class="cl">			awoke = true
</span></span><span class="line"><span class="cl">			iter = 0 // 重置计数
</span></span><span class="line"><span class="cl">		} else {
</span></span><span class="line"><span class="cl">			// 再来
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>是否可以进入自旋状态代码解释<a href="https://cs.opensource.google/go/go/+/master:src/runtime/proc.go;l=6175?q=sync_runtime_canSpin&amp;ss=go%2Fgo">源码地址</a></p>
<h3 id="unlock">Unlock</h3>
<p>第一步直接减去 mutexLocked 标志位常量，如果 new 等于0结束——简单（锁一次开一次，easy）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">new := atomic.AddInt32(&amp;m.state, -mutexLocked)
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果 state 还不等于0（有协程等待，竞争锁）, 进入 unlockSlow</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Mutex) unlockSlow(new int32) {
</span></span><span class="line"><span class="cl">	// 上一步已经减过 locked 位， 在加上应该等于1，否则不是正常解锁（解锁未锁定的锁）。
</span></span><span class="line"><span class="cl">	if (new+mutexLocked)&amp;mutexLocked == 0 {
</span></span><span class="line"><span class="cl">		fatal(&#34;sync: unlock of unlocked mutex&#34;)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	// 正常模式
</span></span><span class="line"><span class="cl">	if new&amp;mutexStarving == 0 {
</span></span><span class="line"><span class="cl">		old := new
</span></span><span class="line"><span class="cl">		for {
</span></span><span class="line"><span class="cl">			// If there are no waiters or a goroutine has already
</span></span><span class="line"><span class="cl">			// been woken or grabbed the lock, no need to wake anyone.
</span></span><span class="line"><span class="cl">			// In starvation mode ownership is directly handed off from unlocking
</span></span><span class="line"><span class="cl">			// goroutine to the next waiter. We are not part of this chain,
</span></span><span class="line"><span class="cl">			// since we did not observe mutexStarving when we unlocked the mutex above.
</span></span><span class="line"><span class="cl">			// So get off the way.
</span></span><span class="line"><span class="cl">			// 没有等待协程无需通过信号量唤醒
</span></span><span class="line"><span class="cl">			// 1. 如果 mutexLocked 位为1，则代表锁已经被新入协程获取。
</span></span><span class="line"><span class="cl">			// 2. mutexWoken 代表协程有协程正在活动，无需再释放信号量
</span></span><span class="line"><span class="cl">			// 3. mutexStarving 锁的状态一直被抢占，才会导致当前位饥饿状态，无需在释放信号量
</span></span><span class="line"><span class="cl">			if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
</span></span><span class="line"><span class="cl">				return
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// Grab the right to wake someone.
</span></span><span class="line"><span class="cl">			new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
</span></span><span class="line"><span class="cl">			if atomic.CompareAndSwapInt3(&amp;m.state, old, new) {
</span></span><span class="line"><span class="cl">				// 信号量唤醒，各自竞争
</span></span><span class="line"><span class="cl">				runtime_Semrelease(&amp;m.sema, false, 1)
</span></span><span class="line"><span class="cl">				return
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	} else {
</span></span><span class="line"><span class="cl">		// 饥饿模式，通过信号量直接移交当前CPU时间
</span></span><span class="line"><span class="cl">		runtime_Semrelease(&amp;m.sema, true, 1)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}2
</span></span></code></pre></td></tr></table>
</div>
</div><p>如何把锁移交给等待队列的协程？</p>
<p>使用 <code>Mutex.sema</code> 信号量实现锁转移</p>
<h2 id="参考">参考</h2>
<p><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18:src/sync/mutex.go;bpv=1;bpt=1">源代码地址sync.mutex.go</a>
<a href="https://pkg.go.dev/sync#Mutex">包说明文档</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>我为什么要学微服务</title>
      <link>https://ynikl.github.io/posts/2022/0526-why-learn-microservices/</link>
      <pubDate>Thu, 26 May 2022 13:29:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/2022/0526-why-learn-microservices/</guid>
      <description>为什么学 高学习产出转化比 助力下一份工作 公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。 后端架构转变的主流方向, 有利于再次找工作。
怎么学 想要学习好一个技术，就需要有想学习这门技术的动力。
首先要对它有较全面的理解：
我们为什么要学习这门技术 技术的使用场景，以及使用的优势和劣势 现在该技术在大环境中的使用情况 再开始学习技术本身。
针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。
具体方法：
我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。 使用 go-zero 框架完成一个练手项目开发。 </description>
      <content:encoded><![CDATA[<h2 id="为什么学">为什么学</h2>
<ol>
<li>高学习产出转化比</li>
<li>助力下一份工作</li>
</ol>
<p>公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。
后端架构转变的主流方向, 有利于再次找工作。</p>
<h2 id="怎么学">怎么学</h2>
<p>想要学习好一个技术，就需要有想学习这门技术的动力。</p>
<p>首先要对它有较全面的理解：</p>
<ol>
<li>我们为什么要学习这门技术</li>
<li>技术的使用场景，以及使用的优势和劣势</li>
<li>现在该技术在大环境中的使用情况</li>
</ol>
<p>再开始学习技术本身。</p>
<p>针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。</p>
<p>具体方法：</p>
<ol>
<li>我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。</li>
<li>使用 <code>go-zero</code> 框架完成一个练手项目开发。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>富兰克林自传读后感</title>
      <link>https://ynikl.github.io/books/autobiography-benjamin_franklin/</link>
      <pubDate>Wed, 25 May 2022 23:14:12 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/autobiography-benjamin_franklin/</guid>
      <description>富兰克林自传
富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。
年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。
摘录富兰克林十三美德：
节制:食不过饱，饮酒不醉； 寡言:言必于人于己有益，避免无益的聊天； 生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做； 决心:当做必做；决心要做的事应坚持不懈； 俭朴:用钱必须于人或于己有益，换言之，切戒浪费； 勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动； 诚恳:不欺骗人；思想要纯洁公正；说话也要如此； 公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务； 适度:避免极端；人若给你应得的处罚，你当容忍之； 清洁:身体、衣服和住所力求清洁； 镇静:勿因小事或普遍不可避免的事故而惊慌失措； 贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉； 谦虚:仿效耶稣和苏格拉底。</description>
      <content:encoded><![CDATA[<p><a href="https://book.douban.com/subject/26324527/">富兰克林自传</a></p>
<p>富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。</p>
<p>年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。</p>
<p>摘录富兰克林十三美德：</p>
<blockquote>
<p>节制:食不过饱，饮酒不醉；
寡言:言必于人于己有益，避免无益的聊天；
生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做；
决心:当做必做；决心要做的事应坚持不懈；
俭朴:用钱必须于人或于己有益，换言之，切戒浪费；
勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动；
诚恳:不欺骗人；思想要纯洁公正；说话也要如此；
公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务；
适度:避免极端；人若给你应得的处罚，你当容忍之；
清洁:身体、衣服和住所力求清洁；
镇静:勿因小事或普遍不可避免的事故而惊慌失措；
贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉；
谦虚:仿效耶稣和苏格拉底。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>【翻译】使用 Godoc 给 go 代码添加文档</title>
      <link>https://ynikl.github.io/blog/golang-godoc-documenting-go-code/</link>
      <pubDate>Wed, 25 May 2022 16:11:10 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-godoc-documenting-go-code/</guid>
      <description>在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。
原文章地址 Godoc: documenting Go code
Go 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。
所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。
godoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。
godoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc&amp;quot;相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。
使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的Fprint函数的注释。
1 2 3 4 // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered.</description>
      <content:encoded><![CDATA[<p>在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。</p>
<p>原文章地址
<a href="https://go.dev/blog/godoc">Godoc: documenting Go code</a></p>
<p>Go 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。</p>
<p>所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。</p>
<p>godoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。</p>
<p>godoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc&quot;相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。</p>
<p>使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的<code>Fprint</code>函数的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Fprint formats using the default formats for its operands and writes to w.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Spaces are added between operands when neither is a string.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It returns the number of bytes written and any write error encountered.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>值得注意的是该注释是以被注释的对象命名开头的一个完整的句子。 这个使用规范可以方便我们生成各种各样的格式文档，从简单的纯文本到 UNIX 是 man 的帮助页，还可以使用其他工具更见简单地获取到信息， 比如提取出第一行或者句子。</p>
<p>在包的声明处的注释，需要写整个包的概括说明。这些注释可以很简洁，就像 sort 包中的简短描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Package sort provides primitives for sorting slices and user-defined
</span></span></span><span class="line"><span class="cl"><span class="c1">// collections.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">sort</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以很详细，比如 gob 包。有另一个使用惯例：像这种有这大量注释文档的包，单独一个<code>doc.go</code>文件，放置包的注释。</p>
<p>不论包的注释文档大小，第一句注释会被展示在 godoc 的呈现包列表中。</p>
<p>那些没有与最外层声明（可以简单理解为包内全局对象）连接在一块的注释会被 godoc 忽略。但是，有一个例外。那些写在最外层且以“BUG(who)”开头的注释，会被识别为已知的 bug，且会被包含在包文档的“Bugs”分区中。这个“who”部分应该填写可以提供更加详细信息的人名。举个已经在 bytes 包中注释的问题:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// BUG(r): The rule Title uses for word boundaries does not handle Unicode punctuation properly.
</span></span></code></pre></td></tr></table>
</div>
</div><p>某些时候，当一个结构体字段，或者函数，类型，甚至一个整个包变成了冗余或者没有使用必要，但是还是需要与旧代码保持兼容。这时，可以增加一个一段落以“Deprecated:”开头后面跟废弃信息的注释。标识该对象不应该再被使用。</p>
<p>下面展示一些 godoc 把注释转化成网页的规则：</p>
<ul>
<li>不同的段落需要以空行分割。否则将会被识别成同一段。</li>
<li>带有格式的文本，需要要缩进。</li>
<li>URL 会被转化成网页连接，无需特殊处理。</li>
</ul>
<p>上方的这些规则不需要你做任何的特殊处理。</p>
<p>事实上，godoc 的极简处理方式使得它非常容易使用。所以，很多 go 项目，包括标准库，都已经开始开始遵循 godoc 的注释文档规范。</p>
<p>你自己的项目也可以通过编写符合文中规范的注释生成漂亮的文档。任何下载在<code>$GOROOT/src/pkg</code> 或者任何在 <code>GOPATH</code> 空间下的 go 代码包，都可以被 godoc 的命令行或者 HTTP 的接口访问， 你也可以通过在命令后添加<code>-path</code>参数或者直接使用<code>godoc .</code>来指定源码的路径。在<a href="https://pkg.go.dev/golang.org/x/tools/cmd/godoc">godoc 文档</a> 你可以查看到更加详细的内容。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>IP表示中 / 代表的意思</title>
      <link>https://ynikl.github.io/blog/cs-the-slash-meaning-of-ip/</link>
      <pubDate>Mon, 23 May 2022 22:01:03 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/cs-the-slash-meaning-of-ip/</guid>
      <description>IP 中斜杠表示的是子网掩码的位数
例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000</description>
      <content:encoded><![CDATA[<p>IP 中斜杠表示的是子网掩码的位数</p>
<p>例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Five Class Programer</title>
      <link>https://ynikl.github.io/posts/five-class-engineer/</link>
      <pubDate>Sun, 15 May 2022 17:11:57 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/five-class-engineer/</guid>
      <description>以前有一段时间, 怀疑过自己&amp;quot;软件工程师&amp;quot;和以前工程意义上的&amp;quot;工程师&amp;quot;有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的见识书中看了一个五级工程师的概念, 算是解惑了我做为一个&amp;quot;码农&amp;quot;和工程师的区别.
(图片来源于图书截图)
第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围. 第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程. 第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维. 第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样. 第一级工程师: 开创一个行业的鼻祖. 能够改变世界. 反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.
所以我自己应该就是 5.0, 五级工程师, 五流程序员.</description>
      <content:encoded><![CDATA[<p>以前有一段时间, 怀疑过自己&quot;软件工程师&quot;和以前工程意义上的&quot;工程师&quot;有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的<a href="https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/">见识</a>书中看了一个五级工程师的概念, 算是解惑了我做为一个&quot;码农&quot;和工程师的区别.</p>
<p><img loading="lazy" src="five_class_engineer.png" alt="五级工程师"  />

(图片来源于图书截图)</p>
<ul>
<li>第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围.</li>
<li>第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程.</li>
<li>第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维.</li>
<li>第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样.</li>
<li>第一级工程师: 开创一个行业的鼻祖. 能够改变世界.</li>
</ul>
<p>反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.</p>
<p>所以我自己应该就是 5.0, 五级工程师, 五流程序员.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Hugo 如何使用已经发布文章做为相对URL</title>
      <link>https://ynikl.github.io/blog/hugo_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Sun, 15 May 2022 16:33:13 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/hugo_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%BF%9E%E6%8E%A5/</guid>
      <description>hugo 的默认内容都是在 content/ 路径下方
在 markdown 文章中使用 { {&amp;lt; ref &amp;quot;/blog/my-first-post.md&amp;quot; &amp;gt;}}(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带/ 是表示从 content/ 目录下的下一个绝对路径
1 [我的文章]({ {&amp;lt; ref &amp;#34;/blog/my-first-post.md&amp;#34; }}) 记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错
hugo官方文档</description>
      <content:encoded><![CDATA[<p>hugo 的默认内容都是在 <code>content/</code> 路径下方</p>
<p>在 markdown 文章中使用 <code>{ {&lt; ref &quot;/blog/my-first-post.md&quot; &gt;}}</code>(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带<code>/</code> 是表示从 <code>content/</code> 目录下的下一个绝对路径</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[我的文章]({ {&lt; ref &#34;/blog/my-first-post.md&#34; }})
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错</strong></p>
<p><a href="https://gohugo.io/content-management/cross-references/">hugo官方文档</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>My first Post</title>
      <link>https://ynikl.github.io/posts/my-first-post/</link>
      <pubDate>Sun, 15 May 2022 16:14:09 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/my-first-post/</guid>
      <description>我的第一篇杂文
阅读了卡片写作笔记法, 和Show Your Work之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.
原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.</description>
      <content:encoded><![CDATA[<p>我的第一篇杂文</p>
<p>阅读了<a href="https://book.douban.com/subject/35503571/">卡片写作笔记法</a>, 和<a href="https://ynikl.github.io/books/showyourwork/" title="about me">Show Your Work</a>之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.</p>
<p>原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>见识</title>
      <link>https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/</link>
      <pubDate>Sat, 14 May 2022 21:06:07 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/</guid>
      <description>见识:豆瓣地址
个人评分: 8.0 分
前辈用他的智慧和经验, 告诉我们如何更好地活着.
为什么读这本书 很多到了中年的人会有这样的体会： 自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。
为了这一句话, 读这一本书. 自己的作为一个普工程序员, 在技术浪潮的最后端被拖着走. 本根不需要到中年, 今年是我从事程序员工作的第四年, 我已经被感受到了被&amp;quot;命&amp;quot;限制住 的感觉了.
书中讲了什么 作者分享了他对商业, 技术, 职业, 创业, 金钱, 读书的观点和看法
用提出了商业的本质是&amp;quot;消费&amp;quot;的观点, 剖析了现在主流的&amp;quot;共享经济&amp;quot;, 带我们用商业的本质眼光, 去看哪些形式的共享经济是真正的&amp;quot;共享经济&amp;quot;, 哪些只是噱头炒概念的而已. 分析了IOT, 和数字跟踪技术, 区块链, 众筹等.
介绍了新科技公司的创业过程中的一些普世经验. 如何选取赛道, 如何发挥自己小公司的优势, 如何在科技浪潮中存活下来, 以及中如何招聘优秀员工.
关于在职场如何招聘到优秀的员工, 又可以引申到自己如何成为一个优秀的员工, 作者也给出了答案.
树立完成的职业思维, 带着发展的目光选择岗位 在职业思维下主动和积极的面对工作 打开自己思维格局, 多去了解行业大局 有了不错的收入之后, 就涉及到了, 如何树立一个正确的金钱观. 要对自己收入有一个正确的认识, 避免过度追求提高收入, 进而牺牲了自己的健康, 家庭等. (现在经常听到我们的工友, 猝死就是这方面没有正确面对)
下半篇, 作者开始就上升到了人生态度问题. 以一个正确的心态, 面对生活, 面对婚姻, 面对死亡. 分清楚自己生活中的 &amp;ldquo;西瓜和芝麻&amp;rdquo;, 避免习惯于低层次的追求, 会影响我们的心志.
最后文中讲述对大学生的建议 (我已经错过了), 阐述沟通的重要性, 以及介绍了拉里·佩奇名人, 巴菲特的非凡&amp;quot;见识&amp;quot;.</description>
      <content:encoded><![CDATA[<p><a href="https://book.douban.com/subject/27167992/">见识:豆瓣地址</a></p>
<p>个人评分: 8.0 分</p>
<p>前辈用他的智慧和经验, 告诉我们如何更好地活着.</p>
<h2 id="为什么读这本书">为什么读这本书</h2>
<blockquote>
<p>很多到了中年的人会有这样的体会： 自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。</p>
</blockquote>
<p>为了这一句话, 读这一本书. 自己的作为一个普工程序员, 在技术浪潮的最后端被拖着走. 本根不需要到中年, 今年是我从事程序员工作的第四年, 我已经被感受到了被&quot;命&quot;限制住 的感觉了.</p>
<h2 id="书中讲了什么">书中讲了什么</h2>
<p>作者分享了他对商业, 技术, 职业, 创业, 金钱, 读书的观点和看法</p>
<p>用提出了商业的本质是&quot;消费&quot;的观点, 剖析了现在主流的&quot;共享经济&quot;, 带我们用商业的本质眼光, 去看哪些形式的共享经济是真正的&quot;共享经济&quot;, 哪些只是噱头炒概念的而已. 分析了IOT, 和数字跟踪技术, 区块链, 众筹等.</p>
<p>介绍了新科技公司的创业过程中的一些普世经验. 如何选取赛道, 如何发挥自己小公司的优势, 如何在科技浪潮中存活下来, 以及中如何招聘优秀员工.</p>
<p>关于在职场如何招聘到优秀的员工, 又可以引申到自己如何成为一个优秀的员工, 作者也给出了答案.</p>
<ol>
<li>树立完成的职业思维, 带着发展的目光选择岗位</li>
<li>在职业思维下主动和积极的面对工作</li>
<li>打开自己思维格局, 多去了解行业大局</li>
</ol>
<p>有了不错的收入之后, 就涉及到了, 如何树立一个正确的金钱观. 要对自己收入有一个正确的认识, 避免过度追求提高收入, 进而牺牲了自己的健康, 家庭等. (现在经常听到我们的工友, 猝死就是这方面没有正确面对)</p>
<p>下半篇, 作者开始就上升到了人生态度问题. 以一个正确的心态, 面对生活, 面对婚姻, 面对死亡. 分清楚自己生活中的 &ldquo;西瓜和芝麻&rdquo;, 避免习惯于低层次的追求, 会影响我们的心志.</p>
<p>最后文中讲述对大学生的建议 (我已经错过了), 阐述沟通的重要性, 以及介绍了拉里·佩奇名人, 巴菲特的非凡&quot;见识&quot;.</p>
<h2 id="我从书中收获了什么">我从书中收获了什么</h2>
<p>对现在的&quot;共享经济&quot;有了更深的认识, 对科技迭代有了一个基础性的认识, 重视自己职业发展和做文字的积累, 开始努力去全面了解自己的行业, 以及在阅读中莫名地增加了我对生活的信心.</p>
<h2 id="书中的三句精华句子">书中的三句精华句子</h2>
<ol>
<li>很多到了中年的人会有这样的体会：自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。</li>
<li>我们知道今天几乎任何一所三甲医院的主治医师，水平一定比 50 年前所谓的名医高很多。但是，今天没有哪个中医敢讲自己比 500 年前的名医水平高。这就是因为前者有积累效应，而后者没有</li>
<li>我们对死亡的恐惧有点儿莫名其妙，我们站在“有”的世界，试图理解“无”的问题，按照“有”的逻辑，对“无”产生恐惧</li>
</ol>
<h2 id="三句话总结本书">三句话总结本书</h2>
<ol>
<li>拓展视野, 打开格局, 重视积累</li>
<li>以发展的眼光看职业生涯, 分清楚工作和职业的区别, 拒绝伪工作.</li>
<li>向死而生</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Show Your Work</title>
      <link>https://ynikl.github.io/books/showyourwork/</link>
      <pubDate>Sat, 30 Apr 2022 17:22:23 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/showyourwork/</guid>
      <description>Show Your Work 读书总结 概括 我为什么要读这本书
如何提高自己的影响力
这本书怎样影响了我
打算开始分享计划, 学习如何分享, 讲述故事. 计划&amp;quot;学术假&amp;quot;
书中的三句精华句子
You find time the same place you find spare change: in the nooks and crannies On the spectrum of creative work, the difference between the mediocre and the good is vast. Mediocrity is, however, still on the spectrum; you can move from mediocre to good in increments. The real gap is between doing nothing and doing something You can turn your flow into stock 三句话总结本书</description>
      <content:encoded><![CDATA[<h1 id="show-your-work-读书总结">Show Your Work 读书总结</h1>
<h2 id="概括">概括</h2>
<p><strong>我为什么要读这本书</strong></p>
<p>如何提高自己的影响力</p>
<p><strong>这本书怎样影响了我</strong></p>
<p>打算开始分享计划, 学习如何分享, 讲述故事.
计划&quot;学术假&quot;</p>
<p><strong>书中的三句精华句子</strong></p>
<ol>
<li>You find time the same place you find spare change: in the nooks and crannies</li>
<li>On the spectrum of creative work, the difference between the mediocre and the good is vast. Mediocrity is, however, still on the spectrum; you can move from mediocre to good in increments. The real gap is between doing nothing and doing something</li>
<li>You can turn your flow into stock</li>
</ol>
<p><strong>三句话总结本书</strong></p>
<ol>
<li>我们需要把自己展示出来, 这样子别人才能知道你是一个什么样子的人. ( 酒香也怕巷子深)</li>
<li>把自己当成一个业务爱好者, 对自己分享负责, 但不用追求到完美, 心态开放, 保持热情</li>
<li>把握自己分享的尺度, 任何事情, 思想, 启发都是值得分享的. 在互联网上保持真诚, 尊重他人, 保护自己.</li>
</ol>
<h2 id="感悟点">感悟点</h2>
<p>不要觉得你没有什么事情可以分享, 一定会有人对你做的事情感兴趣. 比如一天结束，可以分享自己在做什么，做什么什么决定，收获了什么，受到了什么启发，有什么成果</p>
<p>互联网上的人们都很烂，如果不包含链接，99.9%的就不会去找目标网页</p>
<p>如果虚假的分享你的成功，你不仅抢夺了他人的成功，还欺骗了分享成果的人们</p>
<p>要能解释自己正在做什么</p>
<p>分享自己的知识，也可以让别人知道你在干嘛，知道你的工作，也是自己的一种再学习过程</p>
<p>要倾听别人的意见，不要一味地分享自己</p>
<p>要用内容去吸引读者，不要悲哀地要求别人粉你</p>
<p>学会在网上保护自己，过滤垃圾评论</p>
<p>通勤的好处：分离家庭与工作</p>
<p>适当给自己放假，学术假。每七年让自己重新充电🔋。</p>
<p>认识你自己</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Docker 基本使用</title>
      <link>https://ynikl.github.io/blog/docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 07 Apr 2022 13:34:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>启动一个容器 打个样
1 docker run -itd --rm --name hello image_name &amp;ndash; it 将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式
&amp;ndash;rm 当容器停止之后, 会自动删除改容器
外挂文件夹 参数 -v docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash
与容器交互 进入容器 docker attach
exec
docker -it exec CONTAIN_NAME bash
exex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯. 加上 -it, 进入交互的终端模式
查看日志 docker logs CONTAINER 可以查看容器日志
-f 可以持续输出容器内部的最新日志
管理容器 启动
1 docker start CONTAINER 暂停
1 docker stop CONTAINER 提交
1 docker commit --author=&amp;#34;ian&amp;#34; CONTAINER NEW-IMAGENAME:TAG 管理镜像 查看所有的镜像列表</description>
      <content:encoded><![CDATA[<h2 id="启动一个容器">启动一个容器</h2>
<p>打个样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -itd --rm --name hello image_name 
</span></span></code></pre></td></tr></table>
</div>
</div><p>&ndash; it
将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式</p>
<p>&ndash;rm
当容器停止之后, 会自动删除改容器</p>
<p>外挂文件夹
参数 <code>-v </code></p>
<p><code>docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</code></p>
<h2 id="与容器交互">与容器交互</h2>
<h3 id="进入容器">进入容器</h3>
<p><code>docker attach</code></p>
<p>exec</p>
<p><code>docker -it exec CONTAIN_NAME bash</code></p>
<p>exex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯.
加上 <code>-it</code>, 进入交互的终端模式</p>
<h3 id="查看日志">查看日志</h3>
<p><code>docker logs CONTAINER</code>
可以查看容器日志</p>
<p>-f
可以持续输出容器内部的最新日志</p>
<h2 id="管理容器">管理容器</h2>
<p>启动</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker start CONTAINER
</span></span></code></pre></td></tr></table>
</div>
</div><p>暂停</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker stop CONTAINER
</span></span></code></pre></td></tr></table>
</div>
</div><p>提交</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker commit --author=&#34;ian&#34; CONTAINER NEW-IMAGENAME:TAG
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="管理镜像">管理镜像</h2>
<p>查看所有的镜像列表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker image ls
</span></span></code></pre></td></tr></table>
</div>
</div><p>删除镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rmi IMAGE
</span></span></code></pre></td></tr></table>
</div>
</div><p>删除 <code>&lt;none&gt;</code> 名称的镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rmi $(docker images --filter &#34;dangling=true&#34; -q --no-trunc)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="fqa">FQA</h2>
<h3 id="cmd和entrypoint的区别">CMD和ENTRYPOINT的区别</h3>
<p>RUN、CMD 和 ENTRYPOINT 这三个 Dockerfile 指令看上去很类似，很容易混淆。本节将通过实践详细讨论它们的区别。</p>
<p>简单的说：</p>
<p>RUN 执行命令并创建新的镜像层，RUN 经常用于安装软件包。</p>
<p>CMD 设置容器启动后默认执行的命令及其参数，但 CMD 能够被 docker run 后面跟的命令行参数替换。</p>
<p>ENTRYPOINT 配置容器启动时运行的命令。</p>
<p><a href="https://www.cnblogs.com/LucasSong/p/12701357.html">CMD和ENTRYPOINT的区别</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Channel</title>
      <link>https://ynikl.github.io/blog/golang-channel/</link>
      <pubDate>Sat, 02 Apr 2022 10:09:22 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-channel/</guid>
      <description>Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本
channel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)
Do not communicate by sharing memory; instead, share memory by communicating.
channel 保证:
数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开 channel 的实现 channel 在内部实现的结构体为 runtime.hchan
有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe.</description>
      <content:encoded><![CDATA[<h1 id="go-中-channel-中用法和实现总结">Go 中 channel 中用法和实现总结</h1>
<p>以下分析和源码都是基于 go1.17 版本</p>
<h2 id="channel-简介">channel 简介</h2>
<p>Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (<strong>channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递</strong>)</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>channel 保证:</p>
<ol>
<li>数据的先入先出</li>
<li>并发情况下的数据安全</li>
<li>已经关闭的 channel 不可重开</li>
</ol>
<h2 id="channel-的实现">channel 的实现</h2>
<p>channel 在内部实现的结构体为 <code>runtime.hchan</code></p>
<ol>
<li>有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲.</li>
<li>有一把互斥锁<code>mutex</code>, 在并发情况下, 保护自身数据结构的一致性</li>
<li>有两个协程等待链表, 用于挂载因为<strong>发送/接收</strong>而阻塞在该 channel 上的协程</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// 当前 buffer 中有暂存着多少个数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 环形数组开始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">elemsize</span> <span class="kt">uint16</span>         <span class="c1">// channel 传输的元素大小, 用于计算内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">closed</span>   <span class="kt">uint32</span>         <span class="c1">// channel 是否已经关闭 0未关闭, 非0关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span>         <span class="c1">// element type # channel 元素的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sendx</span>    <span class="kt">uint</span>           <span class="c1">// 环形链表中, 发送数据存储的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">recvx</span>    <span class="kt">uint</span>           <span class="c1">// 环形链表中, 接受数据获取数据的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>          <span class="c1">// 阻塞在该 channel 等待获取数据的 Groutine 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>          <span class="c1">// 阻塞在该 channel 等待写入数据的 Groutine 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">lock</span> <span class="nx">mutex</span> <span class="c1">// # 互斥锁 用于保护自身数据变更
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化">初始化</h3>
<ol>
<li>channel 传递的元素不能太大</li>
<li>如果是空结构体或者无缓冲队列, 是不需要分配环形队列内存</li>
<li>如果传递数据类型有内含指针, 需要将环形队列分配到堆上</li>
</ol>
<p>内部实现函数<code>runtime.makechan</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// compiler checks this but be safe.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 编译器会校验channel元素的大小, 小于64KB. 若大于64KB, 编译器会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: invalid channel element type&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">hchanSize</span><span class="o">%</span><span class="nx">maxAlign</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">maxAlign</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: bad alignment&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">-</span><span class="nx">hchanSize</span> <span class="o">||</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// buf points into the same allocation, elemtype is persistent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Queue or element size is zero. # 无缓冲队列或者空结构体为传递值, 不需要额外分配队列内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Race detector uses this location for synchronization.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// # channel 元素不存在指针引导数据, 将环形数组分配在 hchan 后面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Elements do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Allocate hchan and buf in one call.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Elements contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankHchan</span><span class="p">)</span> <span class="c1">// # locakRankHchan 锁的等级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="关闭">关闭</h3>
<p>核心代码<code>runtime.closechan</code>更新自身数据结构中的关闭状态, 并 <strong>唤醒阻塞在 channel 上的所有协程</strong>. 被唤醒的协程(<code>sudog</code>)的 success 标识会被置为 false.</p>
<p>被唤醒的 写操作的协程, 也会发生panic. ( &ldquo;send on closed channel&rdquo; )</p>
<p>自身操作会发生 panic 的情况</p>
<ol>
<li>未初始化 channel</li>
<li>重复关闭 channel</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">closechan</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 未初始化的channel 会发生panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of nil channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 开始关闭, 锁定之后数据都进不来了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">glist</span> <span class="nx">gList</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// release all readers # 唤醒所有因为读取数据阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # [channel 唤醒协议总是设置params为sudog](https://github.com/golang/go/commit/30a68bfb806b5217932e280f5a5f521237e69077)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// release all writers (they will panic) # 唤醒所有因为写入数据阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Ready all Gs now that we&#39;ve dropped the channel lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 唤醒协程, 将协程加入调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="发送数据">发送数据</h3>
<p><strong>向已经关闭的 channel 发送数据会发生 panic</strong></p>
<p>数据流程:</p>
<ol>
<li>检查是否已经初始化</li>
<li>非阻塞写入数据, 检查数据是否已经满, 快速返回</li>
<li>是否已经关闭</li>
<li>检查 channel 中是否已经有等待获取数据而阻塞的协程,  如果有直接将数据发送给等待的协程.</li>
<li>channel 的 buffer 是否还有空间, 如果有将数据放置到 buffer 中, 返回</li>
<li>channel 的 buffer 已经满了, 根据是否为 select 操作, 判断是否需要将协程阻塞</li>
<li>当协程阻塞之后,  在被唤醒之后需要再检查一次, channel 是否已经关闭.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// # block 的参数是由是否在 select 中, 由编译过程决定的; 只有在select语句中block = true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 向未初始化的 channel 发送数据会永远阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanSendNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 带 select 的 channel 在数据已经满了情况直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">full</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 保护数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 先从接受协程队列中获取阻塞的协程, 直接将数据发送给阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Found a waiting receiver. We pass the value we want to send
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// directly to the receiver, bypassing the channel buffer (if any).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # channel 的 buffer 中还有剩余空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Space is available in the channel buffer. Enqueue the element to send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 环形队列, 当索引到最后从头开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 增加当前 channel buffer 存储的数据个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 发送数据的协程阻塞在当前 channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Block on the channel. Some receiver will complete our operation for us.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanSend</span><span class="p">,</span> <span class="nx">traceEvGoBlockSend</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Ensure the value being sent is kept alive until the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// receiver copies it out. The sudog has a pointer to the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack object, but sudogs aren&#39;t considered as roots of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack tracer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 协程被唤醒了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// someone woke us up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">closed</span> <span class="o">:=</span> <span class="p">!</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// # 挂载在协程上的发送协程会 panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">closed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="接收数据">接收数据</h3>
<p>与发送数据一样, 同样带着是否阻塞的参数. 在编译时,由是否有 select 操作决定. 核心代码<code>runtime.chanrecv</code></p>
<ol>
<li>不带 select 从未初始化的 channel 获取数据, 会永远阻塞</li>
<li><code>runtime.chanrecv</code> 返回值中, 第一个返回值<code>selected</code>表示在,select 语句中, 该 case 是否会被选中执行</li>
</ol>
<p>接收数据流程:</p>
<ol>
<li>检查是否已经初始化</li>
<li>检查非阻塞获取数据下, 是否可以直接返回</li>
<li>如果已经关闭的 channel 且没有已经没有缓冲数据, 返回数据类型的默认值.</li>
<li>检查有因发送数据阻塞在 channel 的协程, 如果没有 buffer, 直接从阻塞的协程中获取数据, 否则从 buffer 中获取数据数据, 将第一个阻塞的协程的数据放入 buffer 中.</li>
<li>如果缓冲 buffer 有数据, 则从buffer 中获取数据.</li>
<li>非阻塞操作, 直接返回. 否则协程进行阻塞.</li>
</ol>
<p>注意事项:</p>
<p><strong>当 select 一个 已经关闭的 channel 的时候, 该 case 会被疯狂输出, 导致cpu使用率上升</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// chanrecv receives on channel c and writes the received data to ep.
</span></span></span><span class="line"><span class="cl"><span class="c1">// ep may be nil, in which case received data is ignored.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If block == false and no elements are available, returns (false, false).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, if c is closed, zeros *ep and returns (true, false).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, fills in *ep with an element and returns (true, true).
</span></span></span><span class="line"><span class="cl"><span class="c1">// A non-nil ep must point to the heap or the caller&#39;s stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// select 情况下, selected = false, 不执行该 case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 非 select 会永远阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanReceiveNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 不加锁检查, 带 select 接收操作, 如果 channel 未关闭, 且没有可以获取的数据直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// After observing that the channel is not ready for receiving, we observe whether the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// channel is closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Reordering of these checks could lead to incorrect behavior when racing with a close.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// For example, if the channel was open and not empty, was closed, and then drained,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// reordered reads could incorrectly indicate &#34;open and empty&#34;. To prevent reordering,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// we use atomic loads for both checks, and rely on emptying and closing to happen in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// separate critical sections under the same lock.  This assumption fails when closing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// an unbuffered channel with a blocked send, but that is an error condition anyway.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Because a channel cannot be reopened, the later observation of the channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// being not closed implies that it was also not closed at the moment of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// first observation. We behave as if we observed the channel at that moment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// and report that the receive cannot proceed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The channel is irreversibly closed. Re-check whether the channel has any pending data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// to receive, which could have arrived between the empty and closed checks above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Sequential consistency is also required here, when racing with such a send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// The channel is irreversibly closed and empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// select 会选择改 case 疯狂输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// # 如果 channel 已经关闭, 且buffer 中已经没有数据了, 返回传输数据类型的默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// # 在返回的时候有可能刚好有数据会进来, 所以需要进行加锁操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The channel has been closed, but the channel&#39;s buffer have data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">		<span class="c1">// # 如果 channel 没有 buffer 会直接从阻塞中的发送数据协程中获取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// # 如果 channel 有 buffer. 当可以获取到因为发送数据而阻塞的协程时, 代表缓冲的 buffer 已经满了. 所以, 将从 buffer 中获取数据, 并将获取到的第一个阻塞协程, 的数据放入 buffer 尾端. 保证先入先出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Just found waiting sender with not closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Found a waiting sender. If buffer is size 0, receive value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// directly from sender. Otherwise, receive from head of queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// and add sender&#39;s value to the tail of the queue (both map to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// the same buffer slot because the queue is full).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 从 buffer 中获取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Receive directly from queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 非阻塞操作, 返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 将获取数据的协程阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// no sender available: block on this channel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanReceive</span><span class="p">,</span> <span class="nx">traceEvGoBlockRecv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// someone woke us up
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果是因为 channel的关闭 操作唤醒的, success 值为 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">success</span> <span class="o">:=</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">success</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="用法总结">用法总结</h2>
<p>初始化:</p>
<ol>
<li>避免对未初始化 channel 的进行读写操作, 可能会造成阻塞</li>
<li>在 select 语句中, 对已经关闭的 channel 可以赋予  <code>nil</code> 值, 避免 cpu 飙高</li>
</ol>
<p>关闭协程:</p>
<ol>
<li>关闭协程的动作, 应该由数据写入方操作</li>
<li>channel 当参数传递时, 尽可能带上操作方向(读取/写入), 编译器会保证, 单向写入协程不允许关闭</li>
<li>关闭的时候要确保所有的写入协程都已经操作完毕. 避免引起写入协程发生 panic</li>
</ol>
<p>在 channel 中阻塞的协程, 唤醒条件</p>
<ol>
<li>到达协程数据操作的目标, 写入 / 读取数据</li>
<li>channel 关闭</li>
</ol>
<h2 id="referrences">Referrences</h2>
<ol>
<li><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17:src/runtime/chan.go">Go官方源码</a></li>
<li><a href="https://go.dev/blog/codelab-share">Share Memory By Communication</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>提升文字留存率</title>
      <link>https://ynikl.github.io/posts/%E6%8F%90%E5%8D%87%E6%96%87%E5%AD%97%E7%95%99%E5%AD%98%E7%8E%87/</link>
      <pubDate>Sat, 02 Apr 2022 09:58:23 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/%E6%8F%90%E5%8D%87%E6%96%87%E5%AD%97%E7%95%99%E5%AD%98%E7%8E%87/</guid>
      <description>如何提高自己的所编写的文字留存问题? 自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意. 然后就会把已经写下的文字和内容删除掉.</description>
      <content:encoded><![CDATA[<p>如何提高自己的所编写的文字留存问题?
自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意.
然后就会把已经写下的文字和内容删除掉.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022</title>
      <link>https://ynikl.github.io/neo/okr-2022/</link>
      <pubDate>Fri, 01 Apr 2022 20:09:37 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/neo/okr-2022/</guid>
      <description>2022 年度目标 提升自己的基础技术竞争力, 确保不会找不到工作
精通 go 编程语言 精通 redis 精通 mysql 5 月份 OKR O:
加深对 Go 语言的基础知识理解 熟悉 redis 的所有数据类型 KR:
输出3篇高质量的 go 语言blog
channel module tools 数据 redis 所有数据类型总结博文一篇
所有数据类型总结博文 6 月份 OKR 成为一个 golang 资深开发工程师
Go GMP 调度总结博文 做一个部门内部的 GMP 调度培训 成为一个优秀的软件工程师
微服务架构设计模式通读并完成博文输出 Mysql 表结构数据类型总结博文 成为一个独立的 apple 软件开发者
开发一个 macos 蕃茄钟小程序雏形 总结 6 月份只完成了一项 微服务架构设计模式 书籍的阅读. 完成情况比较差.
主要原因: 对设定的目标不够上心. 6月份对健身很感兴趣, 一心扑在了健身上了, 对于月初制定的计划也就淡忘了.
7 月份 OKR O1: 首要目标, 还是要技术总结和输出 go 语言的基础知识, 成为一个 资深的 golang 开发者</description>
      <content:encoded><![CDATA[<h1 id="2022-年度目标">2022 年度目标</h1>
<p>提升自己的基础技术竞争力, 确保不会找不到工作</p>
<ul>
<li>精通 go 编程语言</li>
<li>精通 redis</li>
<li>精通 mysql</li>
</ul>
<h1 id="5-月份-okr">5 月份 OKR</h1>
<p>O:</p>
<ul>
<li>加深对 Go 语言的基础知识理解</li>
<li>熟悉 redis 的所有数据类型</li>
</ul>
<p>KR:</p>
<p>输出3篇高质量的 go 语言blog</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> channel</li>
<li><input disabled="" type="checkbox"> module</li>
<li><input checked="" disabled="" type="checkbox"> tools</li>
</ul>
<p>数据 redis 所有数据类型总结博文一篇</p>
<ul>
<li><input disabled="" type="checkbox"> 所有数据类型总结博文</li>
</ul>
<h1 id="6-月份-okr">6 月份 OKR</h1>
<p>成为一个 golang 资深开发工程师</p>
<ul>
<li><input disabled="" type="checkbox"> Go GMP 调度总结博文</li>
<li><input disabled="" type="checkbox"> 做一个部门内部的 GMP 调度培训</li>
</ul>
<p>成为一个优秀的软件工程师</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 微服务架构设计模式通读并完成博文输出</li>
<li><input disabled="" type="checkbox"> Mysql 表结构数据类型总结博文</li>
</ul>
<p>成为一个独立的 apple 软件开发者</p>
<ul>
<li><input disabled="" type="checkbox"> 开发一个 macos 蕃茄钟小程序雏形</li>
</ul>
<h2 id="总结">总结</h2>
<p>6 月份只完成了一项 <em>微服务架构设计模式</em>  书籍的阅读. 完成情况比较差.</p>
<p>主要原因:
对设定的目标不够上心. 6月份对健身很感兴趣, 一心扑在了健身上了, 对于月初制定的计划也就淡忘了.</p>
<h1 id="7-月份-okr">7 月份 OKR</h1>
<p>O1: 首要目标, 还是要技术总结和输出 go 语言的基础知识, 成为一个 资深的 golang 开发者</p>
<ul>
<li><input disabled="" type="checkbox"> go gmp 调度总结博文</li>
<li><input disabled="" type="checkbox"> map channel context 总结博文输出</li>
<li><input disabled="" type="checkbox"> Mysql 表结构数据类型总结博文 (6月份遗留)</li>
</ul>
<p>O2: 学习计算机基础知识</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 学习 <em>RabbitMQ 实战指南</em>  (因为当前公司项目有用到相关的组件, 需要快速学习一下)</li>
<li><input checked="" disabled="" type="checkbox"> 总结 docker 的基本使用</li>
<li><input disabled="" type="checkbox"> 学习 <em>unix 网络编程 卷一</em></li>
</ul>
<p>O3: 保持健康, 保持阅读</p>
<ul>
<li><input disabled="" type="checkbox"> 有 25 天完成, 每天阅读 4 番茄钟的.</li>
<li><input checked="" disabled="" type="checkbox"> 每周 至少健身 4次.</li>
</ul>
<h2 id="总结-1">总结</h2>
<p>执行力不够. 每天制定目标早起, 前天晚上又要早睡. 再加上健身时间, 周一至周五非工作时间都已经排满了.</p>
<p>周末, 执行力不够, 会比较懒散地趴在床上刷抖音, 刷视频之类的. 没有有效地利用时间, 导致制定的计划都完不成.</p>
<h1 id="8-月份-okr">8 月份 OKR</h1>
<p>O1: 高级 go 语言开发者</p>
<ul>
<li><input disabled="" type="checkbox"> go gmp 调度总结博文</li>
<li><input disabled="" type="checkbox"> map, context 总结博文输出</li>
</ul>
<p>O2: 补充计算机基础知识</p>
<ul>
<li><input disabled="" type="checkbox"> <del>Tree 数据结构类型</del></li>
<li><input checked="" disabled="" type="checkbox"> Mysql 表结构数据类型总结博文 (6月份遗留)</li>
<li><input disabled="" type="checkbox"> <del>Unix 网络编程 卷一</del></li>
</ul>
<p>O3: 保持健康, 保持阅读</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 有 25 天完成, 每天阅读 4 番茄钟的.</li>
<li><input disabled="" type="checkbox"> <del>有 25 天完成, 当天的总结和第二天的规划.</del></li>
<li><input disabled="" type="checkbox"> 每周有4点,8点半之前到公司</li>
<li><input checked="" disabled="" type="checkbox"> 每周 至少健身 4次.</li>
</ul>
<h2 id="8月份总结">8月份总结</h2>
<ul>
<li>过度娱乐，沉溺于抖音，每一天可以刷1-2个小时</li>
<li>健身花费的时间占比居高不下， 过度重视健身。</li>
</ul>
<h2 id="9月份安排">9月份安排</h2>
<ul>
<li>在写自我技术能力的时候，依旧没有能力把 <strong>精通</strong> 这两个字放在 Go语言前面 &ndash; 9月份最主要目标</li>
<li>下调健身花费的时间占比， 采用5分化训练。 每次尽量把时间控制在一个小时之内。</li>
<li>每天保持一个小时的时间用于提高技术能力。</li>
</ul>
<h1 id="9-月份-okr">9 月份 OKR</h1>
<p>O1: 可以在自我介绍上写上 <strong>精通Go语言</strong></p>
<ul>
<li><input disabled="" type="checkbox"> go gmp 调度总结博文</li>
<li><input disabled="" type="checkbox"> map, context 总结博文输出</li>
<li><input disabled="" type="checkbox"> interface 深入学习</li>
<li><input disabled="" type="checkbox"> reflect 反射包使用</li>
</ul>
<p>O2: 拓展知识</p>
<ul>
<li><input disabled="" type="checkbox"> Mysql 表结构数据类型总结博文 (6月份遗留)</li>
</ul>
<p>O3: 保持健康, 保持阅读</p>
<ul>
<li><input disabled="" type="checkbox"> 有 25 天完成, 每天阅读 4 番茄钟的.</li>
<li><input disabled="" type="checkbox"> 每周有4点,8点半之前到公司</li>
<li><input disabled="" type="checkbox"> 每周 至少健身 4次.</li>
</ul>
<h1 id="10-月份-okr">10 月份 OKR</h1>
<p>无</p>
<h1 id="11-月份-okr">11 月份 OKR</h1>
<p>技术</p>
<p>O1: <strong>精通Go语言</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> go map 总结博文输出</li>
<li><input disabled="" type="checkbox"> go context 总结博文输出</li>
<li><input disabled="" type="checkbox"> go gmp 调度总结博文</li>
</ul>
<p>O2: 拓展技术边界</p>
<ul>
<li><input disabled="" type="checkbox"> 前端技术入门</li>
<li><input disabled="" type="checkbox"> Python 入门</li>
</ul>
<p>生活</p>
<p>O1: 文字沉淀,</p>
<ul>
<li><input disabled="" type="checkbox"> 摩托车给我带来了什么文章总结</li>
<li><input disabled="" type="checkbox"> 摩托车骑行录像整理</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go 常用的命令汇总</title>
      <link>https://ynikl.github.io/blog/golang-cmd/</link>
      <pubDate>Fri, 01 Apr 2022 19:56:59 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-cmd/</guid>
      <description>工具分类 go build 编译源代码文件
-race 编译出的目标程序，会启用数据竞争检测
go doc 查看包的文档(定义于doc.go的注释中), 于包中公开的函数签名
example
1 2 3 go doc go doc encoding/json go env 查看 go 相关的环境变量
1 2 3 4 5 # -w 设置环境变量 go env -w GOPAHT=&amp;#39;/some/path&amp;#39; # -u 恢复成默认设置 go env -u GOPATH go generate 扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”
注释的指令格式
//go:generate command argument...
ps: wire 也是利用命令, 生成依赖注入文件
go get 管理当前module依赖
1 2 3 4 5 6 7 8 # 添加依赖包 go get example.</description>
      <content:encoded><![CDATA[<h1 id="工具分类">工具分类</h1>
<h2 id="go-build">go build</h2>
<p>编译源代码文件</p>
<p><code>-race</code>
编译出的目标程序，会启用数据竞争检测</p>
<h2 id="go-doc">go doc</h2>
<p>查看包的文档(定义于<code>doc.go</code>的注释中), 于包中公开的函数签名</p>
<p>example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go doc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">go doc encoding/json
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-env">go env</h2>
<p>查看 go 相关的环境变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># -w 设置环境变量</span>
</span></span><span class="line"><span class="cl">go env -w <span class="nv">GOPAHT</span><span class="o">=</span><span class="s1">&#39;/some/path&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># -u 恢复成默认设置</span>
</span></span><span class="line"><span class="cl">go env -u GOPATH
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-generate">go generate</h2>
<p>扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”</p>
<p><strong>注释的指令格式</strong></p>
<p><code>//go:generate command argument...</code></p>
<p>ps: wire 也是利用命令, 生成依赖注入文件</p>
<h2 id="go-get">go get</h2>
<p>管理当前module依赖</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 添加依赖包
</span></span><span class="line"><span class="cl">go get example.com/pkg
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 指定包版本
</span></span><span class="line"><span class="cl">go get example.com/pkg@1.2.3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 移除依赖
</span></span><span class="line"><span class="cl">go get example.com/pkg@none
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-install">go install</h2>
<p>获取包文件，并编译和安装。可执行文件编译到<code>$GOBIN</code>路径下, 包文件编译到<code>$GOPATH/pkg</code></p>
<h2 id="go-list">go list</h2>
<p>列出包的数据信息</p>
<h2 id="go-mod">go mod</h2>
<p>管理 modules</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">edit	修改go.mod
</span></span><span class="line"><span class="cl">init	初始化
</span></span><span class="line"><span class="cl">tidy	自动补全依赖包
</span></span><span class="line"><span class="cl">vendor	生成一个所有依赖的vendor文件夹
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-test">go test</h2>
<p>跑单元测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go test -v .
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 指定函数
</span></span><span class="line"><span class="cl">go test -run 函数名
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 性能测试
</span></span><span class="line"><span class="cl">go test -v -bench . -benchtime 50s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 单元测试覆盖率
</span></span><span class="line"><span class="cl">go test -cover
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 强制重新跑测试, 不使用缓存的结果 source: https://stackoverflow.com/a/48882892/9992963
</span></span><span class="line"><span class="cl">go test -count=1
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-tool">go tool</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 不带参数，显示工具列表
</span></span><span class="line"><span class="cl">go tool
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="compile">compile</h3>
<p>使用<code>go tool compile -N -l -S main.go</code>生成汇编代码</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>我</title>
      <link>https://ynikl.github.io/me/</link>
      <pubDate>Wed, 09 Mar 2022 15:24:02 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/me/</guid>
      <description> 我: 昵称: 潜水员
五流程序员 文字业余爱好者 摩托车爱好者 为什么写 在互联网中留下尘埃 把想法外显成文字才会有意义 促进自我思考 目前在学 Go Redis 微服务设计模式 计算机技能 Go Vim Live in Shell Redis Mysql Operating System Algorithm (basic) 想从生活中得到 摄影 游泳 Bucket List 逃离办公室 去西藏 出版一本小说 潜水 跳伞 目录分类说明 blog 一些技术上的杂文 posts 自己的一些感悟和发牢骚 notes 平时遇到的一些有感悟的文字 books 自己读的书籍的一些简单记录 </description>
      <content:encoded><![CDATA[<p><img loading="lazy" src="Ian.jpeg" alt="avatar"  />
</p>
<h1 id="我">我:</h1>
<p>昵称: <strong>潜水员</strong></p>
<ul>
<li>五流程序员</li>
<li>文字业余爱好者</li>
<li>摩托车爱好者</li>
</ul>
<h2 id="为什么写">为什么写</h2>
<ul>
<li>在互联网中留下尘埃</li>
<li>把想法外显成文字才会有意义</li>
<li>促进自我思考</li>
</ul>
<h2 id="目前在学">目前在学</h2>
<ul>
<li>Go</li>
<li>Redis</li>
<li><del>微服务设计模式</del></li>
</ul>
<h2 id="计算机技能">计算机技能</h2>
<ul>
<li><input checked="" disabled="" type="checkbox"> Go</li>
<li><input checked="" disabled="" type="checkbox"> Vim</li>
<li><input checked="" disabled="" type="checkbox"> Live in Shell</li>
<li><input disabled="" type="checkbox"> Redis</li>
<li><input disabled="" type="checkbox"> Mysql</li>
<li><input disabled="" type="checkbox"> Operating System</li>
<li><input disabled="" type="checkbox"> Algorithm (basic)</li>
</ul>
<h2 id="想从生活中得到">想从生活中得到</h2>
<ul>
<li><input disabled="" type="checkbox"> 摄影</li>
<li><input disabled="" type="checkbox"> 游泳</li>
</ul>
<h2 id="bucket-list">Bucket List</h2>
<ul>
<li><input disabled="" type="checkbox"> 逃离办公室</li>
<li><input disabled="" type="checkbox"> 去西藏</li>
<li><input disabled="" type="checkbox"> 出版一本小说</li>
<li><input disabled="" type="checkbox"> 潜水</li>
<li><input disabled="" type="checkbox"> 跳伞</li>
</ul>
<h2 id="目录分类说明">目录分类说明</h2>
<ul>
<li>blog    一些技术上的杂文</li>
<li>posts   自己的一些感悟和发牢骚</li>
<li>notes   平时遇到的一些有感悟的文字</li>
<li>books   自己读的书籍的一些简单记录</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Hugo 文章分类管理</title>
      <link>https://ynikl.github.io/blog/hugo-%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 09 Mar 2022 11:29:17 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/hugo-%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</guid>
      <description>Hugo 文章分类管理 文件夹 内容存放在content/目录下方, content/下方的子目录会形成资源URI,
例如 content/blog/doc.md 文章访问目录即为 https//XXX.github.io/blog.doc.md
分类管理 文章内容表述 (Front Matter) 使用进行分类, 默认只有tags
1 2 3 tags: - Go - fast 可以在config添加自定的分类选项
1 2 3 taxonomies: series: series category: categories 文章路径 类别 描述 地址 home 网站homepage /index.html page 指定页面 /post/页面/index.html section 分区 /section/index.html taxonomy 分类 /tags/index.html term 分类系列 /tags/go/index.html _index.md 和 index.md 在文件夹下方添加_index.md会识别成section. 在文件夹下方添加index.md会被识别成文章.
千万不要在默认的content目录下方添加index.md</description>
      <content:encoded><![CDATA[<h1 id="hugo-文章分类管理">Hugo 文章分类管理</h1>
<h2 id="文件夹">文件夹</h2>
<p>内容存放在<code>content/</code>目录下方, <code>content/</code>下方的子目录会形成资源URI,</p>
<p>例如
<code>content/blog/doc.md</code> 文章访问目录即为 <code>https//XXX.github.io/blog.doc.md</code></p>
<h2 id="分类管理-taxonomies">分类管理 <!-- raw HTML omitted --></h2>
<h2 id="文章内容表述-front-matter">文章内容表述 (Front Matter)</h2>
<p>使用<!-- raw HTML omitted -->进行分类, 默认只有tags</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">tags</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="l">Go</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="l">fast</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以在<code>config</code>添加自定的分类选项</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">taxonomies</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">series</span><span class="p">:</span><span class="w"> </span><span class="l">series</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">category</span><span class="p">:</span><span class="w"> </span><span class="l">categories</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="文章路径">文章路径</h2>
<table>
<thead>
<tr>
<th>类别</th>
<th>描述</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>home</td>
<td>网站homepage</td>
<td>/index.html</td>
</tr>
<tr>
<td>page</td>
<td>指定页面</td>
<td>/post/页面/index.html</td>
</tr>
<tr>
<td>section</td>
<td>分区</td>
<td>/section/index.html</td>
</tr>
<tr>
<td>taxonomy</td>
<td>分类</td>
<td>/tags/index.html</td>
</tr>
<tr>
<td>term</td>
<td>分类系列</td>
<td>/tags/go/index.html</td>
</tr>
</tbody>
</table>
<h2 id="_indexmd-和-indexmd"><code>_index.md</code> 和 <code>index.md</code></h2>
<p>在文件夹下方添加<code>_index.md</code>会识别成section.
在文件夹下方添加<code>index.md</code>会被识别成文章.</p>
<p><strong>千万不要在默认的content目录下方添加<code>index.md</code></strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title></title>
      <link>https://ynikl.github.io/blog/diary/2023-03-20/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/diary/2023-03-20/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
    <item>
      <title></title>
      <link>https://ynikl.github.io/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/readme/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
  </channel>
</rss>
