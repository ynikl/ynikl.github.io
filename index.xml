<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>潜水员的咖啡小屋</title>
    <link>https://ynikl.github.io/</link>
    <description>Recent content on 潜水员的咖啡小屋</description>
    <image>
      <url>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>gilfoyle.k@outlook.com (潜水员)</managingEditor>
    <webMaster>gilfoyle.k@outlook.com (潜水员)</webMaster>
    <copyright>2022 Ian Lin All rights reserved</copyright>
    <lastBuildDate>Thu, 09 Feb 2023 09:02:40 +0800</lastBuildDate><atom:link href="https://ynikl.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>你为什么而工作</title>
      <link>https://ynikl.github.io/books/why-we-work/</link>
      <pubDate>Thu, 09 Feb 2023 09:02:40 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/why-we-work/</guid>
      <description>总结 现状 国富论中的分工合作, 把每个人的工作都进行了细化, 每个人都只能聚焦到眼前的一点点事情. 提升了增体生产效率. 人们失去对增体工作流程的感知, 更加不容易感受到工作所带来的成就感. 不能感知到自己的工作给别人带去了什么.
“一个人把金属线拉长，另一个人将它拉直，第三个人将其切断，第四个人将它削尖，第五个人将顶端切磨好跟头部相接……我曾经目睹过只雇用十位工人的这种小型生产工厂……他们一天最多能生产48 000枚大头针，但如果不采用分工合作的方式，而是由一个人来完成所有工序，那么他们每个人连20枚都完成不了。”
改善 个人: 发现自己的工作的能给别人带来什么, 寻找自己工作的意义. 自己如何看待一份工作是自己决定的. 是工作, 还是职业, 还是使命.
企业:
对员工提供保障, 充分的薪资 分配工作保留充分的自主性 一个充满价值感的工作环境 文摘 “对于那些从工作中获得成就感的人，他们将工作当成事业来经营，并且沉浸其中，尽管并不总是这种状态，但毫无疑问，工作对于他们来说至关重要。对这些人来说，工作中充满挑战，而正是这种挑战性，迫使他们远离舒适和懈怠，不断磨炼和提升自我”
“认为自己从工作中获取了某种掌控感，他们在工作中努力地锻炼自身的自主性和判断力，并借此不断提高自己的工作技能和专业水准。他们孜孜不倦地学习新东西，无论是作为员工还是作为个体的人，都能持续不断地获取自身的发展。”
“从事工作也是出于社交的需要。工作中个体常常作为团队成员一起完成任务，即使是独立工作或工作闲暇时，仍然有许多与他人打交道的社交机会。”
“有时是因为个人从事的工作非常有意义。他们的工作可能正在改变着世界，让他人的生活变得更加美好，更加有意义”
“事实上，当我们谈论一个人是因为钱而工作时，我们并不仅仅是在客观描述，而是夹杂了批判的情感在内”
“流程化的工作方式意味着除了钱之外，他们真的找不到促使其工作的其他理由”
“工作助力个人的成长和发展、工作中被上级和同事欣赏和褒扬、工作中他人尊重和赞同自己的意见和看法、感觉自己所做的工作意义重大、在工作中可以结交好友。所有这些回答都是调查中收集到的反馈。然而，对于绝大多数的职场人士来说，工作更像是无奈之举，他们也并没有积极向上的工作动力。为什么会出现这种情况”
“长期以来我们一直信奉着一项经济准则，而这项准则也被诸多心理学理论所支持，那就是如果你想让他人替你做事，无论是员工、学生、政府官员，还是你自己的孩子，你都得让他们“有所得”，因为人们做事情是因为“有利可图”
国富论
“想过尽可能舒适的生活是每个人的天性，如果一个人从事某项繁重工作和他不做所获得的报酬没有任何差别的话，那么他就会粗心马虎地应付差事，而政府也默认这种行事原则。”
“一个人把金属线拉长，另一个人将它拉直，第三个人将其切断，第四个人将它削尖，第五个人将顶端切磨好跟头部相接……我曾经目睹过只雇用十位工人的这种小型生产工厂……他们一天最多能生产48 000枚大头针，但如果不采用分工合作的方式，而是由一个人来完成所有工序，那么他们每个人连20枚都完成不了。”
“你或许会问为什么会有人愿意在亚当·斯密所描写的大头针工厂中年复一年日复一日地做着将针头和针组合在一起这种简单重复的工作。对此，亚当·斯密给出的回答是：“人们当然并不享受大头针工厂中的这种工作，但他们同样也不愿意在其他任何地方工作。”
“人们愿意工作的唯一原因是工作所带来的报酬。只要能够获得令人满意的报酬，工作内容便无关紧要。”
良好的工作环境是可以影响在其中的员工的心态
“说人类是未完成进化的动物。他指的是所谓人类的天性，很大一部分是周围社会环境的产物，这本身便是人类的天性。这部分人类天性更多是被“创造”出来的，而不是被“发现”的”
流水线的工作导致了员工的自主权利被削减
“流水线分工所带来的一个重要但常被人忽略的后果便是将工作的掌控权从员工的手中转移到了那些管理流水线的主管们手中”
“一种观点认为，我们大多数人相信只有某些种类的工作才会让人觉得充满挑战具有意义，能提供不断学习和成长的机会。如果我们坚守这种观点的话，那么这类好工作可能只属于少数人，如律师、医生、银行家、教师、软件开发人员、公司首席执行官等。对于其他人来说，工作就是“饭碗”。情况就是如此，对你我亦然”
“另一种观点则认为，每一种工作都有可能让人获得满足感。但问题在于常规化、流水线式的工作更容易带来稳定的生产效率”
工作 -&amp;gt; 职业 -&amp;gt; 使命
“正如劳动心理学研究专家皮特所指出的那样，为了让我们对自己的工作满意，我们有必要给自己从事的工作赋予意义” “当人们将自己做的事情仅仅当成一份养家糊口的“工作”来看待的时候，人们很难从工作中获得自主性，也很难从中获取成就感。当人们将工作仅仅看作为了生存必须要做的事情时，人们只在乎报酬，如果其他工作能提供更高的报酬，那么他们随时可能换工作。他们迫不及待地想要退休，也并不鼓励和希望他们的朋友或孩子像他们那样，重蹈他们的覆辙。这种现象也正是亚当·斯密关于工作的观点的具体体现” “当人们将从事的工作视为“使命”时，他们的满意度和成就感是最高的。对这些人来说，工作是生命中最重要的一部分，他们愿意将自己奉献给工作，工作彰显了他们生存的意义，他们深信自己的工作能让世界变得更加美好”
员工的使命感
“如果工作中缺少自主性、意义和满意度，工作具有的“使命感”就会减少，从事这项工作的满意度也会下降，员工也不会把这份工作做得很好”
“其实，你不一定非要在一个救死扶伤的组织内工作，以寻求工作的意义和目标。你只需要找一份能提高人们生活质量的工作就行。”
工作的成就感
“仅仅因为目睹了他们的努力给他人带来的幸福，他们的工作效率便提高了两倍。这就是赋予工作的意义后产生的巨大能量。”
“亚当·斯密描述的那些在大头针工厂中工作的工人也应该试图在内心告诉自己，自己做的事情是有意义和有追求的。也就是说，并不需要耗费太多，就能将几乎任何一份工作变得富有意义。这样做不仅对职工有好处，对服务的客户和员工所在的组织都是有益处的。”
提供完善的工作保障，这些有助于提高员工的忠诚度和信任度。 团队自我管理，分散决策权，给予员工很高的自主权和自我管理权。这同样也能提高员工对组织的信任，同时也减少了管理监督员工的人力成本。 提供给员工高于行业标准的薪酬，让员工觉得自己很有价值。但他们并不怎么依靠个人激励机制去诱导员工努力工作。当公司盈利时，所有的员工都参与利润分成。员工和公司是一个完整的“利益团体”。 完善的培训体系。无论是新员工，还是老员工，都经过系统专业的培训。这种对员工的培训是公司的一种投资形式，同样有利于培养员工的忠诚和信任。长期系统的培训也让员工不断面临新的挑战，不断提高自己的技能。普费弗还对各国的培训时长进行了对比，同样是汽车行业，日本对刚入职的新员工的平均培训时长为364个小时，欧洲是178个小时，而美国只有21个小时。 评估职工的表现，但不过度评估。公司相信员工会努力工作，也相信员工在接受足够的培训后都会成功。 极力强调公司的目标和愿景，并非首席执行官一时兴起的想法，而是将公司的使命渗透至公司上上下下的具体实践中。” “正如普费弗教授所描述的，应对竞争压力的下意识反应——裁员、加强对员工的管理和监视、催促员工加快进度等举措只会不断降低工作效率和员工的工作满意度，让情况变得更加糟糕”
“她的核心观点是当人们处于一种积极向上的情绪状态中时，他们更富有想象力和创造力，他们具有弗雷德里克松所称的“更加宽广和具有建设性的与世界互动的方式”。相反，当人们处于一种消极负面的情绪状态中时，他们更容易变得保守，想坐享其成，时时担心出错或把事情弄砸。危险让我们的视野变得更加狭窄”
现行的比较盛行的措施
“有两套规范的理论用于管理那些对工作不感兴趣的员工，一个是物质激励（工资），另一个是对流水线工作的严密监视，正所谓胡萝卜加大棒。令人惊奇的是，杰弗里·普费弗认为这两种方法对员工工作满意度都有负面效应。但是这两种方法是企业最先采用的，它们不仅让后勤工作人员和流水线上的工人无法拥有令他们满意的工作，同时由于这两种方法不断受到公司高层人员的青睐，因而在这两种方法的管理下，任何工作都有可能被毁掉，成为糟糕的工作。”
如果原先是通过道德进行约束(接送儿童迟到), 变成了通过罚款约束, 就上升到了金钱的交易的层面, 交了罚款就理所应当地迟到了.</description>
      <content:encoded><![CDATA[<h2 id="总结">总结</h2>
<h3 id="现状">现状</h3>
<p>国富论中的分工合作, 把每个人的工作都进行了细化, 每个人都只能聚焦到眼前的一点点事情. 提升了增体生产效率. 人们失去对增体工作流程的感知, 更加不容易感受到工作所带来的成就感. 不能感知到自己的工作给别人带去了什么.</p>
<blockquote>
<p>“一个人把金属线拉长，另一个人将它拉直，第三个人将其切断，第四个人将它削尖，第五个人将顶端切磨好跟头部相接……我曾经目睹过只雇用十位工人的这种小型生产工厂……他们一天最多能生产48 000枚大头针，但如果不采用分工合作的方式，而是由一个人来完成所有工序，那么他们每个人连20枚都完成不了。”</p>
</blockquote>
<h2 id="改善">改善</h2>
<p>个人:
发现自己的工作的能给别人带来什么, 寻找自己工作的意义. 自己如何看待一份工作是自己决定的. 是工作, 还是职业, 还是使命.</p>
<p>企业:</p>
<ol>
<li>对员工提供保障, 充分的薪资</li>
<li>分配工作保留充分的自主性</li>
<li>一个充满价值感的工作环境</li>
</ol>
<h2 id="文摘">文摘</h2>
<blockquote>
<p>“对于那些从工作中获得成就感的人，他们将工作当成事业来经营，并且沉浸其中，尽管并不总是这种状态，但毫无疑问，工作对于他们来说至关重要。对这些人来说，工作中充满挑战，而正是这种挑战性，迫使他们远离舒适和懈怠，不断磨炼和提升自我”</p>
</blockquote>
<blockquote>
<p>“认为自己从工作中获取了某种掌控感，他们在工作中努力地锻炼自身的自主性和判断力，并借此不断提高自己的工作技能和专业水准。他们孜孜不倦地学习新东西，无论是作为员工还是作为个体的人，都能持续不断地获取自身的发展。”</p>
</blockquote>
<blockquote>
<p>“从事工作也是出于社交的需要。工作中个体常常作为团队成员一起完成任务，即使是独立工作或工作闲暇时，仍然有许多与他人打交道的社交机会。”</p>
</blockquote>
<blockquote>
<p>“有时是因为个人从事的工作非常有意义。他们的工作可能正在改变着世界，让他人的生活变得更加美好，更加有意义”</p>
</blockquote>
<blockquote>
<p>“事实上，当我们谈论一个人是因为钱而工作时，我们并不仅仅是在客观描述，而是夹杂了批判的情感在内”</p>
</blockquote>
<blockquote>
<p>“流程化的工作方式意味着除了钱之外，他们真的找不到促使其工作的其他理由”</p>
</blockquote>
<blockquote>
<p>“工作助力个人的成长和发展、工作中被上级和同事欣赏和褒扬、工作中他人尊重和赞同自己的意见和看法、感觉自己所做的工作意义重大、在工作中可以结交好友。所有这些回答都是调查中收集到的反馈。然而，对于绝大多数的职场人士来说，工作更像是无奈之举，他们也并没有积极向上的工作动力。为什么会出现这种情况”</p>
</blockquote>
<blockquote>
<p>“长期以来我们一直信奉着一项经济准则，而这项准则也被诸多心理学理论所支持，那就是如果你想让他人替你做事，无论是员工、学生、政府官员，还是你自己的孩子，你都得让他们“有所得”，因为人们做事情是因为“有利可图”</p>
</blockquote>
<p>国富论</p>
<blockquote>
<p>“想过尽可能舒适的生活是每个人的天性，如果一个人从事某项繁重工作和他不做所获得的报酬没有任何差别的话，那么他就会粗心马虎地应付差事，而政府也默认这种行事原则。”</p>
</blockquote>
<blockquote>
<p>“一个人把金属线拉长，另一个人将它拉直，第三个人将其切断，第四个人将它削尖，第五个人将顶端切磨好跟头部相接……我曾经目睹过只雇用十位工人的这种小型生产工厂……他们一天最多能生产48 000枚大头针，但如果不采用分工合作的方式，而是由一个人来完成所有工序，那么他们每个人连20枚都完成不了。”</p>
</blockquote>
<blockquote>
<p>“你或许会问为什么会有人愿意在亚当·斯密所描写的大头针工厂中年复一年日复一日地做着将针头和针组合在一起这种简单重复的工作。对此，亚当·斯密给出的回答是：“人们当然并不享受大头针工厂中的这种工作，但他们同样也不愿意在其他任何地方工作。”</p>
</blockquote>
<blockquote>
<p>“人们愿意工作的唯一原因是工作所带来的报酬。只要能够获得令人满意的报酬，工作内容便无关紧要。”</p>
</blockquote>
<p>良好的工作环境是可以影响在其中的员工的心态</p>
<blockquote>
<p>“说人类是未完成进化的动物。他指的是所谓人类的天性，很大一部分是周围社会环境的产物，这本身便是人类的天性。这部分人类天性更多是被“创造”出来的，而不是被“发现”的”</p>
</blockquote>
<p>流水线的工作导致了员工的自主权利被削减</p>
<blockquote>
<p>“流水线分工所带来的一个重要但常被人忽略的后果便是将工作的掌控权从员工的手中转移到了那些管理流水线的主管们手中”</p>
</blockquote>
<blockquote>
<p>“一种观点认为，我们大多数人相信只有某些种类的工作才会让人觉得充满挑战具有意义，能提供不断学习和成长的机会。如果我们坚守这种观点的话，那么这类好工作可能只属于少数人，如律师、医生、银行家、教师、软件开发人员、公司首席执行官等。对于其他人来说，工作就是“饭碗”。情况就是如此，对你我亦然”</p>
</blockquote>
<blockquote>
<p>“另一种观点则认为，每一种工作都有可能让人获得满足感。但问题在于常规化、流水线式的工作更容易带来稳定的生产效率”</p>
</blockquote>
<p>工作 -&gt; 职业 -&gt; 使命</p>
<blockquote>
<p>“正如劳动心理学研究专家皮特所指出的那样，为了让我们对自己的工作满意，我们有必要给自己从事的工作赋予意义”
“当人们将自己做的事情仅仅当成一份养家糊口的“工作”来看待的时候，人们很难从工作中获得自主性，也很难从中获取成就感。当人们将工作仅仅看作为了生存必须要做的事情时，人们只在乎报酬，如果其他工作能提供更高的报酬，那么他们随时可能换工作。他们迫不及待地想要退休，也并不鼓励和希望他们的朋友或孩子像他们那样，重蹈他们的覆辙。这种现象也正是亚当·斯密关于工作的观点的具体体现”
“当人们将从事的工作视为“使命”时，他们的满意度和成就感是最高的。对这些人来说，工作是生命中最重要的一部分，他们愿意将自己奉献给工作，工作彰显了他们生存的意义，他们深信自己的工作能让世界变得更加美好”</p>
</blockquote>
<p>员工的使命感</p>
<blockquote>
<p>“如果工作中缺少自主性、意义和满意度，工作具有的“使命感”就会减少，从事这项工作的满意度也会下降，员工也不会把这份工作做得很好”</p>
</blockquote>
<blockquote>
<p>“其实，你不一定非要在一个救死扶伤的组织内工作，以寻求工作的意义和目标。你只需要找一份能提高人们生活质量的工作就行。”</p>
</blockquote>
<p>工作的成就感</p>
<blockquote>
<p>“仅仅因为目睹了他们的努力给他人带来的幸福，他们的工作效率便提高了两倍。这就是赋予工作的意义后产生的巨大能量。”</p>
</blockquote>
<blockquote>
<p>“亚当·斯密描述的那些在大头针工厂中工作的工人也应该试图在内心告诉自己，自己做的事情是有意义和有追求的。也就是说，并不需要耗费太多，就能将几乎任何一份工作变得富有意义。这样做不仅对职工有好处，对服务的客户和员工所在的组织都是有益处的。”</p>
</blockquote>
<blockquote>
<ol>
<li>提供完善的工作保障，这些有助于提高员工的忠诚度和信任度。</li>
<li>团队自我管理，分散决策权，给予员工很高的自主权和自我管理权。这同样也能提高员工对组织的信任，同时也减少了管理监督员工的人力成本。</li>
<li>提供给员工高于行业标准的薪酬，让员工觉得自己很有价值。但他们并不怎么依靠个人激励机制去诱导员工努力工作。当公司盈利时，所有的员工都参与利润分成。员工和公司是一个完整的“利益团体”。</li>
<li>完善的培训体系。无论是新员工，还是老员工，都经过系统专业的培训。这种对员工的培训是公司的一种投资形式，同样有利于培养员工的忠诚和信任。长期系统的培训也让员工不断面临新的挑战，不断提高自己的技能。普费弗还对各国的培训时长进行了对比，同样是汽车行业，日本对刚入职的新员工的平均培训时长为364个小时，欧洲是178个小时，而美国只有21个小时。</li>
<li>评估职工的表现，但不过度评估。公司相信员工会努力工作，也相信员工在接受足够的培训后都会成功。</li>
<li>极力强调公司的目标和愿景，并非首席执行官一时兴起的想法，而是将公司的使命渗透至公司上上下下的具体实践中。”</li>
</ol>
</blockquote>
<blockquote>
<p>“正如普费弗教授所描述的，应对竞争压力的下意识反应——裁员、加强对员工的管理和监视、催促员工加快进度等举措只会不断降低工作效率和员工的工作满意度，让情况变得更加糟糕”</p>
</blockquote>
<blockquote>
<p>“她的核心观点是当人们处于一种积极向上的情绪状态中时，他们更富有想象力和创造力，他们具有弗雷德里克松所称的“更加宽广和具有建设性的与世界互动的方式”。相反，当人们处于一种消极负面的情绪状态中时，他们更容易变得保守，想坐享其成，时时担心出错或把事情弄砸。危险让我们的视野变得更加狭窄”</p>
</blockquote>
<p>现行的比较盛行的措施</p>
<blockquote>
<p>“有两套规范的理论用于管理那些对工作不感兴趣的员工，一个是物质激励（工资），另一个是对流水线工作的严密监视，正所谓胡萝卜加大棒。令人惊奇的是，杰弗里·普费弗认为这两种方法对员工工作满意度都有负面效应。但是这两种方法是企业最先采用的，它们不仅让后勤工作人员和流水线上的工人无法拥有令他们满意的工作，同时由于这两种方法不断受到公司高层人员的青睐，因而在这两种方法的管理下，任何工作都有可能被毁掉，成为糟糕的工作。”</p>
</blockquote>
<p>如果原先是通过道德进行约束(接送儿童迟到), 变成了通过罚款约束, 就上升到了金钱的交易的层面, 交了罚款就理所应当地迟到了. 但是, 这个也要看对象的素质程度 &ndash; 修养以及金钱能力.</p>
<blockquote>
<p>“但是当日托护理中心的家长们又多一个理由（罚款）准时接人的时候，这第二项理由反而削弱了第一项理由（准时接人是理所当然的事情）。当受访的瑞士民众面临是否将核废料垃圾站设立在所在社区这个问题时，仅有一个理由（公民的义务）的情况下，他们同意的比例竟然远高于有两个理由的时候（公民的义务和高额的补偿金）。由此可见，动机并不是多多益善，有时候动机越多，反而会相互削弱。”</p>
</blockquote>
<blockquote>
<p>“你的[[金钱答谢]]会潜意识地提醒人们他们正在进行的是一笔买卖，而非社会互助行为。酬谢金的出现，会让他们不自觉地衡量自己就此所付出的时间和劳力是否“物有所值”，而当别人只是希望他们帮一下忙时，他们是从来不会考虑值不值这个问题的。因此，在这里，社会动机和经济动机是对抗性而非互补性的”</p>
</blockquote>
<p>在行动条论只制定更加详细的条例.</p>
<blockquote>
<p>“详细的条例和规则或许将有助于合同更加“完善”，但如果循着这个方向发展，必然有损于医生、律师、教师甚至护理人员提供的服务质量”</p>
</blockquote>
<blockquote>
<p>“因此工作的单调无聊是无法用薪酬来弥补的。其实更有可能的是，员工们已经安于并顺从这种生活现状了，工作对于他们来说毫无意义，只是一项苦差事而已”</p>
</blockquote>
<blockquote>
<p>“正如经济学家弗雷德·赫希四十年前所说：“写在合同中的越多，你能期望的就越少；写下得越多，你能期望的信任就越少。”</p>
</blockquote>
<blockquote>
<p>“科学的实质便是一场关于理论与实践的持久对话”</p>
</blockquote>
<blockquote>
<p>“至少在社会科学中，提出理论并不受限于事实，而是通过加强理论来重塑现实。你可以先铺设好人行小道，然后通过围禁草地来强制人们必须经由人行小道行走。”</p>
</blockquote>
<blockquote>
<p>“对发现和发明进行区分是至关重要的，并不仅仅因为它影响人们从中赚多少钱。无论是科学家还是其他人，当人们有所发现时，我们并不会问这项发现是否应该存在。换句话说，尽管发现的内容有时会涉及道德层面，但发现本身并不存在道德维度”</p>
</blockquote>
<p>思想观点对我的影响也是巨大的</p>
<blockquote>
<p>“当提及科学的现代影响时，大多数人自然想到的是诸如智能手机和核磁共振扫描这样的技术。但是除了创造“物”的技术外，科学也创造“观点”——关于我们如何理解世界、如何在世界生存的观点，而这些观点将会对我们的思想和行为产生巨大的影响”</p>
</blockquote>
<blockquote>
<p>“由此可见，我们或许认为自己与众不同，不俗气，会关心钱之外的其他事情，但是反过来，我们却很容易认为其他人工作完全是出于金钱的考虑”</p>
</blockquote>
<p>你说我是个恶人, 那我便干脆做一个恶人罢了</p>
<blockquote>
<p>“实际上，“自我实现预言”是对一种情境的错误定义，在这种情境下，一种新的行为表现的出现使得原来错误的观点变成正确的”</p>
</blockquote>
<blockquote>
<p>“皮格马利翁效应”。简而言之，罗森塔尔和雅各布森认为，给某些学生贴上“更有前途”这样类似的标签会导致老师改变对这些孩子的教育方式，进而促进预言的实现。这一发现对心理学和教育学都产生了深远的影响”</p>
</blockquote>
<blockquote>
<p>“意识形态对人们行为的影响很大程度上取决于这套意识形态渗入人们所处文化中的深度、广度和显著度”</p>
</blockquote>
<blockquote>
<p>“如果我们设计的工作环境能够让员工从中找到意义，那么我们就能培育出注重工作意义的人性来。”</p>
</blockquote>
<blockquote>
<p>“我们曾经错失良机，很大程度上是因为意识形态告诉我们，人们都是不愿意工作的”</p>
</blockquote>
<blockquote>
<p>“我之所以关注工作的结构以及工作环境，是因为我相信在一个认为工作毫无意义的极端环境中，个体无法真正发挥出自己的聪明才智”</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>周一清晨的领导课</title>
      <link>https://ynikl.github.io/books/monday-morning-mentoring/</link>
      <pubDate>Sat, 28 Jan 2023 23:42:27 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/monday-morning-mentoring/</guid>
      <description>承担责任 承担责任, 把目光聚焦于未来, 解决问题
与承担责任截然相反的是，把某人或某件事作为导致你所面临的问题的责备对象。当 然，总会有某人或某事是应当受责备的，但真正的领导者只会花时间来解决问题，而不是责 备别人。
“当你横加责备时，你的注意力集中在过去。如果你承担了责任，你才会将眼光投向未 来。杰夫，无论如何，只有在你承担了所有的责任之后，你才能做好计划来达到自己的目标。
“我想让你明白的第一个道理是，你应当控制自己来应对环境。如果你不再责备——甚 至避免这个词从你的口中说出来，你就会积极做出某些改变了。”
和 [[books/ShowYourWork]] 这中表达的意思一样, 思想和计划需要落到文字
“你到家后把这些都写在这个笔记本上。”托尼向我建议，“记住，当你把这些都写下来 时，你便做出了实施的承诺。如果你只是口头上告诉我你想做什么，就不会对你构成约束。”
明确团队的使命 明确团队的目标, 我们是一个怎么样的团队, 我们要做完成什么事情. 确保大家对目标的理解是一致的, 大家都清楚自己职责事情的优先级. 也需要让上级知道当前团队的目标. 上下一致, 齐心协力.
我建议你花时间你管理下属一样来管理一下你的老板。搞清楚她对你有什么样的期 望，告诉你对她有什么样的期望。你知道她的要事是什么吗?她知道你的要事是什么吗?也 许你们应该谈一谈，要想完成你的首要事务，就要弄清楚你们双方应当如何彼此协助
如果员工有离职的意向, 就要反思是不是自己出了问题, 团队出了问题
下属们一般不会因为这些原因而离职。他们 之所以离开，是因为上司不能令他们满意。在炒公司鱿鱼之前，他们已经先炒了上司的鱿鱼。 我不是说这是你们公司中的实际情况，我的意思是说，在多数情况下，老板是员工离职的主 要原因。
避免管理黑洞 逃离信息差, 与下属保持联系.
管理黑洞, 让团队感到困惑的事情
让团队感到迷惑的某些事情， 成了令许多经理掉下去的陷阱，”他说，“我把它称为‘管理黑洞’，这里的事与表面看上去 的有所不同。此外，有时人们总免不了要陷入管理黑洞。
团队的组成
大多数团队包含三种类型的雇员。有些是超级明星——富有经 验和学识，想在岗位上发挥最佳作用的人。有些是中层星——他们也许还不具备超级明星所 拥有的经验，或者也许以前他们是超级明星，由于某些原因，现在失去了争第一的动力;最 后一种我称之为流星:他们尽量逃避责任，希望担子越轻越好。 “在典型的团队中，有 30%的超级明星，50%的中层星，20%的流星。
坚持正确 制定原则 &amp;ndash; 正确的事情, 当你对问题感到困惑的时候, 就参考你原则, 你就知道你应该怎么做.
如果现在你没有一套行为准则或业绩标准的话，就很难知道怎样做才是对的。就目前 情况看这个不成问题&amp;hellip;&amp;hellip;至少从你的话来判断，这不是什么问题。 “当你陷入危机时——就像你现在的境况似的——就很难判断什么是‘对的’。我发现 最佳决策一般都是在发生危机之前做出的。你可以想清楚些，权衡一下两者的利弊
忽视问题是在拿自己正直的口碑冒险。如果你不再正直，你就不能建立以及保持别人 对你的信任——这是人际关系的根本所在
就像想树立一个正确的企业文化, 如果坚定想要建立[[企业文化]], 那么任何违反企业文化的人都应该被开除 (不管这是一位多么优秀的员工)
雇佣合适的员工 寻找合适的员工, &amp;ldquo;合适&amp;rdquo; 可以有很多种定义, 不同处事风格, 不同的个性的团队成员, 都会给团队带来不一样的色彩</description>
      <content:encoded><![CDATA[<h2 id="承担责任">承担责任</h2>
<p>承担责任, 把目光聚焦于未来, 解决问题</p>
<blockquote>
<p>与承担责任截然相反的是，把某人或某件事作为导致你所面临的问题的责备对象。当 然，总会有某人或某事是应当受责备的，但真正的领导者只会花时间来解决问题，而不是责 备别人。</p>
<p>“当你横加责备时，你的注意力集中在过去。如果你承担了责任，你才会将眼光投向未 来。杰夫，无论如何，只有在你承担了所有的责任之后，你才能做好计划来达到自己的目标。</p>
<p>“我想让你明白的第一个道理是，你应当控制自己来应对环境。如果你不再责备——甚 至避免这个词从你的口中说出来，你就会积极做出某些改变了。”</p>
</blockquote>
<p>和 [[books/ShowYourWork]] 这中表达的意思一样, 思想和计划需要落到文字</p>
<blockquote>
<p>“你到家后把这些都写在这个笔记本上。”托尼向我建议，“记住，当你把这些都写下来 时，你便做出了实施的承诺。如果你只是口头上告诉我你想做什么，就不会对你构成约束。”</p>
</blockquote>
<h2 id="明确团队的使命">明确团队的使命</h2>
<p>明确团队的目标, 我们是一个怎么样的团队, 我们要做完成什么事情. 确保大家对目标的理解是一致的, 大家都清楚自己职责事情的优先级. 也需要让上级知道当前团队的目标. 上下一致, 齐心协力.</p>
<blockquote>
<p>我建议你花时间你管理下属一样来管理一下你的老板。搞清楚她对你有什么样的期 望，告诉你对她有什么样的期望。你知道她的要事是什么吗?她知道你的要事是什么吗?也 许你们应该谈一谈，要想完成你的首要事务，就要弄清楚你们双方应当如何彼此协助</p>
</blockquote>
<p>如果员工有离职的意向, 就要反思是不是自己出了问题, 团队出了问题</p>
<blockquote>
<p>下属们一般不会因为这些原因而离职。他们 之所以离开，是因为上司不能令他们满意。在炒公司鱿鱼之前，他们已经先炒了上司的鱿鱼。 我不是说这是你们公司中的实际情况，我的意思是说，在多数情况下，老板是员工离职的主 要原因。</p>
</blockquote>
<h2 id="避免管理黑洞">避免管理黑洞</h2>
<p>逃离信息差, 与下属保持联系.</p>
<p>管理黑洞, 让团队感到困惑的事情</p>
<blockquote>
<p>让团队感到迷惑的某些事情， 成了令许多经理掉下去的陷阱，”他说，“我把它称为‘管理黑洞’，这里的事与表面看上去 的有所不同。此外，有时人们总免不了要陷入管理黑洞。</p>
</blockquote>
<p>团队的组成</p>
<blockquote>
<p>大多数团队包含三种类型的雇员。有些是超级明星——富有经 验和学识，想在岗位上发挥最佳作用的人。有些是中层星——他们也许还不具备超级明星所 拥有的经验，或者也许以前他们是超级明星，由于某些原因，现在失去了争第一的动力;最 后一种我称之为流星:他们尽量逃避责任，希望担子越轻越好。
“在典型的团队中，有 30%的超级明星，50%的中层星，20%的流星。</p>
</blockquote>
<h2 id="坚持正确">坚持正确</h2>
<p>制定原则 &ndash; 正确的事情, 当你对问题感到困惑的时候, 就参考你原则, 你就知道你应该怎么做.</p>
<blockquote>
<p>如果现在你没有一套行为准则或业绩标准的话，就很难知道怎样做才是对的。就目前 情况看这个不成问题&hellip;&hellip;至少从你的话来判断，这不是什么问题。
“当你陷入危机时——就像你现在的境况似的——就很难判断什么是‘对的’。我发现 最佳决策一般都是在发生危机之前做出的。你可以想清楚些，权衡一下两者的利弊</p>
</blockquote>
<blockquote>
<p>忽视问题是在拿自己正直的口碑冒险。如果你不再正直，你就不能建立以及保持别人 对你的信任——这是人际关系的根本所在</p>
</blockquote>
<p>就像想树立一个正确的企业文化, 如果坚定想要建立[[企业文化]], 那么任何违反企业文化的人都应该被开除 (不管这是一位多么优秀的员工)</p>
<h2 id="雇佣合适的员工">雇佣合适的员工</h2>
<p>寻找合适的员工, &ldquo;合适&rdquo; 可以有很多种定义, 不同处事风格, 不同的个性的团队成员, 都会给团队带来不一样的色彩</p>
<blockquote>
<p>公司中最重大的问题是，团队由不合适的员工组成。事实上，比起团队中都是不合适 的员工来说，竞争者对你造成的危害要小多了。
“作为领导者，重要的任务是要雇佣合适的员工。如果都是没有的、效率不高的员工， 你就不可能有强大的、有效率的团队。
“杰夫，现在你有个大好的机会。由于三个职位空缺，你可以借机改变团队的风格。通 过挑选合适的员工，你可以增加员工的多样性、想出新的主意、增添团队的活力。”</p>
</blockquote>
<p>所以, 人不好招是没有错的. 但是, 还是不能因为人不好招, 而过度放低门槛.</p>
<blockquote>
<p>你要做的决策要不就是精挑细选、管理起来很轻松，要不就是轻松招聘、管理起来很 困难的。我可以保证，你是最佳选择是把时间花在前一种方案上，这样招聘到了合适的员工 后，管理就会变成一种享受。</p>
</blockquote>
<blockquote>
<p>面试中，还有人会犯感情用事的错误。空缺的职位让你费时费力，你想快点填补。带 着这种感情，你会速战速决地选择并非很合适的人。我建议你让金或人力资源部的其他人帮 帮忙——他们不会怀有你这样的感情。</p>
</blockquote>
<h2 id="提升效率">提升效率</h2>
<p>端正对待自己时间的态度</p>
<blockquote>
<p>安排时间是你自 己的责任。如果你没时间做重要的事情，只有你自己才能解决这相问题你的团队要靠你来统 筹规划，包括解决你的个人问题</p>
</blockquote>
<blockquote>
<p>关于充分利用时间，我知道的办法只有两种:或者少做事，或者加快工作节奏，除此 之外别无选择。</p>
</blockquote>
<p>记录自己的时间花费, 减少被干扰的次数, 避免无意义会议, 集中处理某部分&quot;杂事&quot; .</p>
<blockquote>
<p>首先你要搞清楚，现在你的时间都花在什么地方。如果想改进，就要知道哪里需要改进。</p>
</blockquote>
<h2 id="提升团队满意度">提升团队满意度</h2>
<p>需要明确自己的对某一位团队成员的期待.</p>
<blockquote>
<p>在解雇更多的人之前，我需要明确自己的期望，还要完善对员工的培训</p>
</blockquote>
<p>团队的力量大于你个人的力量. 团队更加重要</p>
<blockquote>
<p>1.作为领导者，我的业绩是团队共同努力的结果。员工们需要你——你是重要人物。然 而，你的成功是下属的功劳，并非完全源于你自身的努力。
2.你对团队的需要甚于团队对你的需要。有要误会了我的意思——你与员工彼此都离不 开彼此都离不开对方，但团队中 17 位员工的贡献加在一起，比你一个人的贡献更大。</p>
</blockquote>
<p>提升团队成员的满意</p>
<ol>
<li>薪资, 简单且快速的方法, 但是很容易褪去</li>
<li>明确团队成员的目标,  提升工作的满意度</li>
<li>反馈和知道成员.</li>
<li>让成员知道你在意他们, 重视他们.</li>
<li>团队的凝聚力, 大家成为团队的一员.</li>
</ol>
<h2 id="保持学习">保持学习</h2>
<p>我们的天性, 就是喜欢舒服的过日子</p>
<blockquote>
<p>他们早上一睁眼，就开始重复前一天的生活 ——因为他们因此而觉得舒适——直到退休为止</p>
</blockquote>
<p>保持学习</p>
<blockquote>
<p>“你要想出人头地，就不能放任自己躺在舒适地带上自鸣得意。你要追求进步。为了发 挥潜力，你要迈出舒适在带，走入‘学习地带’</p>
</blockquote>
<p>学习的三个阶段: 阅读, 倾听(向他人学习), 分享</p>
<blockquote>
<p>学习地带中有三个‘房间’。第一个房间是阅览室
第二个房间是倾听室。你知道吗?经理们失败的主要原因在于他们骄傲自大、过于自 负、麻木不仁
学习中的第三个房间是给予室。我深深感到，如果不回报，就不会成功。”托尼接着 说道，</p>
</blockquote>
<p>制定明确的目标, 并落成文字
人们为什么没有制定目标</p>
<blockquote>
<p>第一，因为人闪不知道订立目标的重要性。我所知道的每项伟大的成就都开始于一纸 目标。
第二，大部分人不知道该如何制定目标, 书写会让你对目标更为明确。
第三，有时人们因为害怕失败而不敢订立目标。
第四，为了达到目标，人们必须脱离舒适地带。许多人不敢这样做。因为这意味着需 要学习新技术。</p>
</blockquote>
<p>乐观地面对生活</p>
<blockquote>
<p>生活中有很多事情都与生活态度，如何面对生活 带来的苦恼有关。生活是美好的——即使境况恶化时也依然如此。要保持乐观自信。这会有 助于你创造崭新的生活。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>The Power of Habit</title>
      <link>https://ynikl.github.io/books/the-power-of-habit/</link>
      <pubDate>Sat, 28 Jan 2023 13:14:06 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/the-power-of-habit/</guid>
      <description>习惯的力量 什么是习惯 习惯是我们可以不假思索就会完成的一系列动作, 是我们在生物进化过程的中的产物. 由 暗示, 行为, 奖励 三步组成. 我们接受到某种暗示, 潜意识开始渴望获得奖励, 不由自主地开始了习惯行为, 并内心渴望着得到奖励.
“科学家说习惯之所以出现，是因为大脑一直在寻找可以省力的方式”
“第一步，存在着一个暗示，能让大脑进入某种自动行为模式，并决定使用哪种习惯。第二步，存在一个惯常行为，这可以是身体、思维或情感方面的。第三步则是奖赏，这让你的大脑辨别出是否应该记下这个回路，以备将来之用”
“习惯从来都不会消失，它们已经被嵌入了大脑的结构中，而这对我们来说是莫大的优势，因为如果我们每次放完假后都要重新学习如何开车，那可就太糟糕了”
“这种心理的基础是两条基本规律： 第一，找出一种简单又明显的暗示。 第二，清楚地说明有哪些奖赏。”
用 白速得 牙膏的广告, 展示了利用人们习惯的影响, 让大家渴望得到一口漂亮的牙齿, 养成刷牙的习惯.
“看看“白速得”吧。他发现了一种暗示——垢膜，以及一个奖赏——漂亮的牙齿，这使千百万人开始了每天的固定活动——刷牙”
“这解释了为什么习惯如此强大：它们能够创造出神经渴求。在大部分时间里，这些渴求是逐渐产生的，而我们确实没有意识到它们的存在，所以往往看不到它们的影响”
大家如果把手机的震动关闭了, 那可能就不会再有去查看手机的冲动了.
“换言之，如果有人关了震动，也就是消除了暗示，那么大家可能就会一直工作，而不会想去查看未读消息）。”
对奖励的渴望 “92%的参与者说他们习惯性锻炼是因为这让他们“感觉很好”，他们变得越来越期盼并渴求运动时产生的内啡肽和其他神经化学物质。在另一组人中，67%的人说锻炼让他们有一种“成就感”，他们从追踪自己的运动表现中渴求一种经常出现的胜利感。这种自我奖赏足够让体育活动变成一种习惯。”
“暗示加上奖赏本身并不足以让新习惯长期持续。只有你的大脑开始预期奖赏，渴求内啡肽的分泌或成就感时，你才会自觉地在每天早上绑好跑鞋鞋带。而暗示除了能够触发惯常行为，还必须能够触发人对即将到来的奖赏的渴求”
“他们创造了渴求感，让消费者产生了所有东西在有亮闪闪的外观的同时，也有好闻的味道的欲望，这让纺必适在市场上大卖”
“消费者需要一些信号告诉他们这种产品是有效的，我们可以随意调整牙膏的口感，可以是蓝莓味、绿茶味，而只要有那种凉丝丝的刺激感，大家就觉得牙齿刷干净了。这种刺激感并不会让牙膏的效果更好，但可以说服大家牙膏有效。”
“是渴求在驱动着习惯。找到触发渴求的方式让创造新习惯变得更容易。现在是这样，100年之前也是如此。每天晚上，数百万人在刷牙，就是为了获得那种刺激感。每天早上，数百万人穿上跑鞋，就是想获得他们渴求的大量内啡肽。等他们回到家，打扫了厨房或卧室后，有些人又会喷点儿纺必适来满足自己对那种气味的渴求”
习惯是可以改变的 “习惯是一种分为三个步骤的回路，由暗示、惯常行为和奖赏组成，邓吉想做的只是调整中间那个步骤，即惯常行为。根据经验，他知道如果新行为模式的开头和结尾存在一个人熟悉的东西，那么就更容易说服这个人接受新的行为模式。”
习惯是可以替代的.
“这就是黄金法则；如果你用同样的暗示，提供同样的奖赏，你就可以换掉惯常行为，改变自己的习惯。如果暗示和奖赏不变，几乎所有的习惯都是可以被改变的。”
匿名戒酒会通过自我反省和倾诉, 寻找自己形成习惯的内心的渴求的真正因素
这个项目要找的是哪些渴求感在驱使着你的习惯回路。通常来说，喝醉本身并不属于渴求。酗酒者之所以想喝酒，是因为酒让他们能逃避现实，放松心情，又有人陪伴，而且缓解焦虑，情感也得到释放。或许他们想喝杯鸡尾酒来忘记烦心事，但并不一定想“买醉”。酒精的物理作用往往是嗜酒成瘾这个习惯回路中最次要的奖赏之一。
暗示和奖赏不变, 替换掉中间的行为, 我们就可以改变习惯
“旧的暗示和对奖赏的渴求仍在那里，随时准备反击。只有当酗酒者养成了利用以前的暗示和让他们感到熟悉进而有宽慰感的新的惯常行为时，他们才能永久戒酒。”
“这种让病人描述引发他们习惯性行为的暗示的做法，叫做意识训练，正如匿名戒酒互助社坚持让酗酒者找出酗酒的暗示，这是相反习惯训练的第一步”
更深层次的信仰达成, 也是说是一种精神上的奖励
“研究人员发现，起作用的并不是上帝，而是信仰本身。一旦人们学会信仰某种东西，这种信仰就会扩展到生活的其他方面，直到他们开始相信自己能改变。信仰是将改造过的习惯回路变成永久性行为的要素。”
在做之前, 我们要对自己有信心
“但我们的确知道，为了永久改变习惯，人们必须相信改变是可能的”
如果只是一刀斩断习惯, 那么过程将会是痛苦的
“如果你想减肥，就应了解自己的习惯，看看为什么每天休息时，自己都会离开办公桌去吃点心？然后，每到休息时，就找朋友去散步，或到他们办公桌那里闲聊，而不是去咖啡厅，或者加入一个跟踪减肥过程的小组，还可以找一个跟你一样，想在手边放一些苹果而不是薯片的伙伴” “事实一目了然：如果你想改变一个习惯，你必须找另一个惯常行为替代”
企业习惯 在商业上, 一家公司的习惯, 就可以说是这家公司的核心价值观, 就是企业文化. 真正的企业价值是需要所有人都有着一致的认可才行, 当我们在工作上遇到一些有疑惑的事情, 我们可以不假思索地参考我们的企业习惯去处理事情, 这种才能说明, 我们的企业文化有真正的落地.
“一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，它们就是“核心习惯”，影响着人们的工作、饮食、玩乐、消费和沟通方式。核心习惯能启动一个进程，久而久之将改变一切。”
“个人有习惯；组织则有惯例”</description>
      <content:encoded><![CDATA[<h1 id="习惯的力量httpsbookdoubancomsubject20507212"><a href="https://book.douban.com/subject/20507212/">习惯的力量</a></h1>
<h2 id="什么是习惯">什么是习惯</h2>
<p>习惯是我们可以不假思索就会完成的一系列动作, 是我们在生物进化过程的中的产物.  由 暗示, 行为, 奖励 三步组成. 我们接受到某种暗示, 潜意识开始渴望获得奖励, 不由自主地开始了习惯行为, 并内心渴望着得到奖励.</p>
<blockquote>
<p>“科学家说习惯之所以出现，是因为大脑一直在寻找可以省力的方式”</p>
</blockquote>
<blockquote>
<p>“第一步，存在着一个暗示，能让大脑进入某种自动行为模式，并决定使用哪种习惯。第二步，存在一个惯常行为，这可以是身体、思维或情感方面的。第三步则是奖赏，这让你的大脑辨别出是否应该记下这个回路，以备将来之用”</p>
</blockquote>
<blockquote>
<p>“习惯从来都不会消失，它们已经被嵌入了大脑的结构中，而这对我们来说是莫大的优势，因为如果我们每次放完假后都要重新学习如何开车，那可就太糟糕了”</p>
</blockquote>
<blockquote>
</blockquote>
<p>“这种心理的基础是两条基本规律：
第一，找出一种简单又明显的暗示。
第二，清楚地说明有哪些奖赏。”</p>
<p>用 白速得 牙膏的广告, 展示了利用人们习惯的影响, 让大家渴望得到一口漂亮的牙齿, 养成刷牙的习惯.</p>
<blockquote>
<p>“看看“白速得”吧。他发现了一种暗示——垢膜，以及一个奖赏——漂亮的牙齿，这使千百万人开始了每天的固定活动——刷牙”</p>
</blockquote>
<blockquote>
<p>“这解释了为什么习惯如此强大：它们能够创造出神经渴求。在大部分时间里，这些渴求是逐渐产生的，而我们确实没有意识到它们的存在，所以往往看不到它们的影响”</p>
</blockquote>
<p>大家如果把手机的震动关闭了, 那可能就不会再有去查看手机的冲动了.</p>
<blockquote>
<p>“换言之，如果有人关了震动，也就是消除了暗示，那么大家可能就会一直工作，而不会想去查看未读消息）。”</p>
</blockquote>
<h3 id="对奖励的渴望">对奖励的渴望</h3>
<blockquote>
<p>“92%的参与者说他们习惯性锻炼是因为这让他们“感觉很好”，他们变得越来越期盼并渴求运动时产生的内啡肽和其他神经化学物质。在另一组人中，67%的人说锻炼让他们有一种“成就感”，他们从追踪自己的运动表现中渴求一种经常出现的胜利感。这种自我奖赏足够让体育活动变成一种习惯。”</p>
</blockquote>
<blockquote>
<p>“暗示加上奖赏本身并不足以让新习惯长期持续。只有你的大脑开始预期奖赏，渴求内啡肽的分泌或成就感时，你才会自觉地在每天早上绑好跑鞋鞋带。而暗示除了能够触发惯常行为，还必须能够触发人对即将到来的奖赏的渴求”</p>
</blockquote>
<blockquote>
<p>“他们创造了渴求感，让消费者产生了所有东西在有亮闪闪的外观的同时，也有好闻的味道的欲望，这让纺必适在市场上大卖”</p>
</blockquote>
<blockquote>
<p>“消费者需要一些信号告诉他们这种产品是有效的，我们可以随意调整牙膏的口感，可以是蓝莓味、绿茶味，而只要有那种凉丝丝的刺激感，大家就觉得牙齿刷干净了。这种刺激感并不会让牙膏的效果更好，但可以说服大家牙膏有效。”</p>
</blockquote>
<blockquote>
<p>“是渴求在驱动着习惯。找到触发渴求的方式让创造新习惯变得更容易。现在是这样，100年之前也是如此。每天晚上，数百万人在刷牙，就是为了获得那种刺激感。每天早上，数百万人穿上跑鞋，就是想获得他们渴求的大量内啡肽。等他们回到家，打扫了厨房或卧室后，有些人又会喷点儿纺必适来满足自己对那种气味的渴求”</p>
</blockquote>
<h3 id="习惯是可以改变的">习惯是可以改变的</h3>
<blockquote>
<p>“习惯是一种分为三个步骤的回路，由暗示、惯常行为和奖赏组成，邓吉想做的只是调整中间那个步骤，即惯常行为。根据经验，他知道如果新行为模式的开头和结尾存在一个人熟悉的东西，那么就更容易说服这个人接受新的行为模式。”</p>
</blockquote>
<p>习惯是可以替代的.</p>
<blockquote>
<p>“这就是黄金法则；如果你用同样的暗示，提供同样的奖赏，你就可以换掉惯常行为，改变自己的习惯。如果暗示和奖赏不变，几乎所有的习惯都是可以被改变的。”</p>
</blockquote>
<p>匿名戒酒会通过自我反省和倾诉, 寻找自己形成习惯的内心的渴求的真正因素</p>
<blockquote>
<p>这个项目要找的是哪些渴求感在驱使着你的习惯回路。通常来说，喝醉本身并不属于渴求。酗酒者之所以想喝酒，是因为酒让他们能逃避现实，放松心情，又有人陪伴，而且缓解焦虑，情感也得到释放。或许他们想喝杯鸡尾酒来忘记烦心事，但并不一定想“买醉”。酒精的物理作用往往是嗜酒成瘾这个习惯回路中最次要的奖赏之一。</p>
</blockquote>
<p>暗示和奖赏不变, 替换掉中间的行为, 我们就可以改变习惯</p>
<blockquote>
<p>“旧的暗示和对奖赏的渴求仍在那里，随时准备反击。只有当酗酒者养成了利用以前的暗示和让他们感到熟悉进而有宽慰感的新的惯常行为时，他们才能永久戒酒。”</p>
</blockquote>
<blockquote>
<p>“这种让病人描述引发他们习惯性行为的暗示的做法，叫做意识训练，正如匿名戒酒互助社坚持让酗酒者找出酗酒的暗示，这是相反习惯训练的第一步”</p>
</blockquote>
<p>更深层次的信仰达成, 也是说是一种精神上的奖励</p>
<blockquote>
<p>“研究人员发现，起作用的并不是上帝，而是信仰本身。一旦人们学会信仰某种东西，这种信仰就会扩展到生活的其他方面，直到他们开始相信自己能改变。信仰是将改造过的习惯回路变成永久性行为的要素。”</p>
</blockquote>
<p>在做之前, 我们要对自己有信心</p>
<blockquote>
<p>“但我们的确知道，为了永久改变习惯，人们必须相信改变是可能的”</p>
</blockquote>
<p>如果只是一刀斩断习惯, 那么过程将会是痛苦的</p>
<blockquote>
<p>“如果你想减肥，就应了解自己的习惯，看看为什么每天休息时，自己都会离开办公桌去吃点心？然后，每到休息时，就找朋友去散步，或到他们办公桌那里闲聊，而不是去咖啡厅，或者加入一个跟踪减肥过程的小组，还可以找一个跟你一样，想在手边放一些苹果而不是薯片的伙伴”
“事实一目了然：如果你想改变一个习惯，你必须找另一个惯常行为替代”</p>
</blockquote>
<h2 id="企业习惯">企业习惯</h2>
<p>在商业上, 一家公司的习惯, 就可以说是这家公司的核心价值观, 就是企业文化.  真正的企业价值是需要所有人都有着一致的认可才行, 当我们在工作上遇到一些有疑惑的事情, 我们可以不假思索地参考我们的企业习惯去处理事情, 这种才能说明, 我们的企业文化有真正的落地.</p>
<blockquote>
<p>“一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，它们就是“核心习惯”，影响着人们的工作、饮食、玩乐、消费和沟通方式。核心习惯能启动一个进程，久而久之将改变一切。”</p>
</blockquote>
<blockquote>
<p>“个人有习惯；组织则有惯例”</p>
</blockquote>
<p>当早上起来我们把被子折好之后, 看着整齐的床铺, 我们会得到 &ldquo;今天将是美好的一天的暗示&rdquo;</p>
<blockquote>
<p>“当人们开始养成运动的习惯时，即使是一周一次的运动，他们也会不知不觉改变其他与之无关的行为模式”
“每天早上整理床铺，与更高的工作效率、更强的幸福感以及控制预算能力有关”</p>
</blockquote>
<blockquote>
<p>“小成功是关键习惯引起广泛变化这个过程的一部分。大量的研究表明，小成功在实现胜利过程中，有着巨大的影响力”</p>
</blockquote>
<blockquote>
<p>“这就是核心习惯推动广泛变化的最后一种方法：建立能融入新价值观的文化。核心习惯会让艰难的抉择变得容易，比如说开除高层人员这种抉择，因为破坏企业文化的人就得离开。”</p>
</blockquote>
<blockquote>
<p>“核心习惯之所以能改变我们，是因为它能创造出各种文化，让我们清楚地看到那些在抉择困难或者感到茫然的时候很可能被忘记的价值”</p>
</blockquote>
<blockquote>
<p>“，“大部分企业行为可以被理解为企业过去的一般习惯和战略方向的外在反映”</p>
</blockquote>
<h2 id="意志力">意志力</h2>
<p>意志力是一种能量, 会被消耗殆尽的</p>
<blockquote>
<p>“由于之前消耗了一些意志力去抵御饼干的诱惑，那些人就成了容易退出的阵营当中的一员。”姆拉文向我解释道，“从那次试验之后，我们又作了超过200次的研究，结论都是相同的。意志力不是一种技能，而是一种力量，就如同你手臂和大腿中肌肉的力量，用力过猛会感到疲累，肌肉剩余的力量就不足以供给其他活动。”</p>
</blockquote>
<p>意志力是一种能量, 也是可以通过训练得到提高.</p>
<blockquote>
<p>“他们限制垃圾食品的摄入，在工作学习的时候也更有效率。这就像体育锻炼研究中所说的，如果人们在生活的某一方面加强了自己的意志力量，比如体育运动和理财项目，那么这种力量会进入到他们的饮食习惯和工作中。一旦意志力得到加强，它就会延伸到生活的方方面面。”
“来自达特茅斯学院的致力于意志力研究的学者托德·希瑟顿说：“当你学会强迫自己参与体育锻炼，或者开始做家庭作业，只吃沙拉不吃汉堡的时候，你的思维正在改变。当学会控制自己的冲动时，人们就在进步。他们将学会如何在诱惑面前分散注意力。而且一旦你形成了意志力锻炼的习惯，你的大脑就会驾轻就熟地帮助你专注于你的目标。”</p>
</blockquote>
<p>当我们觉得做一件事情, 我们没有认同感, 我们就更加需要使用意志力去强迫我们自己去做这件事.</p>
<blockquote>
<p>“，“当被要求去做一些需要自我克制的事情时，如果参与者认为这是个选择或者因为可以帮助别人而让自己开心，那用到的意志力就会少很多。如果他们感到自己没有自主权，只是单纯地接受命令，他们意志力消耗的速度就会加快。”在这个例子中，学生都忽视了饼干，但当这些学生感觉自己被当成工具对待时，他们的意志力消耗得就会更快。”</p>
</blockquote>
<h2 id="抓住逆境-调整习惯">抓住逆境, 调整习惯</h2>
<p>一家医院因为遇到了发生了重大医疗事故, 大家就需要做出妥协, 有利于企业调整企业的习惯</p>
<blockquote>
<p>“有时候人们需要逆境的鞭策，而医院的这些负面影响就是巨大的逆境，它给了我们一个机会来重新审视这一切。”</p>
</blockquote>
<blockquote>
<p>“医生和护士们不愿意拍摄自己的手术过程，也不愿意其他医院的医护人员指指点点。但是一旦危机笼罩了整所医院，每个人都愿意做出一些改变”</p>
</blockquote>
<blockquote>
<p>“优秀的领导者会抓住危机来重塑组织习惯”</p>
</blockquote>
<blockquote>
<p>“但明智的领导者会寻求危机甚至创造危机感，并让大家都有需要改变的感觉，直到最后所有人都作好准备来彻底改变他们以往习惯的行为模式”</p>
</blockquote>
<h2 id="消费者的习惯">消费者的习惯</h2>
<blockquote>
<p>“有时候，顾客就像是一种被消费习惯支配的生物，他们会自动重复过去的行为，很少考虑到当前的目标”</p>
</blockquote>
<p>利用[[大数据]], 来构建消费的人群画像, 分析消费者的习惯, 促进消费的进一步消费</p>
<blockquote>
<p>“波尔告诉我：“我们将这种分析称为‘为客人画像’，我们对某位顾客了解得越多，就越能猜测出他的购买模式”</p>
</blockquote>
<blockquote>
<p>“当消费者遭遇到人生的重大事件时，他们的消费习惯更容易发生改变”</p>
</blockquote>
<h3 id="习惯影响社会运动">习惯影响社会运动</h3>
<blockquote>
<p>“运动的持续在于运动领袖让参与者形成了新的习惯，树立了新的认同感和主人翁感。”</p>
</blockquote>
<blockquote>
<p>“社会学家认为，通常来说，物以类聚，人以群分。我们的好朋友当中会有一些比较有钱，一些比较贫穷，还有一些是来自其他种族，但总体上说，与我们关系最深厚的朋友，往往是那些性情与我们相近、收入与我们相当，并且与我们有共同背景的人。”</p>
</blockquote>
<blockquote>
<p>“如果你忽视邻里间的义务感，如果你对社群的既定模式不屑一顾，你很可能失去你的社会地位。你会危及自己获得很多社群福利的资格，比如你没法参加乡村俱乐部、校友会或者教会，而这些正是你社群福利的前提。”</p>
</blockquote>
<p>人与人之间联系, 可以分为强联系和弱联系</p>
<blockquote>
<p>“这种习惯来自朋友的期望和普通熟人的同伴压力。所以，不管他们有过怎样的犹豫，最终他们还是会登上去密西西比的班车”</p>
</blockquote>
<blockquote>
<p>“社区中弱联系的力量将所有人联合了起来。在这种环境下，如果你不加入抵制，那你就是异类”</p>
</blockquote>
<blockquote>
<p>“通过引导人们的社会习惯来传教，比如民权运动就是一个很好的模仿对象。麦加兰夫在他的一本书中写道：“固定的目标是让整个社会，也就是所有人皈依基督教，或者让大部分人皈依，这样才可以使个人的社会生活不会受到破坏。”</p>
</blockquote>
<blockquote>
<p>“运动并不是因为大家突然作了同样的决定而出现的。他们依靠的社会习惯模式一开始是作为友谊的习惯存在的，在社群习惯中成长，并由改变参与者自我感的新习惯维系”</p>
</blockquote>
<h3 id="改变自己">改变自己</h3>
<blockquote>
<p>“不过，要想改变习惯，那就必须有决心去改。你必须有意识地去努力寻找驱动着你的习惯每天发生的暗示和奖赏，并且找到它们的替代品。”</p>
</blockquote>
<blockquote>
<p>“如果你相信你可以改变，如果你将其变成一种习惯，那么改变就是真实可行的。这就是习惯的真正力量：你的选择决定了你的习惯。一旦做出选择，并且成了自发行为，”</p>
</blockquote>
<blockquote>
<p>习惯记录笔记</p>
<p>“你在哪？（坐在我的办工桌前）
现在几点？（下午3点36分）
你的情绪怎样？（觉得无聊）
周围有谁？（空无一人）
在买饼干的冲动之前，你做了什么？（我回复了一封电子邮件）”</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Okr 2023</title>
      <link>https://ynikl.github.io/neo/okr-2023/</link>
      <pubDate>Thu, 05 Jan 2023 20:12:10 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/neo/okr-2023/</guid>
      <description>2023 OKR 在生活上, 让时间过得更加有计划性, 持续增加自己的知识储备. 在精神上, 塑造更加坚毅的内心, 输出更多的自我表达. 在工作上, 抓住机遇, 开始打造自己的技术护城河, 争取到一次涨薪. 2023 年加油.
深化打造技术护城河
音视频处理入门 精通 Golang 语言 扩展自己知识认知, 提升自我象形.
每个月 4-5 本书籍的阅读量. 35 cm 的臂维, 肚子没有赘肉. 迈出自己的圈子
完成20次开心的朋友聚会. 达成两场旅游. January O: 加深 Golang 技术
golang 100 Mistake go gorm 学习 go gin 学习 go context go 泛型 O: 算法与数据结构入门
算法数据结构资料汇总, 以及学习计划安排 算法4 完成5章精读 总结:
中间调整目标转向学习视频的编码技术, 下次配合更新OKR目标
聚会次数完成 +=2
February O: 加深 Golang 技术
golang 100 Mistake go 单元测试技能 O: 视频技能入门</description>
      <content:encoded><![CDATA[<h1 id="2023-okr">2023 OKR</h1>
<p>在生活上, 让时间过得更加有计划性, 持续增加自己的知识储备.
在精神上, 塑造更加坚毅的内心,  输出更多的自我表达.
在工作上, 抓住机遇, 开始打造自己的技术护城河, 争取到一次涨薪.
2023 年加油.</p>
<p>深化打造技术护城河</p>
<ul>
<li><input disabled="" type="checkbox"> 音视频处理入门</li>
<li><input disabled="" type="checkbox"> 精通 Golang 语言</li>
</ul>
<p>扩展自己知识认知, 提升自我象形.</p>
<ul>
<li><input disabled="" type="checkbox"> 每个月 4-5 本书籍的阅读量.</li>
<li><input disabled="" type="checkbox"> 35 cm 的臂维, 肚子没有赘肉.</li>
</ul>
<p>迈出自己的圈子</p>
<ul>
<li><input disabled="" type="checkbox"> 完成20次开心的朋友聚会.</li>
<li><input disabled="" type="checkbox"> 达成两场旅游.</li>
</ul>
<h2 id="january">January</h2>
<p>O: 加深 Golang 技术</p>
<ul>
<li><input disabled="" type="checkbox"> golang 100 Mistake</li>
<li><input checked="" disabled="" type="checkbox"> go gorm 学习</li>
<li><input checked="" disabled="" type="checkbox"> go gin 学习</li>
<li><input disabled="" type="checkbox"> go context</li>
<li><input checked="" disabled="" type="checkbox"> go 泛型</li>
</ul>
<p>O: 算法与数据结构入门</p>
<ul>
<li><input disabled="" type="checkbox"> 算法数据结构资料汇总, 以及学习计划安排</li>
<li><input disabled="" type="checkbox"> 算法4 完成5章精读</li>
</ul>
<p>总结:</p>
<p>中间调整目标转向学习视频的编码技术, 下次配合更新OKR目标</p>
<p>聚会次数完成 +=2</p>
<h2 id="february">February</h2>
<p>O: 加深 Golang 技术</p>
<ul>
<li><input disabled="" type="checkbox"> golang 100 Mistake</li>
<li><input disabled="" type="checkbox"> go 单元测试技能</li>
</ul>
<p>O: 视频技能入门</p>
<p><del>- [ ] 业务上完成视频产品接入</del>
<del>- [ ] 一本相关技术书籍完成</del></p>
<p>业务发展调整, 功能承接失败, 但是以视频开发方向暂时不变</p>
<ul>
<li><input disabled="" type="checkbox"> C++ Prime Plus 1/2</li>
<li><input disabled="" type="checkbox"> 大数据相关基础知识入门</li>
</ul>
<p>O: 算法与数据结构入门</p>
<ul>
<li><input disabled="" type="checkbox"> 算法数据结构资料汇总, 以及学习计划安排</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>202301</title>
      <link>https://ynikl.github.io/notes/202301/</link>
      <pubDate>Thu, 05 Jan 2023 14:04:07 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/notes/202301/</guid>
      <description>&amp;ldquo;与其担心宏观经济，不如关注自己。你对自己生活的影响，往往比宏观经济对你的影响大得多。&amp;rdquo;
不要 过度 自己是否会被裁员, 而是要聚焦自己目标的, 提升自己的能力, 抵抗宏观经济问题.
阮一峰网络日志
世界最大对冲基金&amp;quot;桥水基金&amp;quot;创始人达里奥，说过一句话，可以用在这里：&amp;ldquo;如果你忧心忡忡，那是不必要的；如果你毫不担心，那么你需要担心。&amp;rdquo;
要保持担忧, 但更要聚焦于自己</description>
      <content:encoded><![CDATA[<blockquote>
<p>&ldquo;与其担心宏观经济，不如关注自己。你对自己生活的影响，往往比宏观经济对你的影响大得多。&rdquo;</p>
</blockquote>
<p>不要 <strong>过度</strong> 自己是否会被裁员, 而是要聚焦自己目标的, 提升自己的能力, 抵抗宏观经济问题.</p>
<p><a href="https://www.ruanyifeng.com/blog/2022/09/weekly-issue-223.html">阮一峰网络日志</a></p>
<blockquote>
<p>世界最大对冲基金&quot;桥水基金&quot;创始人达里奥，说过一句话，可以用在这里：&ldquo;如果你忧心忡忡，那是不必要的；如果你毫不担心，那么你需要担心。&rdquo;</p>
</blockquote>
<p>要保持担忧, 但更要聚焦于自己</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang Gin</title>
      <link>https://ynikl.github.io/blog/golang-gin/</link>
      <pubDate>Sun, 01 Jan 2023 22:08:25 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-gin/</guid>
      <description>Golang Gin 框架的使用和理解 框架代码地址
中间的几个关键对象 Engine RouterGroup HandlerFunc Context Engine gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过New()或者Default()创建
New 不带任何中间件 Default 会带 logger 和 recover 通过 Engine.Use() 添加中间件到Engine的RouterGroup
Engine.Run 启动, 并绑定到参数的地址
RouterGroup 1 2 3 4 5 6 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 用于存储中间件的处理方法 &amp;ndash; 存储再 HandlersChain 里面, 即[]HandlerFunc
真正的路由地址存储在engine.trees &amp;ndash; 路由树, 检索请求地址和对应处理方法.
Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址. 目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树. 也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.</description>
      <content:encoded><![CDATA[<h1 id="golang-gin-框架的使用和理解">Golang Gin 框架的使用和理解</h1>
<p><a href="https://github.com/gin-gonic/gin">框架代码地址</a></p>
<h2 id="中间的几个关键对象">中间的几个关键对象</h2>
<ul>
<li>Engine</li>
<li>RouterGroup</li>
<li>HandlerFunc</li>
<li>Context</li>
</ul>
<h3 id="engine">Engine</h3>
<p>gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过<code>New()</code>或者<code>Default()</code>创建</p>
<ul>
<li><code>New</code> 不带任何中间件</li>
<li><code>Default</code> 会带 <code>logger</code> 和 <code>recover</code></li>
</ul>
<p>通过 <code>Engine.Use()</code> 添加中间件到Engine的<code>RouterGroup</code></p>
<p><code>Engine.Run</code> 启动, 并绑定到参数的地址</p>
<h3 id="routergroup">RouterGroup</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type RouterGroup struct {
</span></span><span class="line"><span class="cl">	Handlers HandlersChain
</span></span><span class="line"><span class="cl">	basePath string
</span></span><span class="line"><span class="cl">	engine   *Engine
</span></span><span class="line"><span class="cl">	root     bool
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>用于存储中间件的处理方法 &ndash; 存储再 <code>HandlersChain</code> 里面, 即<code>[]HandlerFunc</code></p>
<p>真正的路由地址存储在<code>engine.trees</code> &ndash; 路由树, 检索请求地址和对应处理方法.</p>
<p>Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址.
目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树.
也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes {
</span></span><span class="line"><span class="cl">	absolutePath := group.calculateAbsolutePath(relativePath)
</span></span><span class="line"><span class="cl">	handlers = group.combineHandlers(handlers)
</span></span><span class="line"><span class="cl">	group.engine.addRoute(httpMethod, absolutePath, handlers)
</span></span><span class="line"><span class="cl">	return group.returnObj()
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注册路由之前, 先将当前的 http 处理方法, 与当前中间件配置合并, 再添加到engine.</p>
<h4 id="routergroup-1">RouterGroup</h4>
<p><code>RouterGroup.Group</code>	创建一个新的 <code>RouterGroup</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">group</span> <span class="o">*</span><span class="nx">RouterGroup</span><span class="p">)</span> <span class="nf">Group</span><span class="p">(</span><span class="nx">relativePath</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handlers</span> <span class="o">...</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="o">*</span><span class="nx">RouterGroup</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RouterGroup</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Handlers</span><span class="p">:</span> <span class="nx">group</span><span class="p">.</span><span class="nf">combineHandlers</span><span class="p">(</span><span class="nx">handlers</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">basePath</span><span class="p">:</span> <span class="nx">group</span><span class="p">.</span><span class="nf">calculateAbsolutePath</span><span class="p">(</span><span class="nx">relativePath</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">:</span>   <span class="nx">group</span><span class="p">.</span><span class="nx">engine</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建新的 Group  时候,也会继承旧的 Group, 原先已经设置的 middleware. gin 框架不支持移除中间件的操作，所以在上层设置的中间件的时候一定要确保是公共 common 的</p>
<p>相似的路由捆绑在一块, 路由组写法, 可以做绑定相同中间件处理.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// Simple group: v1
</span></span><span class="line"><span class="cl">v1 := router.Group(&#34;/v1&#34;)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  v1.POST(&#34;/login&#34;, loginEndpoint)
</span></span><span class="line"><span class="cl">  v1.POST(&#34;/submit&#34;, submitEndpoint)
</span></span><span class="line"><span class="cl">  v1.POST(&#34;/read&#34;, readEndpoint)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>中间的花括号只起美化代码作用, 非必需</p>
<h3 id="handlerfunc">HandlerFunc</h3>
<p>中间件和请求处理方法的函数签名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Context</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>处理请求的时候, HandlerFunc 执行完毕 &ndash; 代表该请求处理结束</p>
<h3 id="context">Context</h3>
<p>gin 自己实现的 Context 结构</p>
<ul>
<li>在中间件中传递参数</li>
<li>控制调用流程</li>
<li>获取参数</li>
<li>返回结果</li>
</ul>
<p>Context 结构的重要组成部分介绍</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 存储URL 参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Params</span>   <span class="nx">Params</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 写入请求的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Writer</span>    <span class="nx">ResponseWriter</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 请求的所有处理方法集合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">handlers</span> <span class="nx">HandlersChain</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 当前执行到第几个方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">index</span>    <span class="kt">int8</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 存储流转于中间件的参数式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Keys</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">any</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="在中间件中传递参数">在中间件中传递参数</h4>
<ul>
<li><code>context.Get</code></li>
<li><code>context.Set</code> 两个方法在中间件中传递参数</li>
</ul>
<h4 id="流程控制">流程控制</h4>
<ul>
<li><code>context.Next()</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">&lt;</span> <span class="nb">int8</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="p">](</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将当前代码执行点移交到下一个 <code>HandlerFunc</code> 具体流程看, <a href="#Middleware">Middleware</a></p>
<h4 id="获取参数">获取参数</h4>
<ul>
<li><code>context.Param()</code> 获取 Query Param 的字符串参数</li>
<li><code>context.Query()</code></li>
<li><code>context.QueryMap()</code> 或者 <code>context.PostFormMap</code> 获取 map 的参数</li>
<li><code>context.Bind</code> 将参数包含query参数和body参数解析之后, 反序列化到传入的结构体.
tag <code>binding:&quot;required&quot;</code> 如果没有对应参数会报错</li>
</ul>
<h4 id="调用结束">调用结束</h4>
<ul>
<li><code>conetxt.JSON</code> 以json的形式, 返回结果
举个例子: 如果是json的的化就是 <code>jsonBinding</code> 进行反序列化</li>
<li>报错 500 <code>context.AbortWithStatus()</code></li>
</ul>
<h4 id="cookie-操作">Cookie 操作</h4>
<ul>
<li><code>context.Cookie()</code></li>
<li><code>context.SetCookie()</code></li>
</ul>
<h3 id="middleware">Middleware</h3>
<p>符合 <a href="#HandlerFunc">HandlerFunc</a> 签名的函数. 就可以<code>Engine.Use</code>注册层路由. 路由设置
的处理函数, 在本质上可以称为中间件.</p>
<ol>
<li>gin 会按照 routegroup <code>Use</code> 中间件的先后顺序存储到路由表中</li>
<li>接收请求, 依次执行注册时设置的所有中间件函数.</li>
</ol>
<h4 id="next">Next</h4>
<p>调用流程图:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">middleware 1
</span></span><span class="line"><span class="cl">| - doing m1 work
</span></span><span class="line"><span class="cl">| - call Context.Next()
</span></span><span class="line"><span class="cl">|     - call middleware 2
</span></span><span class="line"><span class="cl">|       - doing m2 work
</span></span><span class="line"><span class="cl">|       - call Context.Next()
</span></span><span class="line"><span class="cl">|         - call middleware 3
</span></span><span class="line"><span class="cl">|         - - done m3
</span></span><span class="line"><span class="cl">|       - continue m2 work
</span></span><span class="line"><span class="cl">|     - - done m2 work
</span></span><span class="line"><span class="cl">| - coninue m1 work
</span></span><span class="line"><span class="cl">| - done 
</span></span><span class="line"><span class="cl">finish
</span></span></code></pre></td></tr></table>
</div>
</div><p>当调研 <code>Context.Next()</code> 时会调用下一个中间函数, 当下一个函数执行完成之后, 执行
代码会返回到原先调用 <code>Context.Next()</code>的地方 &ndash; 递归</p>
<h4 id="abort">Abort</h4>
<p>中间处理时可以调用 <code>Context.Abort()</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Abort</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="nx">abortIndex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>会将函数调用链的index指向一个超大整数 &ndash; 放弃后面所有的处理函数, 但是 <strong>调用Abort后, 同一个函数接下的代码还会继续执行</strong></p>
<h4 id="小demo">小demo</h4>
<p><a href="https://gist.github.com/ynikl/20b603bfd743d2540d482939ac87d133">demo</a></p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">m1</span><span class="p">,</span> <span class="nx">m2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/greet&#34;</span><span class="p">,</span> <span class="nx">m3</span><span class="p">,</span> <span class="nx">greet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/abort&#34;</span><span class="p">,</span> <span class="nx">abort</span><span class="p">,</span> <span class="nx">m3</span><span class="p">,</span> <span class="nx">greet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">m1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;before m1 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;after m1 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">m2</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\tbefore m2 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\tafter m2 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">m3</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\tbefore m3 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\tafter m3 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">abort</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\t\tbefore abort&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Abort</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\t\tafter abort&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\t\t\thow are you doing?&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s">&#34;great&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接口 <code>/greet</code> 的输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">before m1 next
</span></span><span class="line"><span class="cl">        before m2 next
</span></span><span class="line"><span class="cl">                before m3 next
</span></span><span class="line"><span class="cl">                                how are you doing?
</span></span><span class="line"><span class="cl">                after m3 next
</span></span><span class="line"><span class="cl">        after m2 next
</span></span><span class="line"><span class="cl">after m1 next
</span></span></code></pre></td></tr></table>
</div>
</div><p>接口 <code>/abort</code> 的数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">before m1 next
</span></span><span class="line"><span class="cl">        before m2 next
</span></span><span class="line"><span class="cl">                        before abort
</span></span><span class="line"><span class="cl">                        after abort
</span></span><span class="line"><span class="cl">        after m2 next
</span></span><span class="line"><span class="cl">after m1 next
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="其他">其他</h3>
<p>gin.H</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 常用于 engine.JSON() 时返回 json 数据
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="几个问题">几个问题</h2>
<h3 id="gin-的-context-有什么作用和怎么用">Gin 的 context 有什么作用和怎么用?</h3>
<p>context 是 Gin 代码请求流转的核心, 存储处理请求的所有必须参数</p>
<p>基本的使用方法:</p>
<ol>
<li>需要知道如何获取参数 &ndash; <code>Bind</code> 或者 <code>Param</code> 方法</li>
<li>控制处理函数流程 &ndash; <code>Next</code> 或者 <code>Abort</code> 方法</li>
<li>返回结果 &ndash; <code>JSON</code></li>
</ol>
<h3 id="gin-的整体框架流程是怎么样的-从接受到一个请求再到返回请求中间的流程">Gin 的整体框架流程是怎么样的? 从接受到一个请求再到返回请求中间的流程?</h3>
<p>请求的注册入口, <code>Engine.ServeHTTP</code></p>
<p>整体流程</p>
<ol>
<li>存储路由路径和注册的处理函数到&quot;路由树&quot; &ndash; <code>nodetree</code></li>
<li>接收请求</li>
<li>根据接收到的请求地址, 从路由树中取出注册的函数, 组成<code>HandlerChain</code> 函数处理链</li>
<li>把函数处理链赋值到<code>gin.Context</code>中</li>
<li>由<code>gin.Context</code>开始依次调用注册处理函数, 所以函数遍历完成, 处理结束</li>
<li>通过<code>gin.Context.Writer</code>写入http请求结果</li>
<li>请求结束</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>工程能力阶梯分析</title>
      <link>https://ynikl.github.io/posts/my-engineeringladders/</link>
      <pubDate>Thu, 22 Dec 2022 11:38:36 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/my-engineeringladders/</guid>
      <description>工程师能力阶梯
自我能力分析</description>
      <content:encoded><![CDATA[<p><a href="https://github.com/jorgef/engineeringladders">工程师能力阶梯</a></p>
<p><img loading="lazy" src="https://s2.loli.net/2022/12/22/e7WUb6jY859TrsC.png" alt="原图"  />
</p>
<p>自我能力分析</p>
<p><img loading="lazy" src="https://s2.loli.net/2022/12/22/tNIgMAXcFoOdRSW.png" alt="我当前的能力分析"  />
</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql 快速备份数据</title>
      <link>https://ynikl.github.io/blog/mysql-quick-backup-data/</link>
      <pubDate>Tue, 20 Dec 2022 10:55:10 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/mysql-quick-backup-data/</guid>
      <description>1 2 CREATE TABLE dbto.table_name like dbfrom.table_name; insert into dbto.table_name select * from dbfrom.table_name; 原文</description>
      <content:encoded><![CDATA[<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">CREATE TABLE dbto.table_name like dbfrom.table_name;
</span></span><span class="line"><span class="cl">insert into  dbto.table_name select * from dbfrom.table_name;
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://stackoverflow.com/a/63457341/9992963">原文</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang 是否需要为每个请求 New 一个 Client</title>
      <link>https://ynikl.github.io/blog/golang-client-reuse/</link>
      <pubDate>Mon, 19 Dec 2022 15:35:53 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-client-reuse/</guid>
      <description>背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致下游的 nginx 的连接数暴涨.
问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client
探索 在 StackOverflow 发现的相关答案
How to release http.Client in Go?
给的答案是建议复用 Client
The Client&amp;rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
http.Client 的结构体
1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time.</description>
      <content:encoded><![CDATA[<h2 id="背景">背景</h2>
<p>在改动旧代码的时候把, 一个使用全局 <code>http.Client</code> 的代码弄成了每一个请求会新 New
一个 <code>http.Client</code> 导致下游的 nginx 的连接数暴涨.</p>
<h2 id="问题">问题</h2>
<p>处理多个请求的时候, 是否需要为每个请求 New 一个 Client</p>
<h2 id="探索">探索</h2>
<p>在 StackOverflow 发现的相关答案</p>
<p><a href="https://stackoverflow.com/a/36688970/9992963">How to release http.Client in Go?</a></p>
<p>给的答案是建议复用 <code>Client</code></p>
<blockquote>
<p>The Client&rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.</p>
</blockquote>
<p>http.Client 的结构体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type Client struct {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	Transport RoundTripper
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	CheckRedirect func(req *Request, via []*Request) error
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	Jar CookieJar
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	Timeout time.Duration
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>RoundTripper</code> 中实现了连接复用的逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type RoundTripper interface {
</span></span><span class="line"><span class="cl">	RoundTrip(*Request) (*Response, error)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>中定义了 <code>RoundTrip</code> 方法, 提供客户端请求的时候调用.</p>
<p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=1;bpt=1;l=512?q=%2Fnet%2Fhttp%2Ftransport.go&amp;ss=go%2Fgo">调用地址</a></p>
<p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;l=95?q=%2Fnet%2Fhttp%2Ftransport.go&amp;ss=go%2Fgo">查看一下 Golang Transport 的基本实现</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type Transport struct {
</span></span><span class="line"><span class="cl">	idleMu       sync.Mutex
</span></span><span class="line"><span class="cl">	closeIdle    bool                                // user has requested to close all idle conns
</span></span><span class="line"><span class="cl">	idleConn     map[connectMethodKey][]*persistConn // most recently used at end
</span></span><span class="line"><span class="cl">	idleConnWait map[connectMethodKey]wantConnQueue  // waiting getConns
</span></span><span class="line"><span class="cl">	idleLRU      connLRU
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	connsPerHostMu   sync.Mutex
</span></span><span class="line"><span class="cl">	connsPerHost     map[connectMethodKey]int
</span></span><span class="line"><span class="cl">	connsPerHostWait map[connectMethodKey]wantConnQueue // waiting getConns
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	// 还有其他字段略
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>结构体中间有很多连接存储相关的字段.</p>
<p>在 http 请求调用 Transport 中间有一个关键方法 <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;bpv=1;bpt=1;l=1338">getConn</a> 获取一个连接</p>
<p>方法声明一个想要的连接地址, <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=1b2ad1d815ea8967c49b32d848b2992d0c588d88;l=1194">wantConn</a> 推入到 <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=0;bpt=1;l=1422">queueForDial</a></p>
<p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=1;bpt=1;l=1422">QueueForDial 方法</a>会判断时候<code>connsPerHost</code> 中间是否有当前的请求的缓存连接</p>
<ul>
<li>如果有直接拿来重复使用</li>
<li>如果没有, 就需要重新进行拨号</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	w.beforeDial()
</span></span><span class="line"><span class="cl">	if t.MaxConnsPerHost &lt;= 0 {
</span></span><span class="line"><span class="cl">		go t.dialConnFor(w)
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	t.connsPerHostMu.Lock()
</span></span><span class="line"><span class="cl">	defer t.connsPerHostMu.Unlock()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if n := t.connsPerHost[w.key]; n &lt; t.MaxConnsPerHost {
</span></span><span class="line"><span class="cl">		if t.connsPerHost == nil {
</span></span><span class="line"><span class="cl">			t.connsPerHost = make(map[connectMethodKey]int)
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		t.connsPerHost[w.key] = n + 1
</span></span><span class="line"><span class="cl">		go t.dialConnFor(w)
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if t.connsPerHostWait == nil {
</span></span><span class="line"><span class="cl">		t.connsPerHostWait = make(map[connectMethodKey]wantConnQueue)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	q := t.connsPerHostWait[w.key]
</span></span><span class="line"><span class="cl">	q.cleanFront()
</span></span><span class="line"><span class="cl">	q.pushBack(w)
</span></span><span class="line"><span class="cl">	t.connsPerHostWait[w.key] = q
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="结论">结论</h2>
<p>重复使用 http.Client 可以达到 TCP 连接复用的效果</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>查看 Linux 的负载情况</title>
      <link>https://ynikl.github.io/blog/linux-server-device-info/</link>
      <pubDate>Fri, 16 Dec 2022 14:31:33 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/linux-server-device-info/</guid>
      <description>查看负载 系统平均负载
1 uptime 那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。 如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。
查看内存信息 1 free -h 查看 cpu 型号
1 cat /proc/cpuinfo | grep &amp;#39;physical id&amp;#39; | sort | uniq | wc -l 核数
1 cat /proc/cpuinfo |grep &amp;#34;cores&amp;#34;|uniq|awk &amp;#39;{print $4}&amp;#39; 参考文章 https://www.eet-china.com/mp/a87720.html https://colobu.com/2019/02/22/how-to-find-cpu-cores-in-linux/ https://wangchujiang.com/linux-command/c/uptime.html </description>
      <content:encoded><![CDATA[<h2 id="查看负载">查看负载</h2>
<p>系统平均负载</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">uptime
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。
如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。</p>
</blockquote>
<h2 id="查看内存信息">查看内存信息</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">free -h
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="查看-cpu">查看 cpu</h2>
<p>型号</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cat /proc/cpuinfo | grep &#39;physical id&#39; | sort | uniq | wc -l
</span></span></code></pre></td></tr></table>
</div>
</div><p>核数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">cat /proc/cpuinfo |grep &#34;cores&#34;|uniq|awk &#39;{print $4}&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://www.eet-china.com/mp/a87720.html">https://www.eet-china.com/mp/a87720.html</a></li>
<li><a href="https://colobu.com/2019/02/22/how-to-find-cpu-cores-in-linux/">https://colobu.com/2019/02/22/how-to-find-cpu-cores-in-linux/</a></li>
<li><a href="https://wangchujiang.com/linux-command/c/uptime.html">https://wangchujiang.com/linux-command/c/uptime.html</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Git 查看文件指定范围的修改记录</title>
      <link>https://ynikl.github.io/posts/git-view-change-log-in-specifie-line/</link>
      <pubDate>Mon, 12 Dec 2022 15:29:36 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/git-view-change-log-in-specifie-line/</guid>
      <description>查看一个文件指定范围内的所有修改记录
1 git log -p -2 -L1081,+5:&amp;#39;hello/world.go&amp;#39; -p -2 或者 --patch -2
往前展示两个 commit 的 diff . 在 git 中 commit 和 patch 是同一个意思参考下文.
git commands patching
A few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches.
-L 语法 -L&amp;lt;start&amp;gt;,&amp;lt;end&amp;gt;:&amp;lt;file&amp;gt;, -L:&amp;lt;funcname&amp;gt;:&amp;lt;file&amp;gt;
限制指定查看范围.</description>
      <content:encoded><![CDATA[<p>查看一个文件指定范围内的所有修改记录</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">git log -p -2 -L1081,+5:&#39;hello/world.go&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>-p -2</code> 或者 <code>--patch -2</code></p>
<p>往前展示两个 commit 的 diff . 在 git 中 commit 和 patch 是同一个意思参考下文.</p>
<p><a href="https://git-scm.com/book/en/v2/Appendix-C:-Git-Commands-Patching">git commands patching</a></p>
<blockquote>
<p>A few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches.</p>
</blockquote>
<p><code>-L</code> 语法
<code>-L&lt;start&gt;,&lt;end&gt;:&lt;file&gt;, -L:&lt;funcname&gt;:&lt;file&gt;</code></p>
<p>限制指定查看范围.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>202212</title>
      <link>https://ynikl.github.io/notes/202212/</link>
      <pubDate>Fri, 09 Dec 2022 14:04:07 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/notes/202212/</guid>
      <description>5 代码整洁结构 内部不应该依赖外部, 业务逻辑的实现, 不应该依赖于框架
20 1917
Down to Gehenna or up to the Throne, He travels the fastest who travles alone
小狗钱钱
真正的勇敢是在感到最恐惧的时候, 你依然在往前走.
曹大博客
政府/企业对事故的管理一般有一套“事前-事中-事后”的分析框架，可以作为我们处理事故的很好的参考。在开始分析之前，要先简单了解一下这个框架： 所谓事前，就是做事情之前应该有统筹的规划，考虑可能出现的问题和困难，最好提前做实验验证下，以保证在真实现场不出问题，或者即使出现问题也有应对方案，不至于手忙脚乱、大动干戈。 所谓事中，就是做事情的过程中对事前规划的事情进行执行，以及记录过程中出现的问题；整个事中起着承前启后的作用，上对事前的规划进行验证，下对事后的总结反思进行铺垫。 所谓事后，就是做事情结束后对整个事情进行总结反思、问题分类和根因分析等。追踪并确认所有的问题有效进行了解决和应对，以确保下次不会再犯之前同样的错误。
22 工程师能力阶梯
Eleanor Roosevelt
Great minds discuss ideas（伟人谈论想法）
Average minds discuss events （ 普通人谈论事件）
Small minds discuss people（ 庸人谈论他人）</description>
      <content:encoded><![CDATA[<h2 id="5">5</h2>
<h3 id="代码整洁结构httpswwwartacodecompostgolangtemplate"><a href="https://www.artacode.com/post/golang/template/">代码整洁结构</a></h3>
<p>内部不应该依赖外部, <strong>业务逻辑的实现, 不应该依赖于框架</strong></p>
<h2 id="20">20</h2>
<p>1917</p>
<blockquote>
<p>Down to Gehenna or up to the Throne, He travels the fastest who travles alone</p>
</blockquote>
<p>小狗钱钱</p>
<blockquote>
<p>真正的勇敢是在感到最恐惧的时候, 你依然在往前走.</p>
</blockquote>
<p>曹大博客</p>
<blockquote>
<p>政府/企业对事故的管理一般有一套“事前-事中-事后”的分析框架，可以作为我们处理事故的很好的参考。在开始分析之前，要先简单了解一下这个框架：
所谓事前，就是做事情之前应该有统筹的规划，考虑可能出现的问题和困难，最好提前做实验验证下，以保证在真实现场不出问题，或者即使出现问题也有应对方案，不至于手忙脚乱、大动干戈。
所谓事中，就是做事情的过程中对事前规划的事情进行执行，以及记录过程中出现的问题；整个事中起着承前启后的作用，上对事前的规划进行验证，下对事后的总结反思进行铺垫。
所谓事后，就是做事情结束后对整个事情进行总结反思、问题分类和根因分析等。追踪并确认所有的问题有效进行了解决和应对，以确保下次不会再犯之前同样的错误。</p>
</blockquote>
<h2 id="22">22</h2>
<p><a href="https://github.com/jorgef/engineeringladders">工程师能力阶梯</a></p>
<p>Eleanor Roosevelt</p>
<blockquote>
<p>Great minds discuss ideas（伟人谈论想法）<br>
Average minds discuss events （ 普通人谈论事件）<br>
Small minds discuss people（ 庸人谈论他人）</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>代码整洁架构</title>
      <link>https://ynikl.github.io/blog/clean-architectrue/</link>
      <pubDate>Mon, 05 Dec 2022 09:21:02 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/clean-architectrue/</guid>
      <description>代码整洁架构
核心思想 最重要的是依赖顺序需要内收 &amp;ndash; 业务逻辑不能依赖框架
分层 简单分层四层
Entities Use Cases Interface Adapters Framework and Drivers Entity 实体抽象层 我的理解应该是在公司业务, 或者项目领域上对于业务模型的抽象. 不容易改变 (除非公司 业务, 或者项目方向改变). 应该是与 领域驱动设计 不谋而合
Use Cases 使用场景层 业务使用场景, 应该是存放相关不同业务场景的具体实现流程
Interface Adapters 接口转化器层 负责 Use Cases 数据 与外部使用数据转换器实现.
比较特别的例子, 将 Use Cases 产生的数据与外部的 UI 表现层所需要的数据格式做转化.
Framework and Divers 数据库和框架层, 外部工具包接口依赖之类的.
依赖倒置 当遇到跨层依赖的时候, 内层需要引用到外层逻辑时: 比如, Use Case 要呈现 UI 数据结构 (Interface Adapters 层) 时, 不能直接引用 UI 层的数据模型.
而是, 通过依赖倒置. 将 UI 层的处理逻辑, 注入 Use Case 层进行处理, 实现目标.</description>
      <content:encoded><![CDATA[<p>代码整洁架构</p>
<h2 id="核心思想">核心思想</h2>
<p>最重要的是依赖顺序需要内收 &ndash; 业务逻辑不能依赖框架</p>
<h2 id="分层">分层</h2>
<p>简单分层四层</p>
<ul>
<li>Entities</li>
<li>Use Cases</li>
<li>Interface Adapters</li>
<li>Framework and Drivers</li>
</ul>
<h3 id="entity-实体抽象层">Entity 实体抽象层</h3>
<p>我的理解应该是在公司业务, 或者项目领域上对于业务模型的抽象. 不容易改变 (除非公司
业务, 或者项目方向改变). 应该是与 <em>领域驱动设计</em> 不谋而合</p>
<h3 id="use-cases-使用场景层">Use Cases 使用场景层</h3>
<p>业务使用场景, 应该是存放相关不同业务场景的具体实现流程</p>
<h3 id="interface-adapters-接口转化器层">Interface Adapters 接口转化器层</h3>
<p>负责 Use Cases 数据 与外部使用数据转换器实现.</p>
<p>比较特别的例子, 将 Use Cases 产生的数据与外部的 UI 表现层所需要的数据格式做转化.</p>
<h3 id="framework-and-divers">Framework and Divers</h3>
<p>数据库和框架层, 外部工具包接口依赖之类的.</p>
<h2 id="依赖倒置">依赖倒置</h2>
<p>当遇到跨层依赖的时候, 内层需要引用到外层逻辑时: 比如, Use Case 要呈现 UI 数据结构
(Interface Adapters 层) 时, 不能直接引用 UI 层的数据模型.</p>
<p>而是, 通过依赖倒置. 将 UI 层的处理逻辑, 注入 Use Case 层进行处理, 实现目标.</p>
<h2 id="golang-整洁模板">golang 整洁模板</h2>
<p>引用自 <a href="https://github.com/evrone/go-clean-template">golang clean template</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">├─cmd 应用入口
</span></span><span class="line"><span class="cl">│  └─app
</span></span><span class="line"><span class="cl">├─config
</span></span><span class="line"><span class="cl">├─docs // 存放文档
</span></span><span class="line"><span class="cl">├─internal
</span></span><span class="line"><span class="cl">│  ├─app
</span></span><span class="line"><span class="cl">│  ├─controller // 控制器
</span></span><span class="line"><span class="cl">│  │  ├─amqp_rpc
</span></span><span class="line"><span class="cl">│  │  └─http
</span></span><span class="line"><span class="cl">│  │      └─v1
</span></span><span class="line"><span class="cl">│  ├─entity // 实体层
</span></span><span class="line"><span class="cl">│  ├─middleware // 中间件
</span></span><span class="line"><span class="cl">│  └─usecase
</span></span><span class="line"><span class="cl">│      ├─repo // 数据库操作
</span></span><span class="line"><span class="cl">│      └─webapi // RESTful API
</span></span><span class="line"><span class="cl">├─migrations
</span></span><span class="line"><span class="cl">├─pkg //以被外部程序安全导入的包
</span></span><span class="line"><span class="cl">│  ├─crypto
</span></span><span class="line"><span class="cl">│  ├─httpresponse
</span></span><span class="line"><span class="cl">│  ├─httpserver
</span></span><span class="line"><span class="cl">│  ├─logger
</span></span><span class="line"><span class="cl">│  ├─mysql
</span></span><span class="line"><span class="cl">│  ├─postgres
</span></span><span class="line"><span class="cl">│  ├─rabbitmq
</span></span><span class="line"><span class="cl">│  └─redis
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://www.artacode.com/post/golang/template/">结构架构介绍</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">the clean architecture</a></li>
<li><a href="https://github.com/evrone/go-clean-template">goang clean template</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>小狗钱钱</title>
      <link>https://ynikl.github.io/books/ein-hund-namens-money/</link>
      <pubDate>Sun, 27 Nov 2022 13:56:17 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/ein-hund-namens-money/</guid>
      <description>我为什么要读这本书? 检讨自己, 学习理财的相关知识
曾经读完了 穷爸爸富爸爸 在那一段时间内有开始理财的想法, 后续又随的物欲的上涨, 开始过度超前消费, 让自己陷入了债务危机
这本书怎样影响了我? 开始编写梦想日记和成功日记 理解了&amp;quot;鹅&amp;quot;的故事, 开始做储蓄, 划分支出 作为一个陷入&amp;quot;债务危机&amp;quot;的人的自救 72 小时定律: 决定做一件事情要在72个小时内完成 72 公式: 投资 / 年利率 = 本金翻一倍需要的年数; 通货膨胀价值减半需要的年数 书中的三句精华句子? “：“吉娅，你真的认真找过工作了吗？我是说，你有没有用一整个下午的时间来考虑如何挣到钱的问题呢？” &amp;ndash; 很多时候你觉得你思考过了, 但是你真的花费了足够的时间思考了吗? “他用一种恳切的目光望着我，说：“我生命中出现了最美好的东西，是因为我做了原本不敢做的事。” &amp;ndash; 确实如此, 要去尝试自己所不敢做的事情 总结本书 通俗易懂, 醍醐灌顶 陷入债务危机的人的自救方法
销毁信用支付: 信用支付会比现金消费花的钱更多 尽可能少偿还贷款: 避免再次借贷, 弥补空缺 偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费. 书摘 “可是，这正是许多没有钱的人爱犯的错误。他们总是有那么多紧急的事情要做，以至于没有时间来关注重要的事情。”
“钱钱对我点了点头，说：“困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟”
理解重要不紧急的事情
“很简单。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。” ”
陷入债务危机的人的自救方法
销毁信用支付: 信用支付会比现金消费花的钱更多 尽可能少偿还贷款: 避免再次借贷, 弥补空缺 偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费. “鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。”
“我叹道：“要在‘鹅’和愿望之间作取舍真难！” “你根本不用放弃任何一个。两件事可以同时进行。”金先生微笑着说，“比如你挣了10马克，那么你可以分配一下这笔钱，把其中的大部分存入银行，然后把一部分放入你的梦想储蓄罐，剩下的当作零花钱。”
“所有人都希望自己变得富有一些，只是有些人的这一愿望更为强烈，而有些人却假装自己满足于现在的生活。事实上，大多数人都希望自己更幸福、更成功，也想拥有更多的钱”
“可是假如我们缺钱的话，钱就会变得格外重要。你回想一下那次我们差点淹死在河里的情形，当时我们想的只是必须从河里爬上来，其他的一切都变得无关紧要了”
“中国的智者老子说过：‘天下难事，必作于易；天下大事，必作于细”
“第一，我建议你拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。”
“没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西”</description>
      <content:encoded><![CDATA[<h3 id="我为什么要读这本书">我为什么要读这本书?</h3>
<p>检讨自己, 学习理财的相关知识</p>
<p>曾经读完了 <em>穷爸爸富爸爸</em> 在那一段时间内有开始理财的想法, 后续又随的物欲的上涨,
开始过度超前消费, 让自己陷入了债务危机</p>
<h3 id="这本书怎样影响了我">这本书怎样影响了我?</h3>
<ul>
<li>开始编写梦想日记和成功日记</li>
<li>理解了&quot;鹅&quot;的故事, 开始做储蓄, 划分支出</li>
<li>作为一个陷入&quot;债务危机&quot;的人的自救</li>
<li>72 小时定律: 决定做一件事情要在72个小时内完成</li>
<li>72 公式: 投资 / 年利率 = 本金翻一倍需要的年数; 通货膨胀价值减半需要的年数</li>
</ul>
<h3 id="书中的三句精华句子">书中的三句精华句子?</h3>
<ul>
<li>“：“吉娅，你真的认真找过工作了吗？我是说，你有没有用一整个下午的时间来考虑如何挣到钱的问题呢？” &ndash; 很多时候你觉得你思考过了, 但是你真的花费了足够的时间思考了吗?</li>
<li>“他用一种恳切的目光望着我，说：“我生命中出现了最美好的东西，是因为我做了原本不敢做的事。” &ndash; 确实如此, 要去尝试自己所不敢做的事情</li>
<li></li>
</ul>
<h3 id="总结本书">总结本书</h3>
<ul>
<li>通俗易懂, 醍醐灌顶</li>
</ul>
<p>陷入债务危机的人的自救方法</p>
<ol>
<li>销毁信用支付: 信用支付会比现金消费花的钱更多</li>
<li>尽可能少偿还贷款: 避免再次借贷, 弥补空缺</li>
<li>偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费.</li>
</ol>
<h2 id="书摘">书摘</h2>
<p>“可是，这正是许多没有钱的人爱犯的错误。他们总是有那么多紧急的事情要做，以至于没有时间来关注重要的事情。”</p>
<p>“钱钱对我点了点头，说：“困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟”</p>
<p>理解重要不紧急的事情</p>
<p>“很简单。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。”
”</p>
<p>陷入债务危机的人的自救方法</p>
<ol>
<li>销毁信用支付: 信用支付会比现金消费花的钱更多</li>
<li>尽可能少偿还贷款: 避免再次借贷, 弥补空缺</li>
<li>偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费.</li>
</ol>
<p>“鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。”</p>
<p>“我叹道：“要在‘鹅’和愿望之间作取舍真难！”
“你根本不用放弃任何一个。两件事可以同时进行。”金先生微笑着说，“比如你挣了10马克，那么你可以分配一下这笔钱，把其中的大部分存入银行，然后把一部分放入你的梦想储蓄罐，剩下的当作零花钱。”</p>
<p>“所有人都希望自己变得富有一些，只是有些人的这一愿望更为强烈，而有些人却假装自己满足于现在的生活。事实上，大多数人都希望自己更幸福、更成功，也想拥有更多的钱”</p>
<p>“可是假如我们缺钱的话，钱就会变得格外重要。你回想一下那次我们差点淹死在河里的情形，当时我们想的只是必须从河里爬上来，其他的一切都变得无关紧要了”</p>
<p>“中国的智者老子说过：‘天下难事，必作于易；天下大事，必作于细”</p>
<p>“第一，我建议你拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。”</p>
<p>“没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西”</p>
<p>“但如果你的零花钱是现在的10倍的话，你的问题只会变得更加严重。因为我们的支出永远是随着我们的收入而增长的。”</p>
<p>“第一，为别人解决一个难题，那么你就能赚到许多钱；第二，把精力集中在你知道的、能做的和拥有的东西上。”</p>
<p>“：“吉娅，你真的认真找过工作了吗？我是说，你有没有用一整个下午的时间来考虑如何挣到钱的问题呢？”</p>
<p>“情况顺利的时候，人人都能挣到钱。只有在逆境中，一切才能见分晓。”</p>
<p>“可是有的时候，疯狂的念头确实比普通的小目标更容易实现。当你定下大目标的时候，就意味着你必须付出比别人多得多的努力。”</p>
<p>“假如我总是花光我的钱，那我就永远也得不到我的‘鹅’，所以我就总得为了赚钱而工作。而一旦我有了一只‘鹅’，我的钱就会自动为我工作了。”</p>
<p>“没有人能强迫你做你不愿意做的事情。只有你自己才能强迫自己去做。”</p>
<p>“他用一种恳切的目光望着我，说：“我生命中出现了最美好的东西，是因为我做了原本不敢做的事。”</p>
<p>“你就永远不会知道，给自己一些压力之后，你能够做到些什么。一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。这一点你千万不要忘记”</p>
<p>挑选基金</p>
<p>1．基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。
2．应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。
3．对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。</p>
<p>“它的名字叫72公式。”老太太讲解说，“你们直接用72除以你们投资的年利润百分比，得出的数字就是这笔钱翻一倍所要的年数”</p>
<p>“银行存折肯定不是保存钱的最合适的地方，金先生总是把银行存折叫作“吞钱机器”。”</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>go 使用 runtime 包进行内存占用分析</title>
      <link>https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/</link>
      <pubDate>Fri, 18 Nov 2022 19:27:35 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/</guid>
      <description>使用场景 写个demo, 想查看一下程序内部的内存占用情况.
使用方法 主角 runtime 包
对象 MemStats 方法 ReadMemStats demo 展示
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(&amp;amp;m) // For info on each, see: https://golang.</description>
      <content:encoded><![CDATA[<h3 id="使用场景">使用场景</h3>
<p>写个demo, 想查看一下程序内部的内存占用情况.</p>
<h3 id="使用方法">使用方法</h3>
<p>主角 runtime 包</p>
<ul>
<li>对象 <code>MemStats</code></li>
<li>方法 <code>ReadMemStats</code></li>
</ul>
<p>demo 展示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// PrintMemUsage outputs the current, total and OS memory being used. As well as the number 
</span></span></span><span class="line"><span class="cl"><span class="c1">// of garage collection cycles completed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">PrintMemUsage</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bToMb</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">b</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">m</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">MemStats</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// For info on each, see: https://golang.org/pkg/runtime/#MemStats
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Alloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Alloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tTotalAlloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">TotalAlloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tSys = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Sys</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tNumGC = %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">NumGC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://gist.github.com/j33ty/79e8b736141be19687f565ea4c6f4226">代码出处</a></p>
<h3 id="解释">解释</h3>
<h4 id="readmemstats">ReadMemStats</h4>
<p><code>runtime.ReadMemStats</code> 方法会读取到内存分配器的当前时刻最新的内存分配数据, 并将
其填充到传入参数的<code>MemStats</code> 的变量中.</p>
<p>可以充当一个内存快照, 用于进行对比.</p>
<h4 id="memstats-字段">MemStats 字段</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MemStats</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 当前堆上对象的内存分配大小, 同HeapAlloc字段, 单位 bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Alloc</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 历史总的累计分配内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TotalAlloc</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从操作系统分配的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Sys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 记录指针索引性能, go 语言内部使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Lookups</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 堆上分配的对象数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Mallocs</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 堆上剩余的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Frees</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">HeapAlloc</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从操作系统分配的 堆 内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 未使用的空闲内存分片大小 spans
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapIdle</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用中的内存分片大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 回退的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapReleased</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 堆上分配的对象数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapObjects</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 栈上使用的内存片大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">StackInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从操作系统分配的栈的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">StackSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MSpanInuse is bytes of allocated mspan structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MSpanInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MSpanSys is bytes of memory obtained from the OS for mspan
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MSpanSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MCacheInuse is bytes of allocated mcache structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MCacheInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MCacheSys is bytes of memory obtained from the OS for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// mcache structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MCacheSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// BuckHashSys is bytes of memory in profiling bucket hash tables.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">BuckHashSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// GCSys is bytes of memory in garbage collection metadata.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">GCSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// OtherSys is bytes of memory in miscellaneous off-heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// runtime allocations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">OtherSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 在多大的堆内存时, 触发GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NextGC</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 上次GC 时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">LastGC</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PauseTotalNs is the cumulative nanoseconds in GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stop-the-world pauses since the program started.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// During a stop-the-world pause, all goroutines are paused
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// and only the garbage collector can run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PauseTotalNs</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PauseNs is a circular buffer of recent GC stop-the-world
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// pause times in nanoseconds.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// The most recent pause is at PauseNs[(NumGC+255)%256]. In
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// general, PauseNs[N%256] records the time paused in the most
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// recent N%256th GC cycle. There may be multiple pauses per
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// GC cycle; this is the sum of all pauses during a cycle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PauseNs</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PauseEnd is a circular buffer of recent GC pause end times,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// as nanoseconds since 1970 (the UNIX epoch).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This buffer is filled the same way as PauseNs. There may be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// multiple pauses per GC cycle; this records the end of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// last pause in a cycle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PauseEnd</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// GC 次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NumGC</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 手动调用 GC 的次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NumForcedGC</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// GC 使用的 CPU 时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">GCCPUFraction</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 可以GC,一直是true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">EnableGC</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// BySize reports per-size class allocation statistics.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// BySize[N] gives statistics for allocations of size S where
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// BySize[N-1].Size &lt; S ≤ BySize[N].Size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This does not report allocations larger than BySize[60].Size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">BySize</span> <span class="p">[</span><span class="mi">61</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Size is the maximum byte size of an object in this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// size class.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">Size</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Mallocs is the cumulative count of heap objects
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// allocated in this size class. The cumulative bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// of allocation is Size*Mallocs. The number of live
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// objects in this size class is Mallocs - Frees.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">Mallocs</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Frees is the cumulative count of heap objects freed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// in this size class.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">Frees</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://pkg.go.dev/runtime#MemStats">源码出处</a></p>
<h3 id="我用于分析-map-的-delete-操作占用内存">我用于分析 map 的 delete 操作占用内存</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span><span class="p">[</span><span class="s">&#34;a&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;make storage value&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mint</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mint</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 注意: 需要引用, 避免被提前回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mint</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// go run main.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Outpu:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 8192 MiB	TotalAlloc = 8192 MiB	Sys = 8464 MiB	NumGC = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 0 MiB	TotalAlloc = 8192 MiB	Sys = 8465 MiB	NumGC = 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// make storage value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 39168 MiB	TotalAlloc = 47360 MiB	Sys = 48898 MiB	NumGC = 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 39168 MiB	TotalAlloc = 47360 MiB	Sys = 48898 MiB	NumGC = 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 0 2048
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">PrintMemUsage</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bToMb</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">b</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">m</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">MemStats</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// For info on each, see: https://golang.org/pkg/runtime/#MemStats
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Alloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Alloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tTotalAlloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">TotalAlloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tSys = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Sys</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tNumGC = %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">NumGC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>分析结果得出, 如果在 map 中存储的 value, 如果是引用值的话, 占用的内存是被 GC 回收
的. 但是, 如果是值类型如简单的<code>int</code>是不会被回收的.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Asking the Right Questions</title>
      <link>https://ynikl.github.io/books/asking-the-right-questions/</link>
      <pubDate>Thu, 17 Nov 2022 22:53:21 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/asking-the-right-questions/</guid>
      <description>概括 我为什么要读这本书? 养成一个批判性的看待问题方式.
这本书怎样影响了我? 了解了一些常见的经典辩证错误, 比如: 人身攻击, 虚假两难, 完美解决方案 看待一个问题之前, 要想想这个问题, 关我什么事. 对于一些问题的论述会更加注意和小心 书中的三句精华句子? 一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？” 结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。 常见的谬论
人身攻击谬误（ad hominem fallacy）: 人身攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。 滑坡谬误: 指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件发生。 追求完美解决方案谬误: 指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种解决方案根本就不应该采用。 偷换概念谬误:一旦你看到一个关键词或短语在论证中不止一次出现，检查一下看看其意思有没有发生改变，如果意思发生改变，就要警惕偷换概念谬误。 权威谬误: 除非我们知道这些权威对这一论题拥有特别的专门知识，否则我们就要将这个理由视为谬误。这种类型的谬误叫做诉诸可疑权威谬误（appeal to questionable authority fallacy）。 虚假的两难选择: 世界上只有两种人——一种人表演，另一种人观看。” 要让这样的陈述成立，我们必须假设只有这两种选择，是不是这样呢？当然不是！作者创造了一种虚假的两难选择（false dilemma）。 乱扣帽子谬误: 当有人宣称他们发现了导致某个行为的原因，而实际上他们所做的不过是为这种行为起了个名字而已，我们要对这种乱扣帽子谬误[7]（explaining by naming fallacy）保持警惕。 循环论证谬误[1]（begging the question fauacy）。 错误类比谬误指有人提出一个类比，其中却存在重要而又相关的不同点。 过度简化因果关系谬误: 如果持论者不能考虑到各种原因的复杂性，他们就犯了过度简化因果关系谬误[1]（causal oversimplication fallacy）。 事后归因谬误[1]（全称为&amp;quot;post hoc, ergo propter hoc fallacy&amp;quot;，拉丁文的意思是“在这之后，所以是因为这个的谬误”。） 三句话总结本书 书摘 一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？”
小贴士：价值观指的是人们认为较有价值而没有明说出来的观点。它们树立了一定的行为准则，据此我们来衡量人类行为的品质高下。
一厢情愿的思维之所以常常挥之不去，是因为我们否认一切的思维方式常常出现。
描述性论题是指对过去、现在或将来的各种描述的精确与否提出的问题。
我们将这些问题称为规定性论题（prescriptive issues）。社会论争通常都属于规定性论题。
问一问“作者是在对什么事件进行回应”常常能帮你找出一篇文章的中心论题。
但是，当论题并没有直截了当地说出来时，最有效的方法就是先找准结论。很多情况下，在你能确认论题之前都得先找出结论来。
结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。
结论是作者或演说者希望你选择的目的地和终点站。接下来你所关心的是：基于支撑这一论断的所有材料，我该不该接受这个结论？</description>
      <content:encoded><![CDATA[<h2 id="概括">概括</h2>
<h3 id="我为什么要读这本书">我为什么要读这本书?</h3>
<p>养成一个批判性的看待问题方式.</p>
<h3 id="这本书怎样影响了我">这本书怎样影响了我?</h3>
<ul>
<li>了解了一些常见的经典辩证错误, 比如: 人身攻击, 虚假两难, 完美解决方案</li>
<li>看待一个问题之前, 要想想这个问题, 关我什么事.</li>
<li>对于一些问题的论述会更加注意和小心</li>
</ul>
<h3 id="书中的三句精华句子">书中的三句精华句子?</h3>
<ul>
<li>一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？”</li>
<li>结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。</li>
</ul>
<p>常见的谬论</p>
<ul>
<li>人身攻击谬误（ad hominem fallacy）: 人身攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。</li>
<li>滑坡谬误: 指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件发生。</li>
<li>追求完美解决方案谬误: 指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种解决方案根本就不应该采用。</li>
<li>偷换概念谬误:一旦你看到一个关键词或短语在论证中不止一次出现，检查一下看看其意思有没有发生改变，如果意思发生改变，就要警惕偷换概念谬误。</li>
<li>权威谬误:
除非我们知道这些权威对这一论题拥有特别的专门知识，否则我们就要将这个理由视为谬误。这种类型的谬误叫做诉诸可疑权威谬误（appeal to questionable authority fallacy）。</li>
<li>虚假的两难选择: 世界上只有两种人——一种人表演，另一种人观看。” 要让这样的陈述成立，我们必须假设只有这两种选择，是不是这样呢？当然不是！作者创造了一种虚假的两难选择（false dilemma）。</li>
<li>乱扣帽子谬误: 当有人宣称他们发现了导致某个行为的原因，而实际上他们所做的不过是为这种行为起了个名字而已，我们要对这种乱扣帽子谬误[7]（explaining by naming fallacy）保持警惕。</li>
<li>循环论证谬误[1]（begging the question fauacy）。</li>
<li>错误类比谬误指有人提出一个类比，其中却存在重要而又相关的不同点。</li>
<li>过度简化因果关系谬误:  如果持论者不能考虑到各种原因的复杂性，他们就犯了过度简化因果关系谬误[1]（causal oversimplication fallacy）。</li>
<li>事后归因谬误[1]（全称为&quot;post hoc, ergo propter hoc fallacy&quot;，拉丁文的意思是“在这之后，所以是因为这个的谬误”。）</li>
</ul>
<h3 id="三句话总结本书">三句话总结本书</h3>
<ul>
<li></li>
</ul>
<h2 id="书摘">书摘</h2>
<p>一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？”</p>
<p>小贴士：价值观指的是人们认为较有价值而没有明说出来的观点。它们树立了一定的行为准则，据此我们来衡量人类行为的品质高下。</p>
<p>一厢情愿的思维之所以常常挥之不去，是因为我们否认一切的思维方式常常出现。</p>
<p>描述性论题是指对过去、现在或将来的各种描述的精确与否提出的问题。</p>
<p>我们将这些问题称为规定性论题（prescriptive issues）。社会论争通常都属于规定性论题。</p>
<p>问一问“作者是在对什么事件进行回应”常常能帮你找出一篇文章的中心论题。</p>
<p>但是，当论题并没有直截了当地说出来时，最有效的方法就是先找准结论。很多情况下，在你能确认论题之前都得先找出结论来。</p>
<p>结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。</p>
<p>结论是作者或演说者希望你选择的目的地和终点站。接下来你所关心的是：基于支撑这一论断的所有材料，我该不该接受这个结论？</p>
<p>有没有一个清楚明确的论题，通常是区别作家成熟不成熟的一个重要标志。</p>
<p>如果你写作或者演说的目的是为了传达某个特定的结论，你的读者或听众就会尽力去寻找这一结论。老老实实地把结论说出来，而且说得清楚明白，其实也就是在帮助你的读者或听众。</p>
<p>请记住：只有当你找到支撑结论的理由时你才能判定一个结论的价值。</p>
<p>·论证必有其目的。</p>
<p>最后一点需要进一步加以强调和说明。心急火燎地去推进批判性思维并没有什么意义。</p>
<p>在规定性论证中，理由常常不是一般性的规定性陈述就是描述性的看法或原则。</p>
<p>相反，一个关心批判性思维的作者会考虑到可能存在的种种理由并掂量它们的分量，然后才会做出结论。</p>
<p>如果你的论题是利用当前时事来探究政治或社会问题，比如公立教育改革或反恐战争，那就应当从主要的新闻出版物着手。</p>
<p>我们在读书或听讲的时候，一定要强迫自己去寻找那些意思不明确的词或短语，否则你就会抓不住要领。</p>
<p>事实上，很多文献，如美国宪法，都是有意要显得模棱两可，这样这份文献才能与时俱进，其中的关键词如“自由”、“携带武器”的不同含义才能适应不断发展的现实需求。诚然，</p>
<p>因为有人要你接受他的结论，所以你只需要去寻找那些影响你接受其结论的词或短语。这样说来，你应该在理由和结论中寻找这些词或短语。</p>
<p>一个词或短语越抽象，人们越有可能对其做出多重解读。</p>
<p>第一个障碍是你自认为和作者表达的是同一个意思。</p>
<p>意义通常表现为下列三种方式：同义替换、举例说明以及我们通称的“具体标准定义”（</p>
<p>还有一种方法可以帮你发现这个词可能存在的其他含义，那就是尽量在脑海中想象这个词所代表的具体景象，如果你想象不出来，那你很可能就找到了一处重要的歧义。</p>
<p>那些激发强烈情感反应的术语被称为附加感情色彩的术语（loaded terms）。它们感动我们的能力大大超越了它们本身的描述性含义。</p>
<p>作为一个积极主动的学生，你有责任提出各种问题来消除歧义。但你的责任到此为止。作者和演说者才是努力要说服你接受某些观点的人。身为说客，他有责任回答你对可能存在的歧义的各种关心。 你没有义务来评价那些不明确的想法或选择。</p>
<p>我们把这些没有明说出来的想法称为假设（assumptions）。</p>
<p>人的价值观会影响他列举出的种种理由，因而也影响到他的结论。实际上，只有把这些价值观假设添加到推理中，他们的理由才能从逻辑上证实其结论。</p>
<p>当作者对于社会论争采取了一种立场，他们通常都会选择一种价值观而排斥另一种价值观，他们有价值优先或者价值倾向。</p>
<p>找到价值观假设一个比较好的起点就是检查一下作者的背景。</p>
<p>因此，要判断一个人的价值观假设，一个重要手段就是要注意他用来证实结论的各种理由，然后判断哪些价值取向会导致作者认为这些理由比其他理由更可取，</p>
<p>遇到有争议的主题，以这种方式说明价值观假设可以不断提醒自己作者放弃了什么，又得到了什么。</p>
<p>遇到有争议的主题，以这种方式说明价值观假设可以不断提醒自己作者放弃了什么，又得到了什么。尽量抵制住诱惑，不要一找到作者或演说者的价值观就过早地停止分析的过程。</p>
<p>任何一个想要进行论证的人都有必要提供一些解释，说明为什么你应该接受那个论证中暗含的特定的价值观假设。</p>
<p>价值取向需要有一定的正当理由，这样批判性思考的人才能加以考虑。一个价值取向需要有证实它的理由，正如任何一个结论都需要理由一样。</p>
<p>描述性假设（descriptive assumption）就是对这个世界过去、现在或未来是什么样的想法，而你应该记得，规定性的或者说价值观假设是关于这个世界应该是什么样的那些想法。</p>
<p>不断思考结论和理由之间存在的鸿沟。你为什么一开始就要寻找这些假设呢？因为你想让自己能判断理由在多大程度上证实结论。</p>
<p>批判性阅读和聆听的主要目标就在于判定结论的可接受程度或者价值大小。</p>
<p>所谓谬误，就是推理中的欺骗手段，作者有可能利用这个欺骗手段来说服你采纳其结论。</p>
<ul>
<li>人身攻击谬误（ad hominem fallacy）: 人身攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。</li>
<li>滑坡谬误: 指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件发生。</li>
<li>追求完美解决方案谬误: 指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种解决方案根本就不应该采用。</li>
<li>偷换概念谬误:一旦你看到一个关键词或短语在论证中不止一次出现，检查一下看看其意思有没有发生改变，如果意思发生改变，就要警惕偷换概念谬误。</li>
<li>权威谬误:
除非我们知道这些权威对这一论题拥有特别的专门知识，否则我们就要将这个理由视为谬误。这种类型的谬误叫做诉诸可疑权威谬误（appeal to questionable authority fallacy）。</li>
<li>虚假的两难选择: 世界上只有两种人——一种人表演，另一种人观看。” 要让这样的陈述成立，我们必须假设只有这两种选择，是不是这样呢？当然不是！作者创造了一种虚假的两难选择（false dilemma）。</li>
<li>乱扣帽子谬误: 当有人宣称他们发现了导致某个行为的原因，而实际上他们所做的不过是为这种行为起了个名字而已，我们要对这种乱扣帽子谬误[7]（explaining by naming fallacy）保持警惕。</li>
<li>循环论证谬误[1]（begging the question fauacy）。</li>
<li>错误类比谬误指有人提出一个类比，其中却存在重要而又相关的不同点。</li>
<li>过度简化因果关系谬误:  如果持论者不能考虑到各种原因的复杂性，他们就犯了过度简化因果关系谬误[1]（causal oversimplication fallacy）。</li>
<li>事后归因谬误[1]（全称为&quot;post hoc, ergo propter hoc fallacy&quot;，拉丁文的意思是“在这之后，所以是因为这个的谬误”。）</li>
</ul>
<p>当我们被要求解释为什么特定的行为会发生时，我们常常受到诱惑，想要隐藏我们对很多复杂因果关系的无知，干脆给那种行为贴上个标签或者套上个名字，然后我们错误地假设因为我们知道那个标签或名字，我们就知道事情的起因。</p>
<p>如果需要证据，但又没有看到证据，那么这个断言就是孤立论断（mere assertion），意思是它是一个没有用任何方式来加以证实的断言。</p>
<p>与其问一问它们是不是真的，我们宁愿问问它们是不是可靠。其实，我们想问的是：“我们可以依靠这样的看法吗？”</p>
<p>因为单一的个人经历，甚至是个人经历的总和，根本不足以构成一个有代表性的经历样本，个人经历常常会导致我们犯下以偏概全谬误[1]（hasty generalization fallacy）。</p>
<p>典型案例常常很有说服力，因为它们是那样具体生动而又细致感人，很容易就在我们的脑海里浮现出来。</p>
<p>引用具体当事人的这些说法都被称为当事人证词（personal testimonials）。</p>
<p>我们常常说眼见为实，这里则倒过来，相信什么就看得见什么！</p>
<p>引用另一家通讯社（如美联社）。这些引证给人一种支撑证据的幻象但是却绕过了一个最基本的问题：那个原始专家的断言到底有多大可信度？</p>
<p>观察者，不像特定的镜子，并不能给我们提供“纯粹”的观察。我们所“见”所说的都是经过一系列的价值观、偏见、态度和期望值过滤后剩下来的东西。</p>
<p>最后，调查本身所包含的很多偏见让它们变得更加可疑。其中两个最重要的偏见是措辞偏见（biased wording）和语境偏见（biased context）。</p>
<p>当我们因为朋友的极力推荐而选择买下一张CD，我们也是在以相同的方式进行推理。我们这样推理是因为我们彼此之间非常相像，喜欢或不喜欢的东西有很多都是相同的，</p>
<p>当类比用于设定谈话的语气时，识别它们就变得尤其重要。</p>
<p>过度情绪化的类比遮蔽了论证中的真正论题，而且阻碍了实质性的对话。尽量识别包含了重要的情感内涵意义的那些比较，这样做才能避免受这些类比的欺骗。</p>
<p>在寻找替代原因时，我们必须要记住，我们找出的任何一个单独的原因都极有可能是引起事件发生的其中一个原因，而不是其唯一的原因。</p>
<p>将因果关系和相关关系二者混淆起来，既可以理解，同时又异常危险。虽然原因确实先于结果出现，但先于结果出现的还有很多种其他因素，而其中很多不是引发结果的原因。</p>
<p>有一种常见的偏见就是基本归因错误（fundamental attribution error），在这种错误里，我们在解释他人的行为时普遍高估了个人倾向的重要性而低估了环境因素的作用。也就是说，我们喜欢把别人行为的动因看成是来自其内部因素的作用（他们个人的性格特点），而不是来自外部因素的作用（环境的力量）。</p>
<p>你应该时时刻刻向读者证明你并没有忽略其他可选的解释。也许随着你的研究的展开，你发现貌似言之成理的解释实际上并不能被证据所证明。</p>
<p>第一个策略就是尽量找到足够多的关于这些数据是如何采集的信息。</p>
<p>作者谈论的是平均数、中位数还是众数，将会产生很大的区别。</p>
<p>另一个重要的有可能缺失掉的信息类型是相对比较（relevant comparisons）。</p>
<p>因此，真正的自主思考需要我们坚持不懈地寻找作者到底隐瞒了什么信息，不论其是无心省略还是有意隐瞒。</p>
<p>我们从理由当中得出不同的结论是因为我们的背景各不相同，目标千差万别，这样我们在决定将理由和结论连起来的时候必然会被不同的假设所吸引。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>我的人生规划</title>
      <link>https://ynikl.github.io/neo/life/</link>
      <pubDate>Sun, 13 Nov 2022 07:09:37 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/neo/life/</guid>
      <description>我现在需要努力的方向
对于工作项目有帮助的技术, 提升技术的广度 深入学习计算机的基础, 比如: 计算机网络, 算法, 数据结构 保持一个健康的身体 (目前状态不错, 不需要担心) 我希望自己 技术能力
深度 广度 普世价值
极简主义 内心强大 文采斐然 身体健康
40的臂维 6 块腹肌 职业规划 定一个目标, 做程序员至少要干到 35 岁. 也就是还有7年的时间 &amp;ndash; 不许想失业问题, 努力 钻研技术.
既然, 还有7年的程序员职业生涯, 那么就还是要好好努力到底.
提升技术水平, 提高基础薪资水平 发展个人项目 再探索&amp;hellip; 2023 目标 努力挣更多的钱 深挖程序员的深度, 成为 以Golang为基础的编程专家
输出10篇高质量的技术文章 完成数据结构与算法的系统学习 掌握一门基础的前端页面开发技术 培养个人艺术情操 完成3次中远距离出游计划 完成50本书籍阅读 (22年完成49本) 撰写10篇非技术性文章 </description>
      <content:encoded><![CDATA[<p>我现在需要努力的方向</p>
<ul>
<li>对于工作项目有帮助的技术, 提升技术的广度</li>
<li>深入学习计算机的基础, 比如: 计算机网络, 算法, 数据结构</li>
<li>保持一个健康的身体 (目前状态不错, 不需要担心)</li>
</ul>
<h2 id="我希望自己">我希望自己</h2>
<ul>
<li>
<p>技术能力</p>
<ul>
<li>深度</li>
<li>广度</li>
</ul>
</li>
<li>
<p>普世价值</p>
<ul>
<li>极简主义</li>
<li>内心强大</li>
<li>文采斐然</li>
</ul>
</li>
<li>
<p>身体健康</p>
<ul>
<li>40的臂维</li>
<li>6 块腹肌</li>
</ul>
</li>
</ul>
<h2 id="职业规划">职业规划</h2>
<p>定一个目标, 做程序员至少要干到 35 岁. 也就是还有7年的时间 &ndash; 不许想失业问题, 努力
钻研技术.</p>
<blockquote>
<p>既然, 还有7年的程序员职业生涯, 那么就还是要好好努力到底.</p>
</blockquote>
<ol>
<li>提升技术水平, 提高基础薪资水平</li>
<li>发展个人项目</li>
<li>再探索&hellip;</li>
</ol>
<h2 id="2023-目标">2023 目标</h2>
<ol>
<li>努力挣更多的钱</li>
</ol>
<p>深挖程序员的深度, 成为 以Golang为基础的编程专家</p>
<ul>
<li>输出10篇高质量的技术文章</li>
<li>完成数据结构与算法的系统学习</li>
<li>掌握一门基础的前端页面开发技术</li>
</ul>
<ol start="2">
<li>培养个人艺术情操</li>
</ol>
<ul>
<li>完成3次中远距离出游计划</li>
<li>完成50本书籍阅读 (22年完成49本)</li>
<li>撰写10篇非技术性文章</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>202211</title>
      <link>https://ynikl.github.io/notes/202211/</link>
      <pubDate>Wed, 09 Nov 2022 14:04:07 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/notes/202211/</guid>
      <description>吾本乘兴而行，兴尽而返，何必见戴
&amp;ndash; 世说新语·任诞
我本来是乘着一时高兴而来，现在兴尽就返回家，为什么非得见到戴逵呢？</description>
      <content:encoded><![CDATA[<blockquote>
<p>吾本乘兴而行，兴尽而返，何必见戴<br>
&ndash; 世说新语·任诞</p>
</blockquote>
<p>我本来是乘着一时高兴而来，现在兴尽就返回家，为什么非得见到戴逵呢？</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linux 文件系统简单操作流程</title>
      <link>https://ynikl.github.io/posts/linux-filesystem/</link>
      <pubDate>Sat, 05 Nov 2022 13:52:16 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/linux-filesystem/</guid>
      <description>文件系统原理 BIOS：启动主动运行的韧体，会认识第一个可启动的装置 MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序； 启动管理程序(boot loader)：一支可读取核心文件来运行的软件； 相关命令 查看磁盘信息 1 fdisk -l macOS
1 diskutil list 查看磁盘用量
1 df -h 查看文件大小
1 du -h 新磁盘的安装流程 对磁盘进行分割，以创建可用的 partition ； 对该 partition 进行格式化( format )，以创建系统可用的 filesystem； 在 Linux 系统上，需要创建挂载点 ( 亦即是目录 )，并将他挂载上来； 操作磁盘分区, fdisk 后面跟具体的物理磁盘
1 fdisk /dev/hdc 创建一个ext4文件系统
1 mkfs -t ext4 /dev/vdb1 挂载磁盘分区
1 2 mkdir /mnt/hdc6 mount /dev/hdc6 /mnt/hdc6 参考 Linux 磁盘与文件系统管理</description>
      <content:encoded><![CDATA[<h2 id="文件系统原理">文件系统原理</h2>
<ul>
<li>BIOS：启动主动运行的韧体，会认识第一个可启动的装置</li>
<li>MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序；</li>
<li>启动管理程序(boot loader)：一支可读取核心文件来运行的软件；</li>
</ul>
<h2 id="相关命令">相关命令</h2>
<h3 id="查看磁盘信息">查看磁盘信息</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">fdisk -l
</span></span></code></pre></td></tr></table>
</div>
</div><p>macOS</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">diskutil list
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看磁盘用量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">df -h
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看文件大小</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">du -h
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="新磁盘的安装流程">新磁盘的安装流程</h3>
<ol>
<li>对磁盘进行分割，以创建可用的 partition ；</li>
<li>对该 partition 进行格式化( format )，以创建系统可用的 filesystem；</li>
<li>在 Linux 系统上，需要创建挂载点 ( 亦即是目录 )，并将他挂载上来；</li>
</ol>
<p>操作磁盘分区, fdisk 后面跟具体的物理磁盘</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">fdisk /dev/hdc
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建一个ext4文件系统</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mkfs -t ext4 /dev/vdb1
</span></span></code></pre></td></tr></table>
</div>
</div><p>挂载磁盘分区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mkdir /mnt/hdc6
</span></span><span class="line"><span class="cl">mount /dev/hdc6 /mnt/hdc6
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="http://cn.linux.vbird.org/linux_basic/0230filesystem.php#filesys_1">Linux 磁盘与文件系统管理</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang Minimal Version Selection 意识流翻译(仅开头)</title>
      <link>https://ynikl.github.io/blog/golang-minimal-version-selection/</link>
      <pubDate>Tue, 01 Nov 2022 00:15:50 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-minimal-version-selection/</guid>
      <description>原文: Minimal Version Selection
意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.
翻译: Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list). 为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持 编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.
版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:
构建当前的编译列表 升级所有模块到各自对应的最新版本 升级一个模块到对应的版本 降级一个模块到对应的版本 最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进 行升级, 降级, 添加或者移除模块.
这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易 理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖 是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只 用了几行 go 的代码就是实现了.
最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵 守语义化版本: 向前兼容的版本使用小版本号, 不向前兼容的版本使用大版本号.
对应的四种列表操作:
构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份. 升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表 升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入 时如果如果已经存在, 就是仅保存最新的版本 降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标 模块版本之下 这些操作简单, 高效, 且容易实现</description>
      <content:encoded><![CDATA[<p>原文: <a href="https://research.swtch.com/vgo-mvs#low-fidelity_builds">Minimal Version Selection</a></p>
<p>意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.</p>
<h1 id="翻译">翻译:</h1>
<p>Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list).
为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持
编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.</p>
<p>版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:</p>
<ol>
<li>构建当前的编译列表</li>
<li>升级所有模块到各自对应的最新版本</li>
<li>升级一个模块到对应的版本</li>
<li>降级一个模块到对应的版本</li>
</ol>
<p>最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进
行升级, 降级, 添加或者移除模块.</p>
<p>这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易
理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖
是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只
用了几行 go 的代码就是实现了.</p>
<p>最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵
守<a href="https://research.swtch.com/vgo-import">语义化版本</a>: 向前兼容的版本使用小版本号,
不向前兼容的版本使用大版本号.</p>
<p>对应的四种列表操作:</p>
<ol>
<li>构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份.</li>
<li>升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表</li>
<li>升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入
时如果如果已经存在, 就是仅保存最新的版本</li>
<li>降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标
模块版本之下</li>
</ol>
<p>这些操作简单, 高效, 且容易实现</p>
<p><strong>剩余内容 略</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang 解决依赖包版本冲突</title>
      <link>https://ynikl.github.io/blog/golang-find-module-conflict/</link>
      <pubDate>Mon, 31 Oct 2022 08:26:33 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-find-module-conflict/</guid>
      <description>遇到了 grpc 不遵循语义版本, 导致不同版本包之间的冲突.
更新了目标的版本模块之后, 编译一下就发现原先项目引用的 gozero 框架报错了. 搜索一下 相关的关键词,就可以定位到问题是 grpc 搞的鬼.
再找到对应的兼容版本, 升级到对应的版本就可以了.
go 依赖版本选择 [golang 的最小版本选择]https://ynikl.github.io/blog/golang-minimal-version-selection/
大体意思:
会选择当前编译需要依赖包的最高版本(使用语义化版本)
寻找依赖的原因 go mod why
寻找自己项目引用某个包的 最短引用路径, 导致会引用目标包的
1 go mod why google.golang.org/grpc 输出目标包的引用依赖层级
1 2 3 4 5 6 ❯ go mod why google.golang.org/grpc # google.golang.org/grpc hello/world/test git.test.cn/company-open/rpc-pkgs google.golang.org/grpc go mod graph
可以打印出, 模块的依赖图
1 2 3 4 5 6 example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example.</description>
      <content:encoded><![CDATA[<p>遇到了 grpc 不遵循语义版本, 导致<a href="https://github.com/weaveworks/common/issues/239">不同版本包之间的冲突</a>.</p>
<p>更新了目标的版本模块之后, 编译一下就发现原先项目引用的 gozero 框架报错了. 搜索一下
相关的关键词,就可以定位到问题是 grpc 搞的鬼.</p>
<p>再找到对应的兼容版本, 升级到对应的版本就可以了.</p>
<h2 id="go-依赖版本选择">go 依赖版本选择</h2>
<p>[golang 的最小版本选择]https://ynikl.github.io/blog/golang-minimal-version-selection/</p>
<p>大体意思:</p>
<p>会选择当前编译需要依赖包的最高版本(使用语义化版本)</p>
<h2 id="寻找依赖的原因">寻找依赖的原因</h2>
<p><a href="https://go.dev/ref/mod#go-mod-why">go mod why</a></p>
<p>寻找自己项目引用某个包的 <strong>最短引用路径</strong>, 导致会引用目标包的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod why google.golang.org/grpc
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出目标包的引用依赖层级</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">❯ go mod why google.golang.org/grpc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># google.golang.org/grpc
</span></span><span class="line"><span class="cl">hello/world/test
</span></span><span class="line"><span class="cl">git.test.cn/company-open/rpc-pkgs
</span></span><span class="line"><span class="cl">google.golang.org/grpc
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://go.dev/ref/mod#go-mod-graph">go mod graph</a></p>
<p>可以打印出, 模块的依赖图</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">example.com/main example.com/a@v1.1.0
</span></span><span class="line"><span class="cl">example.com/main example.com/b@v1.2.0
</span></span><span class="line"><span class="cl">example.com/a@v1.1.0 example.com/b@v1.1.1
</span></span><span class="line"><span class="cl">example.com/a@v1.1.0 example.com/c@v1.3.0
</span></span><span class="line"><span class="cl">example.com/b@v1.1.0 example.com/c@v1.1.0
</span></span><span class="line"><span class="cl">example.com/b@v1.2.0 example.com/c@v1.2.0
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    
    <item>
      <title>Python 基本语法快速学习</title>
      <link>https://ynikl.github.io/blog/python-basic-quick/</link>
      <pubDate>Sun, 09 Oct 2022 17:34:39 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/python-basic-quick/</guid>
      <description>学习路径 数据结构 流程控制 代码组织 工程化 数据结构 strings int list tuple dictionary 如何查看一个基本的类型对象拥有的方法
1 2 3 name = &amp;#34;ada&amp;#34; dir(name) dir 获取对象的属性
字符串 1 name = &amp;#34;ada lovelace&amp;#34; 拼接, 用+
1 2 3 first_name = &amp;#34;ada&amp;#34; last_name = &amp;#34;lovelace&amp;#34; full_name = first_name + &amp;#34; &amp;#34; + last_name 声明字符串中 &#39;单引号和&amp;quot; 双引号没有区别, 可以用来相互替换 多行字串使用&#39;&#39;&#39;连续三个单引号或双引号声明 字符串格式化
format
1 2 3 &amp;gt;&amp;gt;&amp;gt; &amp;#39;Hey {name}, there is a 0x{errno:x} error!&amp;#39;.format( ... name=name, errno=errno) &amp;#39;Hey Bob, there is a 0xbadc0ffee error!</description>
      <content:encoded><![CDATA[<h2 id="学习路径">学习路径</h2>
<ul>
<li>数据结构</li>
<li>流程控制</li>
<li>代码组织</li>
<li>工程化</li>
</ul>
<h2 id="数据结构">数据结构</h2>
<ul>
<li>strings</li>
<li>int</li>
<li>list</li>
<li>tuple</li>
<li>dictionary</li>
</ul>
<p>如何查看一个基本的类型对象拥有的方法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">name = &#34;ada&#34;
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">dir(name)
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>dir</code> 获取对象的属性</p>
<h3 id="字符串">字符串</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">name = &#34;ada lovelace&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>拼接, 用<code>+</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">first_name = &#34;ada&#34;
</span></span><span class="line"><span class="cl">last_name = &#34;lovelace&#34;
</span></span><span class="line"><span class="cl">full_name = first_name + &#34; &#34; + last_name
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>声明字符串中 <code>'</code>单引号和<code>&quot;</code> 双引号没有区别, 可以用来相互替换</li>
<li>多行字串使用<code>'''</code>连续三个单引号或双引号声明</li>
</ul>
<p>字符串格式化</p>
<p>format</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt;&gt;&gt; &#39;Hey {name}, there is a 0x{errno:x} error!&#39;.format(
</span></span><span class="line"><span class="cl">...     name=name, errno=errno)
</span></span><span class="line"><span class="cl">&#39;Hey Bob, there is a 0xbadc0ffee error!&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><p>&lsquo;f&rsquo;string 模版</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt;&gt;&gt; f&#39;Hello, {name}!&#39;
</span></span><span class="line"><span class="cl">&#39;Hello, Bob!&#39;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="数字">数字</h3>
<ul>
<li>整数 : 不带小数点</li>
<li>浮点数 : 带小数点, 存在精度问题</li>
</ul>
<p>操作符</p>
<ul>
<li><code>+ - * \ %</code></li>
</ul>
<p>与字符串的转换:</p>
<ul>
<li><code>str()</code> 数字转化成字符串</li>
<li><code>int()</code> 字符串转化成整数</li>
<li><code>float()</code> 字符串转化成浮点数</li>
</ul>
<h3 id="逻辑">逻辑</h3>
<p>布尔值</p>
<ul>
<li>True</li>
<li>False</li>
</ul>
<p>与或非</p>
<ul>
<li>and</li>
<li>or</li>
<li>not</li>
</ul>
<p>比较</p>
<ul>
<li>==</li>
<li>!=</li>
<li>&lt;=</li>
<li>
<blockquote>
<p>=</p>
</blockquote>
</li>
<li>&lt;</li>
<li>
<blockquote>
</blockquote>
</li>
</ul>
<p>转化</p>
<ul>
<li><code>bool(1)</code> // True</li>
<li><code>bool(&quot;&quot;)</code> // False</li>
</ul>
<h3 id="列表">列表</h3>
<h4 id="创建">创建</h4>
<p>声明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">people</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;alice&#39;</span><span class="p">,</span> <span class="s1">&#39;fred&#39;</span><span class="p">,</span> <span class="s1">&#39;ian&#39;</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>range</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for i in range(1, 5):
</span></span><span class="line"><span class="cl">	print(i)
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">// 直接创建一个数组
</span></span><span class="line"><span class="cl">intList = list(range(1, 5)
</span></span></code></pre></td></tr></table>
</div>
</div><p>列表解析</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">squares = [ value * 2 for value in range(1, 11)]
</span></span></code></pre></td></tr></table>
</div>
</div><p>切片</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">newPeoples = people[:3]
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="操作">操作</h4>
<p>遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">for</span> <span class="n">person</span> <span class="ow">in</span> <span class="n">people</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nb">print</span><span class="p">(</span><span class="n">person</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="元组">元组</h3>
<p>创建</p>
<p>使用小括号创建, 创建之后内部值无法修改</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">aTuple = (1, 3, 5)
</span></span></code></pre></td></tr></table>
</div>
</div><p>遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for a in aTuple:
</span></span><span class="line"><span class="cl">	print(a)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="字典">字典</h3>
<p>声明</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">peopleCity = { &#34;ian&#34;:&#34;xiamen&#34;, &#34;jinx&#34;:&#34;beijing&#34;}
</span></span></code></pre></td></tr></table>
</div>
</div><p>取值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">print(peopleCity[&#34;ian&#34;])
</span></span></code></pre></td></tr></table>
</div>
</div><p>存在修改, 不存在添加</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">peopleCity[&#34;newguy&#34;] = &#34;newcity&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>删除</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">del peopleCity[&#34;ian&#34;]
</span></span></code></pre></td></tr></table>
</div>
</div><p>遍历</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for person, city in peopleCity.items():
</span></span><span class="line"><span class="cl">	print(person)
</span></span><span class="line"><span class="cl">	print(city)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="流程控制">流程控制</h2>
<h3 id="if">if</h3>
<p>if&hellip;else&hellip;</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if True :
</span></span><span class="line"><span class="cl">	print(&#34;&#34;)
</span></span><span class="line"><span class="cl">elif True:
</span></span><span class="line"><span class="cl">	print(&#34;if if &#34;)
</span></span><span class="line"><span class="cl">else:
</span></span><span class="line"><span class="cl">	print(&#34;&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>判断是否在列表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if person in people: 
</span></span></code></pre></td></tr></table>
</div>
</div><p>判断列表是否为空</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if people :
</span></span><span class="line"><span class="cl">	print(&#34;not empty&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>以下略:</p>
<ul>
<li>while</li>
<li>break</li>
<li>continue</li>
</ul>
<h2 id="代码组织">代码组织</h2>
<h3 id="函数">函数</h3>
<h4 id="定义">定义</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def func_name():
</span></span><span class="line"><span class="cl">	print(&#34;function bdoy&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="普通形参">普通形参</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def greating(name, words):
</span></span><span class="line"><span class="cl">	...
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="关键字参数">关键字参数</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">greating(naem=&#39;ian&#39;, words=&#39;hello&#39;)
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="默认值">默认值</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def greating(name, words=&#39;hello&#39;):
</span></span><span class="line"><span class="cl">	...
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="返回值">返回值</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def getMeFive():
</span></span><span class="line"><span class="cl">	return 5
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="可变参数">可变参数</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">def make_pizza(*toppings):
</span></span><span class="line"><span class="cl">	...
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>*</code>表示可变参数, 内部生成一个元组传递到函数内部</p>
<h3 id="模块">模块</h3>
<p>模块为文件, 使用<code>import</code>导入模块, 假设有<code>hello.py</code>文件, 里有<code>greating</code>函数</p>
<h4 id="导入模块">导入模块</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import hello
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">hello.greating()
</span></span></code></pre></td></tr></table>
</div>
</div><p>不用写前缀</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from hello import *
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="导入函数">导入函数</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from hello import greating
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">greating()
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="别名">别名</h3>
<p>函数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from hello import greating as gt
</span></span></code></pre></td></tr></table>
</div>
</div><p>模块</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import hello as ho
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="类">类</h3>
<p>面向对象</p>
<h4 id="声明">声明</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Dog():
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">def __init__(self, name, age):
</span></span><span class="line"><span class="cl">		&#34;&#34;&#34;初始化属性name和age&#34;&#34;&#34;
</span></span><span class="line"><span class="cl">		self.name = name
</span></span><span class="line"><span class="cl">		self.age = age 6
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">def sit(self):
</span></span><span class="line"><span class="cl">	&#34;&#34;&#34;模拟小狗被命令时蹲下&#34;&#34;&#34; 
</span></span><span class="line"><span class="cl">	print(self.name.title() + &#34; is now sitting.&#34;)
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化函数 <code>__init___</code></p>
<p>指向自身引用 <code>self</code></p>
<h4 id="实例化">实例化</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">my_dog = Dog(&#34;kiki&#34;, 3)
</span></span><span class="line"><span class="cl">my_dog.site()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">// 访问属性
</span></span><span class="line"><span class="cl">print(my_dog.name)
</span></span></code></pre></td></tr></table>
</div>
</div><p>访问不存在的属性, 会出错</p>
<h4 id="继承">继承</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class Car():
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	def __init__(self):
</span></span></code></pre></td></tr></table>
</div>
</div><p>继承</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">class ElectricCar(Car):
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	def __init__(self):
</span></span><span class="line"><span class="cl">		super().init()
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="从模块导入">从模块导入</h4>
<p>与导入方法一致</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">from dog import Dog
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="工程化">工程化</h2>
<h3 id="文件">文件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">wiht open(filename) as file_obj:
</span></span></code></pre></td></tr></table>
</div>
</div><p>json 转存和加载</p>
<ul>
<li>json.dump</li>
<li>json.load</li>
</ul>
<h3 id="异常">异常</h3>
<p>捕获异常</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">try:
</span></span><span class="line"><span class="cl">	print(5/0)
</span></span><span class="line"><span class="cl">except ZeroDivisionError:
</span></span><span class="line"><span class="cl">	pass
</span></span><span class="line"><span class="cl">else:
</span></span><span class="line"><span class="cl">	...
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="单元测试">单元测试</h3>
<p>继承 <code>unittest</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ipmort unittest
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">calss NameTestCase(unittest.TestCase):
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	def test_func_name(self):
</span></span><span class="line"><span class="cl">		// self.assertEqual()
</span></span><span class="line"><span class="cl">		...
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">unittest.main()
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    
    <item>
      <title>乐观锁和悲观锁</title>
      <link>https://ynikl.github.io/blog/cs-optimitic-concurrency-control/</link>
      <pubDate>Sun, 02 Oct 2022 14:05:43 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/cs-optimitic-concurrency-control/</guid>
      <description>乐观锁和悲观锁 首先, 乐观锁和悲观锁和本身并不是一种具体锁.
而是一种编程的并发控制思想. 原名应该叫做乐观并发控制(Optimistic concurrency control) 简称 OCC 和 悲观并发控制(Pessimistic Concurrency Control) 简称 PCC
什么是锁 维基百科对锁的定义
In computer science, a lock or mutex (from mutual exclusion) is a synchronization primitive: a mechanism that enforces limits on access to a resource when there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy, and with a variety of possible methods there exists multiple unique implementations for different applications.</description>
      <content:encoded><![CDATA[<h1 id="乐观锁和悲观锁">乐观锁和悲观锁</h1>
<p>首先, 乐观锁和悲观锁和本身并不是一种具体锁.</p>
<p>而是一种编程的并发控制思想.
原名应该叫做乐观并发控制(Optimistic concurrency control) 简称 OCC 和
悲观并发控制(Pessimistic Concurrency Control) 简称 PCC</p>
<h2 id="什么是锁">什么是锁</h2>
<p><a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">维基百科对锁的定义</a></p>
<blockquote>
<p>In computer science, a lock or mutex (from mutual exclusion) is a synchronization primitive: a mechanism that enforces limits on access to a resource when there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy, and with a variety of possible methods there exists multiple unique implementations for different applications.</p>
</blockquote>
<p>简单表述一下: 锁是一个同步原语, 是一种控制访问资源的线程的手段</p>
<h2 id="乐观锁">乐观锁</h2>
<p>乐观锁是对于要锁定的的访问资源或变量, 持有乐观的态度 &ndash; 即在自己访问该变量的时候,
不会有其他线程来访问该变量.</p>
<p>主要思想是在写入数据的时候, 对比一下, 当前变量的值是不是与自己取出来的时候是一致,
如果一致即表示着 <strong>数据没有被其他线程修改过</strong></p>
<p>有两种具体的策略</p>
<ul>
<li>版本号</li>
<li>CAS</li>
</ul>
<h3 id="版本号">版本号</h3>
<p>在每一次对加锁数据进行修改时候的, 对版本号进行增加操作. 当回写的数据时候判断版本号
是否一致.</p>
<p>如果保持一致, 才会继续进行操作.</p>
<h3 id="cas">CAS</h3>
<p>利用CPU硬件层面支持 &ndash; 比较和写入两步为原子性. 直接对当前值进行判断, 是与取出的数
据一致. 一致才继续进行操作.</p>
<p>利用CAS, 自增完成数字自增的<a href="https://en.wikipedia.org/wiki/Compare-and-swap#Example%20application:%20atomic%20adder">伪代码</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">function add(p: pointer to int, a: int) returns int
</span></span><span class="line"><span class="cl">    done ← false
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    while not done
</span></span><span class="line"><span class="cl">        value ← *p  // Even this operation doesn&#39;t need to be atomic.
</span></span><span class="line"><span class="cl">        done ← cas(p, value, value + a)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    return value + a
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果一直失败的话, cpu就会保持自旋 &ndash; 对cpu算力消耗较大, 直至成功.</p>
<h3 id="aba-问题">ABA 问题</h3>
<p>在乐观锁中, 如果值没有变化, 它的背后含义代表该值没有对其他线程修改过.</p>
<p>但是存在着这种情况.</p>
<ol>
<li>线程1, 取值 A</li>
<li>线程2, 取值 A</li>
<li>线程2, 修改 B 值 &ndash; 成功</li>
<li>线程2, 取值 B, 再修改成 A &ndash; 成功</li>
<li>线程1, 对比 A值, 一致</li>
</ol>
<p>修改的对象值已经被其他对象修改过, 但又被修改成旧的值. 对于 ABA 问题有没有危害,要
看具体的业务场景</p>
<p>如果使用版本号, 每一次修改值, 都增加版本号, 就可以避免该问题.</p>
<h2 id="悲观锁">悲观锁</h2>
<p>悲观锁, 认为自己取值之后, 一定会有其他线程过来修改自己取值的对象.
采取保守策略 &ndash; 直接对该数据进行锁定.</p>
<p>按对数据的锁定类型, 可以分成两种锁:</p>
<ul>
<li>互斥锁</li>
<li>读写锁</li>
</ul>
<h3 id="互斥锁">互斥锁</h3>
<p>对数据锁定期间, 不允许其他线程的访问 &ndash; 读取也不允许. 其他线程只能等待当前的线程
执行完毕</p>
<p>常见的即是各种语言自带的互斥锁.</p>
<h3 id="读写锁">读写锁</h3>
<p>数据锁定期间, 其他线程可以读取数据, 但是不能写入数据.</p>
<p>常见的也是各种语言的读写锁.</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://segmentfault.com/a/1190000016611415">乐观锁、悲观锁，这一篇就够了！</a></li>
<li><a href="https://en.wikipedia.org/wiki/ABA_problem">ABA问题</a></li>
<li><a href="https://en.wikipedia.org/wiki/Lock_(computer_science)">锁的定义</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>高效程序员的45个习惯</title>
      <link>https://ynikl.github.io/books/practices_of_an_agile_developer/</link>
      <pubDate>Fri, 30 Sep 2022 13:41:00 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/practices_of_an_agile_developer/</guid>
      <description>我的总结 对于功能, 业务, 代码逻辑, 不要只停留在表面, 要进一步地去思考为什么 保持开放的心态, 尊重他人的意见, 勇于承认自己的&amp;quot;不知道&amp;quot;. 去思考他人为什么这么想 保持学习, 拥抱变化 有时间观念, 把控项目进度. 控制有规律的开发节奏, 不要让自己经常加班. 每天下班都能完成一天的任务. 让真正的软件用户做决策, 保持定期沟通, 让用户一直确认自己想要的东西 让工具替代人力, 实现自动化 控制代码质量, 简单, 清晰, 内聚 团队内部保持沟通 &amp;ndash; 站会, 及时反映变化. 遇到问题及时求救, 保持向上反馈. 不要辜负人家的预期 深入思考, 保持开发, 拥抱变化, 保持沟通, 注重质量, 保持学习, 自动化.
书本原文 深度思考问题
“拙劣的代码工人会这样不假思索地改完代码，然后快速转向下一个问题。 优秀的程序员会挖掘更深一层，尽力去理解为什么这里必须要加1，更重要的是，他会想明白会产生什么其他影响。”
“在一本流行的管理图书《第五项修炼》中，作者建议，在理解一个问题的时候，需要渐次地问5个以上的“为什么”。这听起来就像退回到了4岁，那时对一切都充满着好奇。它是很好的方式，进一步挖掘简单直白的答案，通过这个路线，设想就会更加接近事实真相。”
当你问“为什么”的时候，也许你会被反问：“为什么你问这个问题？”在提问之前，想好你提问的理由，这会有助于你问出恰当的问题。
保持开发, 承认自己的不知道
“这个，我不知道”是一个好的起点，应该由此进行更进一步的调查，而不应在此戛然结束。”
“如果你对答案不满意，那么看看你是否可以改变问题。”
“作为第1步的理解代码，往往是最难的。如果别人给你的代码很容易理解，接下来的工作就省心多了”
尊重他人的意见
“孤立非常危险，不要让开发人员完全孤立地编写代码（见第155页，习惯40）。如果团队成员花些时间阅读其他同事写的代码，他们就能确保代码是可读和可理解的，并且不会随意加入这些“+1或-1”的代码。阅读代码的频率越高越好。实行代码复审 ，不仅有助于代码更好理解，而且是发现bug最有效的方法之一。”
“用Les Brown的一句话说就是：“你不需要很出色才能起步，但是你必须起步才能变得很出色。”
“如果你是一个有远见的人，就一定要特别尊重别人的意见。你是一个掌舵者，一定要把握方向，深思熟虑，吸取各方的意见。”
保持学习
“谁会帮助你保持步伐前进呢？在一个企业化的社会中，只有一个人会为你负责——你自己。是否能跟上变化，完全取决于你自己”
“跟踪技术变化 。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯”
拥抱变化, 交付用户想要的软件
“敏捷的根本之一就是拥抱变化。既然变化是永恒的，你有可能一直使用相同的技术和工具吗？”
“真正的敌人是变化。软件开发如战争，形势的变化快速而又剧烈。固守昨天的计划而无视环境的变化会带来灾难。”
“不要在前期做大量的设计”并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事”
时间观念
“许多的敏捷技巧来源于时间盒——设定一个短时的期限，为任务设定不能延长的最终期限。你可以选择放弃其他方面的任务，但是最终期限是不变的。你可能不知道完成所有的任务需要多少个时间盒，但每个时间盒必须是短期的、有限的，并且要完成具体的目标”
“如果在你工作的时候没有一个固定的最终期限（例如一天的结束），就应该好好想想了。它会让你的工作有一个节奏，在每天下班的时候，提交所有的工作，开心地收工。这样，明天就能开始新的内容，解决下一系列难题”
“有人说，上帝发明了时间，就是为了防止所有事情同时发生。因此我们需要更具远见，保持不同的开发节奏，这样敏捷项目的所有事情就不会突然同时发生，也不会随机发生，时间也不会不可预知。”</description>
      <content:encoded><![CDATA[<h2 id="我的总结">我的总结</h2>
<ul>
<li>对于功能, 业务, 代码逻辑, 不要只停留在表面, 要进一步地去思考为什么</li>
<li>保持开放的心态, 尊重他人的意见, 勇于承认自己的&quot;不知道&quot;. 去思考他人为什么这么想</li>
<li>保持学习, 拥抱变化</li>
<li>有时间观念, 把控项目进度. 控制有规律的开发节奏, 不要让自己经常加班. 每天下班都能完成一天的任务.</li>
<li>让真正的软件用户做决策, 保持定期沟通, 让用户一直确认自己想要的东西</li>
<li>让工具替代人力, 实现自动化</li>
<li>控制代码质量, 简单, 清晰, 内聚</li>
<li>团队内部保持沟通 &ndash; 站会, 及时反映变化. 遇到问题及时求救, 保持向上反馈. 不要辜负人家的预期</li>
</ul>
<p>深入思考, 保持开发, 拥抱变化, 保持沟通, 注重质量, 保持学习, 自动化.</p>
<h2 id="书本原文">书本原文</h2>
<p>深度思考问题</p>
<blockquote>
<p>“拙劣的代码工人会这样不假思索地改完代码，然后快速转向下一个问题。
优秀的程序员会挖掘更深一层，尽力去理解为什么这里必须要加1，更重要的是，他会想明白会产生什么其他影响。”</p>
</blockquote>
<blockquote>
<p>“在一本流行的管理图书《第五项修炼》中，作者建议，在理解一个问题的时候，需要渐次地问5个以上的“为什么”。这听起来就像退回到了4岁，那时对一切都充满着好奇。它是很好的方式，进一步挖掘简单直白的答案，通过这个路线，设想就会更加接近事实真相。”</p>
</blockquote>
<blockquote>
<p>当你问“为什么”的时候，也许你会被反问：“为什么你问这个问题？”在提问之前，想好你提问的理由，这会有助于你问出恰当的问题。</p>
</blockquote>
<p>保持开发, 承认自己的不知道</p>
<blockquote>
<p>“这个，我不知道”是一个好的起点，应该由此进行更进一步的调查，而不应在此戛然结束。”</p>
</blockquote>
<blockquote>
<p>“如果你对答案不满意，那么看看你是否可以改变问题。”</p>
</blockquote>
<blockquote>
<p>“作为第1步的理解代码，往往是最难的。如果别人给你的代码很容易理解，接下来的工作就省心多了”</p>
</blockquote>
<p>尊重他人的意见</p>
<blockquote>
<p>“孤立非常危险，不要让开发人员完全孤立地编写代码（见第155页，习惯40）。如果团队成员花些时间阅读其他同事写的代码，他们就能确保代码是可读和可理解的，并且不会随意加入这些“+1或-1”的代码。阅读代码的频率越高越好。实行代码复审 ，不仅有助于代码更好理解，而且是发现bug最有效的方法之一。”</p>
</blockquote>
<blockquote>
<p>“用Les Brown的一句话说就是：“你不需要很出色才能起步，但是你必须起步才能变得很出色。”</p>
</blockquote>
<blockquote>
<p>“如果你是一个有远见的人，就一定要特别尊重别人的意见。你是一个掌舵者，一定要把握方向，深思熟虑，吸取各方的意见。”</p>
</blockquote>
<p>保持学习</p>
<blockquote>
<p>“谁会帮助你保持步伐前进呢？在一个企业化的社会中，只有一个人会为你负责——你自己。是否能跟上变化，完全取决于你自己”</p>
</blockquote>
<blockquote>
<p>“跟踪技术变化
。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯”</p>
</blockquote>
<p>拥抱变化, 交付用户想要的软件</p>
<blockquote>
<p>“敏捷的根本之一就是拥抱变化。既然变化是永恒的，你有可能一直使用相同的技术和工具吗？”</p>
</blockquote>
<blockquote>
<p>“真正的敌人是变化。软件开发如战争，形势的变化快速而又剧烈。固守昨天的计划而无视环境的变化会带来灾难。”</p>
</blockquote>
<blockquote>
<p>“不要在前期做大量的设计”并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事”</p>
</blockquote>
<p>时间观念</p>
<blockquote>
<p>“许多的敏捷技巧来源于时间盒——设定一个短时的期限，为任务设定不能延长的最终期限。你可以选择放弃其他方面的任务，但是最终期限是不变的。你可能不知道完成所有的任务需要多少个时间盒，但每个时间盒必须是短期的、有限的，并且要完成具体的目标”</p>
</blockquote>
<blockquote>
<p>“如果在你工作的时候没有一个固定的最终期限（例如一天的结束），就应该好好想想了。它会让你的工作有一个节奏，在每天下班的时候，提交所有的工作，开心地收工。这样，明天就能开始新的内容，解决下一系列难题”</p>
</blockquote>
<blockquote>
<p>“有人说，上帝发明了时间，就是为了防止所有事情同时发生。因此我们需要更具远见，保持不同的开发节奏，这样敏捷项目的所有事情就不会突然同时发生，也不会随机发生，时间也不会不可预知。”</p>
</blockquote>
<p>让真正的用户做决策</p>
<blockquote>
<p>“记录客户做出的决定，并注明原因。好记性不如烂笔头”</p>
</blockquote>
<blockquote>
<p>“不要随意假设低级别的问题不会影响他们的业务。如果能影响他们的业务，就是有价值的问题。”</p>
</blockquote>
<blockquote>
<p>“因而，你只有一个选择：要么现在就让用户做决定，要么现在就开始开发，迟些让用户决定，不过要付出较高的成本。如果你在开发阶段回避这些问题，就增加了风险，但是你要能越早解决这些问题，就越有可能避免繁重的重新设计和编码。甚至在接近项目最终期限的时候，也能避免与日俱增的时间压力。”</p>
</blockquote>
<blockquote>
<p>“开发者（及项目经理）能做的一个最重要的决定就是：判断哪些是自己决定不了的，应该让企业主做决定。你不需要自己给业务上的关键问题做决定。毕竟，那不是你的事情。如果遇到了一个问题，会影响到系统的行为或者如何使用系统，把这个问题告诉业务负责人”</p>
</blockquote>
<blockquote>
<p>“没有人的思想和观点可以及时冻结，特别是项目的客户。就算是他们已经告诉你想要的东西了，他们的期望和想法还是在不停地进化——特别是当他们在使用新系统的部分功能时，他们才开始意识到它的影响和可能发生的问题。这就是人的本性。”</p>
</blockquote>
<blockquote>
<p>“你生产出了他们曾经要求过的软件，但却不是他们现在真正想要的。那最后的结果就是：惊讶、震惊和失望，而不是满意。
”</p>
</blockquote>
<p>分析技术的利弊</p>
<blockquote>
<p>“每一门技术都会有优点和缺点，无论它是开源的还是商业产品、框架、工具或者语言，一定要清楚它的利弊。”</p>
</blockquote>
<p>控制迭代</p>
<blockquote>
<p>“迭代开发是，在小且重复的周期里，你完成各种开发任务：分析、设计、实现、测试和获得反馈，所以叫作迭代”</p>
</blockquote>
<blockquote>
<p>“每个工作日，每个团队成员会重新评估完成一个任务还需要多少小时。不管怎么样，只要所有任务的评估总和超过了一个迭代剩余的时间，那么任务就必须移到下一个迭代中开发”</p>
</blockquote>
<p>单元测试, 控制代码质量</p>
<blockquote>
<p>“单元测试能及时提供反馈 。你的代码会重复得到锻炼。但若修改或者重写了代码，测试用例就会检查你是否破坏了已有的功能。你可以快速得到反馈，并很容易地修复它们。</p>
</blockquote>
<blockquote>
<p>单元测试让你的代码更加健壮
。测试帮助你全面思考代码的行为，帮你练习正面、反面以及异常情况。</p>
</blockquote>
<blockquote>
<p>单元测试是有用的设计工具
。正如我们在实践20中谈论到的，单元测试有助于实现简单的、注重实效的设计。</p>
</blockquote>
<blockquote>
<p>单元测试是让你自信的后台
。你测试代码，了解它在各种不同条件下的行为。这会让你在面对新的任务、时间紧迫的巨大压力之下，找到自信。</p>
</blockquote>
<blockquote>
<p>单元测试是解决问题时的探测器
。单元测试就像是测试印制电路板的示波镜。当问题出现的时候，你可以快速地给代码发送一个脉冲信号。这为你提供[…]”</p>
</blockquote>
<blockquote>
<p>“如果不是真正需要它的时候，你就不应该实现这个功能。基于这一点，现在还没有足够的理由表示你需要Player
这个类”</p>
</blockquote>
<blockquote>
<p>“开发人员在完成任务时，可能会难以抵挡诱惑为节省时间而走“捷径”。然而，这些“捷径”往往只会推迟问题的爆发时间，而不是把它彻底解决掉”</p>
</blockquote>
<blockquote>
<p>“项目是以增量式方式进行开发的，写程序时也应该进行增量式编程</p>
</blockquote>
<blockquote>
<p>“源代码可以被读懂，不是因为其中的注释，而应该是由于它本身优雅而清晰——变量名运用正确、空格使用得当、逻辑分离清晰，以及表达式非常简洁。”</p>
</blockquote>
<blockquote>
<p>“这时要扪心自问，是不是真的需要用它，以及它将如何帮你解决眼前的问题。问问自己，是不是特定的问题强迫你使用这个解决方案。不要让自己被迫进行过分设计，也不要将代码过分复杂化。”</p>
</blockquote>
<blockquote>
<p>“内聚性用来评估一个组件（包、模块或配件）中成员的功能相关性。内聚程度高，表明各个成员共同完成了一个功能特性或是一组功能特性”</p>
</blockquote>
<p>成为自己产品的用户</p>
<blockquote>
<p>“很多成功的公司都是靠着“吃自己的狗食”活着。也就是说，如果要让你的产品尽可能地好，自己先要积极地使用它。”</p>
</blockquote>
<p>度量项目进度</p>
<blockquote>
<p>“所以，我们不应该去计算工作量完成的百分比，而应该测定还剩下多少工作量没有完成。如果你最初估计这个任务需要40个小时，在开发了35个小时之后，你认为还需要另外30个小时的工作。那就得到了很重要的度量结果（这里诚实非常重要，隐瞒真相毫无意义）。”</p>
</blockquote>
<blockquote>
<p>“奇怪的是，它花费的时间很可能要比最初估计时间长。没有关系，我们希望这能作为下一次的参考。在为下一个任务估计工作量时，可以根据这次经验调整评估。如果你低估了一个任务，评估是2天，它最后花费了6天，那么系数就是3。除非是异常情况，否则你应该对下次估计乘以系数3。你的评估会波动一段时间，有时候过低估计，有时候过高估计。但随着时间的推移，你的评估会与事实接近，你也会对任务所花费的时间有更清楚的认识。”</p>
</blockquote>
<p>团队合作</p>
<blockquote>
<p>“既然整个团队都是项目工作的一部分，我们希望实行代码集体所有制
（见第155页），以保证任何团队成员的缺席不会对项目造成影响”</p>
</blockquote>
<blockquote>
<p>“对于初学者来说，准备好后再共享代码才是有礼貌的做法（见第162页），这样才不会用未完成的工作来给团队成员造成麻烦。当准备好之后，我们应该与其他团队成员一起做代码复查</p>
</blockquote>
<blockquote>
<p>“坐着开的会议通常会持续更久，大部分人不喜欢站着进行长时间的谈话。”</p>
</blockquote>
<blockquote>
<p>“通常，立会都是在每个工作日的早些时候，且大家都在上班时举行。但是不要把它安排为上班后的第一件事。要让大家有机会从刚才混乱的交通状况中恢复状态，喝点咖啡，删除一些垃圾邮件什么的。要保证会议结束后有足够的时间，让大家在午餐之前做不少工作，同时也不要开始得过早，让每个人都巴不得赶紧结束会议，去喝点东西。一般来说，在大家到公司之后的半个小时到一个小时之内举行，是个不错的选择。”</p>
</blockquote>
<blockquote>
<p>“如果觉得立会是在浪费时间，那可能是大家还没有形成真正的团队意识。这并不是坏事，有利于针对问题进行改进。”</p>
</blockquote>
<blockquote>
<p>“当多人同时开发时，代码会被频繁地检查、重构以及维护。如果需要修复bug，任何一名开发人员都可以完成这项工作。同时有两个或两个以上的人，可以处理应用中不同部分的代码，可以让项目的日程安排也变得更为容易。”</p>
</blockquote>
<blockquote>
<p>“另一方面，知道别人将会接过自己的代码，就意味着自己要更守规矩。当知道别人在注意时，一定会更加小心。”</p>
</blockquote>
<p>费曼学习法</p>
<blockquote>
<p>“通过详细解释自己知道的东西，可以使自己的理解更深入。当别人提出问题时，也可以发现不同的角度。也许可以发现一些新技巧——听到一个声音这样告诉自己：“我以前还没有这样思考过这个问题”</p>
</blockquote>
<blockquote>
<p>“为团队成员在寻求帮助之前陷入某个问题的时间设定一个时限，一个小时应该是不错的选择”</p>
</blockquote>
<blockquote>
<p>“如果有人还是没有任何线索，那就给更多提示吧（或者甚至是答案）。如果有人提出来某些想法，不妨帮他们分析每种想法的优劣之处。如果有人给出的答案或解决方法更好，那就从中汲取经验，然后分享你的体会吧。这对双方来说都是极佳的学习经验。”</p>
</blockquote>
<blockquote>
<p>“用问题来回答问题，可以引导提问的人走上正确的道路。</p>
</blockquote>
<blockquote>
<p>如果有人真的陷入胶着状态，就不要折磨他们了。告诉他们答案，再解释为什么是这样。”</p>
</blockquote>
<blockquote>
<p>“同样的功能，不同开发人员的代码实现可能不同。差异并不意味着不好。除非你可以让某段代码明确变得更好，否则不要随意批评别人的代码。”</p>
</blockquote>
<p>及时向上反馈</p>
<blockquote>
<p>“及时通报进展与问题，有情况发生时，就不会让别人感到突然，而且他们也很愿意了解目前的进展状况。他们会知道何时应提供帮助，而且你也获得了他们的信任”</p>
</blockquote>
<blockquote>
<p>“接受一个任务，也就意味着做出了要准时交付的承诺”</p>
</blockquote>
<p>慢慢来</p>
<blockquote>
<p>“有句老话说得好：“你可以把马带到水边……但是你不能强迫它使用你最钟爱的代码编辑器。”
You can lead a horse to water, but you can make him drink.</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go  errgroup 的基本用法</title>
      <link>https://ynikl.github.io/blog/golang-errgroup/</link>
      <pubDate>Mon, 19 Sep 2022 09:19:31 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-errgroup/</guid>
      <description>实现并发控制 在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 channel 进行传入和传出.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { concurrencyNum := 10 limitCh := make(chan bool, concurrencyNum) wg := new(sync.WaitGroup) for i := 0; i &amp;lt; 100; i++ { limitCh &amp;lt;- true wg.Add(1) go func() { defer func() { &amp;lt;-limitCh wg.Done() }() time.Sleep(1 * time.Second) fmt.</description>
      <content:encoded><![CDATA[<h2 id="实现并发控制">实现并发控制</h2>
<p>在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 <code>channel</code>
进行传入和传出.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">concurrencyNum</span> <span class="o">:=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">limitCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">concurrencyNum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">limitCh</span> <span class="o">&lt;-</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="o">&lt;-</span><span class="nx">limitCh</span>
</span></span><span class="line"><span class="cl">				<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;do some things...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ok&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果如果中间运行代码有可能存在错误, 捕获错误. 有两种方法:</p>
<ul>
<li>声明一个 err channel 用于承接错误</li>
<li>声明一个外部 err 变量, 并通过互斥锁进行保护</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func main() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	concurrencyNum := 10
</span></span><span class="line"><span class="cl">	limitCh := make(chan bool, concurrencyNum)
</span></span><span class="line"><span class="cl">	errCh := make(chan error, concurrencyNum)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	var externalErr error
</span></span><span class="line"><span class="cl">	wg := new(sync.WaitGroup)
</span></span><span class="line"><span class="cl">	func() {
</span></span><span class="line"><span class="cl">		for i := 0; i &lt; 100; i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			select {
</span></span><span class="line"><span class="cl">			case err := &lt;-errCh:
</span></span><span class="line"><span class="cl">				externalErr = err
</span></span><span class="line"><span class="cl">				return
</span></span><span class="line"><span class="cl">			default:
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			wg.Add(1)
</span></span><span class="line"><span class="cl">			limitCh &lt;- true
</span></span><span class="line"><span class="cl">			go func() {
</span></span><span class="line"><span class="cl">				defer func() {
</span></span><span class="line"><span class="cl">					&lt;-limitCh
</span></span><span class="line"><span class="cl">					wg.Done()
</span></span><span class="line"><span class="cl">				}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				time.Sleep(1 * time.Second)
</span></span><span class="line"><span class="cl">				fmt.Println(&#34;do some things...&#34;)
</span></span><span class="line"><span class="cl">				if rand.Intn(5) == 1 {
</span></span><span class="line"><span class="cl">					err := errors.New(&#34;this is a error&#34;)
</span></span><span class="line"><span class="cl">					errCh &lt;- err
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">			}()
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	wg.Wait()
</span></span><span class="line"><span class="cl">	fmt.Println(&#34;ok&#34;)
</span></span><span class="line"><span class="cl">	fmt.Println(externalErr)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个地放都写这么多代码, 就有了重复的感觉. 本质上就两点:</p>
<ul>
<li>通过 channel 控制并发数</li>
<li>通过 waitgroup 保证所有的协程都执行完毕</li>
<li>通过另一个 errchannel 接受中间执行的错误</li>
</ul>
<h2 id="errgroup"><code>errgroup</code></h2>
<p>可以通过使用, 官方的拓展包 <code>errgroup</code> 更快实现</p>
<p>声明 errgroup</p>
<ul>
<li>普通声明 <code>new(errgroup.Group)</code></li>
<li>使用 context <code>errgroup.WithContext</code></li>
</ul>
<p>限制开启的协程数据</p>
<p><code>eg.SetLimit(goroutineNum)</code></p>
<p>开启协程</p>
<ul>
<li><code>eg.Go</code></li>
<li><code>eg.TryGo</code></li>
</ul>
<p>整体代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	eg := new(errgroup.Group)
</span></span><span class="line"><span class="cl">	eg.SetLimit(10)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for i := 0; i &lt; 100; i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		eg.Go(func() error {
</span></span><span class="line"><span class="cl">			time.Sleep(1 * time.Second)
</span></span><span class="line"><span class="cl">			fmt.Println(&#34;hello go&#34;)
</span></span><span class="line"><span class="cl">			return nil
</span></span><span class="line"><span class="cl">		})
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	err := eg.Wait()
</span></span><span class="line"><span class="cl">	fmt.Println(&#34;done&#34;, err)
</span></span></code></pre></td></tr></table>
</div>
</div><p>目前有个使用场景没办法满足:</p>
<p>就是没办法在开启协程之前, 知道原先已经执行的协程是否有发生错误.
如果有发生错误的. 就停止再继续开启协程.</p>
<p>可以通过添加一个 外部的 errChannel , 覆盖到上面的需求.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何查看 golang 编译之后调用的源码方法</title>
      <link>https://ynikl.github.io/blog/golang-get-assembly-fn/</link>
      <pubDate>Sun, 18 Sep 2022 21:37:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-get-assembly-fn/</guid>
      <description>在 golang 中查看源码是比较方便的. 可以直接到 官方包文档中直接查看文档和跳转到源码
但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成 什么底层方法了.
比如, 我知道一些make(map[int]bool)是怎么实现的.
这时候就需要一些方法了. 引用一下鸟窝大佬的文章 总结一下三种方法:
go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile 产生的汇编代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 0x001c 00028 (main.go:5)	FUNCDATA	$1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB) 0x001c 00028 (main.go:5)	FUNCDATA	$2, main.main.stkobj(SB) 0x001c 00028 (main.go:6)	STP	(ZR, ZR), main.</description>
      <content:encoded><![CDATA[<p>在 golang 中查看源码是比较方便的. 可以直接到 <a href="https://pkg.go.dev/">官方包文档</a>中直接查看文档和跳转到源码</p>
<p>但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成
什么底层方法了.</p>
<p>比如, 我知道一些<code>make(map[int]bool)</code>是怎么实现的.</p>
<p>这时候就需要一些方法了. 引用一下<a href="https://colobu.com/2018/12/29/get-assembly-output-for-go-programs/">鸟窝大佬的文章</a>
总结一下三种方法:</p>
<ul>
<li><code>go tool compile -N -l -S makemap.go</code></li>
<li><code>go tool compile -N -l -S makemap.go</code></li>
<li><code>go tool compile -N -l -S makemap.go</code></li>
</ul>
<p><code>go tool compile</code> 产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	0x001c 00028 (main.go:5)	FUNCDATA	$1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB)
</span></span><span class="line"><span class="cl">	0x001c 00028 (main.go:5)	FUNCDATA	$2, main.main.stkobj(SB)
</span></span><span class="line"><span class="cl">	0x001c 00028 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-48(SP)
</span></span><span class="line"><span class="cl">	0x0020 00032 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-32(SP)
</span></span><span class="line"><span class="cl">	0x0024 00036 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-16(SP)
</span></span><span class="line"><span class="cl">	0x0028 00040 (main.go:6)	MOVD	$type.map[int]bool(SB), R0
</span></span><span class="line"><span class="cl">	0x0030 00048 (main.go:6)	MOVD	$100, R1
</span></span><span class="line"><span class="cl">	0x0034 00052 (main.go:6)	MOVD	$main..autotmp_4-48(SP), R2
</span></span><span class="line"><span class="cl">	0x0038 00056 (main.go:6)	PCDATA	$1, ZR
</span></span><span class="line"><span class="cl">	0x0038 00056 (main.go:6)	CALL	runtime.makemap(SB)
</span></span><span class="line"><span class="cl">	0x003c 00060 (main.go:6)	MOVD	R0, main.mp-112(SP)
</span></span><span class="line"><span class="cl">	0x0040 00064 (main.go:7)	MOVD	R0, R1
</span></span><span class="line"><span class="cl">	0x0044 00068 (main.go:7)	MOVD	ZR, R2
</span></span><span class="line"><span class="cl">	0x0048 00072 (main.go:7)	MOVD	$type.map[int]bool(SB), R0
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>go tool objdump</code>产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  main.go:6		0x10008a734		a907ffff		STP (ZR, ZR), 120(RSP)			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a738		90000160		ADRP 180224(PC), R0			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a73c		91100000		ADD $1024, R0, R0			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a740		d2800c81		MOVD $100, R1				
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a744		910163e2		ADD $88, RSP, R2			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a748		97fe0522		CALL runtime.makemap(SB)		
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a74c		f90023e0		MOVD R0, 64(RSP)			
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>go build -gcflags -S</code> 产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mp_10-32(SP)
</span></span><span class="line"><span class="cl">        0x0024 00036 (/Users/ian/play/map/main.go:6)    STP     (ZR, ZR), main..autotmp_10-16(SP)
</span></span><span class="line"><span class="cl">        0x0028 00040 (/Users/ian/play/map/main.go:6)    MOVD    $type.map[int]bool(SB), R0
</span></span><span class="line"><span class="cl">        0x0030 00048 (/Users/ian/play/map/main.go:6)    MOVD    $100, R1
</span></span><span class="line"><span class="cl">        0x0034 00052 (/Users/ian/play/map/main.go:6)    MOVD    $main..autotmp_10-48(SP), R2
</span></span><span class="line"><span class="cl">        0x0038 00056 (/Users/ian/play/map/main.go:6)    PCDATA  $1, ZR
</span></span><span class="line"><span class="cl">        0x0038 00056 (/Users/ian/play/map/main.go:6)    CALL    runtime.makemap(SB)
</span></span><span class="line"><span class="cl">        0x003c 00060 (/Users/ian/play/map/main.go:6)    MOVD    R0, main.mp-72(SP)
</span></span></code></pre></td></tr></table>
</div>
</div><p>大同小异, 根据源代码的行号(<code>mian.go:6</code>) 都可以从代码中看到,
调用<code>call</code> 了<code>makemap</code> 这个方法</p>
<p>我们在到<a href="https://cs.opensource.google/go/go/+/master:src/runtime/map.go;l=283?q=makemap&amp;ss=go%2Fgo">源码</a>中, 找到<code>makemap</code>方法, 就可以查看对应的源码了</p>
<h2 id="参考">参考</h2>
<p><a href="https://colobu.com/2018/12/29/get-assembly-output-for-go-programs/">得到Go程序的汇编代码的方法</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Journal</title>
      <link>https://ynikl.github.io/journal/</link>
      <pubDate>Fri, 16 Sep 2022 13:26:28 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/journal/</guid>
      <description>开这个目录的目的:
是为了记录一些, 我日常读到的一些文章收获和心得.</description>
      <content:encoded><![CDATA[<p>开这个目录的目的:</p>
<p>是为了记录一些, 我日常读到的一些文章收获和心得.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Content Disposition</title>
      <link>https://ynikl.github.io/posts/http-content-disposition/</link>
      <pubDate>Sun, 04 Sep 2022 21:32:24 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/http-content-disposition/</guid>
      <description>Content-Disposition 常见是用在 http 请求的 Response 的 Header 头部.
告诉请求客户端(浏览器) 如何处理内容;
Content-Disposition是在 MIME 标准定义的. http 中的用法只是其中的一小部分.
语法参数 inline 会在浏览器内部显示
1 Content-Disposition: inline attachment 会被保存成文件
1 Content-Disposition: attachment 后面可以跟 filename, 值为预设文件名称, 中间使用;分号隔开.
1 Content-Disposition: attachment; filename=&amp;#34;filename.jpg&amp;#34; 拓展参数, 有两个文件名称参数可选
filename* filename filename* 采用了 RFC 5987 中规定的编码方式, 假如两个参数都使用 filename* 的优先级更高
RFC 5987 该提议最终还是引用 RFC 2231 中的编码方式. 下面简单介绍一下语法
*星号用于标记该同名参数是支持该编码语法的, 就如( filename* 之于 filename) &#39;单个逗号用于分割 字符集名称 , 语言, 文件名称 %百分号用于标记编码方式, 参考RFC 2047, 所以文件名中不能有% 1 filename*=us-ascii&amp;#39;en-us&amp;#39;This%20is%20%2A%2A%2Afun%2A%2A%2A 使用us-ascii编码, en-us英语</description>
      <content:encoded><![CDATA[<p><code>Content-Disposition</code> 常见是用在 http 请求的 Response 的 Header 头部.</p>
<p>告诉请求客户端(浏览器) 如何处理内容;</p>
<p><code>Content-Disposition</code>是在 MIME 标准定义的. http 中的用法只是其中的一小部分.</p>
<h2 id="语法参数">语法参数</h2>
<h3 id="inline">inline</h3>
<p>会在浏览器内部显示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: inline
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="attachment">attachment</h3>
<p>会被保存成文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: attachment
</span></span></code></pre></td></tr></table>
</div>
</div><p>后面可以跟 filename, 值为预设文件名称, 中间使用<code>;</code>分号隔开.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: attachment; filename=&#34;filename.jpg&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>拓展参数, 有两个文件名称参数可选</p>
<ul>
<li>filename*</li>
<li>filename</li>
</ul>
<p><code>filename*</code> 采用了 RFC 5987 中规定的编码方式,
假如两个参数都使用 <code>filename*</code> 的优先级更高</p>
<h4 id="rfc-5987">RFC 5987</h4>
<p>该提议最终还是引用 <a href="https://www.rfc-editor.org/rfc/rfc2231#section-4">RFC 2231</a>
中的编码方式. 下面简单介绍一下语法</p>
<ul>
<li><code>*</code>星号用于标记该同名参数是支持该编码语法的, 就如( <code>filename*</code> 之于 <code>filename</code>)</li>
<li><code>'</code>单个逗号用于分割 <strong>字符集名称</strong> , <strong>语言</strong>, <strong>文件名称</strong></li>
<li><code>%</code>百分号用于标记编码方式, 参考<a href="https://www.rfc-editor.org/rfc/rfc2047">RFC 2047</a>, 所以文件名中不能有<code>%</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">filename*=us-ascii&#39;en-us&#39;This%20is%20%2A%2A%2Afun%2A%2A%2A
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>us-ascii</code>编码, <code>en-us</code>英语</p>
<h2 id="问题-下载文件名称乱码">问题: 下载文件名称乱码</h2>
<p>根据上面的知识, 就可以解决有的浏览器下载文件时中文名称乱码.</p>
<ul>
<li>Http 返回设置<code>Content-Disposition</code>值</li>
<li>使用 RFC 2231 的文件名称方式, 制定编码<code>utf-8</code></li>
<li>将文件名称移除<code>%</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">disposition</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;attachment;filename*=utf-8&#39;&#39;%s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">.</span><span class="nf">QueryEscape</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition">MDN</a>
<a href="https://www.rfc-editor.org/rfc/rfc2231#section-4">RFC 2231</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>The Chinese Mayor</title>
      <link>https://ynikl.github.io/posts/the-chinese-mayor/</link>
      <pubDate>Tue, 30 Aug 2022 14:06:10 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/the-chinese-mayor/</guid>
      <description>豆瓣因为涉及敏感词不让写, 干脆就写到这里来 (我也没写啥不好的呀 QAQ).
真正的现实，都是充满着矛盾。对万事万物保持一颗敬畏的心.
一方面是平民老百姓承受着流离失所的痛苦，一方面他们又可以从老破房子住到新的高楼“不破不立”，改善环境。 既要看到痛苦，也要看到改善。看外该电影， 更加让我懂得，看待事情要怀着敬畏之心，事情都是有双面性的。
总得来说，还是觉得耿属于“好市长”，在中国经济飞速发展的过程中，为人民干实事，坚定自己的立场，倾听民声（市民赌在司令部门口申诉问题的场景给我印象极深）。</description>
      <content:encoded><![CDATA[<p>豆瓣因为涉及敏感词不让写, 干脆就写到这里来 (我也没写啥不好的呀 QAQ).</p>
<p>真正的现实，都是充满着矛盾。对万事万物保持一颗敬畏的心.</p>
<p>一方面是平民老百姓承受着流离失所的痛苦，一方面他们又可以从老破房子住到新的高楼“不破不立”，改善环境。
既要看到痛苦，也要看到改善。看外该电影， 更加让我懂得，看待事情要怀着敬畏之心，事情都是有双面性的。</p>
<p>总得来说，还是觉得耿属于“好市长”，在中国经济飞速发展的过程中，为人民干实事，坚定自己的立场，倾听民声（市民赌在司令部门口申诉问题的场景给我印象极深）。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>我与地坛</title>
      <link>https://ynikl.github.io/books/%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B/</link>
      <pubDate>Tue, 23 Aug 2022 13:25:15 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B/</guid>
      <description>概括 我为什么要读这本书? 我觉得生活挺无聊, 人生活着没有什么意义. 听说在这本书中会有人生的意义
这本书怎样影响了我? 看清楚自己之所以活着, 就如史铁生所说, 就是还想得到什么. 并不是如我嘴上所说的: &amp;ldquo;人生活着没什么意义&amp;rdquo; 打算更加大胆地去追求自己想要&amp;quot;得到&amp;quot;的东西 看清楚做某一件事情的意义 &amp;ndash; 不只是看重结果, 也要去看重过程 书中的三句精华句子? 可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望 只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。 世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。 上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。 此岸永远是残缺的，否则彼岸就要坍塌。 三句话总结本书 尊重不完美, 不要抱怨, 不断地去追求完美 看清楚自己想要得到什么 人生不能只看重目的, 要去享受这个过程. 书摘 在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。
树干上留着一只蝉蜕，寂寞如一间空屋；露水在草叶上滚动，聚集，压弯了草叶轰然坠地摔开万道金光。”“
上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。
剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。
看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。
就命运而言，休论公道。
其实总共只有三个问题交替着来骚扰我，来陪伴我。第一个是要不要去死，第二个是为什么活，第三个，我干吗要写作。
人为什么活着？因为人想活着，说到底是这么回事，人真正的名字叫做：欲望。
可我为什么还想活呢？因为你还想得到点儿什么，你觉得你还是可以得到点儿什么的，比如说爱情，比如说价值感之类，人真正的名字叫欲望。
结果你又发表了几篇，并且出了一点儿小名，可这时你越来越感到恐慌。我忽然觉得自己活得像个人质，刚刚有点儿像个人了却又过了头，
人都忍不住要为生存找一些牢靠的理由。你不担心你会枯竭了？我不知道，不过我想，活着的问题在死前是完不了的。
就算是三个月！我平白地相信这样一个期限。
多年以后才听一位无名的哲人说过：危卧病榻，难有无神论者。
但在命运的混沌之点，人自然会忽略着科学，向虚暝之中寄托一份虔敬的祈盼。
机会不在外面在心里，结婚的机会有可能在外边，可爱情的机会只能在心里
那位台湾作家三毛说得对：爱如禅，不能说不能说，一说就错。
别人告诉我，她昏迷前的最后一句话是：“我那个有病的儿子和我那个还未成年的女儿……”
砌墙盖房，不单为避风雨，因为大家都有些秘密，其次当然还有一些钱财。秘密，不信你去慢慢推想，它是趣味的爹娘。
千万别把运动和能量，以及和时空分割开来理解。我随即得了启发：也千万别把人和意义分割开来理解。不是人有欲望，而是人即欲望。
如今想来，分明就是为了一个“轻”字：珍宝转眼被处理成垃圾，一段生命轻得飘散了，没有了，以为是什么原来什么也不是，轻易、简单、灰飞烟灭。一段生命之轻，威胁了生命全面之重，惶茫往灵魂里渗透：是不是生命的所有段落都会落此下场啊？人的根本恐惧就在这个“轻”字上，比如歧视和漠视，比如嘲笑，比如穷人手里作废的股票，比如失恋和死亡。轻，最是可怕。
艰苦的生活需要希望，鲜活的生命需要爱情，数不完的日子和数不完的心事，都要诉说。
也许是因为人缺了什么就更喜欢什么吧，我的两条腿一动不能动，却是个体育迷。
上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。
我希望既有一个健美的躯体又有一个了悟人生意义的灵魂，我希望二者兼得。
难道我们不该对灵魂有了残疾的人，比对肢体有了残疾的人，给予更多的同情和爱吗？
既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？
有知识不能只是有对物的知识，而是得有对人的了悟。
我们也完全可以把你以后的生活设计得无比顺利，但这样下去我们是不是绕了一圈又回到那不祥的阴影中去了？你将再没有企盼了吗？再没有新的追求了吗？那么你的心路是不是又在荒芜，于是你的幸福感又要老化、萎缩、枯竭了呢？
只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。
一个只想（只想！）使过程精彩的人是无法被剥夺的，因为死神也无法将一个精彩的过程变成不精彩的过程，因为坏运也无法阻挡你去创造一个精彩的过程，相反你可以把死亡也变成一个精彩的过程，相反坏运更利于你去创造精彩的过程。
过程！对，生命的意义就在于你能创造这过程的美好与精彩，生命的价值就在于你能够镇静而又激动地欣赏这过程的美丽与悲壮。
有位大物理学家说过：“物理学不告诉我们世界是什么，而是告诉我们关于世界我们能够谈论什么。”
历史难免是一部御制经典，文学要弥补它，所以看重的是那些沉默的心魂。
佛嘛，心中无佛什么事都敢干。
丑弱的人和圆满的神之间，是信者永远的路。</description>
      <content:encoded><![CDATA[<h2 id="概括">概括</h2>
<h3 id="我为什么要读这本书">我为什么要读这本书?</h3>
<p>我觉得生活挺无聊, 人生活着没有什么意义. 听说在这本书中会有人生的意义</p>
<h3 id="这本书怎样影响了我">这本书怎样影响了我?</h3>
<ul>
<li>看清楚自己之所以活着, 就如史铁生所说, 就是还想得到什么. 并不是如我嘴上所说的: &ldquo;人生活着没什么意义&rdquo;</li>
<li>打算更加大胆地去追求自己想要&quot;得到&quot;的东西</li>
<li>看清楚做某一件事情的意义 &ndash; 不只是看重结果, 也要去看重过程</li>
</ul>
<h3 id="书中的三句精华句子">书中的三句精华句子?</h3>
<ul>
<li>可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望</li>
<li>只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。</li>
<li>世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。</li>
<li>上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。</li>
<li>此岸永远是残缺的，否则彼岸就要坍塌。</li>
</ul>
<h3 id="三句话总结本书">三句话总结本书</h3>
<ul>
<li>尊重不完美, 不要抱怨, 不断地去追求完美</li>
<li>看清楚自己想要得到什么</li>
<li>人生不能只看重目的, 要去享受这个过程.</li>
</ul>
<h2 id="书摘">书摘</h2>
<p>在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。</p>
<p>树干上留着一只蝉蜕，寂寞如一间空屋；露水在草叶上滚动，聚集，压弯了草叶轰然坠地摔开万道金光。”“</p>
<p>上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。</p>
<p>剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。</p>
<p>看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。</p>
<p>就命运而言，休论公道。</p>
<p>其实总共只有三个问题交替着来骚扰我，来陪伴我。第一个是要不要去死，第二个是为什么活，第三个，我干吗要写作。</p>
<p>人为什么活着？因为人想活着，说到底是这么回事，人真正的名字叫做：欲望。</p>
<p>可我为什么还想活呢？因为你还想得到点儿什么，你觉得你还是可以得到点儿什么的，比如说爱情，比如说价值感之类，人真正的名字叫欲望。</p>
<p>结果你又发表了几篇，并且出了一点儿小名，可这时你越来越感到恐慌。我忽然觉得自己活得像个人质，刚刚有点儿像个人了却又过了头，</p>
<p>人都忍不住要为生存找一些牢靠的理由。你不担心你会枯竭了？我不知道，不过我想，活着的问题在死前是完不了的。</p>
<p>就算是三个月！我平白地相信这样一个期限。</p>
<p>多年以后才听一位无名的哲人说过：危卧病榻，难有无神论者。</p>
<p>但在命运的混沌之点，人自然会忽略着科学，向虚暝之中寄托一份虔敬的祈盼。</p>
<p>机会不在外面在心里，结婚的机会有可能在外边，可爱情的机会只能在心里</p>
<p>那位台湾作家三毛说得对：爱如禅，不能说不能说，一说就错。</p>
<p>别人告诉我，她昏迷前的最后一句话是：“我那个有病的儿子和我那个还未成年的女儿……”</p>
<p>砌墙盖房，不单为避风雨，因为大家都有些秘密，其次当然还有一些钱财。秘密，不信你去慢慢推想，它是趣味的爹娘。</p>
<p>千万别把运动和能量，以及和时空分割开来理解。我随即得了启发：也千万别把人和意义分割开来理解。不是人有欲望，而是人即欲望。</p>
<p>如今想来，分明就是为了一个“轻”字：珍宝转眼被处理成垃圾，一段生命轻得飘散了，没有了，以为是什么原来什么也不是，轻易、简单、灰飞烟灭。一段生命之轻，威胁了生命全面之重，惶茫往灵魂里渗透：是不是生命的所有段落都会落此下场啊？人的根本恐惧就在这个“轻”字上，比如歧视和漠视，比如嘲笑，比如穷人手里作废的股票，比如失恋和死亡。轻，最是可怕。</p>
<p>艰苦的生活需要希望，鲜活的生命需要爱情，数不完的日子和数不完的心事，都要诉说。</p>
<p>也许是因为人缺了什么就更喜欢什么吧，我的两条腿一动不能动，却是个体育迷。</p>
<p>上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。</p>
<p>我希望既有一个健美的躯体又有一个了悟人生意义的灵魂，我希望二者兼得。</p>
<p>难道我们不该对灵魂有了残疾的人，比对肢体有了残疾的人，给予更多的同情和爱吗？</p>
<p>既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？</p>
<p>有知识不能只是有对物的知识，而是得有对人的了悟。</p>
<p>我们也完全可以把你以后的生活设计得无比顺利，但这样下去我们是不是绕了一圈又回到那不祥的阴影中去了？你将再没有企盼了吗？再没有新的追求了吗？那么你的心路是不是又在荒芜，于是你的幸福感又要老化、萎缩、枯竭了呢？</p>
<p>只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。</p>
<p>一个只想（只想！）使过程精彩的人是无法被剥夺的，因为死神也无法将一个精彩的过程变成不精彩的过程，因为坏运也无法阻挡你去创造一个精彩的过程，相反你可以把死亡也变成一个精彩的过程，相反坏运更利于你去创造精彩的过程。</p>
<p>过程！对，生命的意义就在于你能创造这过程的美好与精彩，生命的价值就在于你能够镇静而又激动地欣赏这过程的美丽与悲壮。</p>
<p>有位大物理学家说过：“物理学不告诉我们世界是什么，而是告诉我们关于世界我们能够谈论什么。”</p>
<p>历史难免是一部御制经典，文学要弥补它，所以看重的是那些沉默的心魂。</p>
<p>佛嘛，心中无佛什么事都敢干。</p>
<p>丑弱的人和圆满的神之间，是信者永远的路。</p>
<p>此岸永远是残缺的，否则彼岸就要坍塌。</p>
<p>历史，这两个字，可能包含着任何你想得到和想不到的危险，可能给你带来任何想得到和想不到的灾难。</p>
<p>那个年代的人都懂得，话说到这儿最好止步；历史，这两个字，可能包含着任何你想得到和想不到的危险，可能给你带来任何想得到和想不到的灾难。</p>
<p>家长们把“耐克”一类颠来倒去地看，说：“啥东西，值得这么贵？”他们不懂，春天是不能这样计算的。</p>
<p>大人们其实忘了，春天莫不如此，各位年轻时也是一样。</p>
<p>世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。</p>
<p>我想，那就不必再去地坛寻找安静，莫如在安静中寻找地坛。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>FFmpeg 基本使用</title>
      <link>https://ynikl.github.io/blog/ffmpeg-basics/</link>
      <pubDate>Fri, 19 Aug 2022 00:14:54 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/ffmpeg-basics/</guid>
      <description>最近接手公司一个视频相关项目, 也是使用ffmpeg工具. 需要快速了解下.
概念 码率, 帧率, 文件大小 帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.
interlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i progressive: 现代整页整页呈现, 描述单位p: 60p 码率(bit rate) :视频一秒中有多少位, 决定视频的质量
ABR: 平均码率 CBR: 常量码率 VBR: 动态码率 文件大小 = 视频文件 + 音频文件
视频文件 = 码率 * 时间(s) / 8 音频文件 = 码率 * 时间(s) / 8
文件格式 不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers) 可以存储声音或者视频数据.
相关缩写 encoding (E) decoding (D) video (V) audio (A) subtitles (S) 文件元数据 metadata 描述媒体文件自身的信息, 比如:</description>
      <content:encoded><![CDATA[<p>最近接手公司一个视频相关项目, 也是使用<code>ffmpeg</code>工具.  需要快速了解下.</p>
<h2 id="概念">概念</h2>
<h2 id="码率-帧率-文件大小">码率, 帧率, 文件大小</h2>
<p>帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.</p>
<ul>
<li>interlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i</li>
<li>progressive: 现代整页整页呈现, 描述单位p: 60p</li>
</ul>
<p>码率(bit rate) :视频一秒中有多少位, 决定视频的质量</p>
<ul>
<li>ABR: 平均码率</li>
<li>CBR: 常量码率</li>
<li>VBR: 动态码率</li>
</ul>
<p>文件大小 = 视频文件 + 音频文件</p>
<p>视频文件 =  码率 * 时间(s) / 8
音频文件 =  码率 * 时间(s) / 8</p>
<h3 id="文件格式">文件格式</h3>
<p>不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers)
可以存储声音或者视频数据.</p>
<h3 id="相关缩写">相关缩写</h3>
<ul>
<li>encoding (E)</li>
<li>decoding (D)</li>
<li>video (V)</li>
<li>audio (A)</li>
<li>subtitles (S)</li>
</ul>
<h3 id="文件元数据-metadata">文件元数据 metadata</h3>
<p>描述媒体文件自身的信息, 比如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Metadata:
</span></span><span class="line"><span class="cl">	publisher : Ninja Tune
</span></span><span class="line"><span class="cl">	track : 1
</span></span><span class="line"><span class="cl">	album : Ninja Tuna
</span></span><span class="line"><span class="cl">	artist : Mr. Scruff
</span></span><span class="line"><span class="cl">	album_artist : Mr. Scruff
</span></span><span class="line"><span class="cl">	title : Kalimba
</span></span><span class="line"><span class="cl">	genre : Electronic
</span></span><span class="line"><span class="cl">	composer : A. Carthy and A. Kingslow
</span></span><span class="line"><span class="cl">	date : 2008
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="声音">声音</h3>
<p>数字音频是通过对声音的模拟信息, 抽样且用数据信号表示.</p>
<p>音频使用 bit depths 来表示声音的解析度:</p>
<p>8bit, 12bit, 14bit &hellip;</p>
<p>声音的样本频率用 Hz 表示</p>
<p>8000Hz, 11025Hz, 16000Hz &hellip;</p>
<h3 id="ffmpeg-其他套件">FFmpeg 其他套件</h3>
<ul>
<li>ffplay 播放器</li>
<li>ffprobe 查看媒体文件的信息</li>
<li>ffserver 流服务器</li>
</ul>
<h2 id="使用">使用</h2>
<h3 id="通用参数">通用参数</h3>
<p><code>-i</code> 输入源, 可以是文件也可以是 url</p>
<p><code>-vf</code> option for video filters
<code>-af</code> option for audio filters.</p>
<p><code>-filter_complex</code> 当多个输入源的时候使用</p>
<p><code>-y</code> 输出文件会强制覆盖已经存在的文件</p>
<h3 id="帮助">帮助</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 查看支持格式
</span></span><span class="line"><span class="cl">ffmpeg -formats
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; 编解码器
</span></span><span class="line"><span class="cl">ffmpeg -codecs 
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="调整帧率">调整帧率</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.avi -r 30 output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="调整码率">调整码率</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.avi -b:v 1500k output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="缩放视频大小">缩放视频大小</h3>
<ul>
<li>s : w x h 参数 宽乘以高</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 缩小分辨率
</span></span><span class="line"><span class="cl">ffmpeg -i input.avi -s 640x480 output.avi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; 扩大分辨率
</span></span><span class="line"><span class="cl">ffmpeg -i input.mpg -vf scale=iw/PHI:ih/PHI output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="旋转-翻转">旋转, 翻转</h3>
<p>旋转</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i CMYK.avi -vf transpose=2 CMYK_transposed.avi
</span></span></code></pre></td></tr></table>
</div>
</div><p>竖直翻转</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i meta.mp4 -vf vflip output_flip.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="裁切">裁切</h3>
<p>裁切视频的画中画, 裁切视频的中心 1/2 的视频</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.avi -vf crop=iw/2:ih/2 output.avi
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="模糊化">模糊化</h3>
<p>模糊化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.mpg -vf boxblur=1.5:1 output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><p>锐化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input -vf unsharp output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="叠加">叠加</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="裁剪">裁剪</h3>
<p>获取一个时间段内的音频
<code>-t</code> 参数为秒</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.mp4 -t 180 output_3_min.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>--ss</code> 设置开始时间点 ( seek from start, 从视频开始过多少秒开始操作)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 直接截断开头3分钟
</span></span><span class="line"><span class="cl">ffmpeg -i input.mp4 -ss 180 output_without_start_3.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>截取某一段时间视频</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 截取第4分钟, 一分钟视频
</span></span><span class="line"><span class="cl">ffmpeg -i input.mp4 -ss 180 -t 60 clip_4th_min.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="图片操作">图片操作</h3>
<p>从视频中截取某一帧</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i videoclip.avi -ss 01:23:45 image.jpg
</span></span></code></pre></td></tr></table>
</div>
</div><p>翻转图片</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i orange.jpg -vf hflip orange_hflip.jpg
</span></span><span class="line"><span class="cl">ffmpeg -i orange.jpg -vf vflip orange_vflip.jpg
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; transpose [0, 1, 2, 3]
</span></span><span class="line"><span class="cl">ffmpeg -i image.png -vf transpose=1 image_rotated.png
</span></span></code></pre></td></tr></table>
</div>
</div><p>转换图片格式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i illustration.png illustration.jpg
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="格式转化">格式转化</h3>
<p>格式转化流程:</p>
<p>Demuxer (分解复用) : 将合成信号恢复成原本独立的信号数据
Decoder (解码器) : 解码
Encoder (编码器) : 编码
Muxer ( _ ): 将多个信号数据合并</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -y -i input.avi output.mp4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; 改变格式, 但不更改编解码方式
</span></span><span class="line"><span class="cl">ffmpeg -i input.avi -q 1 -c copy output.mov
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="混音">混音</h3>
<p>将两个声合成一个文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i demo.mp3 -i louder_sound.aac -filter_complex amix=inputs=2 sounds.wav
</span></span></code></pre></td></tr></table>
</div>
</div><p>加强耳机的立体声效果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i music.mp3 -af earwax -q 1 music_headphones.mp3
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li><em>FFmpeg Basics 2012 by Frantisek Korbel</em></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Redis 用于做分布式锁</title>
      <link>https://ynikl.github.io/blog/redis-do-distributed-lock/</link>
      <pubDate>Thu, 18 Aug 2022 12:18:53 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/redis-do-distributed-lock/</guid>
      <description>操作 演进 加锁后进程挂掉了 加锁成功之后, 进程挂掉了没有进行解锁操作. 导致进入死锁状态.
引入 expire 设置超时时长, 自动释放 key
1 2 3 4 5 6 7 8 &amp;gt; setnx lock:key true &amp;gt; OK &amp;gt; expire lock:key 5 &amp;#34; ... do something critical ... &amp;gt; del lock:codehole 加锁动作 到 expire 之间挂掉了 redis 2.8 之后支持 set 拓展指令
1 &amp;gt; set lock:key true ex 5 nx 加锁互斥锁, 并同时设置超时时长
执行超时, 被其他进程获取到了锁 加锁之后, 本身进程执行时间超过了预先设置的 expire 的时间. 就会导致锁被提前释放.
解决方案:
尽量不要用与锁住时间教长的任务, 尝试缩小锁定的&amp;quot;关键区域&amp;quot; 续锁 (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间 执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁 Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。 &amp;ndash; Redis深度历险</description>
      <content:encoded><![CDATA[<h2 id="操作">操作</h2>
<h2 id="演进">演进</h2>
<h3 id="加锁后进程挂掉了">加锁后进程挂掉了</h3>
<p>加锁成功之后, 进程挂掉了没有进行解锁操作.
导致进入死锁状态.</p>
<p>引入 <code>expire</code> 设置超时时长, 自动释放 key</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; setnx lock:key true 
</span></span><span class="line"><span class="cl">&gt; OK
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; expire lock:key 5 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; ... do something critical ... 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; del lock:codehole
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="加锁动作-到-expire-之间挂掉了">加锁动作 到 expire 之间挂掉了</h3>
<p>redis 2.8 之后支持 <code>set</code> 拓展指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; set lock:key true ex 5 nx
</span></span></code></pre></td></tr></table>
</div>
</div><p>加锁互斥锁, 并同时设置超时时长</p>
<h3 id="执行超时-被其他进程获取到了锁">执行超时, 被其他进程获取到了锁</h3>
<p>加锁之后, 本身进程执行时间超过了预先设置的 <code>expire</code> 的时间. 就会导致锁被提前释放.</p>
<p>解决方案:</p>
<ol>
<li>尽量不要用与锁住时间教长的任务, 尝试缩小锁定的&quot;关键区域&quot;</li>
<li><strong>续锁</strong> (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间</li>
</ol>
<h3 id="执行超时-被其他进程获取到了锁之后-超时进程误删其他进程的锁">执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁</h3>
<blockquote>
<p>Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。
&ndash; Redis深度历险</p>
</blockquote>
<p>解决方案: 给加锁的 key 设置随机数的value, 删除之前先匹配是否一致再删除</p>
<p>匹配和删除动作之间的原子性可以用 Lua 脚本保证</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="o">#</span> <span class="n">delifequals</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="n">redis.call</span><span class="p">(</span><span class="s2">&#34;get&#34;</span><span class="p">,</span><span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">	<span class="kr">return</span> <span class="n">redis.call</span><span class="p">(</span><span class="s2">&#34;del&#34;</span><span class="p">,</span><span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="kr">else</span>
</span></span><span class="line"><span class="cl">	<span class="kr">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="可重入锁">可重入锁</h3>
<p>利用线程的本地变量(Threadloacl), 维护锁的持有计数, 实现支持多次加锁, 多次解锁</p>
<h2 id="参考">参考</h2>
<ul>
<li><em>Redis 深度历险</em></li>
<li><a href="https://www.51cto.com/article/679902.html">阿里二面：Redis分布式锁过期了但业务还没有执行完，怎么办</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>CI/CD</title>
      <link>https://ynikl.github.io/posts/ci-cd/</link>
      <pubDate>Sun, 14 Aug 2022 15:27:33 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/ci-cd/</guid>
      <description>CI 自动化发布流程 可重复 可快速回滚 发布流程快速 在合并的时候可以对代码进行快速验证 CD 部署流程平台化 一键部署 总结 所谓的 CI/CD 就是通过自动化操作, 比如自动化测试, 自动化部署. 使用项目拥有快速上线的能力 &amp;ndash; 可以快速验证, 快速回滚, 快速发布.</description>
      <content:encoded><![CDATA[<h2 id="ci">CI</h2>
<ul>
<li>自动化发布流程</li>
<li>可重复</li>
<li>可快速回滚</li>
<li>发布流程快速</li>
<li>在合并的时候可以对代码进行快速验证</li>
</ul>
<h2 id="cd">CD</h2>
<ul>
<li>部署流程平台化</li>
<li>一键部署</li>
</ul>
<h2 id="总结">总结</h2>
<p>所谓的 CI/CD 就是通过自动化操作, 比如自动化测试, 自动化部署. 使用项目拥有快速上线的能力 &ndash; 可以快速验证, 快速回滚, 快速发布.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang Map 介绍</title>
      <link>https://ynikl.github.io/blog/golang-map/</link>
      <pubDate>Sat, 13 Aug 2022 14:14:30 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-map/</guid>
      <description>本想写一篇关于 golang 中 map 底层的文章， 但是发现已经了相当不错的文章 &amp;ndash; 字节跳动技术团队 - Golang 中 map 探究 这里只补充一下，缺少的 map 的删除操作
内部数据结构 初始化 map 是一个有&amp;quot;包含内容&amp;quot;的数据结构, 使用之前需要提前初始化, 即调用make
真正是调用源码是 runtime.makemap
获取数据 删除 源码地址
删除的关键代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Only clear key if there are pointers in it. // # 当 Key 是指针类型的时候会去清空指针 if t.key.ptrdata != 0 { if goarch.</description>
      <content:encoded><![CDATA[<p>本想写一篇关于 golang 中 map 底层的文章， 但是发现已经了相当不错的文章 &ndash;
<a href="https://mp.weixin.qq.com/s/UT8tydajjOUJkfc-Brcblw">字节跳动技术团队 - Golang 中 map 探究</a>
这里只补充一下，缺少的 map 的删除操作</p>
<h2 id="内部数据结构">内部数据结构</h2>
<h2 id="初始化">初始化</h2>
<p>map 是一个有&quot;包含内容&quot;的数据结构, 使用之前需要提前初始化, 即调用<code>make</code></p>
<p>真正是调用源码是 <a href="https://cs.opensource.google/go/go/+/master:src/runtime/map.go;l=283;bpv=1;bpt=1?q=makemap&amp;ss=go%2Fgo">runtime.makemap</a></p>
<h2 id="获取数据">获取数据</h2>
<h2 id="删除">删除</h2>
<p><a href="https://cs.opensource.google/go/go/+/master:src/runtime/map_fast64.go;drc=3e5c2c155645ebaed62e4481430c455045b0fff5;bpv=1;bpt=1;l=273?q=mapdelete_fast64&amp;ss=go%2Fgo">源码地址</a></p>
<p>删除的关键代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// Only clear key if there are pointers in it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// # 当 Key 是指针类型的时候会去清空指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// There are three ways to squeeze at one ore more 32 bit pointers into 64 bits.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// Just call memclrHasPointers instead of trying to handle all cases here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// # 当 Value 为指针类型的时候, 指针为空, 解除引用 -&gt; GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">			<span class="c1">// # 讲 hash 值标记为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">emptyOne</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述删除代码操作现象</p>
<ul>
<li>当<code>map</code>的<code>value</code>类型中包含引用类型, 删除对应的<code>key</code>之后, 经过GC就会释放占用的内存</li>
<li>当<code>map</code>的<code>value</code> 类型不包含引用类型, 删除对应的<code>key</code>之后, GC无法释放类型</li>
</ul>
<p>可以查看我自己的实验结果 {{}}</p>
https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/
<h2 id="扩容">扩容</h2>
<h2 id="参考">参考</h2>
<p><a href="https://mp.weixin.qq.com/s/UT8tydajjOUJkfc-Brcblw">Golang 中 map 探究</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>活着的意义</title>
      <link>https://ynikl.github.io/posts/the-meaning-of-living/</link>
      <pubDate>Tue, 09 Aug 2022 23:40:37 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/the-meaning-of-living/</guid>
      <description>我觉得人生活着没有意义，但是我又为什么还活着呢？今天， 刚好看到了史铁生的《我与地坛》里面给了我答案
可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望</description>
      <content:encoded><![CDATA[<p>我觉得人生活着没有意义，但是我又为什么还活着呢？今天， 刚好看到了史铁生的《我与地坛》里面给了我答案</p>
<blockquote>
<p>可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>巴菲特致股东的信</title>
      <link>https://ynikl.github.io/books/%E5%B7%B4%E8%8F%B2%E7%89%B9%E8%87%B4%E8%82%A1%E4%B8%9C%E7%9A%84%E4%BF%A1/</link>
      <pubDate>Mon, 08 Aug 2022 13:27:29 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/%E5%B7%B4%E8%8F%B2%E7%89%B9%E8%87%B4%E8%82%A1%E4%B8%9C%E7%9A%84%E4%BF%A1/</guid>
      <description>概括 我为什么要读这本书? Youtuber 推荐, 好奇金融相关的知识
这本书怎样影响了我? 不要轻易地去触碰股市, 直到我真正的理解它.
书中的三句精华句子? 一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力 他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误 活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。 三句话总结本书 投资的时候要看重的公司的内在价值而不是市场先生的报价 减少交易次数 努力地去看透事情的本质 书摘 笔记摘自
巴菲特致股东的信：投资者和公司高管教程（原书第4版）
【美】沃伦E.巴菲特
关于巴菲特一生的成功秘诀，已经有无数人做出了评价，我个人认为可以归结为八个字：与时俱进，良性循环
“与坏人打交道，做成一笔好生意，这样的事情，我从来没有遇见过。”巴菲特的这句名言令人深思
从别人的故事里，找到自己的人生启发，这就是读书的意义所在
广受尊重的投资家兼作家菲尔·费雪（即菲利普·费雪，Phil Fisher）曾经将公司吸引股东的策略比喻为餐馆吸引顾客的策略。 一家餐馆可以定位于特定的食客阶层——喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困惑，最终离开。
应该可以直接与公司CEO进行沟通，得到他现在和未来如何对企业进行估值的看法
如果我们对一只股票有良好的长期预期，那么短期的价格波动对我们来说毫无意义，除非有人报给我们一个非常有吸引力的价格。
芒格和我无法向你承诺结果。但我们可以保证，只要你是我们的合伙人，在任何时段，你的金融资产和我们自己的资产将完全保持一致的成长
为了达成目标，我们的首选是直接持有一系列多元化的企业，从中获得稳定的现金流和持续的高于市场平均水平的资本回报
从整体和长期来看，我们希望那些未体现的盈利，通过资本增值的形式体现在我们的内在价值里
巴菲特以及伯克希尔避免进行预测，因为这是一种糟糕的管理习惯，经常会导致管理人粉饰报表
但是任何短期的压力都不应以牺牲长期竞争力为代价
一场大会的毫无建树是由于参与股东们更在意自己在台上的表现，而不是关心公司运营的状况
在伯克希尔公司，我们通常会换位思考，设想如果我们自己处于股东的位置，应该得到什么样的信息，我们会从这样的角度向股东披露完整的报告
这种打假活动针对的目标是公司信息披露行为中的“选择性披露”，近些年来，这种选择性披露行为像癌症一样蔓延。的确，信息的选择性披露已经成为大型公司的一种标准化的行为
CEO们预测公司增长速度，是骗人的和危险的。当然，他们是被分析师和公司自己的投资者关系部门怂恿裹挟着这么做。但他们应该拒绝，因为这样预测多了会招致麻烦。
厨房里如果有蟑螂，绝不可能只有一只
在一个由一群和事佬组成的董事会里，不太可能会有人提出更换CEO的提议。同样，也不可能对CEO提议的公司并购活动提出质疑
毕竟，没有人会喜欢去洗外面租来的车
除了要维持独立性，董事们也必须具备丰富的商业经验，以股东利益为导向，以及在公司拥有真正的利益
在收购之前，他们就已是商界的管理明星，已经证明了自己在各自领域中的才华，我们的主要贡献就是让他们自由发挥天分，不给他们添乱
“如果我们雇用的都是比我们矮的人，我们将成为一家侏儒公司；但如果我们雇用的都是比我们高的人，我们会成为一家巨人公司。”
我们希望我们的经理人队伍考虑什么是重要的，而不是考虑什么被认为是重要的。
当投资的时候，我们将自己视为企业分析师——而不是市场分析师，不是宏观经济分析师，甚至不是证券分析师。
他说你应该将市场报价想象为一个名叫“市场先生”的人
如果你不懂得你的公司，不能比市场先生更准确地评估你的公司，你就不要参与这场游戏
就像人们打牌时说的：“如果玩了30分钟，你还不知道谁是倒霉蛋，有可能就是你。
一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力
有些人会在不同市场间倒手，意图赚取差价。你不必感到惊讶，从业者为此选了一个法语词汇：套利。
如果需要同时做很多事情，就像同时将很多烙铁放在火中，人们就必须花大量的时间，既要监控交易的过程，又要监控市场股价的波动。这不是芒格和我所想的生活模式。（如果只是为了赚钱而整天盯着股票行情，这种生活有什么意义可言？
在完全忽视股价的情况下，一家拥有子公司的母公司，如果子公司长期表现优异，母公司是不可能出售子公司的。“为什么要卖出？”CEO会问，“难道要我卖出皇冠上的宝石吗
应该评估是否在其预期的持股期间，其投资的税后收益总和（包括他卖出所得）会带给他至少在投资开始之初同等的购买力，加上合理的利率因素
一个视力平平的人，没有必要在干草堆里寻找绣花针。
我们的座右铭是：“如果你一开始就取得了成功，那么，不必再做测试。
很多大名鼎鼎的基金管理人现在关注的是其他基金管理人未来几天干什么，而不是关注企业未来几年干什么。对于他们而言，股票仅仅是游戏中的筹码，就像大富翁游戏中，如同顶针和熨斗一样的道具
我们的目标是发现那些价格合理的杰出公司，而不是价格便宜的平庸公司
最值得拥有的公司是，那些在一个一直延伸的时期周期里，可以不断利用增量资本获得很高回报率的公司
他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误
二级市场经常周期性地被大量傻瓜所主导，会持续设定一个“清算”价格。无论这个价格多么愚蠢，它是股票或债券持有者需要或希望卖出的价格，总是有这样的机会出现
无论什么样的天才或努力，有些事情总是需要时间。即便你能让九个女人同时怀孕，也不可能让她们在一个月的时间里生出小宝宝。）
但我更喜欢一个确定的良好结果，而不是一个期望的伟大结果。
在企业内部，有一种看不见的力量足以压倒一切，我们可以称其为“惯性驱使”或“机构强迫症”
如果我们在资产负债表上使用适当的负债，可以在安全的前提下增加一些盈利
信用就像氧气。此二者，在充足的时候，人们不会注意到它们的存在；当它们消失的时候，人们才会发现它们的重要性
当年花1美元可以买到的东西，今天要花7美元以上。因此，即便一个不用交税的机构，也必须在同期从债券上获得4.3%的年化利息收入，才能维持其购买力不变。如果这些机构的管理人将任何的利息部分视为“收入”的话，他们一定是在和自己开玩笑
即使在最混乱的经济环境中，美国国债也是唯一靠得住的流动性良好的投资对象
大多数人宁愿去死，也不愿意思考。很多人就是这样
巨大的负债可以让管理层前所未有地专注工作，就像在汽车方向盘上装一把匕首，可以提高司机的注意力一样
衍生品还可能造成连锁反应式的风险，因为很多保险公司或再保险公司将它们的风险分散给其他保险公司</description>
      <content:encoded><![CDATA[<h2 id="概括">概括</h2>
<h3 id="我为什么要读这本书">我为什么要读这本书?</h3>
<p>Youtuber 推荐, 好奇金融相关的知识</p>
<h3 id="这本书怎样影响了我">这本书怎样影响了我?</h3>
<p>不要轻易地去触碰股市, 直到我真正的理解它.</p>
<h3 id="书中的三句精华句子">书中的三句精华句子?</h3>
<ol>
<li>一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力</li>
<li>他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误</li>
<li>活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。</li>
</ol>
<h3 id="三句话总结本书">三句话总结本书</h3>
<ul>
<li>投资的时候要看重的公司的内在价值而不是市场先生的报价</li>
<li>减少交易次数</li>
<li>努力地去看透事情的本质</li>
</ul>
<h2 id="书摘">书摘</h2>
<p>笔记摘自</p>
<p>巴菲特致股东的信：投资者和公司高管教程（原书第4版）</p>
<p>【美】沃伦E.巴菲特</p>
<blockquote>
<p>关于巴菲特一生的成功秘诀，已经有无数人做出了评价，我个人认为可以归结为八个字：与时俱进，良性循环</p>
</blockquote>
<blockquote>
<p>“与坏人打交道，做成一笔好生意，这样的事情，我从来没有遇见过。”巴菲特的这句名言令人深思</p>
</blockquote>
<blockquote>
<p>从别人的故事里，找到自己的人生启发，这就是读书的意义所在</p>
</blockquote>
<blockquote>
<p>广受尊重的投资家兼作家菲尔·费雪（即菲利普·费雪，Phil Fisher）曾经将公司吸引股东的策略比喻为餐馆吸引顾客的策略。 一家餐馆可以定位于特定的食客阶层——喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困惑，最终离开。</p>
</blockquote>
<blockquote>
<p>应该可以直接与公司CEO进行沟通，得到他现在和未来如何对企业进行估值的看法</p>
</blockquote>
<blockquote>
<p>如果我们对一只股票有良好的长期预期，那么短期的价格波动对我们来说毫无意义，除非有人报给我们一个非常有吸引力的价格。</p>
</blockquote>
<blockquote>
<p>芒格和我无法向你承诺结果。但我们可以保证，只要你是我们的合伙人，在任何时段，你的金融资产和我们自己的资产将完全保持一致的成长</p>
</blockquote>
<blockquote>
<p>为了达成目标，我们的首选是直接持有一系列多元化的企业，从中获得稳定的现金流和持续的高于市场平均水平的资本回报</p>
</blockquote>
<blockquote>
<p>从整体和长期来看，我们希望那些未体现的盈利，通过资本增值的形式体现在我们的内在价值里</p>
</blockquote>
<blockquote>
<p>巴菲特以及伯克希尔避免进行预测，因为这是一种糟糕的管理习惯，经常会导致管理人粉饰报表</p>
</blockquote>
<blockquote>
<p>但是任何短期的压力都不应以牺牲长期竞争力为代价</p>
</blockquote>
<blockquote>
<p>一场大会的毫无建树是由于参与股东们更在意自己在台上的表现，而不是关心公司运营的状况</p>
</blockquote>
<blockquote>
<p>在伯克希尔公司，我们通常会换位思考，设想如果我们自己处于股东的位置，应该得到什么样的信息，我们会从这样的角度向股东披露完整的报告</p>
</blockquote>
<blockquote>
<p>这种打假活动针对的目标是公司信息披露行为中的“选择性披露”，近些年来，这种选择性披露行为像癌症一样蔓延。的确，信息的选择性披露已经成为大型公司的一种标准化的行为</p>
</blockquote>
<blockquote>
<p>CEO们预测公司增长速度，是骗人的和危险的。当然，他们是被分析师和公司自己的投资者关系部门怂恿裹挟着这么做。但他们应该拒绝，因为这样预测多了会招致麻烦。</p>
</blockquote>
<blockquote>
<p>厨房里如果有蟑螂，绝不可能只有一只</p>
</blockquote>
<blockquote>
<p>在一个由一群和事佬组成的董事会里，不太可能会有人提出更换CEO的提议。同样，也不可能对CEO提议的公司并购活动提出质疑</p>
</blockquote>
<blockquote>
<p>毕竟，没有人会喜欢去洗外面租来的车</p>
</blockquote>
<blockquote>
<p>除了要维持独立性，董事们也必须具备丰富的商业经验，以股东利益为导向，以及在公司拥有真正的利益</p>
</blockquote>
<blockquote>
<p>在收购之前，他们就已是商界的管理明星，已经证明了自己在各自领域中的才华，我们的主要贡献就是让他们自由发挥天分，不给他们添乱</p>
</blockquote>
<blockquote>
<p>“如果我们雇用的都是比我们矮的人，我们将成为一家侏儒公司；但如果我们雇用的都是比我们高的人，我们会成为一家巨人公司。”</p>
</blockquote>
<blockquote>
<p>我们希望我们的经理人队伍考虑什么是重要的，而不是考虑什么被认为是重要的。</p>
</blockquote>
<blockquote>
<p>当投资的时候，我们将自己视为企业分析师——而不是市场分析师，不是宏观经济分析师，甚至不是证券分析师。</p>
</blockquote>
<blockquote>
<p>他说你应该将市场报价想象为一个名叫“市场先生”的人</p>
</blockquote>
<blockquote>
<p>如果你不懂得你的公司，不能比市场先生更准确地评估你的公司，你就不要参与这场游戏</p>
</blockquote>
<blockquote>
<p>就像人们打牌时说的：“如果玩了30分钟，你还不知道谁是倒霉蛋，有可能就是你。</p>
</blockquote>
<blockquote>
<p>一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力</p>
</blockquote>
<blockquote>
<p>有些人会在不同市场间倒手，意图赚取差价。你不必感到惊讶，从业者为此选了一个法语词汇：套利。</p>
</blockquote>
<blockquote>
<p>如果需要同时做很多事情，就像同时将很多烙铁放在火中，人们就必须花大量的时间，既要监控交易的过程，又要监控市场股价的波动。这不是芒格和我所想的生活模式。（如果只是为了赚钱而整天盯着股票行情，这种生活有什么意义可言？</p>
</blockquote>
<blockquote>
<p>在完全忽视股价的情况下，一家拥有子公司的母公司，如果子公司长期表现优异，母公司是不可能出售子公司的。“为什么要卖出？”CEO会问，“难道要我卖出皇冠上的宝石吗</p>
</blockquote>
<blockquote>
<p>应该评估是否在其预期的持股期间，其投资的税后收益总和（包括他卖出所得）会带给他至少在投资开始之初同等的购买力，加上合理的利率因素</p>
</blockquote>
<blockquote>
<p>一个视力平平的人，没有必要在干草堆里寻找绣花针。</p>
</blockquote>
<blockquote>
<p>我们的座右铭是：“如果你一开始就取得了成功，那么，不必再做测试。</p>
</blockquote>
<blockquote>
<p>很多大名鼎鼎的基金管理人现在关注的是其他基金管理人未来几天干什么，而不是关注企业未来几年干什么。对于他们而言，股票仅仅是游戏中的筹码，就像大富翁游戏中，如同顶针和熨斗一样的道具</p>
</blockquote>
<blockquote>
<p>我们的目标是发现那些价格合理的杰出公司，而不是价格便宜的平庸公司</p>
</blockquote>
<blockquote>
<p>最值得拥有的公司是，那些在一个一直延伸的时期周期里，可以不断利用增量资本获得很高回报率的公司</p>
</blockquote>
<blockquote>
<p>他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误</p>
</blockquote>
<blockquote>
<p>二级市场经常周期性地被大量傻瓜所主导，会持续设定一个“清算”价格。无论这个价格多么愚蠢，它是股票或债券持有者需要或希望卖出的价格，总是有这样的机会出现</p>
</blockquote>
<blockquote>
<p>无论什么样的天才或努力，有些事情总是需要时间。即便你能让九个女人同时怀孕，也不可能让她们在一个月的时间里生出小宝宝。）</p>
</blockquote>
<blockquote>
<p>但我更喜欢一个确定的良好结果，而不是一个期望的伟大结果。</p>
</blockquote>
<blockquote>
<p>在企业内部，有一种看不见的力量足以压倒一切，我们可以称其为“惯性驱使”或“机构强迫症”</p>
</blockquote>
<blockquote>
<p>如果我们在资产负债表上使用适当的负债，可以在安全的前提下增加一些盈利</p>
</blockquote>
<blockquote>
<p>信用就像氧气。此二者，在充足的时候，人们不会注意到它们的存在；当它们消失的时候，人们才会发现它们的重要性</p>
</blockquote>
<blockquote>
<p>当年花1美元可以买到的东西，今天要花7美元以上。因此，即便一个不用交税的机构，也必须在同期从债券上获得4.3%的年化利息收入，才能维持其购买力不变。如果这些机构的管理人将任何的利息部分视为“收入”的话，他们一定是在和自己开玩笑</p>
</blockquote>
<blockquote>
<p>即使在最混乱的经济环境中，美国国债也是唯一靠得住的流动性良好的投资对象</p>
</blockquote>
<blockquote>
<p>大多数人宁愿去死，也不愿意思考。很多人就是这样</p>
</blockquote>
<blockquote>
<p>巨大的负债可以让管理层前所未有地专注工作，就像在汽车方向盘上装一把匕首，可以提高司机的注意力一样</p>
</blockquote>
<blockquote>
<p>衍生品还可能造成连锁反应式的风险，因为很多保险公司或再保险公司将它们的风险分散给其他保险公司</p>
</blockquote>
<blockquote>
<p>“世俗的智慧告诉我们，循规蹈矩的失败，可能比标新立异的成功，更有利于保全名声</p>
</blockquote>
<blockquote>
<p>这场愚蠢游戏的核心是，人们通常都认为房屋的价格肯定会随着时间而上升，任何的下降都是可以忽略不计的。这个前提几乎贯穿于任何房屋的交易行为和交易价格中</p>
</blockquote>
<blockquote>
<p>借贷者将钱借给那些以他们的收入根本还不起钱的人，借款者很愉快地签署这些合同。借贷双方都寄希望于“房价的上升”，以弥补这项“不可能完成的任务”所带来的缺口。</p>
</blockquote>
<p>.&gt; 但是，居住和使用应作为买房时的首要动机，而不应该将购房视作升值盈利或再融资的手段。同时，购房时应该考虑与收入相匹配，量力而行。</p>
<blockquote>
<p>投资者的整体回报，随着交易频率的上升而减少。</p>
</blockquote>
<blockquote>
<p>道琼斯在20世纪的100年中，从65.73点上升到11497.12点，相当于年化复合回报率5.3%（当然，投资者在此期间还能收到分红。）在接下来21世纪的100年中，为了达到同样的回报率，道琼斯指数必须——你需要深呼一口气——达到2011011.23点。也就是说，到21世纪末，道琼斯将以200万点收盘，但看看本世纪初的前六年，道琼斯指数几乎原地没动。</p>
</blockquote>
<blockquote>
<p>活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。这实际上是对股东们征收的重税，虽然只是一个人决定“换个位子”，虽然支付的对象是金融机构，而不是华盛顿</p>
</blockquote>
<blockquote>
<p>并不是所有的收益都是在同等的情况下创造的。在很多公司，尤其是那些具有高资产/利润比特征的公司里，通货膨胀会侵蚀财报中显示的部分甚至全部收益。这个会被通胀侵蚀的收益部分，我们称之为“受限定收益”，不能被用于派发红利，以利于公司保持其经济竞争地位。</p>
</blockquote>
<blockquote>
<p>如果再投资能获得高回报，就应该保留收益进行再投资；如果回报低下，就应该分红</p>
</blockquote>
<blockquote>
<p>除非它们经历了极其巨大的惊人的单位成长，杰出的公司一定会产生大量的富余现金。如果公司将这些收益投在那些回报低下的业务，公司的整体留存资本的表现可能依然会很卓越，因为，核心业务部分的回报非凡。这就像高尔夫比赛中，职业选手和业余选手的混合赛，即便队伍中的业余选手都是没有希望的笨蛋，但整个球队的表现还是不错，因为得分主要来源于其中的职业选手</p>
</blockquote>
<blockquote>
<p>如果一家公司的股票价格远低于其内在价值，通常在这个时候，回购最有意义</p>
</blockquote>
<blockquote>
<p>首先，一家公司有充足的现金以备运营和流动性之需；其次，股价远低于保守计算的内在价值</p>
</blockquote>
<blockquote>
<p>以及那些冲着分拆预期而来的买家，毫无疑问将会稀释现有股东群体的质量</p>
</blockquote>
<blockquote>
<p>过度活跃的股市是企业的扒手。</p>
</blockquote>
<blockquote>
<p>我们采取的方式就像一个人寻找合适的另一半一样：保持积极、兴趣、开放的心态，但不能着急</p>
</blockquote>
<blockquote>
<p>桑塔亚娜（Santayana）曾说：“当你忘却了目标，狂热会让你付出很多倍的努力</p>
</blockquote>
<blockquote>
<p>我们试图避免一些小动作——“如果一些事情不值得做，也就不值得做好。</p>
</blockquote>
<blockquote>
<p>诺亚法则：重要的是建造方舟，而不是预测大雨</p>
</blockquote>
<blockquote>
<p>我们喜欢与那些热爱自家公司的人做生意，而不仅仅是因为喜欢钱（虽然，我们也可以理解他为何喜欢）。当这种附加的情感存在时，它是一个信号，让人可以发现企业所具有的重要品质：不做假账，以产品为荣，尊重客户，以及一群忠诚的、有强烈方向感的人。与此相反的情况，也是真的。当</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql- 数据类型 - 数字</title>
      <link>https://ynikl.github.io/blog/mysql-data-type-numbers/</link>
      <pubDate>Sun, 31 Jul 2022 17:49:46 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/mysql-data-type-numbers/</guid>
      <description>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期和时间 空间 JSON 数字类型 整数类型 Interger 类型 存储大小 bytes 其他别名 TinyInt 1 bool, boolean = tinyint(1) SmallInt 2 MediumInt 3 Int 4 BigInt 8 int(M) 表示显示宽度, 最大显示宽度为(255), M 与存储空间的大小无关. 空间大小由具体类型决定.
如果具体数值达不到宽度, 左边就会用0值补齐至 M 位.
浮点 ( Floating-Point ) 类型 存储 补充 范围 Float 4 bytes 单精度 Double 8 bytes 双精度 Float(p) p 表示小数点后的精度位数
Float(M, D) Mysql 语法: M表示总显示位数, D表示小数点后个数 &amp;ndash; 由Mysql自己做约分处理. Mysql 8.0 后废弃该语法.
定点 ( Fixed-Point ) 用于需要准备保存字段数据, 如金钱相关字段.</description>
      <content:encoded><![CDATA[<h2 id="概览">概览</h2>
<p>Mysql 支持以下数据类型</p>
<ul>
<li>数字类型</li>
<li>串类型(字符和字节)</li>
<li>日期和时间</li>
<li>空间</li>
<li>JSON</li>
</ul>
<h2 id="数字类型">数字类型</h2>
<h3 id="整数类型-interger">整数类型 Interger</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小 bytes</th>
<th>其他别名</th>
</tr>
</thead>
<tbody>
<tr>
<td>TinyInt</td>
<td>1</td>
<td>bool, boolean = tinyint(1)</td>
</tr>
<tr>
<td>SmallInt</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>MediumInt</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>Int</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>BigInt</td>
<td>8</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>int(M) 表示显示宽度, 最大显示宽度为(255), M 与存储空间的大小无关. 空间大小由具体类型决定.</strong></p>
<p>如果具体数值达不到宽度, 左边就会用0值补齐至 M 位.</p>
<h3 id="浮点--floating-point-">浮点 ( Floating-Point )</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储</th>
<th>补充</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>Float</td>
<td>4 bytes</td>
<td>单精度</td>
<td></td>
</tr>
<tr>
<td>Double</td>
<td>8 bytes</td>
<td>双精度</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>Float(p)</code> p 表示小数点后的精度位数</p>
<p><code>Float(M, D)</code> Mysql 语法: M表示总显示位数, D表示小数点后个数 &ndash; 由Mysql自己做约分处理. Mysql 8.0 后废弃该语法.</p>
<h3 id="定点--fixed-point-">定点 ( Fixed-Point )</h3>
<p>用于需要准备保存字段数据, 如金钱相关字段.</p>
<p><code>Decimal(M, D)</code> 其中, M 表示字段中有效数据个数, D 表示小数点后个数</p>
<p>Decimal(5,2) 的精度为 <code>-999.99 - 999.99</code></p>
<h3 id="位--bit-value-">位 ( Bit-Value )</h3>
<p><code>BIT(M)</code> 用于存储位值, M范围(1-64), 当存储的数值小于 M, 会进行左边补0</p>
<p>example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql&gt; CREATE TABLE t (b BIT(8));
</span></span><span class="line"><span class="cl">mysql&gt; INSERT INTO t SET b = b&#39;11111111&#39;;
</span></span><span class="line"><span class="cl">mysql&gt; INSERT INTO t SET b = b&#39;1010&#39;;
</span></span><span class="line"><span class="cl">mysql&gt; INSERT INTO t SET b = b&#39;0101&#39;;
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql&gt; SELECT b+0, BIN(b), OCT(b), HEX(b) FROM t;
</span></span><span class="line"><span class="cl">+------+----------+--------+--------+
</span></span><span class="line"><span class="cl">| b+0  | BIN(b)   | OCT(b) | HEX(b) |
</span></span><span class="line"><span class="cl">+------+----------+--------+--------+
</span></span><span class="line"><span class="cl">|  255 | 11111111 | 377    | FF     |
</span></span><span class="line"><span class="cl">|   10 | 1010     | 12     | A      |
</span></span><span class="line"><span class="cl">|    5 | 101      | 5      | 5      |
</span></span><span class="line"><span class="cl">+------+----------+--------+--------+
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">Mysql 8.0 官方文档</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql- 数据类型 - 日期</title>
      <link>https://ynikl.github.io/blog/mysql-data-type-date/</link>
      <pubDate>Sun, 31 Jul 2022 17:49:46 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/mysql-data-type-date/</guid>
      <description>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期类型 空间 JSON 日期类型 Mysql 支持的数据类型
DATE TIME DATETIME TIMESTAMP YEAR Date 只存储日期数据, 不包含时间. YYYY-MM-DD, 范围是从 &amp;lsquo;1000-01-01&amp;rsquo; to &amp;lsquo;9999-12-31&amp;rsquo;
DateTime 存储日期, 也存储时间 &#39;YYYY-MM-DD hh:mm:ss&#39;
范围是从&#39;1000-01-01 00:00:00&amp;rsquo; to &amp;lsquo;9999-12-31 23:59:59&amp;rsquo;
TIMESTAMP 存储Unix时间戳数据 会受到服务器时区影响&amp;ndash; 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之 时区环境变量设置 范围 &amp;lsquo;1970-01-01 00:00:01&amp;rsquo; UTC to &amp;lsquo;2038-01-19 03:14:07&amp;rsquo; UTC.
相关函数:
FROM_UNIXTIME 把 Unix 时间戳转化成日期 UNIX_TIMESTAMP 把日期转化成 Unix 时间戳 YEAR 显示形式 YYYY, 可选显示位数YYYY(M)
默认4位显示 &amp;lsquo;1991&amp;rsquo; TIME 只有时间部分,没有日期部分 hh:mm:ss, 范围从 &amp;lsquo;-838:59:59&amp;rsquo; 到 &amp;lsquo;838:59:59&amp;rsquo;</description>
      <content:encoded><![CDATA[<h2 id="概览">概览</h2>
<p>Mysql 支持以下数据类型</p>
<ul>
<li>数字类型</li>
<li>串类型(字符和字节)</li>
<li>日期类型</li>
<li>空间</li>
<li>JSON</li>
</ul>
<h2 id="日期类型">日期类型</h2>
<p>Mysql 支持的数据类型</p>
<ul>
<li>DATE</li>
<li>TIME</li>
<li>DATETIME</li>
<li>TIMESTAMP</li>
<li>YEAR</li>
</ul>
<h3 id="date">Date</h3>
<p>只存储日期数据, 不包含时间. <code>YYYY-MM-DD</code>, 范围是从 &lsquo;1000-01-01&rsquo; to &lsquo;9999-12-31&rsquo;</p>
<h3 id="datetime">DateTime</h3>
<p>存储日期, 也存储时间 <code>'YYYY-MM-DD hh:mm:ss'</code></p>
<p>范围是从'1000-01-01 00:00:00&rsquo; to &lsquo;9999-12-31 23:59:59&rsquo;</p>
<h3 id="timestamp">TIMESTAMP</h3>
<ul>
<li>存储Unix时间戳数据</li>
<li>会受到服务器时区影响&ndash; 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_time_zone">时区环境变量设置</a></li>
</ul>
<p>范围 &lsquo;1970-01-01 00:00:01&rsquo; UTC to &lsquo;2038-01-19 03:14:07&rsquo; UTC.</p>
<p>相关函数:</p>
<ul>
<li>FROM_UNIXTIME 把 Unix 时间戳转化成日期</li>
<li>UNIX_TIMESTAMP 把日期转化成 Unix 时间戳</li>
</ul>
<h3 id="year">YEAR</h3>
<p>显示形式 <code>YYYY</code>, 可选显示位数<code>YYYY(M)</code></p>
<ul>
<li>默认4位显示 &lsquo;1991&rsquo;</li>
</ul>
<h3 id="time">TIME</h3>
<p>只有时间部分,没有日期部分 <code>hh:mm:ss</code>, 范围从 &lsquo;-838:59:59&rsquo; 到 &lsquo;838:59:59&rsquo;</p>
<h3 id="自动更新">自动更新</h3>
<p>DateTime 和 Timestamp 在 <strong>Mysql 8.0</strong>, 支持自动初始化和当数据更新时自动更新.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">ts</span><span class="w"> </span><span class="k">TIMESTAMP</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">UPDATE</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">dt</span><span class="w"> </span><span class="n">DATETIME</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">UPDATE</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="存储毫秒级别的时间">存储毫秒级别的时间</h3>
<p>支持存储毫秒级别的时间类型有:</p>
<ul>
<li>TIME</li>
<li>DATETIME</li>
<li>TIMESTAMP</li>
</ul>
<p>声明模式为 <code>type_name(fsp)</code>, fsp 为0-6, 表示小数点后个数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">fractest</span><span class="p">(</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="n">TIME</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="n">DATETIME</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="k">TIMESTAMP</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">VALUES</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="s1">&#39;17:51:04.777&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;2018-09-08 17:51:04.777&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;2018-09-08 17:51:04.777&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="存储空间">存储空间</h3>
<p>| 类型      | 大小    | 其他                 |
| Year      | 1 bytes |                      |
| DATE      | 3 bytes |                      |
| Time      | 3 bytes | 5.6.4 之后支持小数点 |
| Timestamp | 4 bytes | 同上                 |
| DateTime  | 8 bytes | 同上                 |</p>
<p>小数点精度的位数</p>
<p>| 0    | 0 bytes |
| 1,2  | 1 bytes |
| 3,4  | 2 bytes |
| 4,5  | 3 bytes |</p>
<h3 id="使用推荐">使用推荐</h3>
<p><em>高性能 Mysql</em> 里面总结 DateTime 和 Timestamp 的使用选择:</p>
<ul>
<li>非特殊情况, 尽量使用 timestamp, 因为空间效率更高.</li>
<li>Timestamp 不会存储时区, 而 Datetime 会存储时区</li>
<li>Timestamp 做为索引的话会更加轻量</li>
</ul>
<p>Timestamp 和 Int 的使用选择</p>
<ul>
<li>没有必要用 INT 存储, 保存时间戳. 因为没有任何收益.</li>
<li>Timestamp 可以支持数据变更时自动更新.</li>
</ul>
<h3 id="相关的一些函数">相关的一些函数</h3>
<ul>
<li>FROM_UNIXTIME 可以将 Unix 时间戳转化成日期</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">Mysql 8.0 官方文档</a>
<a href="https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html">Mysql date 内部数据结构</a>
[高性能 Mysql]</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>xorm 的 session 和 salve 的区别</title>
      <link>https://ynikl.github.io/posts/xorm-slave-newsseion/</link>
      <pubDate>Fri, 22 Jul 2022 19:08:05 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/xorm-slave-newsseion/</guid>
      <description>简单分析下xorm 里面 session 和 slave 里面 close 的代码
1 xorm.EngineGroup.Slave() Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用）） 如果这时候再调用 close 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。 如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 NewSsession 和 Close, 所以不在需要手动调用close 1 xorm.EngineGroup.NewSsession() 会返回一个xorm.Session对象, 对应我们数据库操作中的&amp;quot;会话事务&amp;quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交) 调用 close, 对清除 session 中未提交的事务和一些缓存的 sql 前置处理语句 对于普通 select 语句调不调用是没什么太大影响 (但是还是建议new之后调用close) </description>
      <content:encoded><![CDATA[<p>简单分析下xorm 里面 session 和 slave 里面 close 的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xorm.EngineGroup.Slave()
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用））</li>
<li>如果这时候再调用 <code>close</code> 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。</li>
<li>如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 <code>NewSsession</code> 和 <code>Close</code>, 所以不在需要手动调用<code>close</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xorm.EngineGroup.NewSsession()
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>会返回一个<code>xorm.Session</code>对象, 对应我们数据库操作中的&quot;会话事务&quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交)</li>
<li>调用 <code>close</code>, 对清除 session 中未提交的事务和一些缓存的 <code>sql</code> 前置处理语句</li>
<li>对于普通 <code>select</code> 语句调不调用是没什么太大影响 (但是还是建议<code>new</code>之后调用<code>close</code>)</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Make 的基本使用</title>
      <link>https://ynikl.github.io/posts/makefile-basic-use/</link>
      <pubDate>Sun, 10 Jul 2022 17:47:42 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/makefile-basic-use/</guid>
      <description>想自己整理一篇基本的 make 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.
阮一峰文章地址
如果不写 c, 主要理解就几个概念就可以使用了
target 可以用来当作想要执行的命令集的名称 .PHONY: 可以用来声明命令集名称 recipes 实际执行的命令集合 介绍一下我自己的应用场景 我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.
case 1: 简化本地编译和测试, 自动做 setup 和 teardown
当我想要尝试一下整个项目是否编译
1 2 3 4 .PHONY: build build: go build . rm -rf [PROJECT NAME] 使用上面的 makefile, 我就只需要 make build, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 build 一下
case 2: git 提交代码自动化操作
当我想要把我代码推送到, 测试分支, 进行集成测试
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .</description>
      <content:encoded><![CDATA[<p>想自己整理一篇基本的 <code>make</code> 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.</p>
<p><a href="https://www.ruanyifeng.com/blog/2015/02/make.html">阮一峰文章地址</a></p>
<p>如果不写 c, 主要理解就几个概念就可以使用了</p>
<ul>
<li>target 可以用来当作想要执行的命令集的名称</li>
<li>.PHONY:  可以用来声明命令集名称</li>
<li>recipes 实际执行的命令集合</li>
</ul>
<h2 id="介绍一下我自己的应用场景">介绍一下我自己的应用场景</h2>
<p>我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.</p>
<p>case 1: 简化本地编译和测试, 自动做 <code>setup</code> 和 <code>teardown</code></p>
<p>当我想要尝试一下整个项目是否编译</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">.</span><span class="nx">PHONY</span><span class="p">:</span> <span class="nx">build</span>
</span></span><span class="line"><span class="cl"><span class="nx">build</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">build</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rm</span> <span class="o">-</span><span class="nx">rf</span> <span class="p">[</span><span class="nx">PROJECT</span> <span class="nx">NAME</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用上面的 <code>makefile</code>, 我就只需要 <code>make build</code>, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 <code>build</code> 一下</p>
<p>case 2: git 提交代码自动化操作</p>
<p>当我想要把我代码推送到, 测试分支, 进行集成测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.PHONY: dev
</span></span><span class="line"><span class="cl">ProjectName=&#34;Your Project Name&#34;
</span></span><span class="line"><span class="cl">TargetBranch=&#34;Your want to merge branch&#34;
</span></span><span class="line"><span class="cl">CurBranch=$(shell git branch --show-current)
</span></span><span class="line"><span class="cl">dev:
</span></span><span class="line"><span class="cl">	go build .
</span></span><span class="line"><span class="cl">	rm -f $(ProjectName)
</span></span><span class="line"><span class="cl">	git add .
</span></span><span class="line"><span class="cl">	git commit -m $(msg)
</span></span><span class="line"><span class="cl">	git push
</span></span><span class="line"><span class="cl">	git checkout ${DevBranch}
</span></span><span class="line"><span class="cl">	git pull --rebase
</span></span><span class="line"><span class="cl">	git merge ${CurBranch} -m &#34;Merge branch &#39;${CurBranch}&#39; into ${DevBranch}&#34;
</span></span><span class="line"><span class="cl">	go build
</span></span><span class="line"><span class="cl">	rm -f $(ProjectName) 
</span></span><span class="line"><span class="cl">	git push
</span></span><span class="line"><span class="cl">	git checkout ${CurBranch}
</span></span></code></pre></td></tr></table>
</div>
</div><p>简化 git 的操作流程, 现在只需要<code>make dev</code>就可以完成, 还可以在合并之前和之后增加测试, 我自己目前知识简单的 <code>build</code> 下而已 QAQ.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>RabbitMQ 基本入门实践</title>
      <link>https://ynikl.github.io/blog/rabbitmq-learning-note/</link>
      <pubDate>Sat, 09 Jul 2022 16:43:26 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/rabbitmq-learning-note/</guid>
      <description>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.
介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件
消息中间件的作用
解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释
Producer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型
fanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:</description>
      <content:encoded><![CDATA[<p>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.</p>
<h2 id="介绍一下-rabbitmq">介绍一下 RabbitMQ</h2>
<p>Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件</p>
<p>消息中间件的作用</p>
<ul>
<li>解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性.</li>
<li>冗余存储: 保存失败的消息</li>
<li>拓展性</li>
<li>削峰</li>
<li>缓冲</li>
</ul>
<h3 id="结构">结构</h3>
<p>涉及的名词简单解释</p>
<ul>
<li>Producer</li>
<li>Consumer</li>
<li>Broker: 服务节点</li>
<li>Queue: 内存存储消息数据的对象</li>
<li>Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据<code>routingkey</code> 和 <code>bindingkey</code> 决定投递到哪个队列
<ul>
<li>RoutingKey: 生产消息提供<code>routingkey</code> 给交换器用于指定要投递的队列</li>
<li>BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来</li>
</ul>
</li>
<li>Connection: 客户端与 Broke 建立的 TCP 连接</li>
<li>Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接</li>
</ul>
<p>交换器的类型</p>
<ul>
<li>fanout : 投递到所有队列</li>
<li>direct: 投递到 <code>routingkey</code>  和 <code>bindingkey</code> 匹配的</li>
<li>topic: direct 的拓展, 支持模糊匹配</li>
<li>headers : 性能差, 少用</li>
</ul>
<p>消息投递流程:</p>
<ol>
<li>生产者连接到 Broker, 开启信道</li>
<li>生产者声明一个交换器</li>
<li>生产者声明一个队列</li>
<li>生产者通过路由键将交换器和队列绑定</li>
<li>生产者发送消息到 Broker</li>
<li>交换器根据接受对路由键匹配队列</li>
<li>投递到对应的消息队列</li>
<li>如果没有匹配的队列, 丢弃或者退回给生产者</li>
</ol>
<p>消费者接受消息流程:</p>
<ol>
<li>建立连接, 开启信道</li>
<li>消费者向 Broker 发起消息请求</li>
<li>Broker 回应并返回消息</li>
<li>消费者发送确认 (ack) 接受到消息</li>
<li>关闭信道</li>
<li>关闭连接</li>
</ol>
<h3 id="amqp">AMQP</h3>
<p>位于应用层的通信协议 ( 在 TCP 之上, 将数据填充到 TCP 中)</p>
<p>几个基础的协议定义的操作</p>
<ul>
<li>Protocal Header 0-9-1 指定协议</li>
<li>Connection.Start</li>
<li>Channel.Open</li>
<li>Basic.Publish 推送消息</li>
<li>Channel.Close</li>
<li>Connection.Close</li>
</ul>
<h2 id="部署">部署</h2>
<p>在你的机子上部署一个玩具吧</p>
<p>采用 docker 部署
<code>docker run -itd --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</code></p>
<p>进入管理页面
访问 http://127.0.0.1:15672/</p>
<p>登入
用户名: guest
密码: guest</p>
<p><a href="https://www.rabbitmq.com/configure.html#supported-environment-variables">更多默认配置</a></p>
<h2 id="管理">管理</h2>
<p>进入交互 shell
<code>docker exec -it rabbitmq bash</code></p>
<p>增加一个用户
<code>rabbitmqctl add_user ian ian1234</code></p>
<p>增加一个 vhost
<code>rabbitmqctl add_vhost playground</code></p>
<p>vhost是什么?
vhost (virtual host), 虚拟主机, 在实例间提供逻辑上的分离 &ndash; 实现数据隔离.
RabbitMQ 默认创建一个名为 &ldquo;/&rdquo; 的 vhost</p>
<p>查看 vhost
<code>rabbitmqctl list_vhosts</code></p>
<p>设置权限
<code>rabbitmqctl set_permissions --vhost playground ian &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></p>
<p><strong>amqp uri规则</strong>
<code>&quot;amqp://userName:password@ipAddress:portNumber/virtualHost&quot;</code>
根据我们上述的新增在用户和vhost, 可以得到uri:
<code>amqp://ian:ian1234@localhost:5672/playground</code>
5672为 rabbitmq的默认终端, 我们的 docker contain 需要把它映射到本机带端口</p>
<h2 id="实现生产者">实现生产者</h2>
<p>go 使用 <code>github.com/rabbitmq/amqp091-go</code> 包</p>
<p>根据上文的消息投递流程实现</p>
<p>连接到 broker</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">connectionUrl</span> <span class="o">:=</span> <span class="s">&#34;amqp://ian:ian1234@localhost:5672/playground&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">amqp</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">connectionUrl</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>打开 channel</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">ch</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Channel</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>声明一个交互器( 该步骤可以省略, 直接使用默认的 <code>direct</code>交换器)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">ExchangeDeclare</span><span class="p">(</span><span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="s">&#34;direct&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>声明一个队列</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">q</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">QueueDeclare</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将 Exchange 绑定到队列上 (如果声明交换器的步骤省略了, 该步骤也可以省略)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">QueueBind</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="s">&#34;hellokey&#34;</span><span class="p">,</span> <span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>发送消息 (如果没有声明交换器, 对应的参数直接传入空字符串<code>&quot;&quot;</code>, 会使用默认的 <code>direct</code> 交换器)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">Publish</span><span class="p">(</span><span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="s">&#34;hellokey&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">amqp</span><span class="p">.</span><span class="nx">Publishing</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ContentType</span><span class="p">:</span> <span class="s">&#34;text/plain&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Body</span><span class="p">:</span>        <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">body</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://github.com/ynikl/rabbitmq-demo/blob/main/cmd/producer/main.go">完整代码地址</a></p>
<p>登录到本地管理页面可以查看类似于下图, 有消息投递</p>
<p><img loading="lazy" src="/rabbitmq-producer-manager-pic-20220704.png" alt="生产消息成功"  />
</p>
<h2 id="实现消费者">实现消费者</h2>
<p>消费者相对于生产者就简单多了.
打开信道直接消费就可以了.</p>
<p>连接, 打开信道</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">connectionUrl</span> <span class="o">:=</span> <span class="s">&#34;amqp://ian:ian1234@localhost:5672/playground&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">amqp</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">connectionUrl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Channel</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>开始消费</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="c1">// msgsCh 是一个消息管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">msgsCh</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">Consume</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="s">&#34;consumer-name&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">msgsCh</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;received a message: &#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Body</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done, msg channel is closed&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/rabbitmq-receive-success-20220709.png" alt="消费成功"  />
</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.rabbitmq.com/tutorials/tutorial-one-go.html">官网 tutorial</a></li>
<li><a href="https://book.douban.com/subject/27591386/">RabbitMQ 实战指南</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Life Is Not Short</title>
      <link>https://ynikl.github.io/posts/life-is-not-short/</link>
      <pubDate>Fri, 01 Jul 2022 08:55:44 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/life-is-not-short/</guid>
      <description>The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.
life if not short</description>
      <content:encoded><![CDATA[<blockquote>
<p>The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.</p>
</blockquote>
<p><a href="https://dkb.show/post/life-is-not-short">life if not short</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>我理解的微服务 -- 读《微服务设计模式》总结</title>
      <link>https://ynikl.github.io/books/miscroservices-patterns/</link>
      <pubDate>Sun, 19 Jun 2022 22:20:56 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/miscroservices-patterns/</guid>
      <description>微服务是针对公司某一复杂业务程序实现的设计模式, 与巨石架构(Monolith)是相对的.
微服务对应的应该是公司业务能力层级上的拆分与设计, 为了减少业务之间的耦合而导致相互拖累, 在对外业务能力不变的情况下, 在应用内部将能力拆分成一些微小服务. 也可以理解为是对巨石架构进行&amp;quot;解耦&amp;quot;.
举个例子: 原先公司做的是一个外卖系统, 这个系统中可能包含了客户下单, 商家接单, 骑手配送等功能. 但是全部都打包在一个程序中. 发版时, 可能客户下单功能修改了功能, 导致商家没办法接单了. 或者商家接单功能实现的有问题, 导致整个应用程序挂掉, 现在用户下不了单, 骑手也没法接单, 整个公司的业务就瘫痪了. 然后, 在客户下单-商家接单-骑手配送这个大业务流程不变的情况下, 我们在外卖系统内部, 分成了多个服务, 各个服务之间使用 API 松耦合通信, 隔离影响. 比如, 客户下单服务, 专门处理客户下单这一业务, 并将生成的订单推送到消息代理 (如:kafka) 或直接推送给其他服务等, 它只要能保证完成它的职责即可. 后者, 就可以称之为 &amp;ldquo;微服务架构&amp;rdquo;. 当然, 这只是一个例子, 实际情况会更加复杂.
在&amp;laquo;微服务设计模式&amp;raquo; 中对微服务的定义:
将应用程序构建为松耦合, 可独立部署的一组服务
书中也对&amp;quot;微&amp;quot;的大小给了定义:
大小的定义为能够由小团队开发服务
不用刻意地去追求服务的大小. 微服务的落地, 往往就会伴随着, 组织结构和开发的流程的改变, 由不同的 小团队 独立负某一服务.
像我们现在如果提到微服务, 就经常也会提到一些微服务框架 go-zero, go-micro 或者基础设施 docker, k8s 或者工具 gRPC, prometheus 之类的.
像这种框架和组件之类的只是一种技术工具. 他们并不能定义微服务, 他们可能只是为了克服微服务架构设计带来的某一些缺陷, 或者与微服务结合可以发挥出更大的价值.</description>
      <content:encoded><![CDATA[<p>微服务是针对公司某一复杂业务程序实现的设计模式, 与巨石架构(Monolith)是相对的.</p>
<p>微服务对应的应该是公司业务能力层级上的拆分与设计, 为了减少业务之间的耦合而导致相互拖累, 在对外业务能力不变的情况下, 在应用内部将能力拆分成一些微小服务. 也可以理解为是对巨石架构进行&quot;解耦&quot;.</p>
<p>举个例子: 原先公司做的是一个外卖系统, 这个系统中可能包含了客户下单, 商家接单, 骑手配送等功能. 但是全部都打包在一个程序中. 发版时, 可能客户下单功能修改了功能, 导致商家没办法接单了. 或者商家接单功能实现的有问题, 导致整个应用程序挂掉, 现在用户下不了单, 骑手也没法接单, 整个公司的业务就瘫痪了. 然后, 在客户下单-商家接单-骑手配送这个大业务流程不变的情况下, 我们在外卖系统内部, 分成了多个服务, 各个服务之间使用 API 松耦合通信, 隔离影响. 比如, 客户下单服务, 专门处理客户下单这一业务, 并将生成的订单推送到消息代理 (如:kafka) 或直接推送给其他服务等, 它只要能保证完成它的职责即可. 后者, 就可以称之为 &ldquo;微服务架构&rdquo;. 当然, 这只是一个例子, 实际情况会更加复杂.</p>
<p>在&laquo;微服务设计模式&raquo; 中对微服务的定义:</p>
<blockquote>
<p>将应用程序构建为松耦合, 可独立部署的一组服务</p>
</blockquote>
<p>书中也对&quot;微&quot;的大小给了定义:</p>
<blockquote>
<p>大小的定义为能够由小团队开发服务</p>
</blockquote>
<p>不用刻意地去追求服务的大小. 微服务的落地, 往往就会伴随着, 组织结构和开发的流程的改变, 由不同的 <strong>小团队</strong> 独立负某一服务.</p>
<p>像我们现在如果提到微服务, 就经常也会提到一些微服务框架 go-zero, go-micro 或者基础设施 docker, k8s 或者工具 gRPC, prometheus 之类的.</p>
<p>像这种框架和组件之类的只是一种技术工具. 他们并不能定义微服务, 他们可能只是为了克服微服务架构设计带来的某一些缺陷, 或者与微服务结合可以发挥出更大的价值.</p>
<p>举个极端的例子: 在你后端业务完全不划分的情况下, 你甚至可以在 go-zero 的框架基础上, 将你公司所有的业务打包进一个应用程序, 用docker打包, 并部署在k8s环境中, 再通过 gRPC 与前端通信. 你用到了很多著名的名词技术, 但是你实现出来应用的是巨石架构还是微服务架构呢?</p>
<h2 id="参考">参考</h2>
<p><a href="https://book.douban.com/subject/33425123">微服务设计模式</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>什么是 &#34;胶水代码&#34;</title>
      <link>https://ynikl.github.io/posts/what-is-glue-code/</link>
      <pubDate>Sat, 18 Jun 2022 20:04:38 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/what-is-glue-code/</guid>
      <description>胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 连接 两个 不兼容 的组件, 或是两个不兼容的服务.
胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.
参考 Quora 回答 wiki</description>
      <content:encoded><![CDATA[<p>胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 <strong>连接</strong> 两个 <strong>不兼容</strong> 的组件, 或是两个不兼容的服务.</p>
<p>胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.</p>
<h2 id="参考">参考</h2>
<p><a href="https://www.quora.com/What-is-glue-code">Quora 回答</a>
<a href="https://en.wikipedia.org/wiki/Glue_code">wiki</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go中slice[i:j:k]第三个参数是做什么的</title>
      <link>https://ynikl.github.io/blog/golang-reslicing-slice/</link>
      <pubDate>Thu, 09 Jun 2022 23:52:30 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-reslicing-slice/</guid>
      <description>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.
简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:
1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:
array 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址
简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, &amp;ldquo;左闭右开原则&amp;rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即&amp;quot;cap(a) - low&amp;quot; low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt.</description>
      <content:encoded><![CDATA[<p>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.</p>
<h2 id="简单介绍-slice-的数据结构">简单介绍 slice 的数据结构</h2>
<p>首先, 介绍一下 golang 中切片的结构体:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type slice struct {
</span></span><span class="line"><span class="cl">	array unsafe.Pointer
</span></span><span class="line"><span class="cl">	len   int
</span></span><span class="line"><span class="cl">	cap   int
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>有三个字段:</p>
<ul>
<li>array 是切片所指向的底层数组数据</li>
<li>len 就是切片的长度</li>
<li>cap 即容量, 很明显</li>
</ul>
<p><a href="https://cs.opensource.google/go/go/+/master:src/runtime/slice.go;l=15?q=slice&amp;ss=go%2Fgo">源码地址</a></p>
<h2 id="简单版重切片-alowhigh">简单版重切片 <code>a[low:high]</code></h2>
<ul>
<li>接受切片中的开始下标和结束下标, &ldquo;左闭右开原则&rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值</li>
<li>新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即&quot;cap(a) - low&quot;</li>
<li>low 参数可以省略, 默认从 0 下标开始</li>
<li>high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [10]int{}
</span></span><span class="line"><span class="cl">oldSlice := a[:5]
</span></span><span class="line"><span class="cl">newSlice := a[2:4]
</span></span><span class="line"><span class="cl">fmt.Printf(&#34;b: len %d, cap %d, c: len %d, c:cap %d&#34;, len(b), cap(b), len(c), cap(c))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">输出:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b: len 5, cap 10, c: len 2, c:cap 8
</span></span></code></pre></td></tr></table>
</div>
</div><p>底层分配情况如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">底层数组       : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">旧切片容量: 10 : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">旧切片长度: 5  : [0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">新切片容量: 8  :     [0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">新切片长度: 2  :     [0 0]
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="完整版重切片-alowhighmax">完整版重切片 <code>a[low:high:max]</code></h2>
<p>完整版是为了补充简单版, 新切片会默认拥有从开始下标后的所有底层数组容量. 即新数组拥有修改全部数据底层能力 (<strong>重切片出来的不同切片, 在没有 append 操作触发重新分配底层数组的前提下, 指向的都是同一个数据, 修改数据相互可见</strong>)</p>
<ul>
<li>增加了 max 参数, 表示新切片可以获取到最大的原切片的容量大小.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [10]int{}
</span></span><span class="line"><span class="cl">oldSlice := a[:5]
</span></span><span class="line"><span class="cl">newSlice := a[2:4:6]
</span></span><span class="line"><span class="cl">fmt.Printf(&#34;b: len %d, cap %d, c: len %d, c:cap %d&#34;, len(b), cap(b), len(c), cap(c))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">输出:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b: len 5, cap 10, c: len 2, c:cap 4
</span></span></code></pre></td></tr></table>
</div>
</div><p>底层分配情况如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">底层数组       : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">旧切片容量:10  : [0 0 0 0 0 0 0 0 0 0] 
</span></span><span class="line"><span class="cl">旧切片长度:5   : [0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">新切片容量:4   :     [0 0 0 0] 
</span></span><span class="line"><span class="cl">新切片长度:2   :     [0 0]
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是, 如果 max 要求获取的容量大于旧数据容量. 可想而知, 那一定会 <code>panic</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[:</span><span class="mi">4</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="err">输出</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">panic</span><span class="p">:</span> <span class="nx">runtime</span> <span class="kt">error</span><span class="p">:</span> <span class="nx">slice</span> <span class="nx">bounds</span> <span class="nx">out</span> <span class="nx">of</span> <span class="k">range</span> <span class="p">[::</span><span class="mi">5</span><span class="p">]</span> <span class="nx">with</span> <span class="nx">capacity</span> <span class="mi">4</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以参数要求: <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/27938177/golang-slice-slicing-a-slice-with-sliceabc">stack overflow 问题1 简单版</a></li>
<li><a href="https://stackoverflow.com/questions/12768744/re-slicing-slices-in-golang/18911267#18911267">stack overflow 问题2 详细版</a></li>
<li><a href="https://go.dev/ref/spec#Slice_expressions">golang 官方文档</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>我们为何选择 XXX 技术方案</title>
      <link>https://ynikl.github.io/posts/thinking-choosing-tech/</link>
      <pubDate>Wed, 08 Jun 2022 20:15:26 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/thinking-choosing-tech/</guid>
      <description>一个完善的方案的需要考虑的三个方面
当前需求 理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。
结果上下文 好处：当前方案的好处，解决了什么 弊端: 什么是它不能解决的 问题：引入什么新的问题 与其他方案的关系 前导：当前方案是怎么演变出来。 后续：当前方案会引入什么新问题，有什么后续的解决方案 替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案 参考《微服务设计模式》的1.6.2&amp;quot;模式和模式语言&amp;quot;, 相对减少了模式关系中的泛化和特化。</description>
      <content:encoded><![CDATA[<p>一个完善的方案的需要考虑的三个方面</p>
<ol>
<li>当前需求</li>
</ol>
<p>理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。</p>
<ol start="2">
<li>结果上下文</li>
</ol>
<ul>
<li>好处：当前方案的好处，解决了什么</li>
<li>弊端: 什么是它不能解决的</li>
<li>问题：引入什么新的问题</li>
</ul>
<ol start="3">
<li>与其他方案的关系</li>
</ol>
<ul>
<li>前导：当前方案是怎么演变出来。</li>
<li>后续：当前方案会引入什么新问题，有什么后续的解决方案</li>
<li>替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案</li>
</ul>
<p>参考《微服务设计模式》的1.6.2&quot;模式和模式语言&quot;, 相对减少了模式关系中的泛化和特化。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>设计模式 -- 策略模式</title>
      <link>https://ynikl.github.io/posts/strategy-pattern/</link>
      <pubDate>Wed, 08 Jun 2022 19:50:42 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/strategy-pattern/</guid>
      <description>场景 在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.
比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.
分析 优点:
将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象 在不同策略之间划清界限 增加单独策略的可测试性 缺点:
后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动 会带来的问题:
可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力 总结:
在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).
实现流程 主要的思想, 我觉得还是 面向接口编程
分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(interface) 将算法或策略剥离成独立的策略对象, 并实现上述抽象接口 主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略&amp;quot;插入&amp;quot;(plugin)流程, 调用, 获取结果, ok. 参考 refactoringguru - strategy </description>
      <content:encoded><![CDATA[<h2 id="场景">场景</h2>
<p>在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.</p>
<p>比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.</p>
<h2 id="分析">分析</h2>
<p>优点:</p>
<ul>
<li>将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象</li>
<li>在不同策略之间划清界限</li>
<li>增加单独策略的可测试性</li>
</ul>
<p>缺点:</p>
<ul>
<li>后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动</li>
</ul>
<p>会带来的问题:</p>
<ul>
<li>可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力</li>
</ul>
<p>总结:</p>
<p>在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).</p>
<h2 id="实现流程">实现流程</h2>
<p>主要的思想, 我觉得还是 <strong>面向接口编程</strong></p>
<ol>
<li>分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(<strong>interface</strong>)</li>
<li>将算法或策略剥离成独立的策略对象, 并实现上述抽象接口</li>
<li>主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略&quot;插入&quot;(plugin)流程, 调用, 获取结果, ok.</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/strategy">refactoringguru - strategy</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Linked List</title>
      <link>https://ynikl.github.io/dsa/linked-list/</link>
      <pubDate>Mon, 06 Jun 2022 19:18:31 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/dsa/linked-list/</guid>
      <description>链表的定义： wiki 百科给出定义:
In computer science, a linked list is a linear collection of data elemetns whose order is not given by their physical placement in memory. Instead, each element points to the next.
翻译一下：
一个线性表 每个元素会指向下一个元素的位置 链表的优缺点 优点:
不需要提前分配内存 在查找到元素位置的提前下，插入和删除动作是一个常量，即 O(1) 没有容量上限，可以自由扩容 缺点:
查询某个元素，需要从头开始遍历，即 O(n) 实现代码
单向链表 最普通的链表
双向链表 循环链表 </description>
      <content:encoded><![CDATA[<h2 id="链表的定义">链表的定义：</h2>
<p>wiki 百科给出定义:</p>
<blockquote>
<p>In computer science, a linked list is a linear collection of data elemetns whose order is not given by their physical placement in memory. Instead, each element points to the next.</p>
</blockquote>
<p>翻译一下：</p>
<ul>
<li>一个线性表</li>
<li>每个元素会指向下一个元素的位置</li>
</ul>
<h2 id="链表的优缺点">链表的优缺点</h2>
<p>优点:</p>
<ul>
<li>不需要提前分配内存</li>
<li>在查找到元素位置的提前下，插入和删除动作是一个常量，即 O(1)</li>
<li>没有容量上限，可以自由扩容</li>
</ul>
<p>缺点:</p>
<ul>
<li>查询某个元素，需要从头开始遍历，即 O(n)</li>
</ul>
<p><a href="https://github.com/ynikl/dsa/blob/main/linked-list.go">实现代码</a></p>
<h2 id="单向链表">单向链表</h2>
<p>最普通的链表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"></code></pre></td></tr></table>
</div>
</div><h2 id="双向链表">双向链表</h2>
<h2 id="循环链表">循环链表</h2>
]]></content:encoded>
    </item>
    
    <item>
      <title>基础数据结构列表</title>
      <link>https://ynikl.github.io/dsa/datastructures-list/</link>
      <pubDate>Sun, 05 Jun 2022 21:40:30 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/dsa/datastructures-list/</guid>
      <description>github code
非科班出身的我，有好几次尝试过跟着国外大学的课程重新学习计算机基础， 但是每次都是半途放弃了，这次尝试根据数据结构主题进行学习。
主流的数据结构类型
Linked List（链表） List （线性表） 2D Arrays Strings（串） Stack （栈） Queue（队列） Hash Table（哈希表） Heap （堆） Tree （树） Graphs（图） Binary Tree Binary Search Tree </description>
      <content:encoded><![CDATA[<p><a href="https://github.com/ynikl/dsa">github code</a></p>
<p>非科班出身的我，有好几次尝试过跟着国外大学的课程重新学习计算机基础，
但是每次都是半途放弃了，这次尝试根据数据结构主题进行学习。</p>
<p><strong>主流的数据结构类型</strong></p>
<ul>
<li><a href="">Linked List（链表）</a></li>
<li>List （线性表）</li>
<li>2D Arrays</li>
<li>Strings（串）</li>
<li>Stack （栈）</li>
<li>Queue（队列）</li>
<li>Hash Table（哈希表）</li>
<li>Heap （堆）</li>
<li>Tree （树）</li>
<li>Graphs（图）</li>
<li>Binary Tree</li>
<li>Binary Search Tree</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>计算机中的：大端和小端</title>
      <link>https://ynikl.github.io/posts/endianness/</link>
      <pubDate>Sat, 04 Jun 2022 00:19:23 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/endianness/</guid>
      <description>大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”
大端的优势是高位计算，和可读性 小端的优势的低位运算 各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。
以上是阅读阮一峰的博文-字节序探析：大端与小端的比较的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。
参考连接 阮一峰的博文-字节序探析：大端与小端的比较 </description>
      <content:encoded><![CDATA[<p>大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”</p>
<ul>
<li>大端的优势是高位计算，和可读性</li>
<li>小端的优势的低位运算</li>
</ul>
<p>各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。</p>
<p>以上是阅读<a href="https://www.ruanyinfeng.com/blog/2022/06/endianness-analysis.html">阮一峰的博文-字节序探析：大端与小端的比较</a>的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。</p>
<h2 id="参考连接">参考连接</h2>
<ul>
<li><a href="https://www.ruanyinfeng.com/blog/2022/06/endianness-analysis.html">阮一峰的博文-字节序探析：大端与小端的比较</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>小窥 Go 中的 Modules</title>
      <link>https://ynikl.github.io/blog/go-modules/</link>
      <pubDate>Fri, 03 Jun 2022 18:16:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/go-modules/</guid>
      <description>是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =&amp;gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 &amp;gt; cat go.</description>
      <content:encoded><![CDATA[<h2 id="是什么">是什么</h2>
<p>Modules （下文称为模块）是 Go 语言设计用来管理依赖包。</p>
<p>在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。</p>
<p>模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在<code>go.mod</code>文件中。</p>
<h3 id="gomod-文件">go.mod 文件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-v" data-lang="v"><span class="line"><span class="cl"><span class="kn">module</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">my</span><span class="o">/</span><span class="nv">thing</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">go</span> <span class="mf">1.12</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">require</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">other</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.0.2</span>
</span></span><span class="line"><span class="cl"><span class="nv">require</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">new</span><span class="o">/</span><span class="nv">thing</span><span class="o">/</span><span class="nv">v2</span> <span class="nv">v2</span><span class="mf">.3.4</span>
</span></span><span class="line"><span class="cl"><span class="nv">exclude</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">old</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.2.3</span>
</span></span><span class="line"><span class="cl"><span class="nv">replace</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">bad</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.4.5</span> <span class="o">=</span><span class="p">&gt;</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">good</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.4.5</span>
</span></span><span class="line"><span class="cl"><span class="nv">retract</span> <span class="p">[</span><span class="na">v1</span><span class="err">.9.0,</span> <span class="na">v1</span><span class="err">.9.5</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>文件中各行意思</p>
<ul>
<li>module 当前自己模块的名的完整路径</li>
<li>go 版本号</li>
<li>require 需要依赖的目标模块以及最小的版本号</li>
<li>exclude 排除目标模块的特定版本</li>
<li>replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块</li>
<li>retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况</li>
</ul>
<p><code>go.mod</code> 可以通过相关命令修改，也可以直接修改文件数据</p>
<h3 id="gosum-文件">go.sum 文件</h3>
<p>与<code>go.mod</code>经常在一起的会是一个<code>go.sum</code>文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; cat go.sum
</span></span><span class="line"><span class="cl">example.com/mod v1.0.0 h1:6Cz1EhbAk54HWaw6fhCpSPxWGjIMLuF9MlO4Ou568sQ=
</span></span><span class="line"><span class="cl">example.com/mod v1.0.0/go.mod h1:mgm3p5SY7FVOgVLVSXIYK9qk0umwLQLOG06xLpFUeTI=
</span></span></code></pre></td></tr></table>
</div>
</div><p>文件中以：模块路径 + 版本号 + hash算法名 + hash值 的组合写入</p>
<ul>
<li><code>example.com/mod</code> 是模块路径名</li>
<li>v1.0.0 是版本号，在第二行有是以<code>/go.mod</code>结尾，代表该 hash 值是对依赖模块本身的<code>go.mod</code>文件的 hash 值</li>
<li>h1: 代表使用的 hash 算法，代表 SHA-256</li>
<li>哈希值，没什么好说的了</li>
</ul>
<h3 id="module-cache">Module cache</h3>
<p>本地的目录，用户存放下载下来的的模块文件。</p>
<p>默认路径是在<code>$GOPAth/pkg/mod</code></p>
<p><a href="https://go.dev/ref/mod#module-cache">Module cache 文件夹详细说明</a></p>
<h3 id="语义化版本">语义化版本</h3>
<p>go 采用语义化版本 v1.18.1</p>
<p>一个模块的版本是不变的 —— 只要拉过一次模块，该模块就会存在缓存在<a href="https://proxy.golang.org/">Go 官方的模块服务</a>中，以后拉取改模块就会从官方的模块服务拉取，且该动作不可逆。</p>
<p>版本号 = &ldquo;v&rdquo; + 主版本号 + 小版本号 + 补丁号</p>
<ul>
<li>主版本号的增加后，小版本号和补丁号要重新置零。主版本号增加，代表该版本出现不向后兼容的改动。比如移除旧的包</li>
<li>小版本号增加后，补丁号重新置零。表示版本改动公共接口但是向后兼容的，比如增加一个函数</li>
<li>补丁号增加，表示该版本对公开接口没有改动。比如修改bug</li>
</ul>
<p>版本的后面可能还会增加一些提前发布的标识，比如 v1.18.1-beta v1.18.1-pre</p>
<p>当 go 的 模块没有声明发布版本的时候(比如拉取某分支做为模块)，go 就会自己生成 <a href="https://go.dev/ref/mod#pseudo-versions">伪版本</a>, 可以仅作了解。</p>
<p><strong>如果使用模块的版本号大于等于v2的时候，需要在引入包的后缀加上<code>/v2</code></strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import &#34;github.com/urfave/cli/v2&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="怎么用">怎么用</h2>
<h3 id="开启模块功能">开启模块功能</h3>
<p>模块功能的开启, 配置在环境变量<code>GO111MODULE</code></p>
<ul>
<li>=off, 忽略<code>GOPATH</code>路径下的<code>go.mod</code>文件，直接引用<code>GOPATH/src</code>中的包文件</li>
<li>=on，启用模块功能</li>
<li>=auto, 如果项目有<code>go.mod</code>文件启用，没有则是用<code>GOPATH</code>模式</li>
</ul>
<h3 id="常用命令快览">常用命令快览</h3>
<p><strong>go mod</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod init example.com/example/m1
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化当前文件夹，让其成为一个 module</p>
<p><strong>go get</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get -d example.com/example/m1@v1.2.3
</span></span></code></pre></td></tr></table>
</div>
</div><p>主要用法:修改当前项目的<code>go.mod</code>，引入新的依赖项目。</p>
<p><code>-d</code> 的标志，表示获取目标包之后，不进行本地编译或安装。Go 1.18 之后的默认行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get -d -u example.com/example/m1
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以用来升级依赖模块的版本，升级到最新版本。如果目标模块的新版的所依赖的其他模块也可能会一并升级。也可以指定版本<code>-u=patch</code></p>
<p>修改制定依赖版本的操作也可以通过制定后缀版本号实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get example.com/example/m1@v2.3.1
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>go mod edit</strong></p>
<p>通过指令修改<code>go.mod</code>文件，与直接修改<code>go.mod</code>效果一致</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod edit -replace example.com/a@v1.0.0=./a
</span></span></code></pre></td></tr></table>
</div>
</div><p>将某个模块引用指向本地。可以用来解决引用正在开发中，还没有发布过的模块</p>
<p><strong>go mod tidy</strong></p>
<p>根据项目的源码引用整理<code>go.mod</code>中的引用情况。添加缺少的依赖，或者移除冗余的依赖。</p>
<p><strong>go mod vendor</strong></p>
<p>将依赖一并放在自己项目的中，可以省去自己拉取依赖的很多麻烦，提高可用性。go 项目的根目录中的 vendor 文件夹就是用来干这个事的</p>
<p>将项目依赖移入<code>vendor</code>文件中，当存在了vendor文件夹，项目会使用vendor中的依赖。大于 1.14 版本需要指定参数<code>-mod=vendor</code>才会启用</p>
<p>本地修改之后模块版本之后需要，重新使用<code>go mod vendor</code>将新的依赖模块同步入<code>vendor</code>中。</p>
<p><strong>go mod verify</strong></p>
<p>用于检测模块再被下载之后入，模块中的代码是否有被修改过。</p>
<p>对源码文件的 hash，与当前文件的<code>go.sum</code>中的 hash 对比校验是否有被修改过。
如果<code>go.sum</code>中没有该模块的hash值，就会从<a href="https://sum.golang.org">checksum database</a> 中获取目标 hash 值。（除非设置了<code>GOPRIVATE</code>或者<code>GONOSUMDB</code>)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">❯ go mod verify
</span></span><span class="line"><span class="cl">github.com/ynikl/playmod v1.0.0: dir has been modified (/Users/ian/go/pkg/mod/github.com/ynikl/playmod@v1.0.0)
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述例子，源文件被我手动强制修改过，就会报错</p>
<p><strong>go mod why</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod why example.com/mod
</span></span></code></pre></td></tr></table>
</div>
</div><p>用于解释当前项目为什么会依赖某一个模块，输出项目对目标模块的依赖树图</p>
<p><strong>go list -m all</strong></p>
<p>可以用于输出当前项目依赖的所有模块</p>
<h3 id="mvs">MVS</h3>
<p><em>Minimal version selection</em>（MVS), 当引入的不同模块，又存在依赖与相同模块的（相同大版本，不同版本小版本）的时候。</p>
<p>在使用模块相关命令的时候，会选择所依赖的不同版本的中，构建项目所需要从最小版本。</p>
<p><img loading="lazy" src="mvs.png" alt="图片来源于官网"  />
</p>
<p>A.12 与 B1.2 分别需要 C1.3 和 C1.4 为了是项目能正常进行，需要使用 C1.4 版本</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://go.dev/ref/mod">官网Go Modules参考</a></li>
<li><a href="https://research.swtch.com/vgo-mvs">Minimal Version Seletion</a></li>
<li><a href="https://go.dev/blog/modules2019">官方介绍 Modules 博文</a></li>
<li><a href="https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#checksum-database">提议</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql 不支持事务嵌套</title>
      <link>https://ynikl.github.io/posts/mysql-nested-transactions/</link>
      <pubDate>Thu, 02 Jun 2022 16:16:58 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/mysql-nested-transactions/</guid>
      <description>mysql 在事务中再开启事务，前一个事务会被自动提交
stackoverflow</description>
      <content:encoded><![CDATA[<p>mysql 在事务中再开启事务，前一个事务会被自动提交</p>
<p><a href="https://stackoverflow.com/questions/1306869/are-nested-transactions-allowed-in-mysql">stackoverflow</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>并发与并行的区别</title>
      <link>https://ynikl.github.io/posts/concurrency-and-parallelism/</link>
      <pubDate>Tue, 31 May 2022 22:36:34 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/concurrency-and-parallelism/</guid>
      <description>举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。
并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构
并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。
Concurrency is not Parallelism by Rob Pike</description>
      <content:encoded><![CDATA[<p>举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。</p>
<p>并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构</p>
<p>并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。</p>
<p><a href="https://www.youtube.com/watch?v=oV9rvDllKEg&amp;list=WL&amp;index=5&amp;t=9s">Concurrency is not Parallelism by Rob Pike</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何做决定——遗憾最小化</title>
      <link>https://ynikl.github.io/posts/how-make-decisions/</link>
      <pubDate>Mon, 30 May 2022 19:17:51 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/how-make-decisions/</guid>
      <description>读Randy&amp;rsquo;s的博客遗憾最小化框架有感
在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定
做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾
Jeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。
Bezos的视频地址 Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁
Ask yourself: in 10 years from now, will you be proud of having done this? &amp;hellip; Do things that your future self will be proud, is my motto for the time being.</description>
      <content:encoded><![CDATA[<p>读Randy&rsquo;s的博客<a href="https://lutaonan.com/blog/regret-minimization-framework/">遗憾最小化框架</a>有感</p>
<p><em>在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定</em></p>
<p><strong>做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾</strong></p>
<blockquote>
<p>Jeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。</p>
</blockquote>
<p><a href="https://www.youtube.com/watch?v=jwG_qR6XmDQ&amp;ab_channel=MickyThompson">Bezos的视频地址</a>
Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁</p>
<blockquote>
<p>Ask yourself: in 10 years from now, will you be proud of having done this? &hellip; Do things that your future self will be proud, is my motto for the time being.</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go-互斥锁的实现</title>
      <link>https://ynikl.github.io/blog/golang-sync_mutex/</link>
      <pubDate>Sun, 29 May 2022 20:52:35 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-sync_mutex/</guid>
      <description>Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法
Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。
Mutex 实现了一个 sync.Locker 接口, 该接口只有两个方法
Lock Unlock Mutex 锁有几种状态
mutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量
mutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态</description>
      <content:encoded><![CDATA[<h2 id="mutex-数据结构">Mutex 数据结构</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">state</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sema</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Mutex 使用过之后是不可被拷贝的</li>
<li>state 等于 0 值的时候才是无锁的状态</li>
<li>sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。</li>
</ul>
<p>Mutex 对象总共有三个公开方法</p>
<ul>
<li>Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞</li>
<li>TryLock</li>
<li>Unlock 解除互斥锁， <strong>解锁未锁定的互斥锁会发生panic</strong></li>
</ul>
<p>Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。</p>
<p>Mutex 实现了一个 <code>sync.Locker</code> 接口, 该接口只有两个方法</p>
<ul>
<li>Lock</li>
<li>Unlock</li>
</ul>
<p>Mutex 锁有几种状态</p>
<ul>
<li>mutexLocked = 1 已经锁定</li>
<li>mutexWoken = 2  表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量</li>
<li>mutexStarving = 4 当前锁已经进入了饥饿状态</li>
</ul>
<p>其他常量</p>
<ul>
<li>mutexWaiterShift = 3 统计的等待在<code>Mutex.state</code>字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving）</li>
<li>starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms</li>
</ul>
<h2 id="mutex-锁的竞争方式">Mutex 锁的竞争方式</h2>
<p>Mutex 锁有两种状态</p>
<ul>
<li>正常模式 normal</li>
<li>饥饿模式 starvation</li>
</ul>
<p>正常模式下，等待获取的锁的协程遵循先进先出的原则。</p>
<p>但是，当释放锁的时候如果有新协程进入获取锁代码的时候。因为新入协程本身已经运行在CPU上了，所以有抢占锁的优势。由于阻塞在等待队列上的协程，竞争不过新入协程。当等待时间操作 1ms，就会触发饥饿模式。</p>
<p>饥饿模式，进行互斥锁解锁的协程直接的将锁的所有权直接已经给等待队列的第一个协程。新进协程被禁止抢占互斥锁。</p>
<p>在转移所有权的时候，如果满足一下任意条件，则进入正常模式：</p>
<ul>
<li>锁的等待者只剩最后一个</li>
<li>等待时间小于1ms</li>
</ul>
<p>正常模式有利于更好的性能，饥饿模式则避免出现“饿死”情况。</p>
<h2 id="mutex-的方法详解">Mutex 的方法详解</h2>
<h3 id="lock">Lock</h3>
<p>第一步，通过调用 atomic 的 CAS 操作，尝试加锁，如果成功加锁直接返回</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked)
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果第一步失败，则代表该锁已经被加过锁，锁定了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Mutex) lockSlow() {
</span></span><span class="line"><span class="cl">	// 当前协程的变量, 可以用于表示当前协程的状态
</span></span><span class="line"><span class="cl">	// 用于统计锁的等待时长，是否进入饥饿模式
</span></span><span class="line"><span class="cl">	var waitStartTime int64
</span></span><span class="line"><span class="cl">	starving := false // 当前协程是否处于饥饿
</span></span><span class="line"><span class="cl">	awoke := false // 是否处于唤醒
</span></span><span class="line"><span class="cl">	iter := 0 // 统计自旋次数
</span></span><span class="line"><span class="cl">	old := m.state
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		// 进入自旋的状态条件， **已经锁定** 且非饥饿状态。
</span></span><span class="line"><span class="cl">		if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
</span></span><span class="line"><span class="cl">			// 如果锁的状态 woken 字段未被标记， 将自身标记位唤醒，且将 Mutex 的 woken 位标记位1
</span></span><span class="line"><span class="cl">			// 当协程自己进入获取锁的第一候选人
</span></span><span class="line"><span class="cl">			if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
</span></span><span class="line"><span class="cl">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
</span></span><span class="line"><span class="cl">				awoke = true
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			runtime_doSpin()
</span></span><span class="line"><span class="cl">			// 控制自旋次数，大于4次之后不进入自旋状态
</span></span><span class="line"><span class="cl">			iter++
</span></span><span class="line"><span class="cl">			// 获取最新的状态
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">			continue
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 有可能，自旋自后已经解锁或者只是单纯不能自旋限制了。下面尝试通过 CAS 竞争锁。
</span></span><span class="line"><span class="cl">		// 新值用于设置新的状态
</span></span><span class="line"><span class="cl">		new := old
</span></span><span class="line"><span class="cl">		// 非饥饿状态才设置锁定
</span></span><span class="line"><span class="cl">		if old&amp;mutexStarving == 0 {
</span></span><span class="line"><span class="cl">			new |= mutexLocked
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if old&amp;(mutexLocked|mutexStarving) != 0 {
</span></span><span class="line"><span class="cl">			// 等待者加1
</span></span><span class="line"><span class="cl">			new += 1 &lt;&lt; mutexWaiterShift
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 当前协程是饥饿状态，尝试标记锁的新状态位饥饿状态。
</span></span><span class="line"><span class="cl">		if starving &amp;&amp; old&amp;mutexLocked != 0 {
</span></span><span class="line"><span class="cl">			new |= mutexStarving
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if awoke {
</span></span><span class="line"><span class="cl">			// The goroutine has been woken from sleep,
</span></span><span class="line"><span class="cl">			// so we need to reset the flag in either case.
</span></span><span class="line"><span class="cl">			if new&amp;mutexWoken == 0 {
</span></span><span class="line"><span class="cl">				// Mutex 的唤醒位被抢走，出现不一致。协程变量的唤醒位应该与 Mutex 的唤醒位一致
</span></span><span class="line"><span class="cl">				throw(&#34;sync: inconsistent mutex state&#34;)
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// 标志 锁的唤醒位为0
</span></span><span class="line"><span class="cl">			new &amp;^= mutexWoken
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// CAS 尝试, Mutex 状态没有被变更
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
</span></span><span class="line"><span class="cl">			// 非饥饿状态下，CAS 成功新的 new 字段中会有 mutexLocked 标记（在new下的第一个if）。当前协程获取到了互斥锁,
</span></span><span class="line"><span class="cl">			if old&amp;(mutexLocked|mutexStarving) == 0 {
</span></span><span class="line"><span class="cl">				break // locked the mutex with CAS
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// queueLifo 表示该协程是否为第一次获取锁。如果中间被唤醒过，这放在等待队列头部
</span></span><span class="line"><span class="cl">			queueLifo := waitStartTime != 0
</span></span><span class="line"><span class="cl">			if waitStartTime == 0 {
</span></span><span class="line"><span class="cl">				waitStartTime = runtime_nanotime()
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// 通过信号量，进入阻塞 
</span></span><span class="line"><span class="cl">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)
</span></span><span class="line"><span class="cl">			// 进入饥饿模式
</span></span><span class="line"><span class="cl">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">			// 当前是饥饿模式
</span></span><span class="line"><span class="cl">			if old&amp;mutexStarving != 0 {
</span></span><span class="line"><span class="cl">				// 如果当前锁的状态位饥饿模式，但是当前协程可以执行的当前行代码，代表当前协程已经被从阻塞中唤醒。
</span></span><span class="line"><span class="cl">				// 饥饿状态 + 被唤醒 =》当前锁已经已经到当前协程上
</span></span><span class="line"><span class="cl">				if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
</span></span><span class="line"><span class="cl">					// 检查状态一致
</span></span><span class="line"><span class="cl">					throw(&#34;sync: inconsistent mutex state&#34;)
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">				// 由当协程来设置最新的锁定状态
</span></span><span class="line"><span class="cl">				delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)
</span></span><span class="line"><span class="cl">				// 判断是否需要退出饥饿模式
</span></span><span class="line"><span class="cl">				if !starving || old&gt;&gt;mutexWaiterShift == 1 {
</span></span><span class="line"><span class="cl">					delta -= mutexStarving
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">				atomic.AddInt32(&amp;m.state, delta)
</span></span><span class="line"><span class="cl">				break
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// 当前是正常模式，通过CAS自由竞争锁。
</span></span><span class="line"><span class="cl">			awoke = true
</span></span><span class="line"><span class="cl">			iter = 0 // 重置计数
</span></span><span class="line"><span class="cl">		} else {
</span></span><span class="line"><span class="cl">			// 再来
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>是否可以进入自旋状态代码解释<a href="https://cs.opensource.google/go/go/+/master:src/runtime/proc.go;l=6175?q=sync_runtime_canSpin&amp;ss=go%2Fgo">源码地址</a></p>
<h3 id="unlock">Unlock</h3>
<p>第一步直接减去 mutexLocked 标志位常量，如果 new 等于0结束——简单（锁一次开一次，easy）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">new := atomic.AddInt32(&amp;m.state, -mutexLocked)
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果 state 还不等于0（有协程等待，竞争锁）, 进入 unlockSlow</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Mutex) unlockSlow(new int32) {
</span></span><span class="line"><span class="cl">	// 上一步已经减过 locked 位， 在加上应该等于1，否则不是正常解锁（解锁未锁定的锁）。
</span></span><span class="line"><span class="cl">	if (new+mutexLocked)&amp;mutexLocked == 0 {
</span></span><span class="line"><span class="cl">		fatal(&#34;sync: unlock of unlocked mutex&#34;)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	// 正常模式
</span></span><span class="line"><span class="cl">	if new&amp;mutexStarving == 0 {
</span></span><span class="line"><span class="cl">		old := new
</span></span><span class="line"><span class="cl">		for {
</span></span><span class="line"><span class="cl">			// If there are no waiters or a goroutine has already
</span></span><span class="line"><span class="cl">			// been woken or grabbed the lock, no need to wake anyone.
</span></span><span class="line"><span class="cl">			// In starvation mode ownership is directly handed off from unlocking
</span></span><span class="line"><span class="cl">			// goroutine to the next waiter. We are not part of this chain,
</span></span><span class="line"><span class="cl">			// since we did not observe mutexStarving when we unlocked the mutex above.
</span></span><span class="line"><span class="cl">			// So get off the way.
</span></span><span class="line"><span class="cl">			// 没有等待协程无需通过信号量唤醒
</span></span><span class="line"><span class="cl">			// 1. 如果 mutexLocked 位为1，则代表锁已经被新入协程获取。
</span></span><span class="line"><span class="cl">			// 2. mutexWoken 代表协程有协程正在活动，无需再释放信号量
</span></span><span class="line"><span class="cl">			// 3. mutexStarving 锁的状态一直被抢占，才会导致当前位饥饿状态，无需在释放信号量
</span></span><span class="line"><span class="cl">			if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
</span></span><span class="line"><span class="cl">				return
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// Grab the right to wake someone.
</span></span><span class="line"><span class="cl">			new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
</span></span><span class="line"><span class="cl">			if atomic.CompareAndSwapInt3(&amp;m.state, old, new) {
</span></span><span class="line"><span class="cl">				// 信号量唤醒，各自竞争
</span></span><span class="line"><span class="cl">				runtime_Semrelease(&amp;m.sema, false, 1)
</span></span><span class="line"><span class="cl">				return
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	} else {
</span></span><span class="line"><span class="cl">		// 饥饿模式，通过信号量直接移交当前CPU时间
</span></span><span class="line"><span class="cl">		runtime_Semrelease(&amp;m.sema, true, 1)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}2
</span></span></code></pre></td></tr></table>
</div>
</div><p>如何把锁移交给等待队列的协程？</p>
<p>使用 <code>Mutex.sema</code> 信号量实现锁转移</p>
<h2 id="参考">参考</h2>
<p><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18:src/sync/mutex.go;bpv=1;bpt=1">源代码地址sync.mutex.go</a>
<a href="https://pkg.go.dev/sync#Mutex">包说明文档</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>我为什么要学微服务</title>
      <link>https://ynikl.github.io/posts/2022/0526-why-learn-microservices/</link>
      <pubDate>Thu, 26 May 2022 13:29:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/2022/0526-why-learn-microservices/</guid>
      <description>为什么学 高学习产出转化比 助力下一份工作 公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。 后端架构转变的主流方向, 有利于再次找工作。
怎么学 想要学习好一个技术，就需要有想学习这门技术的动力。
首先要对它有较全面的理解：
我们为什么要学习这门技术 技术的使用场景，以及使用的优势和劣势 现在该技术在大环境中的使用情况 再开始学习技术本身。
针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。
具体方法：
我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。 使用 go-zero 框架完成一个练手项目开发。 </description>
      <content:encoded><![CDATA[<h2 id="为什么学">为什么学</h2>
<ol>
<li>高学习产出转化比</li>
<li>助力下一份工作</li>
</ol>
<p>公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。
后端架构转变的主流方向, 有利于再次找工作。</p>
<h2 id="怎么学">怎么学</h2>
<p>想要学习好一个技术，就需要有想学习这门技术的动力。</p>
<p>首先要对它有较全面的理解：</p>
<ol>
<li>我们为什么要学习这门技术</li>
<li>技术的使用场景，以及使用的优势和劣势</li>
<li>现在该技术在大环境中的使用情况</li>
</ol>
<p>再开始学习技术本身。</p>
<p>针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。</p>
<p>具体方法：</p>
<ol>
<li>我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。</li>
<li>使用 <code>go-zero</code> 框架完成一个练手项目开发。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>富兰克林自传读后感</title>
      <link>https://ynikl.github.io/books/autobiography-benjamin_franklin/</link>
      <pubDate>Wed, 25 May 2022 23:14:12 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/autobiography-benjamin_franklin/</guid>
      <description>富兰克林自传
富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。
年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。
摘录富兰克林十三美德：
节制:食不过饱，饮酒不醉； 寡言:言必于人于己有益，避免无益的聊天； 生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做； 决心:当做必做；决心要做的事应坚持不懈； 俭朴:用钱必须于人或于己有益，换言之，切戒浪费； 勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动； 诚恳:不欺骗人；思想要纯洁公正；说话也要如此； 公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务； 适度:避免极端；人若给你应得的处罚，你当容忍之； 清洁:身体、衣服和住所力求清洁； 镇静:勿因小事或普遍不可避免的事故而惊慌失措； 贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉； 谦虚:仿效耶稣和苏格拉底。</description>
      <content:encoded><![CDATA[<p><a href="https://book.douban.com/subject/26324527/">富兰克林自传</a></p>
<p>富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。</p>
<p>年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。</p>
<p>摘录富兰克林十三美德：</p>
<blockquote>
<p>节制:食不过饱，饮酒不醉；
寡言:言必于人于己有益，避免无益的聊天；
生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做；
决心:当做必做；决心要做的事应坚持不懈；
俭朴:用钱必须于人或于己有益，换言之，切戒浪费；
勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动；
诚恳:不欺骗人；思想要纯洁公正；说话也要如此；
公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务；
适度:避免极端；人若给你应得的处罚，你当容忍之；
清洁:身体、衣服和住所力求清洁；
镇静:勿因小事或普遍不可避免的事故而惊慌失措；
贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉；
谦虚:仿效耶稣和苏格拉底。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>【翻译】使用 Godoc 给 go 代码添加文档</title>
      <link>https://ynikl.github.io/blog/golang-godoc-documenting-go-code/</link>
      <pubDate>Wed, 25 May 2022 16:11:10 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-godoc-documenting-go-code/</guid>
      <description>在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。
原文章地址 Godoc: documenting Go code
Go 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。
所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。
godoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。
godoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc&amp;quot;相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。
使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的Fprint函数的注释。
1 2 3 4 // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered.</description>
      <content:encoded><![CDATA[<p>在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。</p>
<p>原文章地址
<a href="https://go.dev/blog/godoc">Godoc: documenting Go code</a></p>
<p>Go 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。</p>
<p>所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。</p>
<p>godoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。</p>
<p>godoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc&quot;相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。</p>
<p>使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的<code>Fprint</code>函数的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Fprint formats using the default formats for its operands and writes to w.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Spaces are added between operands when neither is a string.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It returns the number of bytes written and any write error encountered.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>值得注意的是该注释是以被注释的对象命名开头的一个完整的句子。 这个使用规范可以方便我们生成各种各样的格式文档，从简单的纯文本到 UNIX 是 man 的帮助页，还可以使用其他工具更见简单地获取到信息， 比如提取出第一行或者句子。</p>
<p>在包的声明处的注释，需要写整个包的概括说明。这些注释可以很简洁，就像 sort 包中的简短描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Package sort provides primitives for sorting slices and user-defined
</span></span></span><span class="line"><span class="cl"><span class="c1">// collections.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">sort</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以很详细，比如 gob 包。有另一个使用惯例：像这种有这大量注释文档的包，单独一个<code>doc.go</code>文件，放置包的注释。</p>
<p>不论包的注释文档大小，第一句注释会被展示在 godoc 的呈现包列表中。</p>
<p>那些没有与最外层声明（可以简单理解为包内全局对象）连接在一块的注释会被 godoc 忽略。但是，有一个例外。那些写在最外层且以“BUG(who)”开头的注释，会被识别为已知的 bug，且会被包含在包文档的“Bugs”分区中。这个“who”部分应该填写可以提供更加详细信息的人名。举个已经在 bytes 包中注释的问题:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// BUG(r): The rule Title uses for word boundaries does not handle Unicode punctuation properly.
</span></span></code></pre></td></tr></table>
</div>
</div><p>某些时候，当一个结构体字段，或者函数，类型，甚至一个整个包变成了冗余或者没有使用必要，但是还是需要与旧代码保持兼容。这时，可以增加一个一段落以“Deprecated:”开头后面跟废弃信息的注释。标识该对象不应该再被使用。</p>
<p>下面展示一些 godoc 把注释转化成网页的规则：</p>
<ul>
<li>不同的段落需要以空行分割。否则将会被识别成同一段。</li>
<li>带有格式的文本，需要要缩进。</li>
<li>URL 会被转化成网页连接，无需特殊处理。</li>
</ul>
<p>上方的这些规则不需要你做任何的特殊处理。</p>
<p>事实上，godoc 的极简处理方式使得它非常容易使用。所以，很多 go 项目，包括标准库，都已经开始开始遵循 godoc 的注释文档规范。</p>
<p>你自己的项目也可以通过编写符合文中规范的注释生成漂亮的文档。任何下载在<code>$GOROOT/src/pkg</code> 或者任何在 <code>GOPATH</code> 空间下的 go 代码包，都可以被 godoc 的命令行或者 HTTP 的接口访问， 你也可以通过在命令后添加<code>-path</code>参数或者直接使用<code>godoc .</code>来指定源码的路径。在<a href="https://pkg.go.dev/golang.org/x/tools/cmd/godoc">godoc 文档</a> 你可以查看到更加详细的内容。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>IP表示中 / 代表的意思</title>
      <link>https://ynikl.github.io/posts/cs-the-slash-meaning-of-ip/</link>
      <pubDate>Mon, 23 May 2022 22:01:03 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/cs-the-slash-meaning-of-ip/</guid>
      <description>IP 中斜杠表示的是子网掩码的位数
例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000</description>
      <content:encoded><![CDATA[<p>IP 中斜杠表示的是子网掩码的位数</p>
<p>例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Five Class Programer</title>
      <link>https://ynikl.github.io/posts/five-class-engineer/</link>
      <pubDate>Sun, 15 May 2022 17:11:57 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/five-class-engineer/</guid>
      <description>以前有一段时间, 怀疑过自己&amp;quot;软件工程师&amp;quot;和以前工程意义上的&amp;quot;工程师&amp;quot;有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的见识书中看了一个五级工程师的概念, 算是解惑了我做为一个&amp;quot;码农&amp;quot;和工程师的区别.
(图片来源于图书截图)
第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围. 第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程. 第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维. 第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样. 第一级工程师: 开创一个行业的鼻祖. 能够改变世界. 反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.
所以我自己应该就是 5.0, 五级工程师, 五流程序员.</description>
      <content:encoded><![CDATA[<p>以前有一段时间, 怀疑过自己&quot;软件工程师&quot;和以前工程意义上的&quot;工程师&quot;有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的<a href="https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/">见识</a>书中看了一个五级工程师的概念, 算是解惑了我做为一个&quot;码农&quot;和工程师的区别.</p>
<p><img loading="lazy" src="five_class_engineer.png" alt="五级工程师"  />

(图片来源于图书截图)</p>
<ul>
<li>第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围.</li>
<li>第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程.</li>
<li>第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维.</li>
<li>第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样.</li>
<li>第一级工程师: 开创一个行业的鼻祖. 能够改变世界.</li>
</ul>
<p>反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.</p>
<p>所以我自己应该就是 5.0, 五级工程师, 五流程序员.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Hugo 如何使用已经发布文章做为相对URL</title>
      <link>https://ynikl.github.io/posts/hugo_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Sun, 15 May 2022 16:33:13 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/hugo_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%BF%9E%E6%8E%A5/</guid>
      <description>hugo 的默认内容都是在 content/ 路径下方
在 markdown 文章中使用 { {&amp;lt; ref &amp;quot;/blog/my-first-post.md&amp;quot; &amp;gt;}}(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带/ 是表示从 content/ 目录下的下一个绝对路径
1 [我的文章]({ {&amp;lt; ref &amp;#34;/blog/my-first-post.md&amp;#34; }}) 记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错
hugo官方文档</description>
      <content:encoded><![CDATA[<p>hugo 的默认内容都是在 <code>content/</code> 路径下方</p>
<p>在 markdown 文章中使用 <code>{ {&lt; ref &quot;/blog/my-first-post.md&quot; &gt;}}</code>(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带<code>/</code> 是表示从 <code>content/</code> 目录下的下一个绝对路径</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[我的文章]({ {&lt; ref &#34;/blog/my-first-post.md&#34; }})
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错</strong></p>
<p><a href="https://gohugo.io/content-management/cross-references/">hugo官方文档</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>My first Post</title>
      <link>https://ynikl.github.io/posts/my-first-post/</link>
      <pubDate>Sun, 15 May 2022 16:14:09 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/my-first-post/</guid>
      <description>我的第一篇杂文
阅读了卡片写作笔记法, 和Show Your Work之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.
原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.</description>
      <content:encoded><![CDATA[<p>我的第一篇杂文</p>
<p>阅读了<a href="https://book.douban.com/subject/35503571/">卡片写作笔记法</a>, 和<a href="https://ynikl.github.io/books/showyourwork/" title="about me">Show Your Work</a>之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.</p>
<p>原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>见识</title>
      <link>https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/</link>
      <pubDate>Sat, 14 May 2022 21:06:07 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/</guid>
      <description>见识:豆瓣地址
个人评分: 8.0 分
前辈用他的智慧和经验, 告诉我们如何更好地活着.
为什么读这本书 很多到了中年的人会有这样的体会： 自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。
为了这一句话, 读这一本书. 自己的作为一个普工程序员, 在技术浪潮的最后端被拖着走. 本根不需要到中年, 今年是我从事程序员工作的第四年, 我已经被感受到了被&amp;quot;命&amp;quot;限制住 的感觉了.
书中讲了什么 作者分享了他对商业, 技术, 职业, 创业, 金钱, 读书的观点和看法
用提出了商业的本质是&amp;quot;消费&amp;quot;的观点, 剖析了现在主流的&amp;quot;共享经济&amp;quot;, 带我们用商业的本质眼光, 去看哪些形式的共享经济是真正的&amp;quot;共享经济&amp;quot;, 哪些只是噱头炒概念的而已. 分析了IOT, 和数字跟踪技术, 区块链, 众筹等.
介绍了新科技公司的创业过程中的一些普世经验. 如何选取赛道, 如何发挥自己小公司的优势, 如何在科技浪潮中存活下来, 以及中如何招聘优秀员工.
关于在职场如何招聘到优秀的员工, 又可以引申到自己如何成为一个优秀的员工, 作者也给出了答案.
树立完成的职业思维, 带着发展的目光选择岗位 在职业思维下主动和积极的面对工作 打开自己思维格局, 多去了解行业大局 有了不错的收入之后, 就涉及到了, 如何树立一个正确的金钱观. 要对自己收入有一个正确的认识, 避免过度追求提高收入, 进而牺牲了自己的健康, 家庭等. (现在经常听到我们的工友, 猝死就是这方面没有正确面对)
下半篇, 作者开始就上升到了人生态度问题. 以一个正确的心态, 面对生活, 面对婚姻, 面对死亡. 分清楚自己生活中的 &amp;ldquo;西瓜和芝麻&amp;rdquo;, 避免习惯于低层次的追求, 会影响我们的心志.
最后文中讲述对大学生的建议 (我已经错过了), 阐述沟通的重要性, 以及介绍了拉里·佩奇名人, 巴菲特的非凡&amp;quot;见识&amp;quot;.</description>
      <content:encoded><![CDATA[<p><a href="https://book.douban.com/subject/27167992/">见识:豆瓣地址</a></p>
<p>个人评分: 8.0 分</p>
<p>前辈用他的智慧和经验, 告诉我们如何更好地活着.</p>
<h2 id="为什么读这本书">为什么读这本书</h2>
<blockquote>
<p>很多到了中年的人会有这样的体会： 自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。</p>
</blockquote>
<p>为了这一句话, 读这一本书. 自己的作为一个普工程序员, 在技术浪潮的最后端被拖着走. 本根不需要到中年, 今年是我从事程序员工作的第四年, 我已经被感受到了被&quot;命&quot;限制住 的感觉了.</p>
<h2 id="书中讲了什么">书中讲了什么</h2>
<p>作者分享了他对商业, 技术, 职业, 创业, 金钱, 读书的观点和看法</p>
<p>用提出了商业的本质是&quot;消费&quot;的观点, 剖析了现在主流的&quot;共享经济&quot;, 带我们用商业的本质眼光, 去看哪些形式的共享经济是真正的&quot;共享经济&quot;, 哪些只是噱头炒概念的而已. 分析了IOT, 和数字跟踪技术, 区块链, 众筹等.</p>
<p>介绍了新科技公司的创业过程中的一些普世经验. 如何选取赛道, 如何发挥自己小公司的优势, 如何在科技浪潮中存活下来, 以及中如何招聘优秀员工.</p>
<p>关于在职场如何招聘到优秀的员工, 又可以引申到自己如何成为一个优秀的员工, 作者也给出了答案.</p>
<ol>
<li>树立完成的职业思维, 带着发展的目光选择岗位</li>
<li>在职业思维下主动和积极的面对工作</li>
<li>打开自己思维格局, 多去了解行业大局</li>
</ol>
<p>有了不错的收入之后, 就涉及到了, 如何树立一个正确的金钱观. 要对自己收入有一个正确的认识, 避免过度追求提高收入, 进而牺牲了自己的健康, 家庭等. (现在经常听到我们的工友, 猝死就是这方面没有正确面对)</p>
<p>下半篇, 作者开始就上升到了人生态度问题. 以一个正确的心态, 面对生活, 面对婚姻, 面对死亡. 分清楚自己生活中的 &ldquo;西瓜和芝麻&rdquo;, 避免习惯于低层次的追求, 会影响我们的心志.</p>
<p>最后文中讲述对大学生的建议 (我已经错过了), 阐述沟通的重要性, 以及介绍了拉里·佩奇名人, 巴菲特的非凡&quot;见识&quot;.</p>
<h2 id="我从书中收获了什么">我从书中收获了什么</h2>
<p>对现在的&quot;共享经济&quot;有了更深的认识, 对科技迭代有了一个基础性的认识, 重视自己职业发展和做文字的积累, 开始努力去全面了解自己的行业, 以及在阅读中莫名地增加了我对生活的信心.</p>
<h2 id="书中的三句精华句子">书中的三句精华句子</h2>
<ol>
<li>很多到了中年的人会有这样的体会：自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。</li>
<li>我们知道今天几乎任何一所三甲医院的主治医师，水平一定比 50 年前所谓的名医高很多。但是，今天没有哪个中医敢讲自己比 500 年前的名医水平高。这就是因为前者有积累效应，而后者没有</li>
<li>我们对死亡的恐惧有点儿莫名其妙，我们站在“有”的世界，试图理解“无”的问题，按照“有”的逻辑，对“无”产生恐惧</li>
</ol>
<h2 id="三句话总结本书">三句话总结本书</h2>
<ol>
<li>拓展视野, 打开格局, 重视积累</li>
<li>以发展的眼光看职业生涯, 分清楚工作和职业的区别, 拒绝伪工作.</li>
<li>向死而生</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Show Your Work</title>
      <link>https://ynikl.github.io/books/showyourwork/</link>
      <pubDate>Sat, 30 Apr 2022 17:22:23 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/showyourwork/</guid>
      <description>Show Your Work 读书总结 概括 我为什么要读这本书
如何提高自己的影响力
这本书怎样影响了我
打算开始分享计划, 学习如何分享, 讲述故事. 计划&amp;quot;学术假&amp;quot;
书中的三句精华句子
You find time the same place you find spare change: in the nooks and crannies On the spectrum of creative work, the difference between the mediocre and the good is vast. Mediocrity is, however, still on the spectrum; you can move from mediocre to good in increments. The real gap is between doing nothing and doing something You can turn your flow into stock 三句话总结本书</description>
      <content:encoded><![CDATA[<h1 id="show-your-work-读书总结">Show Your Work 读书总结</h1>
<h2 id="概括">概括</h2>
<p><strong>我为什么要读这本书</strong></p>
<p>如何提高自己的影响力</p>
<p><strong>这本书怎样影响了我</strong></p>
<p>打算开始分享计划, 学习如何分享, 讲述故事.
计划&quot;学术假&quot;</p>
<p><strong>书中的三句精华句子</strong></p>
<ol>
<li>You find time the same place you find spare change: in the nooks and crannies</li>
<li>On the spectrum of creative work, the difference between the mediocre and the good is vast. Mediocrity is, however, still on the spectrum; you can move from mediocre to good in increments. The real gap is between doing nothing and doing something</li>
<li>You can turn your flow into stock</li>
</ol>
<p><strong>三句话总结本书</strong></p>
<ol>
<li>我们需要把自己展示出来, 这样子别人才能知道你是一个什么样子的人. ( 酒香也怕巷子深)</li>
<li>把自己当成一个业务爱好者, 对自己分享负责, 但不用追求到完美, 心态开放, 保持热情</li>
<li>把握自己分享的尺度, 任何事情, 思想, 启发都是值得分享的. 在互联网上保持真诚, 尊重他人, 保护自己.</li>
</ol>
<h2 id="感悟点">感悟点</h2>
<p>不要觉得你没有什么事情可以分享, 一定会有人对你做的事情感兴趣. 比如一天结束，可以分享自己在做什么，做什么什么决定，收获了什么，受到了什么启发，有什么成果</p>
<p>互联网上的人们都很烂，如果不包含链接，99.9%的就不会去找目标网页</p>
<p>如果虚假的分享你的成功，你不仅抢夺了他人的成功，还欺骗了分享成果的人们</p>
<p>要能解释自己正在做什么</p>
<p>分享自己的知识，也可以让别人知道你在干嘛，知道你的工作，也是自己的一种再学习过程</p>
<p>要倾听别人的意见，不要一味地分享自己</p>
<p>要用内容去吸引读者，不要悲哀地要求别人粉你</p>
<p>学会在网上保护自己，过滤垃圾评论</p>
<p>通勤的好处：分离家庭与工作</p>
<p>适当给自己放假，学术假。每七年让自己重新充电🔋。</p>
<p>认识你自己</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Docker 基本使用</title>
      <link>https://ynikl.github.io/blog/docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 07 Apr 2022 13:34:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>启动一个容器 打个样
1 docker run -itd --rm --name hello image_name &amp;ndash; it 将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式
&amp;ndash;rm 当容器停止之后, 会自动删除改容器
外挂文件夹 参数 -v docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash
与容器交互 进入容器 docker attach
exec
docker -it exec CONTAIN_NAME bash
exex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯. 加上 -it, 进入交互的终端模式
查看日志 docker logs CONTAINER 可以查看容器日志
-f 可以持续输出容器内部的最新日志
管理容器 启动
1 docker start CONTAINER 暂停
1 docker stop CONTAINER 提交
1 docker commit --author=&amp;#34;ian&amp;#34; CONTAINER NEW-IMAGENAME:TAG 管理镜像 查看所有的镜像列表</description>
      <content:encoded><![CDATA[<h2 id="启动一个容器">启动一个容器</h2>
<p>打个样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -itd --rm --name hello image_name 
</span></span></code></pre></td></tr></table>
</div>
</div><p>&ndash; it
将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式</p>
<p>&ndash;rm
当容器停止之后, 会自动删除改容器</p>
<p>外挂文件夹
参数 <code>-v </code></p>
<p><code>docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</code></p>
<h2 id="与容器交互">与容器交互</h2>
<h3 id="进入容器">进入容器</h3>
<p><code>docker attach</code></p>
<p>exec</p>
<p><code>docker -it exec CONTAIN_NAME bash</code></p>
<p>exex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯.
加上 <code>-it</code>, 进入交互的终端模式</p>
<h3 id="查看日志">查看日志</h3>
<p><code>docker logs CONTAINER</code>
可以查看容器日志</p>
<p>-f
可以持续输出容器内部的最新日志</p>
<h2 id="管理容器">管理容器</h2>
<p>启动</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker start CONTAINER
</span></span></code></pre></td></tr></table>
</div>
</div><p>暂停</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker stop CONTAINER
</span></span></code></pre></td></tr></table>
</div>
</div><p>提交</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker commit --author=&#34;ian&#34; CONTAINER NEW-IMAGENAME:TAG
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="管理镜像">管理镜像</h2>
<p>查看所有的镜像列表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker image ls
</span></span></code></pre></td></tr></table>
</div>
</div><p>删除镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rmi IMAGE
</span></span></code></pre></td></tr></table>
</div>
</div><p>删除 <code>&lt;none&gt;</code> 名称的镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rmi $(docker images --filter &#34;dangling=true&#34; -q --no-trunc)
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    
    <item>
      <title>Channel</title>
      <link>https://ynikl.github.io/blog/golang-channel/</link>
      <pubDate>Sat, 02 Apr 2022 10:09:22 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-channel/</guid>
      <description>Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本
channel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)
Do not communicate by sharing memory; instead, share memory by communicating.
channel 保证:
数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开 channel 的实现 channel 在内部实现的结构体为 runtime.hchan
有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe.</description>
      <content:encoded><![CDATA[<h1 id="go-中-channel-中用法和实现总结">Go 中 channel 中用法和实现总结</h1>
<p>以下分析和源码都是基于 go1.17 版本</p>
<h2 id="channel-简介">channel 简介</h2>
<p>Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (<strong>channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递</strong>)</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>channel 保证:</p>
<ol>
<li>数据的先入先出</li>
<li>并发情况下的数据安全</li>
<li>已经关闭的 channel 不可重开</li>
</ol>
<h2 id="channel-的实现">channel 的实现</h2>
<p>channel 在内部实现的结构体为 <code>runtime.hchan</code></p>
<ol>
<li>有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲.</li>
<li>有一把互斥锁<code>mutex</code>, 在并发情况下, 保护自身数据结构的一致性</li>
<li>有两个协程等待链表, 用于挂载因为<strong>发送/接收</strong>而阻塞在该 channel 上的协程</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// 当前 buffer 中有暂存着多少个数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 环形数组开始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">elemsize</span> <span class="kt">uint16</span>         <span class="c1">// channel 传输的元素大小, 用于计算内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">closed</span>   <span class="kt">uint32</span>         <span class="c1">// channel 是否已经关闭 0未关闭, 非0关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span>         <span class="c1">// element type # channel 元素的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sendx</span>    <span class="kt">uint</span>           <span class="c1">// 环形链表中, 发送数据存储的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">recvx</span>    <span class="kt">uint</span>           <span class="c1">// 环形链表中, 接受数据获取数据的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>          <span class="c1">// 阻塞在该 channel 等待获取数据的 Groutine 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>          <span class="c1">// 阻塞在该 channel 等待写入数据的 Groutine 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">lock</span> <span class="nx">mutex</span> <span class="c1">// # 互斥锁 用于保护自身数据变更
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化">初始化</h3>
<ol>
<li>channel 传递的元素不能太大</li>
<li>如果是空结构体或者无缓冲队列, 是不需要分配环形队列内存</li>
<li>如果传递数据类型有内含指针, 需要将环形队列分配到堆上</li>
</ol>
<p>内部实现函数<code>runtime.makechan</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// compiler checks this but be safe.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 编译器会校验channel元素的大小, 小于64KB. 若大于64KB, 编译器会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: invalid channel element type&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">hchanSize</span><span class="o">%</span><span class="nx">maxAlign</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">maxAlign</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: bad alignment&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">-</span><span class="nx">hchanSize</span> <span class="o">||</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// buf points into the same allocation, elemtype is persistent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Queue or element size is zero. # 无缓冲队列或者空结构体为传递值, 不需要额外分配队列内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Race detector uses this location for synchronization.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// # channel 元素不存在指针引导数据, 将环形数组分配在 hchan 后面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Elements do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Allocate hchan and buf in one call.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Elements contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankHchan</span><span class="p">)</span> <span class="c1">// # locakRankHchan 锁的等级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="关闭">关闭</h3>
<p>核心代码<code>runtime.closechan</code>更新自身数据结构中的关闭状态, 并 <strong>唤醒阻塞在 channel 上的所有协程</strong>. 被唤醒的协程(<code>sudog</code>)的 success 标识会被置为 false.</p>
<p>被唤醒的 写操作的协程, 也会发生panic. ( &ldquo;send on closed channel&rdquo; )</p>
<p>自身操作会发生 panic 的情况</p>
<ol>
<li>未初始化 channel</li>
<li>重复关闭 channel</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">closechan</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 未初始化的channel 会发生panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of nil channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 开始关闭, 锁定之后数据都进不来了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">glist</span> <span class="nx">gList</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// release all readers # 唤醒所有因为读取数据阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # [channel 唤醒协议总是设置params为sudog](https://github.com/golang/go/commit/30a68bfb806b5217932e280f5a5f521237e69077)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// release all writers (they will panic) # 唤醒所有因为写入数据阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Ready all Gs now that we&#39;ve dropped the channel lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 唤醒协程, 将协程加入调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="发送数据">发送数据</h3>
<p><strong>向已经关闭的 channel 发送数据会发生 panic</strong></p>
<p>数据流程:</p>
<ol>
<li>检查是否已经初始化</li>
<li>非阻塞写入数据, 检查数据是否已经满, 快速返回</li>
<li>是否已经关闭</li>
<li>检查 channel 中是否已经有等待获取数据而阻塞的协程,  如果有直接将数据发送给等待的协程.</li>
<li>channel 的 buffer 是否还有空间, 如果有将数据放置到 buffer 中, 返回</li>
<li>channel 的 buffer 已经满了, 根据是否为 select 操作, 判断是否需要将协程阻塞</li>
<li>当协程阻塞之后,  在被唤醒之后需要再检查一次, channel 是否已经关闭.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// # block 的参数是由是否在 select 中, 由编译过程决定的; 只有在select语句中block = true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 向未初始化的 channel 发送数据会永远阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanSendNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 带 select 的 channel 在数据已经满了情况直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">full</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 保护数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 先从接受协程队列中获取阻塞的协程, 直接将数据发送给阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Found a waiting receiver. We pass the value we want to send
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// directly to the receiver, bypassing the channel buffer (if any).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # channel 的 buffer 中还有剩余空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Space is available in the channel buffer. Enqueue the element to send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 环形队列, 当索引到最后从头开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 增加当前 channel buffer 存储的数据个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 发送数据的协程阻塞在当前 channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Block on the channel. Some receiver will complete our operation for us.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanSend</span><span class="p">,</span> <span class="nx">traceEvGoBlockSend</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Ensure the value being sent is kept alive until the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// receiver copies it out. The sudog has a pointer to the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack object, but sudogs aren&#39;t considered as roots of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack tracer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 协程被唤醒了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// someone woke us up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">closed</span> <span class="o">:=</span> <span class="p">!</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// # 挂载在协程上的发送协程会 panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">closed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="接收数据">接收数据</h3>
<p>与发送数据一样, 同样带着是否阻塞的参数. 在编译时,由是否有 select 操作决定. 核心代码<code>runtime.chanrecv</code></p>
<ol>
<li>不带 select 从未初始化的 channel 获取数据, 会永远阻塞</li>
<li><code>runtime.chanrecv</code> 返回值中, 第一个返回值<code>selected</code>表示在,select 语句中, 该 case 是否会被选中执行</li>
</ol>
<p>接收数据流程:</p>
<ol>
<li>检查是否已经初始化</li>
<li>检查非阻塞获取数据下, 是否可以直接返回</li>
<li>如果已经关闭的 channel 且没有已经没有缓冲数据, 返回数据类型的默认值.</li>
<li>检查有因发送数据阻塞在 channel 的协程, 如果没有 buffer, 直接从阻塞的协程中获取数据, 否则从 buffer 中获取数据数据, 将第一个阻塞的协程的数据放入 buffer 中.</li>
<li>如果缓冲 buffer 有数据, 则从buffer 中获取数据.</li>
<li>非阻塞操作, 直接返回. 否则协程进行阻塞.</li>
</ol>
<p>注意事项:</p>
<p><strong>当 select 一个 已经关闭的 channel 的时候, 该 case 会被疯狂输出, 导致cpu使用率上升</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// chanrecv receives on channel c and writes the received data to ep.
</span></span></span><span class="line"><span class="cl"><span class="c1">// ep may be nil, in which case received data is ignored.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If block == false and no elements are available, returns (false, false).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, if c is closed, zeros *ep and returns (true, false).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, fills in *ep with an element and returns (true, true).
</span></span></span><span class="line"><span class="cl"><span class="c1">// A non-nil ep must point to the heap or the caller&#39;s stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// select 情况下, selected = false, 不执行该 case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 非 select 会永远阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanReceiveNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 不加锁检查, 带 select 接收操作, 如果 channel 未关闭, 且没有可以获取的数据直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// After observing that the channel is not ready for receiving, we observe whether the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// channel is closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Reordering of these checks could lead to incorrect behavior when racing with a close.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// For example, if the channel was open and not empty, was closed, and then drained,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// reordered reads could incorrectly indicate &#34;open and empty&#34;. To prevent reordering,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// we use atomic loads for both checks, and rely on emptying and closing to happen in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// separate critical sections under the same lock.  This assumption fails when closing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// an unbuffered channel with a blocked send, but that is an error condition anyway.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Because a channel cannot be reopened, the later observation of the channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// being not closed implies that it was also not closed at the moment of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// first observation. We behave as if we observed the channel at that moment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// and report that the receive cannot proceed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The channel is irreversibly closed. Re-check whether the channel has any pending data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// to receive, which could have arrived between the empty and closed checks above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Sequential consistency is also required here, when racing with such a send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// The channel is irreversibly closed and empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// select 会选择改 case 疯狂输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// # 如果 channel 已经关闭, 且buffer 中已经没有数据了, 返回传输数据类型的默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// # 在返回的时候有可能刚好有数据会进来, 所以需要进行加锁操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The channel has been closed, but the channel&#39;s buffer have data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">		<span class="c1">// # 如果 channel 没有 buffer 会直接从阻塞中的发送数据协程中获取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// # 如果 channel 有 buffer. 当可以获取到因为发送数据而阻塞的协程时, 代表缓冲的 buffer 已经满了. 所以, 将从 buffer 中获取数据, 并将获取到的第一个阻塞协程, 的数据放入 buffer 尾端. 保证先入先出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Just found waiting sender with not closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Found a waiting sender. If buffer is size 0, receive value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// directly from sender. Otherwise, receive from head of queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// and add sender&#39;s value to the tail of the queue (both map to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// the same buffer slot because the queue is full).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 从 buffer 中获取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Receive directly from queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 非阻塞操作, 返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 将获取数据的协程阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// no sender available: block on this channel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanReceive</span><span class="p">,</span> <span class="nx">traceEvGoBlockRecv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// someone woke us up
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果是因为 channel的关闭 操作唤醒的, success 值为 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">success</span> <span class="o">:=</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">success</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="用法总结">用法总结</h2>
<p>初始化:</p>
<ol>
<li>避免对未初始化 channel 的进行读写操作, 可能会造成阻塞</li>
<li>在 select 语句中, 对已经关闭的 channel 可以赋予  <code>nil</code> 值, 避免 cpu 飙高</li>
</ol>
<p>关闭协程:</p>
<ol>
<li>关闭协程的动作, 应该由数据写入方操作</li>
<li>channel 当参数传递时, 尽可能带上操作方向(读取/写入), 编译器会保证, 单向写入协程不允许关闭</li>
<li>关闭的时候要确保所有的写入协程都已经操作完毕. 避免引起写入协程发生 panic</li>
</ol>
<p>在 channel 中阻塞的协程, 唤醒条件</p>
<ol>
<li>到达协程数据操作的目标, 写入 / 读取数据</li>
<li>channel 关闭</li>
</ol>
<h2 id="referrences">Referrences</h2>
<ol>
<li><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17:src/runtime/chan.go">Go官方源码</a></li>
<li><a href="https://go.dev/blog/codelab-share">Share Memory By Communication</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>提升文字留存率</title>
      <link>https://ynikl.github.io/posts/%E6%8F%90%E5%8D%87%E6%96%87%E5%AD%97%E7%95%99%E5%AD%98%E7%8E%87/</link>
      <pubDate>Sat, 02 Apr 2022 09:58:23 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/%E6%8F%90%E5%8D%87%E6%96%87%E5%AD%97%E7%95%99%E5%AD%98%E7%8E%87/</guid>
      <description>如何提高自己的所编写的文字留存问题? 自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意. 然后就会把已经写下的文字和内容删除掉.</description>
      <content:encoded><![CDATA[<p>如何提高自己的所编写的文字留存问题?
自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意.
然后就会把已经写下的文字和内容删除掉.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>2022</title>
      <link>https://ynikl.github.io/neo/okr-2022/</link>
      <pubDate>Fri, 01 Apr 2022 20:09:37 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/neo/okr-2022/</guid>
      <description>2022 年度目标 提升自己的基础技术竞争力, 确保不会找不到工作
精通 go 编程语言 精通 redis 精通 mysql 5 月份 OKR O:
加深对 Go 语言的基础知识理解 熟悉 redis 的所有数据类型 KR:
输出3篇高质量的 go 语言blog
channel module tools 数据 redis 所有数据类型总结博文一篇
所有数据类型总结博文 6 月份 OKR 成为一个 golang 资深开发工程师
Go GMP 调度总结博文 做一个部门内部的 GMP 调度培训 成为一个优秀的软件工程师
微服务架构设计模式通读并完成博文输出 Mysql 表结构数据类型总结博文 成为一个独立的 apple 软件开发者
开发一个 macos 蕃茄钟小程序雏形 总结 6 月份只完成了一项 微服务架构设计模式 书籍的阅读. 完成情况比较差.
主要原因: 对设定的目标不够上心. 6月份对健身很感兴趣, 一心扑在了健身上了, 对于月初制定的计划也就淡忘了.
7 月份 OKR O1: 首要目标, 还是要技术总结和输出 go 语言的基础知识, 成为一个 资深的 golang 开发者</description>
      <content:encoded><![CDATA[<h1 id="2022-年度目标">2022 年度目标</h1>
<p>提升自己的基础技术竞争力, 确保不会找不到工作</p>
<ul>
<li>精通 go 编程语言</li>
<li>精通 redis</li>
<li>精通 mysql</li>
</ul>
<h1 id="5-月份-okr">5 月份 OKR</h1>
<p>O:</p>
<ul>
<li>加深对 Go 语言的基础知识理解</li>
<li>熟悉 redis 的所有数据类型</li>
</ul>
<p>KR:</p>
<p>输出3篇高质量的 go 语言blog</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> channel</li>
<li><input disabled="" type="checkbox"> module</li>
<li><input checked="" disabled="" type="checkbox"> tools</li>
</ul>
<p>数据 redis 所有数据类型总结博文一篇</p>
<ul>
<li><input disabled="" type="checkbox"> 所有数据类型总结博文</li>
</ul>
<h1 id="6-月份-okr">6 月份 OKR</h1>
<p>成为一个 golang 资深开发工程师</p>
<ul>
<li><input disabled="" type="checkbox"> Go GMP 调度总结博文</li>
<li><input disabled="" type="checkbox"> 做一个部门内部的 GMP 调度培训</li>
</ul>
<p>成为一个优秀的软件工程师</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 微服务架构设计模式通读并完成博文输出</li>
<li><input disabled="" type="checkbox"> Mysql 表结构数据类型总结博文</li>
</ul>
<p>成为一个独立的 apple 软件开发者</p>
<ul>
<li><input disabled="" type="checkbox"> 开发一个 macos 蕃茄钟小程序雏形</li>
</ul>
<h2 id="总结">总结</h2>
<p>6 月份只完成了一项 <em>微服务架构设计模式</em>  书籍的阅读. 完成情况比较差.</p>
<p>主要原因:
对设定的目标不够上心. 6月份对健身很感兴趣, 一心扑在了健身上了, 对于月初制定的计划也就淡忘了.</p>
<h1 id="7-月份-okr">7 月份 OKR</h1>
<p>O1: 首要目标, 还是要技术总结和输出 go 语言的基础知识, 成为一个 资深的 golang 开发者</p>
<ul>
<li><input disabled="" type="checkbox"> go gmp 调度总结博文</li>
<li><input disabled="" type="checkbox"> map channel context 总结博文输出</li>
<li><input disabled="" type="checkbox"> Mysql 表结构数据类型总结博文 (6月份遗留)</li>
</ul>
<p>O2: 学习计算机基础知识</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 学习 <em>RabbitMQ 实战指南</em>  (因为当前公司项目有用到相关的组件, 需要快速学习一下)</li>
<li><input checked="" disabled="" type="checkbox"> 总结 docker 的基本使用</li>
<li><input disabled="" type="checkbox"> 学习 <em>unix 网络编程 卷一</em></li>
</ul>
<p>O3: 保持健康, 保持阅读</p>
<ul>
<li><input disabled="" type="checkbox"> 有 25 天完成, 每天阅读 4 番茄钟的.</li>
<li><input checked="" disabled="" type="checkbox"> 每周 至少健身 4次.</li>
</ul>
<h2 id="总结-1">总结</h2>
<p>执行力不够. 每天制定目标早起, 前天晚上又要早睡. 再加上健身时间, 周一至周五非工作时间都已经排满了.</p>
<p>周末, 执行力不够, 会比较懒散地趴在床上刷抖音, 刷视频之类的. 没有有效地利用时间, 导致制定的计划都完不成.</p>
<h1 id="8-月份-okr">8 月份 OKR</h1>
<p>O1: 高级 go 语言开发者</p>
<ul>
<li><input disabled="" type="checkbox"> go gmp 调度总结博文</li>
<li><input disabled="" type="checkbox"> map, context 总结博文输出</li>
</ul>
<p>O2: 补充计算机基础知识</p>
<ul>
<li><input disabled="" type="checkbox"> <del>Tree 数据结构类型</del></li>
<li><input checked="" disabled="" type="checkbox"> Mysql 表结构数据类型总结博文 (6月份遗留)</li>
<li><input disabled="" type="checkbox"> <del>Unix 网络编程 卷一</del></li>
</ul>
<p>O3: 保持健康, 保持阅读</p>
<ul>
<li><input checked="" disabled="" type="checkbox"> 有 25 天完成, 每天阅读 4 番茄钟的.</li>
<li><input disabled="" type="checkbox"> <del>有 25 天完成, 当天的总结和第二天的规划.</del></li>
<li><input disabled="" type="checkbox"> 每周有4点,8点半之前到公司</li>
<li><input checked="" disabled="" type="checkbox"> 每周 至少健身 4次.</li>
</ul>
<h2 id="8月份总结">8月份总结</h2>
<ul>
<li>过度娱乐，沉溺于抖音，每一天可以刷1-2个小时</li>
<li>健身花费的时间占比居高不下， 过度重视健身。</li>
</ul>
<h2 id="9月份安排">9月份安排</h2>
<ul>
<li>在写自我技术能力的时候，依旧没有能力把 <strong>精通</strong> 这两个字放在 Go语言前面 &ndash; 9月份最主要目标</li>
<li>下调健身花费的时间占比， 采用5分化训练。 每次尽量把时间控制在一个小时之内。</li>
<li>每天保持一个小时的时间用于提高技术能力。</li>
</ul>
<h1 id="9-月份-okr">9 月份 OKR</h1>
<p>O1: 可以在自我介绍上写上 <strong>精通Go语言</strong></p>
<ul>
<li><input disabled="" type="checkbox"> go gmp 调度总结博文</li>
<li><input disabled="" type="checkbox"> map, context 总结博文输出</li>
<li><input disabled="" type="checkbox"> interface 深入学习</li>
<li><input disabled="" type="checkbox"> reflect 反射包使用</li>
</ul>
<p>O2: 拓展知识</p>
<ul>
<li><input disabled="" type="checkbox"> Mysql 表结构数据类型总结博文 (6月份遗留)</li>
</ul>
<p>O3: 保持健康, 保持阅读</p>
<ul>
<li><input disabled="" type="checkbox"> 有 25 天完成, 每天阅读 4 番茄钟的.</li>
<li><input disabled="" type="checkbox"> 每周有4点,8点半之前到公司</li>
<li><input disabled="" type="checkbox"> 每周 至少健身 4次.</li>
</ul>
<h1 id="10-月份-okr">10 月份 OKR</h1>
<p>无</p>
<h1 id="11-月份-okr">11 月份 OKR</h1>
<p>技术</p>
<p>O1: <strong>精通Go语言</strong></p>
<ul>
<li><input checked="" disabled="" type="checkbox"> go map 总结博文输出</li>
<li><input disabled="" type="checkbox"> go context 总结博文输出</li>
<li><input disabled="" type="checkbox"> go gmp 调度总结博文</li>
</ul>
<p>O2: 拓展技术边界</p>
<ul>
<li><input disabled="" type="checkbox"> 前端技术入门</li>
<li><input disabled="" type="checkbox"> Python 入门</li>
</ul>
<p>生活</p>
<p>O1: 文字沉淀,</p>
<ul>
<li><input disabled="" type="checkbox"> 摩托车给我带来了什么文章总结</li>
<li><input disabled="" type="checkbox"> 摩托车骑行录像整理</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go 常用的命令汇总</title>
      <link>https://ynikl.github.io/blog/golang-cmd/</link>
      <pubDate>Fri, 01 Apr 2022 19:56:59 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-cmd/</guid>
      <description>工具分类 go build 编译源代码文件
-race 编译出的目标程序，会启用数据竞争检测
go doc 查看包的文档(定义于doc.go的注释中), 于包中公开的函数签名
example
1 2 3 go doc go doc encoding/json go env 查看 go 相关的环境变量
1 2 3 4 5 # -w 设置环境变量 go env -w GOPAHT=&amp;#39;/some/path&amp;#39; # -u 恢复成默认设置 go env -u GOPATH go generate 扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”
注释的指令格式
//go:generate command argument...
ps: wire 也是利用命令, 生成依赖注入文件
go get 管理当前module依赖
1 2 3 4 5 6 7 8 # 添加依赖包 go get example.</description>
      <content:encoded><![CDATA[<h1 id="工具分类">工具分类</h1>
<h2 id="go-build">go build</h2>
<p>编译源代码文件</p>
<p><code>-race</code>
编译出的目标程序，会启用数据竞争检测</p>
<h2 id="go-doc">go doc</h2>
<p>查看包的文档(定义于<code>doc.go</code>的注释中), 于包中公开的函数签名</p>
<p>example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go doc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">go doc encoding/json
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-env">go env</h2>
<p>查看 go 相关的环境变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># -w 设置环境变量</span>
</span></span><span class="line"><span class="cl">go env -w <span class="nv">GOPAHT</span><span class="o">=</span><span class="s1">&#39;/some/path&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># -u 恢复成默认设置</span>
</span></span><span class="line"><span class="cl">go env -u GOPATH
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-generate">go generate</h2>
<p>扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”</p>
<p><strong>注释的指令格式</strong></p>
<p><code>//go:generate command argument...</code></p>
<p>ps: wire 也是利用命令, 生成依赖注入文件</p>
<h2 id="go-get">go get</h2>
<p>管理当前module依赖</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 添加依赖包
</span></span><span class="line"><span class="cl">go get example.com/pkg
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 指定包版本
</span></span><span class="line"><span class="cl">go get example.com/pkg@1.2.3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 移除依赖
</span></span><span class="line"><span class="cl">go get example.com/pkg@none
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-install">go install</h2>
<p>获取包文件，并编译和安装。可执行文件编译到<code>$GOBIN</code>路径下, 包文件编译到<code>$GOPATH/pkg</code></p>
<h2 id="go-list">go list</h2>
<p>列出包的数据信息</p>
<h2 id="go-mod">go mod</h2>
<p>管理 modules</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">edit	修改go.mod
</span></span><span class="line"><span class="cl">init	初始化
</span></span><span class="line"><span class="cl">tidy	自动补全依赖包
</span></span><span class="line"><span class="cl">vendor	生成一个所有依赖的vendor文件夹
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-test">go test</h2>
<p>跑单元测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go test -v .
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 指定函数
</span></span><span class="line"><span class="cl">go test -run 函数名
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 性能测试
</span></span><span class="line"><span class="cl">go test -v -bench . -benchtime 50s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 单元测试覆盖率
</span></span><span class="line"><span class="cl">go test -cover
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 强制重新跑测试, 不使用缓存的结果 source: https://stackoverflow.com/a/48882892/9992963
</span></span><span class="line"><span class="cl">go test -count=1
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-tool">go tool</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 不带参数，显示工具列表
</span></span><span class="line"><span class="cl">go tool
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="compile">compile</h3>
<p>使用<code>go tool compile -N -l -S main.go</code>生成汇编代码</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>我</title>
      <link>https://ynikl.github.io/me/</link>
      <pubDate>Wed, 09 Mar 2022 15:24:02 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/me/</guid>
      <description> 我: 昵称: 潜水员
五流程序员 文字业余爱好者 摩托车爱好者 为什么写 在互联网中留下尘埃 把想法外显成文字才会有意义 促进自我思考 目前在学 Go Redis 微服务设计模式 计算机技能 Go Vim Live in Shell Redis Mysql Operating System Algorithm (basic) 想从生活中得到 摄影 游泳 Bucket List 逃离办公室 去西藏 出版一本小说 潜水 跳伞 目录分类说明 blog 一些技术上的杂文 posts 自己的一些感悟和发牢骚 notes 平时遇到的一些有感悟的文字 books 自己读的书籍的一些简单记录 </description>
      <content:encoded><![CDATA[<p><img loading="lazy" src="Ian.jpeg" alt="avatar"  />
</p>
<h1 id="我">我:</h1>
<p>昵称: <strong>潜水员</strong></p>
<ul>
<li>五流程序员</li>
<li>文字业余爱好者</li>
<li>摩托车爱好者</li>
</ul>
<h2 id="为什么写">为什么写</h2>
<ul>
<li>在互联网中留下尘埃</li>
<li>把想法外显成文字才会有意义</li>
<li>促进自我思考</li>
</ul>
<h2 id="目前在学">目前在学</h2>
<ul>
<li>Go</li>
<li>Redis</li>
<li><del>微服务设计模式</del></li>
</ul>
<h2 id="计算机技能">计算机技能</h2>
<ul>
<li><input checked="" disabled="" type="checkbox"> Go</li>
<li><input checked="" disabled="" type="checkbox"> Vim</li>
<li><input checked="" disabled="" type="checkbox"> Live in Shell</li>
<li><input disabled="" type="checkbox"> Redis</li>
<li><input disabled="" type="checkbox"> Mysql</li>
<li><input disabled="" type="checkbox"> Operating System</li>
<li><input disabled="" type="checkbox"> Algorithm (basic)</li>
</ul>
<h2 id="想从生活中得到">想从生活中得到</h2>
<ul>
<li><input disabled="" type="checkbox"> 摄影</li>
<li><input disabled="" type="checkbox"> 游泳</li>
</ul>
<h2 id="bucket-list">Bucket List</h2>
<ul>
<li><input disabled="" type="checkbox"> 逃离办公室</li>
<li><input disabled="" type="checkbox"> 去西藏</li>
<li><input disabled="" type="checkbox"> 出版一本小说</li>
<li><input disabled="" type="checkbox"> 潜水</li>
<li><input disabled="" type="checkbox"> 跳伞</li>
</ul>
<h2 id="目录分类说明">目录分类说明</h2>
<ul>
<li>blog    一些技术上的杂文</li>
<li>posts   自己的一些感悟和发牢骚</li>
<li>notes   平时遇到的一些有感悟的文字</li>
<li>books   自己读的书籍的一些简单记录</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Hugo 文章分类管理</title>
      <link>https://ynikl.github.io/blog/hugo-%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 09 Mar 2022 11:29:17 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/hugo-%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</guid>
      <description>Hugo 文章分类管理 文件夹 内容存放在content/目录下方, content/下方的子目录会形成资源URI,
例如 content/blog/doc.md 文章访问目录即为 https//XXX.github.io/blog.doc.md
分类管理 文章内容表述 (Front Matter) 使用进行分类, 默认只有tags
1 2 3 tags: - Go - fast 可以在config添加自定的分类选项
1 2 3 taxonomies: series: series category: categories 文章路径 类别 描述 地址 home 网站homepage /index.html page 指定页面 /post/页面/index.html section 分区 /section/index.html taxonomy 分类 /tags/index.html term 分类系列 /tags/go/index.html _index.md 和 index.md 在文件夹下方添加_index.md会识别成section. 在文件夹下方添加index.md会被识别成文章.
千万不要在默认的content目录下方添加index.md</description>
      <content:encoded><![CDATA[<h1 id="hugo-文章分类管理">Hugo 文章分类管理</h1>
<h2 id="文件夹">文件夹</h2>
<p>内容存放在<code>content/</code>目录下方, <code>content/</code>下方的子目录会形成资源URI,</p>
<p>例如
<code>content/blog/doc.md</code> 文章访问目录即为 <code>https//XXX.github.io/blog.doc.md</code></p>
<h2 id="分类管理-taxonomies">分类管理 <!-- raw HTML omitted --></h2>
<h2 id="文章内容表述-front-matter">文章内容表述 (Front Matter)</h2>
<p>使用<!-- raw HTML omitted -->进行分类, 默认只有tags</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">tags</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="l">Go</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="l">fast</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以在<code>config</code>添加自定的分类选项</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">taxonomies</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">series</span><span class="p">:</span><span class="w"> </span><span class="l">series</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">category</span><span class="p">:</span><span class="w"> </span><span class="l">categories</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="文章路径">文章路径</h2>
<table>
<thead>
<tr>
<th>类别</th>
<th>描述</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>home</td>
<td>网站homepage</td>
<td>/index.html</td>
</tr>
<tr>
<td>page</td>
<td>指定页面</td>
<td>/post/页面/index.html</td>
</tr>
<tr>
<td>section</td>
<td>分区</td>
<td>/section/index.html</td>
</tr>
<tr>
<td>taxonomy</td>
<td>分类</td>
<td>/tags/index.html</td>
</tr>
<tr>
<td>term</td>
<td>分类系列</td>
<td>/tags/go/index.html</td>
</tr>
</tbody>
</table>
<h2 id="_indexmd-和-indexmd"><code>_index.md</code> 和 <code>index.md</code></h2>
<p>在文件夹下方添加<code>_index.md</code>会识别成section.
在文件夹下方添加<code>index.md</code>会被识别成文章.</p>
<p><strong>千万不要在默认的content目录下方添加<code>index.md</code></strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title></title>
      <link>https://ynikl.github.io/readme/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/readme/</guid>
      <description></description>
      <content:encoded><![CDATA[]]></content:encoded>
    </item>
    
  </channel>
</rss>
