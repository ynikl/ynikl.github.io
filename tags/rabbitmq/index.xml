<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rabbitmq on 潜水员的咖啡小屋</title>
    <link>https://ynikl.github.io/tags/rabbitmq/</link>
    <description>Recent content in Rabbitmq on 潜水员的咖啡小屋</description>
    <image>
      <url>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>gilfoyle.k@outlook.com (潜水员)</managingEditor>
    <webMaster>gilfoyle.k@outlook.com (潜水员)</webMaster>
    <copyright>2022 Ian Lin All rights reserved</copyright>
    <lastBuildDate>Sat, 09 Jul 2022 16:43:26 +0800</lastBuildDate><atom:link href="https://ynikl.github.io/tags/rabbitmq/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>RabbitMQ 基本入门实践</title>
      <link>https://ynikl.github.io/blog/rabbitmq-learning-note/</link>
      <pubDate>Sat, 09 Jul 2022 16:43:26 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/rabbitmq-learning-note/</guid>
      <description>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.
介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件
消息中间件的作用
解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释
Producer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型
fanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:</description>
      <content:encoded><![CDATA[<p>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.</p>
<h2 id="介绍一下-rabbitmq">介绍一下 RabbitMQ</h2>
<p>Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件</p>
<p>消息中间件的作用</p>
<ul>
<li>解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性.</li>
<li>冗余存储: 保存失败的消息</li>
<li>拓展性</li>
<li>削峰</li>
<li>缓冲</li>
</ul>
<h3 id="结构">结构</h3>
<p>涉及的名词简单解释</p>
<ul>
<li>Producer</li>
<li>Consumer</li>
<li>Broker: 服务节点</li>
<li>Queue: 内存存储消息数据的对象</li>
<li>Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据<code>routingkey</code> 和 <code>bindingkey</code> 决定投递到哪个队列
<ul>
<li>RoutingKey: 生产消息提供<code>routingkey</code> 给交换器用于指定要投递的队列</li>
<li>BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来</li>
</ul>
</li>
<li>Connection: 客户端与 Broke 建立的 TCP 连接</li>
<li>Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接</li>
</ul>
<p>交换器的类型</p>
<ul>
<li>fanout : 投递到所有队列</li>
<li>direct: 投递到 <code>routingkey</code>  和 <code>bindingkey</code> 匹配的</li>
<li>topic: direct 的拓展, 支持模糊匹配</li>
<li>headers : 性能差, 少用</li>
</ul>
<p>消息投递流程:</p>
<ol>
<li>生产者连接到 Broker, 开启信道</li>
<li>生产者声明一个交换器</li>
<li>生产者声明一个队列</li>
<li>生产者通过路由键将交换器和队列绑定</li>
<li>生产者发送消息到 Broker</li>
<li>交换器根据接受对路由键匹配队列</li>
<li>投递到对应的消息队列</li>
<li>如果没有匹配的队列, 丢弃或者退回给生产者</li>
</ol>
<p>消费者接受消息流程:</p>
<ol>
<li>建立连接, 开启信道</li>
<li>消费者向 Broker 发起消息请求</li>
<li>Broker 回应并返回消息</li>
<li>消费者发送确认 (ack) 接受到消息</li>
<li>关闭信道</li>
<li>关闭连接</li>
</ol>
<h3 id="amqp">AMQP</h3>
<p>位于应用层的通信协议 ( 在 TCP 之上, 将数据填充到 TCP 中)</p>
<p>几个基础的协议定义的操作</p>
<ul>
<li>Protocal Header 0-9-1 指定协议</li>
<li>Connection.Start</li>
<li>Channel.Open</li>
<li>Basic.Publish 推送消息</li>
<li>Channel.Close</li>
<li>Connection.Close</li>
</ul>
<h2 id="部署">部署</h2>
<p>在你的机子上部署一个玩具吧</p>
<p>采用 docker 部署
<code>docker run -itd --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</code></p>
<p>进入管理页面
访问 http://127.0.0.1:15672/</p>
<p>登入
用户名: guest
密码: guest</p>
<p><a href="https://www.rabbitmq.com/configure.html#supported-environment-variables">更多默认配置</a></p>
<h2 id="管理">管理</h2>
<p>进入交互 shell
<code>docker exec -it rabbitmq bash</code></p>
<p>增加一个用户
<code>rabbitmqctl add_user ian ian1234</code></p>
<p>增加一个 vhost
<code>rabbitmqctl add_vhost playground</code></p>
<p>vhost是什么?
vhost (virtual host), 虚拟主机, 在实例间提供逻辑上的分离 &ndash; 实现数据隔离.
RabbitMQ 默认创建一个名为 &ldquo;/&rdquo; 的 vhost</p>
<p>查看 vhost
<code>rabbitmqctl list_vhosts</code></p>
<p>设置权限
<code>rabbitmqctl set_permissions --vhost playground ian &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></p>
<p><strong>amqp uri规则</strong>
<code>&quot;amqp://userName:password@ipAddress:portNumber/virtualHost&quot;</code>
根据我们上述的新增在用户和vhost, 可以得到uri:
<code>amqp://ian:ian1234@localhost:5672/playground</code>
5672为 rabbitmq的默认终端, 我们的 docker contain 需要把它映射到本机带端口</p>
<h2 id="实现生产者">实现生产者</h2>
<p>go 使用 <code>github.com/rabbitmq/amqp091-go</code> 包</p>
<p>根据上文的消息投递流程实现</p>
<p>连接到 broker</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">connectionUrl</span> <span class="o">:=</span> <span class="s">&#34;amqp://ian:ian1234@localhost:5672/playground&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">amqp</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">connectionUrl</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>打开 channel</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">ch</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Channel</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>声明一个交互器( 该步骤可以省略, 直接使用默认的 <code>direct</code>交换器)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">ExchangeDeclare</span><span class="p">(</span><span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="s">&#34;direct&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>声明一个队列</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">q</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">QueueDeclare</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将 Exchange 绑定到队列上 (如果声明交换器的步骤省略了, 该步骤也可以省略)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">QueueBind</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="s">&#34;hellokey&#34;</span><span class="p">,</span> <span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>发送消息 (如果没有声明交换器, 对应的参数直接传入空字符串<code>&quot;&quot;</code>, 会使用默认的 <code>direct</code> 交换器)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">Publish</span><span class="p">(</span><span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="s">&#34;hellokey&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">amqp</span><span class="p">.</span><span class="nx">Publishing</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ContentType</span><span class="p">:</span> <span class="s">&#34;text/plain&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Body</span><span class="p">:</span>        <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">body</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://github.com/ynikl/rabbitmq-demo/blob/main/cmd/producer/main.go">完整代码地址</a></p>
<p>登录到本地管理页面可以查看类似于下图, 有消息投递</p>
<p><img loading="lazy" src="/rabbitmq-producer-manager-pic-20220704.png" alt="生产消息成功"  />
</p>
<h2 id="实现消费者">实现消费者</h2>
<p>消费者相对于生产者就简单多了.
打开信道直接消费就可以了.</p>
<p>连接, 打开信道</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">connectionUrl</span> <span class="o">:=</span> <span class="s">&#34;amqp://ian:ian1234@localhost:5672/playground&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">amqp</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">connectionUrl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Channel</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>开始消费</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="c1">// msgsCh 是一个消息管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">msgsCh</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">Consume</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="s">&#34;consumer-name&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">msgsCh</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;received a message: &#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Body</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done, msg channel is closed&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/rabbitmq-receive-success-20220709.png" alt="消费成功"  />
</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.rabbitmq.com/tutorials/tutorial-one-go.html">官网 tutorial</a></li>
<li><a href="https://book.douban.com/subject/27591386/">RabbitMQ 实战指南</a></li>
</ul>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
