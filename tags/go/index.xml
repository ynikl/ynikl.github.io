<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>go on 潜水员的咖啡小屋</title>
    <link>https://ynikl.github.io/tags/go/</link>
    <description>Recent content in go on 潜水员的咖啡小屋</description>
    <image>
      <url>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sun, 29 May 2022 20:52:35 +0800</lastBuildDate><atom:link href="https://ynikl.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Go-互斥锁的实现</title>
      <link>https://ynikl.github.io/blog/go-sync_mutex/</link>
      <pubDate>Sun, 29 May 2022 20:52:35 +0800</pubDate>
      
      <guid>https://ynikl.github.io/blog/go-sync_mutex/</guid>
      <description>Mutex 数据结构 1 2 3 4  type Mutex struct { state int32 sema uint32 }    Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。  Mutex 对象总共有三个公开方法
 Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic  Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。
Mutex 实现了一个 sync.Locker 接口, 该接口只有两个方法
 Lock Unlock  Mutex 锁有几种状态
 mutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态  其他常量
 mutexWaiterShift = 3 统计的等待在Mutex.</description>
    </item>
    
    <item>
      <title>Channel</title>
      <link>https://ynikl.github.io/blog/go-channel/</link>
      <pubDate>Sat, 02 Apr 2022 10:09:22 +0800</pubDate>
      
      <guid>https://ynikl.github.io/blog/go-channel/</guid>
      <description>Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本
channel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)
 Do not communicate by sharing memory; instead, share memory by communicating.
 channel 保证:
 数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开  channel 的实现 channel 在内部实现的结构体为 runtime.hchan
 有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程  1 2 3 4 5 6 7 8 9 10 11 12 13 14  type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 	dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 	buf unsafe.</description>
    </item>
    
    <item>
      <title>Go 常用的命令汇总</title>
      <link>https://ynikl.github.io/blog/go-cmd/</link>
      <pubDate>Fri, 01 Apr 2022 19:56:59 +0800</pubDate>
      
      <guid>https://ynikl.github.io/blog/go-cmd/</guid>
      <description>工具分类 go build 编译源代码文件
-race 编译出的目标程序，会启用数据竞争检测
go doc 查看包的文档(定义于doc.go的注释中), 于包中公开的函数签名
example
1 2 3  go doc go doc encoding/json   go env 查看 go 相关的环境变量
1 2 3 4 5  # -w 设置环境变量 go env -w GOPAHT=&amp;#39;/some/path&amp;#39; # -u 恢复成默认设置 go env -u GOPATH   go generate 扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”
注释的指令格式
//go:generate command argument...
ps: wire 也是利用命令, 生成依赖注入文件
go get 管理当前module依赖
1 2 3 4 5 6 7 8  # 添加依赖包 go get example.</description>
    </item>
    
  </channel>
</rss>
