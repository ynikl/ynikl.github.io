<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Golang on 潜水员的咖啡小屋</title>
    <link>https://ynikl.github.io/tags/golang/</link>
    <description>Recent content in Golang on 潜水员的咖啡小屋</description>
    <image>
      <url>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>gilfoyle.k@outlook.com (潜水员)</managingEditor>
    <webMaster>gilfoyle.k@outlook.com (潜水员)</webMaster>
    <copyright>2022 Ian Lin All rights reserved</copyright>
    <lastBuildDate>Tue, 05 Mar 2024 20:27:39 +0800</lastBuildDate><atom:link href="https://ynikl.github.io/tags/golang/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>md5 128位但长度为32位</title>
      <link>https://ynikl.github.io/posts/md5-length/</link>
      <pubDate>Tue, 05 Mar 2024 20:27:39 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/md5-length/</guid>
      <description>背景：
后端（Golang) 接口卡控前端给的md5 值的长度， 百度md5 结构为128位长度，心理默认8位为一个字符。卡控判断md5 长度为16位，但是前端时间传入 md5 长度位32字符
原因：
golang 的 len 判断的是 字符数（bytes) md5 的结果是128位， 也即是16bytes 没错，但是通常md5会原先转成16进制，即4位一个字符，即转化成一个128/4=32 字符的字符串。传递到后端即为32位字符。</description>
      <content:encoded><![CDATA[<p>背景：</p>
<p>后端（Golang) 接口卡控前端给的md5 值的长度， 百度md5 结构为128位长度，心理默认8位为一个字符。卡控判断md5 长度为16位，但是前端时间传入 md5 长度位32字符</p>
<p>原因：</p>
<p>golang 的 len 判断的是 字符数（bytes)
md5 的结果是128位， 也即是16bytes 没错，但是通常md5会原先转成16进制，即4位一个字符，即转化成一个128/4=32 字符的字符串。传递到后端即为32位字符。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go Build Time Variable</title>
      <link>https://ynikl.github.io/posts/go-build-time-variable/</link>
      <pubDate>Mon, 20 Nov 2023 13:50:52 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/go-build-time-variable/</guid>
      <description>使用背景
一套程序代码，配置文件，需要同时在不同的云厂商运行。
通过修改 jenkins, 的部署 pipeline , 让开发人员准确的获取到当前程序的运行环境 还能保持代码统一.
ldflags 修改的变量, 无大小写限制, 小写变量也可修改编译过程进行修改
变量引用需要 fullpath. 例如 main 文件中的变量 go build -ldflags=&amp;quot;-X &#39;main/varName=xxx&#39;
子包，需要当前 mod 包名称开头。 可以查看第二篇文章
go build variable
https://programmingpercy.tech/blog/modify-variables-during-build/
发现更加简单的解决方案
go build -tags targetCloud
https://pkg.go.dev/go/build#hdr-Build_Constraints </description>
      <content:encoded><![CDATA[<p>使用背景</p>
<p>一套程序代码，配置文件，需要同时在不同的云厂商运行。</p>
<p>通过修改 jenkins, 的部署 pipeline , 让开发人员准确的获取到当前程序的运行环境
还能保持代码统一.</p>
<ul>
<li>
<p>ldflags 修改的变量, 无大小写限制, 小写变量也可修改编译过程进行修改</p>
</li>
<li>
<p>变量引用需要 fullpath. 例如 main 文件中的变量 <code>go build -ldflags=&quot;-X 'main/varName=xxx'</code></p>
</li>
<li>
<p>子包，需要当前 mod 包名称开头。 可以查看第二篇文章</p>
</li>
<li>
<p><a href="https://belief-driven-design.com/build-time-variables-in-go-51439b26ef9/">go build variable</a></p>
</li>
<li>
<p><a href="https://programmingpercy.tech/blog/modify-variables-during-build/">https://programmingpercy.tech/blog/modify-variables-during-build/</a></p>
</li>
</ul>
<p>发现更加简单的解决方案</p>
<p><code>go build -tags targetCloud</code></p>
<ul>
<li><a href="https://pkg.go.dev/go/build#hdr-Build_Constraints">https://pkg.go.dev/go/build#hdr-Build_Constraints</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>GO 代码结构中为什么老有 cmd 和 internal 文件夹</title>
      <link>https://ynikl.github.io/blog/golang-project-layout-cmd/</link>
      <pubDate>Thu, 03 Aug 2023 20:34:58 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-project-layout-cmd/</guid>
      <description>总结:
cmd 一个代码库多个启动程序, 清晰明了 internal 将外部依赖放置在 internal 外面, 避免内部逻辑代码直接引用. 比如, 数据持久层 MySQL 参考一下 ChatGPT 给我的答案:
在 Go 语言中，使用 cmd 目录和 internal 目录的组合是一种常见的方式来组织项目结构。 cmd 目录通常包含可执行程序的入口点。这些可执行程序可以是应用程序的命令行接口、工具或测试二进制文件。每个子目录都包含一个可执行程序的主要文件，以及与其关联的其他文件。这种风格使得每个程序都可以独立编译和分发，并且可以让其它人轻松了解和使用它们。
对于 internal 目录，其命名约束了该目录下的代码仅供内部使用。这意味着代码不应该由任何可以被外部依赖使用的包引用。这种风格允许对代码的控制更精细，因为程序员可以更好地控制哪些代码可以被其他人使用。
使用这样的结构来组织 Go 项目有很多好处，包括：
代码更易于维护和理解：使用独立的可执行程序和内部目录，可以让代码更清晰且更容易维护，使开发人员能够更好地理解代码的用途和位置。
扩展性强：该结构使得每个可执行程序都可以相对独立地进行开发、测试和部署。这也使得代码更有扩展和修改的完整性。
松耦合：使用 cmd 和 internal 目录方式可以大大增强代码间的松耦合度。这使得程序员可以更好地对代码变化做出反应，同时减少代码冲突及协调问题。
综上所述，使用 cmd 和 internal 目录方式更易于开发和维护，是现代化 Go 应用程序中广受欢迎的项目结构设计方式。</description>
      <content:encoded><![CDATA[<p>总结:</p>
<ul>
<li>cmd 一个代码库多个启动程序, 清晰明了</li>
<li>internal 将外部依赖放置在 internal 外面, 避免内部逻辑代码直接引用. 比如, 数据持久层 MySQL</li>
</ul>
<p>参考一下 ChatGPT 给我的答案:</p>
<blockquote>
<p>在 Go 语言中，使用 cmd 目录和 internal 目录的组合是一种常见的方式来组织项目结构。
cmd 目录通常包含可执行程序的入口点。这些可执行程序可以是应用程序的命令行接口、工具或测试二进制文件。每个子目录都包含一个可执行程序的主要文件，以及与其关联的其他文件。这种风格使得每个程序都可以独立编译和分发，并且可以让其它人轻松了解和使用它们。</p>
<p>对于 internal 目录，其命名约束了该目录下的代码仅供内部使用。这意味着代码不应该由任何可以被外部依赖使用的包引用。这种风格允许对代码的控制更精细，因为程序员可以更好地控制哪些代码可以被其他人使用。</p>
<p>使用这样的结构来组织 Go 项目有很多好处，包括：</p>
<p>代码更易于维护和理解：使用独立的可执行程序和内部目录，可以让代码更清晰且更容易维护，使开发人员能够更好地理解代码的用途和位置。</p>
<p>扩展性强：该结构使得每个可执行程序都可以相对独立地进行开发、测试和部署。这也使得代码更有扩展和修改的完整性。</p>
<p>松耦合：使用 cmd 和 internal 目录方式可以大大增强代码间的松耦合度。这使得程序员可以更好地对代码变化做出反应，同时减少代码冲突及协调问题。</p>
<p>综上所述，使用 cmd 和 internal 目录方式更易于开发和维护，是现代化 Go 应用程序中广受欢迎的项目结构设计方式。</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang 100 mistake 的简单读书笔记</title>
      <link>https://ynikl.github.io/blog/golang-100mistake/</link>
      <pubDate>Thu, 25 May 2023 12:10:53 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-100mistake/</guid>
      <description>variable shadowing init 弊端
初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序 影响测试， 会在测试之前执行 获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试） 什么时候使用
避免错误产生没有err 不会产生全局变量 getters and setters 如果只是简单获取值的话，就不应该用
方法命名
获取值 Balance 而不是 （ GetBalance) 设置值 SetBalance interface pollution interface 的价值
通用的方法（ 如排序） 解耦 限制实体行为（仅提供特定方法） 只要在当我们真正用到的时候才去创建
we should create an interface when we need it, not when we foresee that we could need it
interface 抽象 是通过发现的，而不是通过创造的
生产端接口声明，与实现放在同一个包中 消费端接口声明，与使用interface的放在同一个包中 Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。
准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。
return interfaceBe conservative in what you do, be liberal in fr Be conservative in what you do, be liberal in what you accept from others.</description>
      <content:encoded><![CDATA[<h3 id="variable-shadowing">variable shadowing</h3>
<h3 id="init">init</h3>
<p>弊端</p>
<ol>
<li>初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序</li>
<li>影响测试， 会在测试之前执行</li>
<li>获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试）</li>
</ol>
<p>什么时候使用</p>
<ol>
<li>避免错误产生没有err</li>
<li>不会产生全局变量</li>
</ol>
<h3 id="getters-and-setters">getters and setters</h3>
<p>如果只是简单获取值的话，就不应该用</p>
<p>方法命名</p>
<ul>
<li>获取值 Balance 而不是 （ GetBalance)</li>
<li>设置值 SetBalance</li>
</ul>
<h3 id="interface-pollution">interface pollution</h3>
<p>interface 的价值</p>
<ul>
<li>通用的方法（ 如排序）</li>
<li>解耦</li>
<li>限制实体行为（仅提供特定方法）</li>
</ul>
<p>只要在当我们真正用到的时候才去创建</p>
<p>we should create an interface when we need it, not when we foresee that we could need it</p>
<p>interface 抽象 是通过发现的，而不是通过创造的</p>
<ul>
<li>生产端接口声明，与实现放在同一个包中</li>
<li>消费端接口声明，与使用interface的放在同一个包中</li>
</ul>
<p>Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。</p>
<p>准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。</p>
<h3 id="return-interfacebe-conservative-in-what-you-do-be-liberal-in-fr">return interfaceBe conservative in what you do, be liberal in fr</h3>
<p>Be conservative in what you do, be liberal in what you accept from others.</p>
<p>对自己依赖别人的功能保守，对自己赋予别人的能力保持开放</p>
<ul>
<li>尽量接收 interface</li>
<li>尽量返回 结构体</li>
</ul>
<p>正常 consumer 定义接口， 就会造成循环引用</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/12365435/1674099857741-bb77c007-cc4e-4f15-abd7-16bf11de95c5.png" alt=""  />
</p>
<p>如果 是现房new 的时候返回 interface 就会变成，由实现方来限制了限制了客户端使用接口消费的抽象组合方式</p>
<h3 id="confuse-generics">Confuse Generics</h3>
<p>限制 constraint， 可以是一下两种</p>
<ul>
<li>接口</li>
<li>任意类型</li>
</ul>
<p>~int， 限制 底层类型</p>
<h3 id="embbding">embbding</h3>
<p>错误使用将底层的方法公开出来</p>
<p>type client struct {
sync.Mutex // 错误地将 Lock() 和 Unlock() 方法暴露给客户端了
protectData map[string]string
}</p>
<p>Functional Options Parttern</p>
<p>定义闭包声明函数，更新和修改配置， 有几个好处</p>
<ul>
<li>使用默认配置时， 避免声明空的 cfg 参数结构体</li>
<li>通过闭包延迟 err 的处理， 聚合在客户端内部</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">type</span> <span class="n">options</span> <span class="n">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">port</span> <span class="o">*</span><span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">type</span> <span class="n">Option</span> <span class="k">func</span><span class="p">(</span><span class="n">opt</span> <span class="n">options</span><span class="p">)</span> <span class="n">error</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">func</span> <span class="n">WithPort</span><span class="p">(</span><span class="n">port</span> <span class="ne">int</span><span class="p">)</span> <span class="n">Option</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">opt</span> <span class="n">options</span><span class="p">)</span> <span class="n">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">opt</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">func</span> <span class="n">NewServer</span><span class="p">(</span><span class="n">c</span> <span class="n">client</span><span class="p">,</span> <span class="n">opts</span> <span class="o">...</span><span class="n">Option</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">var</span> <span class="n">cfg</span> <span class="n">options</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">op</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">opts</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       	<span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NewServer</span><span class="p">(</span><span class="n">http</span><span class="o">.</span><span class="n">DefaultClient</span><span class="p">,</span> <span class="n">WihtPort</span><span class="p">(</span><span class="mi">8080</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="12-project-organization">12 Project Organization</h3>
<p><a href="https://github.com/golang-standards/project-layout">project-layout</a></p>
<p>We should minimize what should be exported as much as possible to reduce the coupling between pack-<br>
ages and keep unnecessary exported elements hidden.</p>
<p>包的成员，非必要不公开。</p>
<h3 id="13-utility-package">13 Utility Package</h3>
<p>创建类似与 common ， utility, base， shared 等没有意义的包名，共享一些工具类代码。</p>
<h3 id="14-ignoring-package-name-collisions">14 Ignoring Package name collisions</h3>
<p>避免包名和变量名冲突</p>
<ul>
<li>使用不同的变量名<code>redisClient</code></li>
<li>对引用的包取别名 <code>redisPkg</code></li>
</ul>
<h3 id="15-missing-code-documentation">15 Missing code documentation</h3>
<ol>
<li>exported 的公开变量 都需要进行文档备注</li>
<li><code>Deprecated: //</code></li>
<li>Package 的说明应该在 <code>doc.go</code> 文件 <code>// Package 包名</code>开头</li>
<li>与 Go 代码声明有空行间隔 会被忽略</li>
</ol>
<h3 id="16-not-using-linters">16 Not using linters</h3>
<h3 id="17-creating-confusion-with-octal-literal">17 Creating confusion with octal literal</h3>
<p>错误使用 010， 表示八进制</p>
<ul>
<li>0b 二进制</li>
<li>0x 十六进制</li>
<li>0i 虚数</li>
</ul>
<h3 id="18-integer-overflow">18 Integer Overflow</h3>
<p>整形溢出， 多注意</p>
<h3 id="19-floating-points">19 floating points</h3>
<h3 id="20-slice-length-and-capactity">20 slice length and capactity</h3>
<p>the slice length is the number of available elements in the slice,<br>
whereas the slice capacity is the number of elements in the backing arra</p>
<p>长度是 slice 可用的长度， 容量是slice底层数据的长度</p>
<h3 id="22-slice-empty-and-nil">22 slice empty and nil</h3>
<p>slice nil</p>
<ul>
<li>不需要分配内存， nil slice 是 empty slice</li>
</ul>
<p>empty slice</p>
<ul>
<li>长度等于 0</li>
</ul>
<h3 id="23-check-slice-by-nil">23 check slice by nil</h3>
<p>通过 <code>list == nil</code> 判断 slice 是否为空，是错误的</p>
<p>要通过长度判断 <code>len(list)</code>判断 slice 是否为空。</p>
<h3 id="24-copy-slice">24 copy slice</h3>
<p>赋值数量为最小两个slice 之间最小长度</p>
<p>复制之前应该，注意复制的目标数组的长度</p>
<p>src := []int{0, 1, 2}
dst := make([]int, len(src))
copy(dst, src)
fmt.Println(dst)</p>
<p>不同的复制方式</p>
<p>src := []int{0, 1, 2}
dst := append([]int(nil), src&hellip;)</p>
<h3 id="25-切片更新添加数据副作用">25 切片更新添加数据副作用</h3>
<p>s1 := []int{1,2,3}
s2 := s1[1:2]
s3 := append(s2, 10}</p>
<p>// Output:
// s1 [1, 2, 10]</p>
<h3 id="26-slice-导致内存泄露">26 slice 导致内存泄露</h3>
<p>使用切变承接输入的大数据数组， 获取小部分数据。</p>
<p>小数据的slice， 仍然会指向大数组的空间，内存占用仍会较高。</p>
<p>需要重新声明 slice， 使用copy 复制需要的数据。</p>
<p>GC 不会回收 slice 已经分配但没有使用的空间。</p>
<h3 id="27--map-初始化">27  Map 初始化</h3>
<p><code>load factor</code>
<code>overflowed</code></p>
<p>make(map, hint_size)
初始化 map, 带预计大小, 可以避免map 在插入的时候, 需要复制.</p>
<ul>
<li>获取足够的内存</li>
<li>重新平衡分配元素到各个bucket</li>
</ul>
<h3 id="28-map-memory-leaks">28 map memory leaks</h3>
<p><code>A map can only grow and have more buckets; it never shrinks.</code></p>
<p>GC 可以回收 map 的元素, 但是无法回收 map 本身占用的空间大小.</p>
<p>解决方法</p>
<ul>
<li>创建副本, 创建一个新的map, 复制现有的值, 释放原有的map</li>
<li>map的value 存放 指针, 缩小每一个空的bucket 占用的空间大小 (指针空间 8bytes or 4bytes)</li>
</ul>
<h3 id="29-值比较">29 值比较</h3>
<p> Booleans—Compare whether two Booleans are equal.<br>
 Numerics (int, float, and complex types)—Compare whether two numerics are equal.</p>
<ul>
<li>
<p> Strings—Compare whether two strings are equal.</p>
</li>
<li>
<p>  Channels—Compare whether two channels were created by the same call to</p>
<p>make or if both are nil.</p>
</li>
<li>
<p>  Interfaces—Compare whether two interfaces have identical dynamic types and</p>
<p>equal dynamic values or if both are nil.</p>
</li>
<li>
<p>  Pointers—Compare whether two pointers point to the same value in memory or</p>
<p>if both are nil.</p>
</li>
<li>
<p>  Structs and arrays—Compare whether they are composed of similar types.</p>
</li>
</ul>
<p>对比方法</p>
<ul>
<li>简单通过 <code>==</code>  对比, 无法处理复杂类型</li>
<li><code>reflect.DeepEuqal</code> 有性能瓶颈</li>
<li>自己实现对比方法, 参考已经有标准库, 如<code>bytes.Compare</code></li>
</ul>
<h3 id="30-copy-value-in-range">30 copy value in range</h3>
<p>在 <code>range</code> 遍历的过程中, 是值复制</p>
<h3 id="31-range-expresion-evaluated">31 range expresion evaluated</h3>
<p><code>for i, v := range exp</code>
exp 针对不同类型表达式, 会在 开始执行 loop 之前, 对exp 进行复制</p>
<h4 id="slice">slice</h4>
<p>range 会在开始range的时候, 计算slice 的长度和容量, 并创建一个临时的 slice</p>
<p>![[Pasted image 20230221093451.png]]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">s := []int{0, 1, 2}
</span></span><span class="line"><span class="cl">for i := 0; i &lt; len(s); i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    s = append(s, 10)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>会无限执行下去, 因为 <code>len</code> 是每次执行的时候都会计算一次</p>
<h4 id="channel">channel</h4>
<p>与slice 一样, 同样会在开始的时候为 channel 创建一个临时变量.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ch := ch1
</span></span><span class="line"><span class="cl">for v := range ch {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    fmt.Println(v)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ch = ch2 }
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个在range 这替换的动作是无效的, range 的仍然是ch1</p>
<h4 id="array">array</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [3]int{0, 1, 2}
</span></span><span class="line"><span class="cl">for i, v := range a {
</span></span><span class="line"><span class="cl">    a[2] = 10
</span></span><span class="line"><span class="cl">    if i == 2 {
</span></span><span class="line"><span class="cl">        fmt.Println(v)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>会对 a 整个数据进行复制, 输出是2, 原数组不变</p>
<p>修改原数组方案</p>
<ul>
<li>使用 index , 访问和修改数据</li>
<li>对数据取指针方法 <code>for i, v := range &amp;a</code></li>
</ul>
<h3 id="32-range-过程中使用-遍历元素的指针">32 range 过程中使用 遍历元素的指针</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for _, customer := range customers {
</span></span><span class="line"><span class="cl">        s.m[customer.ID] = &amp;customer
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>&amp;customer</code> 指向的是 range 复制出来的内存</p>
<h3 id="33-对-map-数据的错误消费">33 对 map 数据的错误消费</h3>
<ol>
<li>依赖 map 的顺序， map 的数据是无序的</li>
<li>在遍历过程中继续插入新的数据， 结果是不可预测的。有可能会被遍历到，也有可能会被跳过</li>
</ol>
<h3 id="34-break-层的错误理解">34 break 层的错误理解</h3>
<p>break 对 for, select, switch 三个语句的最内层生效</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for i := 0; i &lt; 5; i++ {
</span></span><span class="line"><span class="cl">	switch i {
</span></span><span class="line"><span class="cl">	case 2:
</span></span><span class="line"><span class="cl">	break
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>没有中断， 结果正常遍历。</p>
<p>可以使用 Label 达到中断 for 的方式， 标准库也经常采用该种写法。</p>
<h3 id="35-在-for-中使用-defer">35 在 for 中使用 defer</h3>
<h3 id="36-没有理解-rune">36 没有理解 rune</h3>
<p>string 是一个结构体, 有两个字段</p>
<ul>
<li>A pointer to an immutable byte sequence</li>
<li>长度</li>
</ul>
<p>Unicode 是字符集
Utf-8 是编码方式</p>
<p>Rune 是 Unicode 的字符集表示，相当于一个字符, golang 使用utf-8编码方式， 所以一个rune 是1-4个字节 bytes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type rune = int32
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>len()</code>函数返回的是 bytes 的长度</p>
<h3 id="37-对-string-的错误遍历">37 对 string 的错误遍历</h3>
<p>获取字符串的字符个数 <code>utf8.RuneCountInString</code></p>
<p>获取字符串的第i个字符</p>
<ol>
<li>如果是纯ascii码字符串，直接通过str[i]获取。 获取出来的是 bytes 编码需要转成字符</li>
<li>如果存在非ascii 字符
<ol>
<li>通过 <code>for i, c := range str</code>遍历获取到第 i 个 rune 字符， 和 c 字符编码</li>
<li>通过索引获取， 需要先强制转化成 <code>[]rune(str)[i]</code> 可以直接获取字符串的第 i 个 rune 字符</li>
</ol>
</li>
</ol>
<h3 id="38-对-trimright--trimsuffix-混淆">38 对 TrimRight / TrimSuffix 混淆</h3>
<p>strings.TrimRight 是从右到开始移除所有符合的字符集，直到遇到第一个不符合的字符
TrimSuffix 是移除整个字符串</p>
<h3 id="39-使用--字符串拼接">39 使用 += 字符串拼接</h3>
<p>使用 += 拼接一系列字符串，会造成内存分配频繁，因为每一个字串都是不变的。
推荐使用 <code>strings.Builder</code></p>
<h3 id="40-冗余转化成字符串">40 冗余转化成字符串</h3>
<p>所有的字符串操作 strings 包， 在 bytes 包都会有相对应的替换方法，没有必要将 bytes 转化成 string 在进行操作。</p>
<h3 id="41-substring-导致内存泄露">41 subString 导致内存泄露</h3>
<p>substring 生成的 新字符串与旧字符串指向同一块内存，原理同slice</p>
<h3 id="42-方法值接受者和指针接收者">42 方法值接受者和指针接收者</h3>
<p>pointer receiver</p>
<ul>
<li>需要修改对象数据</li>
<li>接收者包含不能copy的对象，如 sync</li>
<li>接收者为大对象</li>
</ul>
<p>value receiver</p>
<ul>
<li>不修改接收者</li>
<li>接收者为 map, channel</li>
<li>接收者为小对象， 基础类型</li>
</ul>
<h3 id="43-命名的返回参数">43 命名的返回参数</h3>
<p>用处</p>
<ol>
<li>增加代码可读性， 如果无法增加可读性，就不需要命名</li>
<li>提前初始化变量</li>
<li>使用 naked return 的提前是函数短小，太长的函数会降低可读性，需要一直记住变量</li>
<li>不应改混着使用 naked return 和 带参数return</li>
</ol>
<h3 id="44-返回了未赋值的命名-err">44 返回了未赋值的命名 err</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">func</span> <span class="n">name</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ne">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Err</span><span class="p">()</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="n">err</span> <span class="n">is</span> <span class="n">nil</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="45-interface-返回-non-nil">45 interface 返回 non-nil</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">func</span> <span class="n">Validate</span><span class="p">()</span> <span class="n">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">var</span> <span class="n">m</span> <span class="o">*</span><span class="n">MutilErrorStruct</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">m</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="err">返回值</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="err">永远为</span><span class="bp">true</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>nil 的结构体， 在返回 interface 的函数之后就永远不等于 nil
![[Pasted image 20230309221827.png]]</p>
<p>解决方案，永远明确地返回 nil</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if m != nil {
</span></span><span class="line"><span class="cl">	return m
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">return nil
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="46-不用使用文件名作为参数">46 不用使用文件名作为参数</h3>
<p>使用 io.Reader 做为参数, 替代文件有两种好处</p>
<ol>
<li>方法的具体实现可以与数据源的类型无关, 文件, 或者http, 或者sock</li>
<li>方便测试, 无法因为测试而创建一堆文件</li>
</ol>
<h3 id="47-defer-参数的计算">47 defer 参数的计算</h3>
<p>defer 在代码执行到的时候会, 立刻使用当前函数的参数的变量值, 包括方法的接收者作为参数.</p>
<h3 id="48-panic">48 panic</h3>
<p>什么时候应该panic</p>
<ul>
<li>a pure programmer error ( 程序员编码错误 )</li>
<li>依赖初始化失败</li>
</ul>
<h3 id="49-error-wrap">49 Error Wrap</h3>
<p>什么时候使用 Error Wrap</p>
<ul>
<li>添加额外的信息</li>
<li>标记为某一特定的错误类型</li>
</ul>
<p>处理的信息的多种选择</p>
<ul>
<li>直接返回错误</li>
<li>自定义错误类型</li>
<li>fmt.Errorf + %w wrap 错误</li>
<li>fmt.Errorf + %v 包含错误文字</li>
</ul>
<p><img loading="lazy" src="https://s2.loli.net/2023/03/21/CPdiq867VhUcAwW.png" alt="错误处理的多种选择"  />
</p>
<h3 id="50-用-as-检查err类型">50 用 as 检查Err类型</h3>
<p>通过 wrap 的 error 需要使用 <code>error.As(err, &amp;targetErrorStruct{})</code> 判断是否为目标结构体</p>
<h3 id="51-errosis">51 erros.Is</h3>
<p>制定 error 错误信息的原则:</p>
<ol>
<li>可以预测的错误使用制定错误变量 <code>ErrFoo = errors.New(&quot;foo&quot;)</code></li>
<li>无法预测的错误,使用指定错误类型 <code>type BarError struct</code></li>
</ol>
<p>使用 <code>error.Is(err, sql.ErrNoRows)</code> 判断错误是否为指定的错误类型.</p>
<h3 id="52-多次处理同一个错误">52 多次处理同一个错误</h3>
<p>一个错误多次重复打日志, 会让调试更加艰难.</p>
<blockquote>
<p>打印错误也是一种错误的处理方式. 所有, 要么选择打印错误, 要么选择向上抛出错误.
不要两者同时.</p>
</blockquote>
<p>向上层函数抛出错误的时候, 需要通过 WrapErr 附加上当前的额外错误信息</p>
<h3 id="53-明确忽略的-error">53 明确忽略的 error</h3>
<p>使用 <code>_</code> 接收返回的error, 明确表示不处理, 错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> _ = funcReturnErr()
</span></span></code></pre></td></tr></table>
</div>
</div><p>建议再加上注释说明为什么不处理函数错误</p>
<h3 id="54-处理-defer-函数返回的错误">54 处理 defer 函数返回的错误</h3>
<p>记得要处理 defer 的函数返回的错误, 至少需要显示忽略</p>
<h3 id="55-并发和并行">55 并发和并行</h3>
<p>并发的重点是可以处理多项事务的设计结构, 并行是多项事务可以同时进行处理.</p>
<blockquote>
<p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.
—Rob Pike</p>
</blockquote>
<p>并发并不代表多件事务真正意义上的&quot;同时进行&quot;, 同时进行是并行, 并发主要处理阻塞的流程
优化</p>
<h3 id="56-并发-不一定更快">56 并发 不一定更快</h3>
<p>过小的切分任务, 会让时间消耗在创建和消费协程上, 并没有真正的提高&quot;并行&quot;能力.</p>
<h3 id="57-通道和互斥锁">57 通道和互斥锁</h3>
<p>通道的底层也是互斥锁.</p>
<p>当协程之间需要传递信息, 或者数据, 使用通道 &ndash; 互斥锁的更高抽象</p>
<h3 id="58-数据竞争data-race-和条件竞争race-condition">58 数据竞争(data race) 和条件竞争(race condition)</h3>
<p>数据竞争:</p>
<p>同时有多个协程同时访问统一块内存, 且至少有一个协程正在写入数据</p>
<p>条件竞争:</p>
<p>事件发生的先后顺序不可控制, 无法控制协程的执行先后顺序, 导致结果不可控.</p>
<h3 id="59-区分任务类型-计算密集或者-io密集型">59 区分任务类型 (计算密集或者 I/O密集型)</h3>
<p>如果是计算密集型, goroutine 的并发上线应该采用 <code>runtime.GOMAXPROCS(0)</code></p>
<p>过多的协程, 可能导致创建过得的 M, 就会出现多个 M 在一个 cpu 核心 中疯狂切换.</p>
<h3 id="60-conetxt">60 Conetxt</h3>
<ul>
<li>Deadline 设置超时时间 <code>context.WithTimeout</code></li>
<li>传递取消消息 <code>context.WithCancel</code></li>
<li>传递值 <code>context.WithValue</code></li>
<li><code>context.Err</code> 会返回解释, 为何<code>context.Done</code>关闭</li>
</ul>
<p>传递值时, key 不直接使用 string 是为了避免, 冲突覆盖.</p>
<blockquote>
<p>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables&rsquo; static type should be a pointer or interface.</p>
</blockquote>
<p>疑惑的时候就使用 <code>context.TODO</code></p>
<blockquote>
<p>When in doubt about which context to use, we should use context.TODO() instead of passing an empty context with context.Background.</p>
</blockquote>
<h3 id="61-传递-context">61 传递 context</h3>
<h3 id="62-关心-goroutine-什么时候停止">62 关心 goroutine 什么时候停止</h3>
<p>关心 goroutine 持有的文件描述符是否被正确的关闭
注意协程持有的资源</p>
<h3 id="63-注意-goroutine-获取循环变量">63 注意 goroutine 获取循环变量</h3>
<h3 id="64-select-是随机-case-先后顺序不保证优先级">64 select 是随机, case 先后顺序不保证优先级.</h3>
<h3 id="65-消息型-channel">65 消息型 channel</h3>
<p>消息型 channel 的数据结构应该使用 <code>make(chan struct{})</code> 空结构体, 编程惯例, 提醒
接收者, 传递的消息是没有任何意义的.</p>
<h3 id="66-使用-nil-channel">66 使用 nil channel</h3>
<p>在使用 select 的时候, 当 channel 已经 close 掉后, 就可以将channel 设置成 <code>nil</code> ,
让该 case 条件进入堵塞状态</p>
<h3 id="67-分清-buffed-and-unbeffed-channel-的使用场景">67 分清 buffed and unbeffed channel 的使用场景</h3>
<h3 id="68-string-format-的副作用">68 string format 的副作用</h3>
<p>如果有协程正在更新 ctx, context的值的话, 就会出现数据竞争, fmt 读取ctx的内部值</p>
<p><code>ctxKey := fmt.Sprintf(&quot;%v&quot;, ctx)</code></p>
<p>fmt 会读取 <code>string()</code> 的方法, 应注意该方法中的读写锁是否会造成死锁.</p>
<h3 id="69-append-的数据竞争">69 append 的数据竞争</h3>
<p>slice 更新和读取不通的index时不会出问题.</p>
<p>map 操作时存在更新, 无论key是否相同有可能产生冲突. 因为, map 的底层是数组, 不同的
key 也有可能指向相同的数组</p>
<h3 id="70">70</h3>
<h3 id="71-wgadd-在协程开启前">71 wg.Add 在协程开启前</h3>
<h3 id="72-sycncond">72 sycn.cond</h3>
<h3 id="73-errgroup">73 errgroup</h3>
<h3 id="74-sync-包不能被复制-要小心值复制">74 sync 包不能被复制, 要小心值复制</h3>
<h3 id="75-timeduration-的时间单位是-纳秒">75 time.Duration 的时间单位是 纳秒</h3>
<p>标准使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1 * time.Second
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="76-timeafte-导致内存泄露">76 time.Afte 导致内存泄露</h3>
<p>方法内部实现的协程, 需要等到时间到了, 才会释放资源, 所以不要在循环中调用.</p>
<h3 id="77-结构体-序列化和反序列化">77 结构体 序列化和反序列化</h3>
<h4 id="结构体嵌套">结构体嵌套</h4>
<p>直接嵌入未命名的结构体, 可能会使用sub embedding struct 的序列化接口方法, 导致bug</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type a struct {
</span></span><span class="line"><span class="cl">ID int 
</span></span><span class="line"><span class="cl">time.Time
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>a 结构体再序列化的时候会使用 <code>time.Time</code> 的<code>MarshalJSON()</code>的方法</p>
<ul>
<li>使用命名结构体接入</li>
<li>重新实现接口方法</li>
</ul>
<h4 id="time-的对比">time 的对比</h4>
<p>time 内部包含 wall clock 和 montonic clock 字段, 返回序列化后的 time 对象, 不包含
montonic clock 直接对比, 会不相同</p>
<blockquote>
<p>The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time.</p>
</blockquote>
<ul>
<li>可以使用 <code>time.Equal</code> 方法</li>
<li>或者使用 <code>Truncate</code> 移除 monotonic clock 数值</li>
</ul>
<h4 id="map">map</h4>
<p><code>map[string]any</code> 数值反序列化后类型都为 float64</p>
<h3 id="78-sql-错误">78 SQL 错误</h3>
<h4 id="sqlopen">sql.Open</h4>
<p><code>sql.Open()</code> 不一定是与数据库服务建立了连接, 具体还是需要看 驱动 实现, 可以通过
ping 方法, 强制建立连接</p>
<h4 id="sql-连接池的配置">sql 连接池的配置</h4>
<p>sql 连接状态分两种</p>
<ul>
<li>使用者</li>
<li>idle 等待使用, 已创建但没有再使用</li>
</ul>
<p>sql 连接池配置</p>
<ul>
<li>SetMaxOpenConns 最大连接数量, 考虑到下游服务的性能</li>
<li>SetMaxIdleConn 在并发高时适当增加, 避免创建耗时</li>
<li>SetConnMaxIdleTime 并发增加之后, 维持多久销毁连接</li>
<li>SetConnMaxLifetime 不希望一个连接持续过久</li>
</ul>
<h4 id="sqlprepared-语句">sql.prepared 语句</h4>
<ul>
<li>高效: 更加高效, 避免 SQL 重复编译</li>
<li>安全: 避免SQL注入</li>
</ul>
<h4 id="string-处理-null-值">string 处理 null 值</h4>
<ul>
<li>使用指针声明 <code>*string</code></li>
<li>使用 <code>sql.NullString</code> 类型</li>
</ul>
<h4 id="rowserr-错误捕获">rows.Err 错误捕获</h4>
<h3 id="79-资源关闭">79 资源关闭</h3>
<p>实现 <code>io.Closer</code> 的临时资源需要 及时 close</p>
<ul>
<li>http 请求的客户端, respBody 需要close</li>
<li>sql.Rows</li>
<li>os.File</li>
</ul>
<h3 id="80-http-handle-忘记-return">80 http handle 忘记 return</h3>
<h3 id="81-使用-默认http-client-和-server">81 使用 默认http client 和 server</h3>
<h4 id="client">client</h4>
<p>http 的请求步骤</p>
<ol>
<li>dial</li>
<li>tls 握手</li>
<li>send</li>
<li>read header</li>
<li>read body</li>
</ol>
<p><img loading="lazy" src="./__assets/100mistake-http-step1to5.png" alt="100mistake-http-step1to5"  />
</p>
<p>4个超时配置</p>
<ol>
<li><code>net.Dialer.Timeout</code> 建立连接超时</li>
<li><code>http.Transport.TLSHandshakeTimeout</code> TLS 握手超时</li>
<li><code>http.Transport.ResponseHeaderTimeout</code> 等待服务返回头此时</li>
<li><code>http.Client.Timeout</code> 这个请求的时间限制, from 上述步骤1到5</li>
</ol>
<p><code>net/http: request canceled (Client.Timeout exceeded while awaiting headers)</code> 报错
服务端返回超时, 在step4, 读取头时等待超时.</p>
<p>http 连接池</p>
<ul>
<li><code>http.Transport.IdleConnTimeout</code></li>
<li><code>http.Transport.MaxIdleConns</code></li>
<li><code>http.Transport.MaxIdleConnsPerHost</code> 默认为2, 严重影响并发</li>
</ul>
<h4 id="server">server</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">server := &amp;http.Server{}
</span></span><span class="line"><span class="cl">server.Serve(listener)
</span></span></code></pre></td></tr></table>
</div>
</div><p>服务端步骤</p>
<ol>
<li>等待请求</li>
<li>TLS</li>
<li>read request headers</li>
<li>read request body</li>
<li>write response</li>
</ol>
<p>3个 timeout</p>
<ul>
<li><code>http.Sever.ReadHeadersTimeout</code></li>
<li><code>http.Server.ReadTimeout</code></li>
<li><code>http.TimeoutHandler</code></li>
<li><code>http.Server.IdleTimeout</code> keep-alive 请求可以保持多久</li>
</ul>
<p><code>TimeoutHanlder 包裹 handle 当处理超时时,返回503</code></p>
<p><img loading="lazy" src="./__assets/100mistake-server-timeout1-5.png" alt="100mistake-server-timeout1-5"  />
</p>
<p>如果都没有配置超时的话, 服务器就没有超时机制, 会一直等待客户端主动关闭连接.
当服务暴露给不信任客户端时, 至少需要配置 ReadTimeout 和 TimeoutHandler 避免资源被耗尽.</p>
<h3 id="82-对单元测试进行分类">82 对单元测试进行分类</h3>
<p>避免执行不需要单元测试, 提升测试效率.</p>
<ol>
<li>使用 tag <code>go test --tags=integration -v .</code></li>
<li>根据环境变量, 使用<code>testing.Skip()</code> 显示调用为什么跳过测试</li>
<li>使用 <code>testing.Short()</code> 判断当前执行模式, 跳过需要长时间耗时的测试 <code>go test -short -v .</code></li>
</ol>
<h3 id="83-测试启用---race">83 测试启用 &ndash;race</h3>
<p>编译时带 <code>--race</code> 会增加程序消耗</p>
<ul>
<li>内存提高5-10倍</li>
<li>运行时间2-20倍</li>
</ul>
<p>避免在生产环境使用, 在CI的时候使用</p>
<h3 id="84-test-的执行模式">84 test 的执行模式</h3>
<p>parallel</p>
<p><code>testing.T.Parallel()</code> 会先暂停, 等待顺序测试任务完成后, 继续执行.</p>
<p><code>go test - parallel 16 .</code> 并发执行测试</p>
<p>shuffle</p>
<p><code>go test -shuffle=on -v .</code> 打乱 go test 函数的执行顺序</p>
<h3 id="85-table-driven-表驱动测试">85 Table-driven 表驱动测试</h3>
<p><code>t.Run(name, func(t *testing.T) {})</code></p>
<p>执行子测试
<code>go test -run=TestFoo/subtest_1 -v</code></p>
<h3 id="86-避免测试中的-sleep">86 避免测试中的 sleep</h3>
<p>在并发场景下, 我们使用 <code>time.Sleep</code> 模拟, 任务处理耗时, 但是我们不知道时间是否足够</p>
<ol>
<li>使用多次尝试校验, retry</li>
<li>mock 对象使用消息通知校验</li>
</ol>
<h3 id="87-处理依赖时间测试">87 处理依赖时间测试</h3>
<ul>
<li>改变依赖, 造假数据</li>
<li>修改方法, 让接口传入时间</li>
</ul>
<h3 id="88-单测工具包">88 单测工具包</h3>
<p>http 相关</p>
<ul>
<li>httptest.NewServer</li>
<li>httptest.NewRequest</li>
</ul>
<p>iotest</p>
<h3 id="89-正确使用-benchmark-测试">89 正确使用 benchmark 测试</h3>
<ul>
<li>忽略耗时函数</li>
<li>忽略对硬件底层</li>
</ul>
<h3 id="90-单元测试的拓展功能">90 单元测试的拓展功能</h3>
<ul>
<li>TestMain</li>
<li>从不同的包测试 ( 重视包对外的开放功能)</li>
<li>cover 单测覆盖率</li>
</ul>
<h3 id="91-cpu-cache">91 CPU cache</h3>
<p>cpu 三级缓存</p>
<p><img loading="lazy" src="./__assets/100mistakecpucache.png" alt="100mistakecpucache"  />
</p>
<ul>
<li>cpu cache Line 加载的  locality of reference, 局部性和相关性</li>
<li>cache line 一般 64 bytes,</li>
</ul>
<p>CPU 内存加载预测</p>
<ul>
<li>Unit stride</li>
<li>Constant stride</li>
<li>Non-Unit stride</li>
</ul>
<h3 id="92-通过-padding-避免并发操作相同内存复制到不同cpu-core-中">92 通过 padding 避免并发操作相同内存复制到不同cpu core 中</h3>
<p>cpu 会有cache line 加载数据, 如果两个协程, 并发操作的不同的数据字段(在同一块cache line 大小内存中)
内存中. 这块内存会被同时加载到不同的cpu 核心的缓存中. 因为cpu MESI保证内存一致, 一边更新另一边会失效.</p>
<blockquote>
<p>When a cache line is shared across multiple cores and at least one goroutine is a writer, the entire cache line is invalidated.</p>
</blockquote>
<p>使用 pading , 将同时操作的内存分到不同cache line 中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type result struct {
</span></span><span class="line"><span class="cl">	sumA int64
</span></span><span class="line"><span class="cl">	_ [56]byte // padding
</span></span><span class="line"><span class="cl">	sumB int64
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="93-考虑指令集优化">93 考虑指令集优化</h3>
<ul>
<li></li>
</ul>
<h3 id="94-内存对齐">94 内存对齐</h3>
<p>内存对齐可以减少结构体占用的内存大小.</p>
<p>结构体的内存对齐系数, 为各字段中最大的系数</p>
<p><a href="https://go.dev/ref/spec#Size%20and%20alignment%20guarantees">官方文档</a></p>
<h3 id="95-stack--heap">95 stack &amp;&amp; heap</h3>
<p>栈内存是不需要GC, 只是会根据栈的大小范围表示为不可用, 再次使用的时候, 新值直接覆盖旧值.</p>
<p>当变量内存分配到栈上, 且函数退出, 变量引用表示不可用 &ndash; 无法再次访问, 所以需要 堆.</p>
<p>堆的使用成本更大, 需要GC, 内存分配成本也更大.</p>
<h3 id="96-优化内存分配">96 优化内存分配</h3>
<ul>
<li>string.Builder 代替 +</li>
<li>避免 []byte 转 string</li>
<li>slice map 的初始化</li>
<li>结构体内存对齐</li>
<li>改变 interface 声明, 避免内存逃逸</li>
<li>sync.Pool</li>
<li>编译器优化, 避免 bytes-to-string 转化</li>
</ul>
<h3 id="97-编译器函数内联">97 编译器函数内联</h3>
<p>inline. 当调用的子函数较为简单时, 编译器会是将调用函数的内部实现嵌入当前调用点.</p>
<ul>
<li>避免函数的调用成本</li>
<li>可以使编译器进一步优化 (比如, 内存逃逸 直接分配到栈中)</li>
</ul>
<p>当子函数过为复杂时, 可以抽出子函数的复杂部分为另一个调用函数实现 mid inline. 让中间函数嵌入调用点.</p>
<h3 id="98-使用分析工具">98 使用分析工具</h3>
<ul>
<li>pprof</li>
<li>trace</li>
</ul>
<h3 id="99-gc">99 GC</h3>
<p>marks and sweep</p>
<ul>
<li>遍历所有对象, 标记是否在使用</li>
<li>遍历所以对象, 清除没有在使用的对象</li>
</ul>
<p>GOGC 配置 GC 的敏感度, 当 GOGC=100 时, 当堆内存容量涨100%时触发GC.</p>
<ul>
<li><a href="https://xargin.com/dynamic-gogc/">通过 GOGC 进行优化</a></li>
<li><a href="https://www.uber.com/en-TW/blog/how-we-saved-70k-cores-across-30-mission-critical-services/">uber 调优原文</a></li>
<li><a href="https://blog.ideawand.com/2020/08/01/go-gc-tuning-practice-1/">GOGC 调优</a></li>
</ul>
<h3 id="100-docker-和-k8s-资源分配对并发性能的影响">100 Docker 和 K8s 资源分配对并发性能的影响</h3>
<p>引用 <code>http://github.com/uber-go/automaxprocs</code> 自动设置 GOPROMAX</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang 100 mistake 的简单读书笔记</title>
      <link>https://ynikl.github.io/books/golang-100mistake/</link>
      <pubDate>Thu, 25 May 2023 12:10:53 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/books/golang-100mistake/</guid>
      <description>variable shadowing init 弊端
初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序 影响测试， 会在测试之前执行 获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试） 什么时候使用
避免错误产生没有err 不会产生全局变量 getters and setters 如果只是简单获取值的话，就不应该用
方法命名
获取值 Balance 而不是 （ GetBalance) 设置值 SetBalance interface pollution interface 的价值
通用的方法（ 如排序） 解耦 限制实体行为（仅提供特定方法） 只要在当我们真正用到的时候才去创建
we should create an interface when we need it, not when we foresee that we could need it
interface 抽象 是通过发现的，而不是通过创造的
生产端接口声明，与实现放在同一个包中 消费端接口声明，与使用interface的放在同一个包中 Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。
准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。
return interfaceBe conservative in what you do, be liberal in fr Be conservative in what you do, be liberal in what you accept from others.</description>
      <content:encoded><![CDATA[<h3 id="variable-shadowing">variable shadowing</h3>
<h3 id="init">init</h3>
<p>弊端</p>
<ol>
<li>初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序</li>
<li>影响测试， 会在测试之前执行</li>
<li>获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试）</li>
</ol>
<p>什么时候使用</p>
<ol>
<li>避免错误产生没有err</li>
<li>不会产生全局变量</li>
</ol>
<h3 id="getters-and-setters">getters and setters</h3>
<p>如果只是简单获取值的话，就不应该用</p>
<p>方法命名</p>
<ul>
<li>获取值 Balance 而不是 （ GetBalance)</li>
<li>设置值 SetBalance</li>
</ul>
<h3 id="interface-pollution">interface pollution</h3>
<p>interface 的价值</p>
<ul>
<li>通用的方法（ 如排序）</li>
<li>解耦</li>
<li>限制实体行为（仅提供特定方法）</li>
</ul>
<p>只要在当我们真正用到的时候才去创建</p>
<p>we should create an interface when we need it, not when we foresee that we could need it</p>
<p>interface 抽象 是通过发现的，而不是通过创造的</p>
<ul>
<li>生产端接口声明，与实现放在同一个包中</li>
<li>消费端接口声明，与使用interface的放在同一个包中</li>
</ul>
<p>Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。</p>
<p>准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。</p>
<h3 id="return-interfacebe-conservative-in-what-you-do-be-liberal-in-fr">return interfaceBe conservative in what you do, be liberal in fr</h3>
<p>Be conservative in what you do, be liberal in what you accept from others.</p>
<p>对自己依赖别人的功能保守，对自己赋予别人的能力保持开放</p>
<ul>
<li>尽量接收 interface</li>
<li>尽量返回 结构体</li>
</ul>
<p>正常 consumer 定义接口， 就会造成循环引用</p>
<p><img loading="lazy" src="https://cdn.nlark.com/yuque/0/2023/png/12365435/1674099857741-bb77c007-cc4e-4f15-abd7-16bf11de95c5.png" alt=""  />
</p>
<p>如果 是现房new 的时候返回 interface 就会变成，由实现方来限制了限制了客户端使用接口消费的抽象组合方式</p>
<h3 id="confuse-generics">Confuse Generics</h3>
<p>限制 constraint， 可以是一下两种</p>
<ul>
<li>接口</li>
<li>任意类型</li>
</ul>
<p>~int， 限制 底层类型</p>
<h3 id="embbding">embbding</h3>
<p>错误使用将底层的方法公开出来</p>
<p>type client struct {
sync.Mutex // 错误地将 Lock() 和 Unlock() 方法暴露给客户端了
protectData map[string]string
}</p>
<p>Functional Options Parttern</p>
<p>定义闭包声明函数，更新和修改配置， 有几个好处</p>
<ul>
<li>使用默认配置时， 避免声明空的 cfg 参数结构体</li>
<li>通过闭包延迟 err 的处理， 聚合在客户端内部</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="n">type</span> <span class="n">options</span> <span class="n">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">port</span> <span class="o">*</span><span class="ne">int</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">type</span> <span class="n">Option</span> <span class="k">func</span><span class="p">(</span><span class="n">opt</span> <span class="n">options</span><span class="p">)</span> <span class="n">error</span> 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">func</span> <span class="n">WithPort</span><span class="p">(</span><span class="n">port</span> <span class="ne">int</span><span class="p">)</span> <span class="n">Option</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="k">func</span><span class="p">(</span><span class="n">opt</span> <span class="n">options</span><span class="p">)</span> <span class="n">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">opt</span><span class="o">.</span><span class="n">port</span> <span class="o">=</span> <span class="n">port</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">func</span> <span class="n">NewServer</span><span class="p">(</span><span class="n">c</span> <span class="n">client</span><span class="p">,</span> <span class="n">opts</span> <span class="o">...</span><span class="n">Option</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">var</span> <span class="n">cfg</span> <span class="n">options</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">op</span> <span class="p">:</span><span class="o">=</span> <span class="nb">range</span> <span class="n">opts</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">       	<span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">op</span><span class="p">(</span><span class="n">cfg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">            
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="n">NewServer</span><span class="p">(</span><span class="n">http</span><span class="o">.</span><span class="n">DefaultClient</span><span class="p">,</span> <span class="n">WihtPort</span><span class="p">(</span><span class="mi">8080</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="12-project-organization">12 Project Organization</h3>
<p><a href="https://github.com/golang-standards/project-layout">project-layout</a></p>
<p>We should minimize what should be exported as much as possible to reduce the coupling between pack-<br>
ages and keep unnecessary exported elements hidden.</p>
<p>包的成员，非必要不公开。</p>
<h3 id="13-utility-package">13 Utility Package</h3>
<p>创建类似与 common ， utility, base， shared 等没有意义的包名，共享一些工具类代码。</p>
<h3 id="14-ignoring-package-name-collisions">14 Ignoring Package name collisions</h3>
<p>避免包名和变量名冲突</p>
<ul>
<li>使用不同的变量名<code>redisClient</code></li>
<li>对引用的包取别名 <code>redisPkg</code></li>
</ul>
<h3 id="15-missing-code-documentation">15 Missing code documentation</h3>
<ol>
<li>exported 的公开变量 都需要进行文档备注</li>
<li><code>Deprecated: //</code></li>
<li>Package 的说明应该在 <code>doc.go</code> 文件 <code>// Package 包名</code>开头</li>
<li>与 Go 代码声明有空行间隔 会被忽略</li>
</ol>
<h3 id="16-not-using-linters">16 Not using linters</h3>
<h3 id="17-creating-confusion-with-octal-literal">17 Creating confusion with octal literal</h3>
<p>错误使用 010， 表示八进制</p>
<ul>
<li>0b 二进制</li>
<li>0x 十六进制</li>
<li>0i 虚数</li>
</ul>
<h3 id="18-integer-overflow">18 Integer Overflow</h3>
<p>整形溢出， 多注意</p>
<h3 id="19-floating-points">19 floating points</h3>
<h3 id="20-slice-length-and-capactity">20 slice length and capactity</h3>
<p>the slice length is the number of available elements in the slice,<br>
whereas the slice capacity is the number of elements in the backing arra</p>
<p>长度是 slice 可用的长度， 容量是slice底层数据的长度</p>
<h3 id="22-slice-empty-and-nil">22 slice empty and nil</h3>
<p>slice nil</p>
<ul>
<li>不需要分配内存， nil slice 是 empty slice</li>
</ul>
<p>empty slice</p>
<ul>
<li>长度等于 0</li>
</ul>
<h3 id="23-check-slice-by-nil">23 check slice by nil</h3>
<p>通过 <code>list == nil</code> 判断 slice 是否为空，是错误的</p>
<p>要通过长度判断 <code>len(list)</code>判断 slice 是否为空。</p>
<h3 id="24-copy-slice">24 copy slice</h3>
<p>赋值数量为最小两个slice 之间最小长度</p>
<p>复制之前应该，注意复制的目标数组的长度</p>
<p>src := []int{0, 1, 2}
dst := make([]int, len(src))
copy(dst, src)
fmt.Println(dst)</p>
<p>不同的复制方式</p>
<p>src := []int{0, 1, 2}
dst := append([]int(nil), src&hellip;)</p>
<h3 id="25-切片更新添加数据副作用">25 切片更新添加数据副作用</h3>
<p>s1 := []int{1,2,3}
s2 := s1[1:2]
s3 := append(s2, 10}</p>
<p>// Output:
// s1 [1, 2, 10]</p>
<h3 id="26-slice-导致内存泄露">26 slice 导致内存泄露</h3>
<p>使用切变承接输入的大数据数组， 获取小部分数据。</p>
<p>小数据的slice， 仍然会指向大数组的空间，内存占用仍会较高。</p>
<p>需要重新声明 slice， 使用copy 复制需要的数据。</p>
<p>GC 不会回收 slice 已经分配但没有使用的空间。</p>
<h3 id="27--map-初始化">27  Map 初始化</h3>
<p><code>load factor</code>
<code>overflowed</code></p>
<p>make(map, hint_size)
初始化 map, 带预计大小, 可以避免map 在插入的时候, 需要复制.</p>
<ul>
<li>获取足够的内存</li>
<li>重新平衡分配元素到各个bucket</li>
</ul>
<h3 id="28-map-memory-leaks">28 map memory leaks</h3>
<p><code>A map can only grow and have more buckets; it never shrinks.</code></p>
<p>GC 可以回收 map 的元素, 但是无法回收 map 本身占用的空间大小.</p>
<p>解决方法</p>
<ul>
<li>创建副本, 创建一个新的map, 复制现有的值, 释放原有的map</li>
<li>map的value 存放 指针, 缩小每一个空的bucket 占用的空间大小 (指针空间 8bytes or 4bytes)</li>
</ul>
<h3 id="29-值比较">29 值比较</h3>
<p> Booleans—Compare whether two Booleans are equal.<br>
 Numerics (int, float, and complex types)—Compare whether two numerics are equal.</p>
<ul>
<li>
<p> Strings—Compare whether two strings are equal.</p>
</li>
<li>
<p>  Channels—Compare whether two channels were created by the same call to</p>
<p>make or if both are nil.</p>
</li>
<li>
<p>  Interfaces—Compare whether two interfaces have identical dynamic types and</p>
<p>equal dynamic values or if both are nil.</p>
</li>
<li>
<p>  Pointers—Compare whether two pointers point to the same value in memory or</p>
<p>if both are nil.</p>
</li>
<li>
<p>  Structs and arrays—Compare whether they are composed of similar types.</p>
</li>
</ul>
<p>对比方法</p>
<ul>
<li>简单通过 <code>==</code>  对比, 无法处理复杂类型</li>
<li><code>reflect.DeepEuqal</code> 有性能瓶颈</li>
<li>自己实现对比方法, 参考已经有标准库, 如<code>bytes.Compare</code></li>
</ul>
<h3 id="30-copy-value-in-range">30 copy value in range</h3>
<p>在 <code>range</code> 遍历的过程中, 是值复制</p>
<h3 id="31-range-expresion-evaluated">31 range expresion evaluated</h3>
<p><code>for i, v := range exp</code>
exp 针对不同类型表达式, 会在 开始执行 loop 之前, 对exp 进行复制</p>
<h4 id="slice">slice</h4>
<p>range 会在开始range的时候, 计算slice 的长度和容量, 并创建一个临时的 slice</p>
<p>![[Pasted image 20230221093451.png]]</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">s := []int{0, 1, 2}
</span></span><span class="line"><span class="cl">for i := 0; i &lt; len(s); i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    s = append(s, 10)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>会无限执行下去, 因为 <code>len</code> 是每次执行的时候都会计算一次</p>
<h4 id="channel">channel</h4>
<p>与slice 一样, 同样会在开始的时候为 channel 创建一个临时变量.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ch := ch1
</span></span><span class="line"><span class="cl">for v := range ch {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    fmt.Println(v)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">ch = ch2 }
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个在range 这替换的动作是无效的, range 的仍然是ch1</p>
<h4 id="array">array</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [3]int{0, 1, 2}
</span></span><span class="line"><span class="cl">for i, v := range a {
</span></span><span class="line"><span class="cl">    a[2] = 10
</span></span><span class="line"><span class="cl">    if i == 2 {
</span></span><span class="line"><span class="cl">        fmt.Println(v)
</span></span><span class="line"><span class="cl">    }
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>会对 a 整个数据进行复制, 输出是2, 原数组不变</p>
<p>修改原数组方案</p>
<ul>
<li>使用 index , 访问和修改数据</li>
<li>对数据取指针方法 <code>for i, v := range &amp;a</code></li>
</ul>
<h3 id="32-range-过程中使用-遍历元素的指针">32 range 过程中使用 遍历元素的指针</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for _, customer := range customers {
</span></span><span class="line"><span class="cl">        s.m[customer.ID] = &amp;customer
</span></span><span class="line"><span class="cl">    }
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>&amp;customer</code> 指向的是 range 复制出来的内存</p>
<h3 id="33-对-map-数据的错误消费">33 对 map 数据的错误消费</h3>
<ol>
<li>依赖 map 的顺序， map 的数据是无序的</li>
<li>在遍历过程中继续插入新的数据， 结果是不可预测的。有可能会被遍历到，也有可能会被跳过</li>
</ol>
<h3 id="34-break-层的错误理解">34 break 层的错误理解</h3>
<p>break 对 for, select, switch 三个语句的最内层生效</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">for i := 0; i &lt; 5; i++ {
</span></span><span class="line"><span class="cl">	switch i {
</span></span><span class="line"><span class="cl">	case 2:
</span></span><span class="line"><span class="cl">	break
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>没有中断， 结果正常遍历。</p>
<p>可以使用 Label 达到中断 for 的方式， 标准库也经常采用该种写法。</p>
<h3 id="35-在-for-中使用-defer">35 在 for 中使用 defer</h3>
<h3 id="36-没有理解-rune">36 没有理解 rune</h3>
<p>string 是一个结构体, 有两个字段</p>
<ul>
<li>A pointer to an immutable byte sequence</li>
<li>长度</li>
</ul>
<p>Unicode 是字符集
Utf-8 是编码方式</p>
<p>Rune 是 Unicode 的字符集表示，相当于一个字符, golang 使用utf-8编码方式， 所以一个rune 是1-4个字节 bytes.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type rune = int32
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>len()</code>函数返回的是 bytes 的长度</p>
<h3 id="37-对-string-的错误遍历">37 对 string 的错误遍历</h3>
<p>获取字符串的字符个数 <code>utf8.RuneCountInString</code></p>
<p>获取字符串的第i个字符</p>
<ol>
<li>如果是纯ascii码字符串，直接通过str[i]获取。 获取出来的是 bytes 编码需要转成字符</li>
<li>如果存在非ascii 字符
<ol>
<li>通过 <code>for i, c := range str</code>遍历获取到第 i 个 rune 字符， 和 c 字符编码</li>
<li>通过索引获取， 需要先强制转化成 <code>[]rune(str)[i]</code> 可以直接获取字符串的第 i 个 rune 字符</li>
</ol>
</li>
</ol>
<h3 id="38-对-trimright--trimsuffix-混淆">38 对 TrimRight / TrimSuffix 混淆</h3>
<p>strings.TrimRight 是从右到开始移除所有符合的字符集，直到遇到第一个不符合的字符
TrimSuffix 是移除整个字符串</p>
<h3 id="39-使用--字符串拼接">39 使用 += 字符串拼接</h3>
<p>使用 += 拼接一系列字符串，会造成内存分配频繁，因为每一个字串都是不变的。
推荐使用 <code>strings.Builder</code></p>
<h3 id="40-冗余转化成字符串">40 冗余转化成字符串</h3>
<p>所有的字符串操作 strings 包， 在 bytes 包都会有相对应的替换方法，没有必要将 bytes 转化成 string 在进行操作。</p>
<h3 id="41-substring-导致内存泄露">41 subString 导致内存泄露</h3>
<p>substring 生成的 新字符串与旧字符串指向同一块内存，原理同slice</p>
<h3 id="42-方法值接受者和指针接收者">42 方法值接受者和指针接收者</h3>
<p>pointer receiver</p>
<ul>
<li>需要修改对象数据</li>
<li>接收者包含不能copy的对象，如 sync</li>
<li>接收者为大对象</li>
</ul>
<p>value receiver</p>
<ul>
<li>不修改接收者</li>
<li>接收者为 map, channel</li>
<li>接收者为小对象， 基础类型</li>
</ul>
<h3 id="43-命名的返回参数">43 命名的返回参数</h3>
<p>用处</p>
<ol>
<li>增加代码可读性， 如果无法增加可读性，就不需要命名</li>
<li>提前初始化变量</li>
<li>使用 naked return 的提前是函数短小，太长的函数会降低可读性，需要一直记住变量</li>
<li>不应改混着使用 naked return 和 带参数return</li>
</ol>
<h3 id="44-返回了未赋值的命名-err">44 返回了未赋值的命名 err</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">func</span> <span class="n">name</span><span class="p">(</span><span class="n">ctx</span> <span class="n">context</span><span class="o">.</span><span class="n">Context</span><span class="p">)</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ne">int</span><span class="p">,</span> <span class="n">err</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="n">ctx</span><span class="o">.</span><span class="n">Err</span><span class="p">()</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="n">err</span> <span class="n">is</span> <span class="n">nil</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="45-interface-返回-non-nil">45 interface 返回 non-nil</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">func</span> <span class="n">Validate</span><span class="p">()</span> <span class="n">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">var</span> <span class="n">m</span> <span class="o">*</span><span class="n">MutilErrorStruct</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">m</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="o">//</span> <span class="err">返回值</span> <span class="n">err</span> <span class="o">!=</span> <span class="n">nil</span> <span class="err">永远为</span><span class="bp">true</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>nil 的结构体， 在返回 interface 的函数之后就永远不等于 nil
![[Pasted image 20230309221827.png]]</p>
<p>解决方案，永远明确地返回 nil</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">if m != nil {
</span></span><span class="line"><span class="cl">	return m
</span></span><span class="line"><span class="cl">}
</span></span><span class="line"><span class="cl">return nil
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="46-不用使用文件名作为参数">46 不用使用文件名作为参数</h3>
<p>使用 io.Reader 做为参数, 替代文件有两种好处</p>
<ol>
<li>方法的具体实现可以与数据源的类型无关, 文件, 或者http, 或者sock</li>
<li>方便测试, 无法因为测试而创建一堆文件</li>
</ol>
<h3 id="47-defer-参数的计算">47 defer 参数的计算</h3>
<p>defer 在代码执行到的时候会, 立刻使用当前函数的参数的变量值, 包括方法的接收者作为参数.</p>
<h3 id="48-panic">48 panic</h3>
<p>什么时候应该panic</p>
<ul>
<li>a pure programmer error ( 程序员编码错误 )</li>
<li>依赖初始化失败</li>
</ul>
<h3 id="49-error-wrap">49 Error Wrap</h3>
<p>什么时候使用 Error Wrap</p>
<ul>
<li>添加额外的信息</li>
<li>标记为某一特定的错误类型</li>
</ul>
<p>处理的信息的多种选择</p>
<ul>
<li>直接返回错误</li>
<li>自定义错误类型</li>
<li>fmt.Errorf + %w wrap 错误</li>
<li>fmt.Errorf + %v 包含错误文字</li>
</ul>
<p><img loading="lazy" src="https://s2.loli.net/2023/03/21/CPdiq867VhUcAwW.png" alt="错误处理的多种选择"  />
</p>
<h3 id="50-用-as-检查err类型">50 用 as 检查Err类型</h3>
<p>通过 wrap 的 error 需要使用 <code>error.As(err, &amp;targetErrorStruct{})</code> 判断是否为目标结构体</p>
<h3 id="51-errosis">51 erros.Is</h3>
<p>制定 error 错误信息的原则:</p>
<ol>
<li>可以预测的错误使用制定错误变量 <code>ErrFoo = errors.New(&quot;foo&quot;)</code></li>
<li>无法预测的错误,使用指定错误类型 <code>type BarError struct</code></li>
</ol>
<p>使用 <code>error.Is(err, sql.ErrNoRows)</code> 判断错误是否为指定的错误类型.</p>
<h3 id="52-多次处理同一个错误">52 多次处理同一个错误</h3>
<p>一个错误多次重复打日志, 会让调试更加艰难.</p>
<blockquote>
<p>打印错误也是一种错误的处理方式. 所有, 要么选择打印错误, 要么选择向上抛出错误.
不要两者同时.</p>
</blockquote>
<p>向上层函数抛出错误的时候, 需要通过 WrapErr 附加上当前的额外错误信息</p>
<h3 id="53-明确忽略的-error">53 明确忽略的 error</h3>
<p>使用 <code>_</code> 接收返回的error, 明确表示不处理, 错误</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"> _ = funcReturnErr()
</span></span></code></pre></td></tr></table>
</div>
</div><p>建议再加上注释说明为什么不处理函数错误</p>
<h3 id="54-处理-defer-函数返回的错误">54 处理 defer 函数返回的错误</h3>
<p>记得要处理 defer 的函数返回的错误, 至少需要显示忽略</p>
<h3 id="55-并发和并行">55 并发和并行</h3>
<p>并发的重点是可以处理多项事务的设计结构, 并行是多项事务可以同时进行处理.</p>
<blockquote>
<p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.
—Rob Pike</p>
</blockquote>
<p>并发并不代表多件事务真正意义上的&quot;同时进行&quot;, 同时进行是并行, 并发主要处理阻塞的流程
优化</p>
<h3 id="56-并发-不一定更快">56 并发 不一定更快</h3>
<p>过小的切分任务, 会让时间消耗在创建和消费协程上, 并没有真正的提高&quot;并行&quot;能力.</p>
<h3 id="57-通道和互斥锁">57 通道和互斥锁</h3>
<p>通道的底层也是互斥锁.</p>
<p>当协程之间需要传递信息, 或者数据, 使用通道 &ndash; 互斥锁的更高抽象</p>
<h3 id="58-数据竞争data-race-和条件竞争race-condition">58 数据竞争(data race) 和条件竞争(race condition)</h3>
<p>数据竞争:</p>
<p>同时有多个协程同时访问统一块内存, 且至少有一个协程正在写入数据</p>
<p>条件竞争:</p>
<p>事件发生的先后顺序不可控制, 无法控制协程的执行先后顺序, 导致结果不可控.</p>
<h3 id="59-区分任务类型-计算密集或者-io密集型">59 区分任务类型 (计算密集或者 I/O密集型)</h3>
<p>如果是计算密集型, goroutine 的并发上线应该采用 <code>runtime.GOMAXPROCS(0)</code></p>
<p>过多的协程, 可能导致创建过得的 M, 就会出现多个 M 在一个 cpu 核心 中疯狂切换.</p>
<h3 id="60-conetxt">60 Conetxt</h3>
<ul>
<li>Deadline 设置超时时间 <code>context.WithTimeout</code></li>
<li>传递取消消息 <code>context.WithCancel</code></li>
<li>传递值 <code>context.WithValue</code></li>
<li><code>context.Err</code> 会返回解释, 为何<code>context.Done</code>关闭</li>
</ul>
<p>传递值时, key 不直接使用 string 是为了避免, 冲突覆盖.</p>
<blockquote>
<p>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables&rsquo; static type should be a pointer or interface.</p>
</blockquote>
<p>疑惑的时候就使用 <code>context.TODO</code></p>
<blockquote>
<p>When in doubt about which context to use, we should use context.TODO() instead of passing an empty context with context.Background.</p>
</blockquote>
<h3 id="61-传递-context">61 传递 context</h3>
<h3 id="62-关心-goroutine-什么时候停止">62 关心 goroutine 什么时候停止</h3>
<p>关心 goroutine 持有的文件描述符是否被正确的关闭
注意协程持有的资源</p>
<h3 id="63-注意-goroutine-获取循环变量">63 注意 goroutine 获取循环变量</h3>
<h3 id="64-select-是随机-case-先后顺序不保证优先级">64 select 是随机, case 先后顺序不保证优先级.</h3>
<h3 id="65-消息型-channel">65 消息型 channel</h3>
<p>消息型 channel 的数据结构应该使用 <code>make(chan struct{})</code> 空结构体, 编程惯例, 提醒
接收者, 传递的消息是没有任何意义的.</p>
<h3 id="66-使用-nil-channel">66 使用 nil channel</h3>
<p>在使用 select 的时候, 当 channel 已经 close 掉后, 就可以将channel 设置成 <code>nil</code> ,
让该 case 条件进入堵塞状态</p>
<h3 id="67-分清-buffed-and-unbeffed-channel-的使用场景">67 分清 buffed and unbeffed channel 的使用场景</h3>
<h3 id="68-string-format-的副作用">68 string format 的副作用</h3>
<p>如果有协程正在更新 ctx, context的值的话, 就会出现数据竞争, fmt 读取ctx的内部值</p>
<p><code>ctxKey := fmt.Sprintf(&quot;%v&quot;, ctx)</code></p>
<p>fmt 会读取 <code>string()</code> 的方法, 应注意该方法中的读写锁是否会造成死锁.</p>
<h3 id="69-append-的数据竞争">69 append 的数据竞争</h3>
<p>slice 更新和读取不通的index时不会出问题.</p>
<p>map 操作时存在更新, 无论key是否相同有可能产生冲突. 因为, map 的底层是数组, 不同的
key 也有可能指向相同的数组</p>
<h3 id="70">70</h3>
<h3 id="71-wgadd-在协程开启前">71 wg.Add 在协程开启前</h3>
<h3 id="72-sycncond">72 sycn.cond</h3>
<h3 id="73-errgroup">73 errgroup</h3>
<h3 id="74-sync-包不能被复制-要小心值复制">74 sync 包不能被复制, 要小心值复制</h3>
<h3 id="75-timeduration-的时间单位是-纳秒">75 time.Duration 的时间单位是 纳秒</h3>
<p>标准使用</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1 * time.Second
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="76-timeafte-导致内存泄露">76 time.Afte 导致内存泄露</h3>
<p>方法内部实现的协程, 需要等到时间到了, 才会释放资源, 所以不要在循环中调用.</p>
<h3 id="77-结构体-序列化和反序列化">77 结构体 序列化和反序列化</h3>
<h4 id="结构体嵌套">结构体嵌套</h4>
<p>直接嵌入未命名的结构体, 可能会使用sub embedding struct 的序列化接口方法, 导致bug</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type a struct {
</span></span><span class="line"><span class="cl">ID int 
</span></span><span class="line"><span class="cl">time.Time
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>a 结构体再序列化的时候会使用 <code>time.Time</code> 的<code>MarshalJSON()</code>的方法</p>
<ul>
<li>使用命名结构体接入</li>
<li>重新实现接口方法</li>
</ul>
<h4 id="time-的对比">time 的对比</h4>
<p>time 内部包含 wall clock 和 montonic clock 字段, 返回序列化后的 time 对象, 不包含
montonic clock 直接对比, 会不相同</p>
<blockquote>
<p>The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time.</p>
</blockquote>
<ul>
<li>可以使用 <code>time.Equal</code> 方法</li>
<li>或者使用 <code>Truncate</code> 移除 monotonic clock 数值</li>
</ul>
<h4 id="map">map</h4>
<p><code>map[string]any</code> 数值反序列化后类型都为 float64</p>
<h3 id="78-sql-错误">78 SQL 错误</h3>
<h4 id="sqlopen">sql.Open</h4>
<p><code>sql.Open()</code> 不一定是与数据库服务建立了连接, 具体还是需要看 驱动 实现, 可以通过
ping 方法, 强制建立连接</p>
<h4 id="sql-连接池的配置">sql 连接池的配置</h4>
<p>sql 连接状态分两种</p>
<ul>
<li>使用者</li>
<li>idle 等待使用, 已创建但没有再使用</li>
</ul>
<p>sql 连接池配置</p>
<ul>
<li>SetMaxOpenConns 最大连接数量, 考虑到下游服务的性能</li>
<li>SetMaxIdleConn 在并发高时适当增加, 避免创建耗时</li>
<li>SetConnMaxIdleTime 并发增加之后, 维持多久销毁连接</li>
<li>SetConnMaxLifetime 不希望一个连接持续过久</li>
</ul>
<h4 id="sqlprepared-语句">sql.prepared 语句</h4>
<ul>
<li>高效: 更加高效, 避免 SQL 重复编译</li>
<li>安全: 避免SQL注入</li>
</ul>
<h4 id="string-处理-null-值">string 处理 null 值</h4>
<ul>
<li>使用指针声明 <code>*string</code></li>
<li>使用 <code>sql.NullString</code> 类型</li>
</ul>
<h4 id="rowserr-错误捕获">rows.Err 错误捕获</h4>
<h3 id="79-资源关闭">79 资源关闭</h3>
<p>实现 <code>io.Closer</code> 的临时资源需要 及时 close</p>
<ul>
<li>http 请求的客户端, respBody 需要close</li>
<li>sql.Rows</li>
<li>os.File</li>
</ul>
<h3 id="80-http-handle-忘记-return">80 http handle 忘记 return</h3>
<h3 id="81-使用-默认http-client-和-server">81 使用 默认http client 和 server</h3>
<h4 id="client">client</h4>
<p>http 的请求步骤</p>
<ol>
<li>dial</li>
<li>tls 握手</li>
<li>send</li>
<li>read header</li>
<li>read body</li>
</ol>
<p><img loading="lazy" src="./100mistake-http-step1to5.png" alt="100mistake-http-step1to5"  />
</p>
<p>4个超时配置</p>
<ol>
<li><code>net.Dialer.Timeout</code> 建立连接超时</li>
<li><code>http.Transport.TLSHandshakeTimeout</code> TLS 握手超时</li>
<li><code>http.Transport.ResponseHeaderTimeout</code> 等待服务返回头此时</li>
<li><code>http.Client.Timeout</code> 这个请求的时间限制, from 上述步骤1到5</li>
</ol>
<p><code>net/http: request canceled (Client.Timeout exceeded while awaiting headers)</code> 报错
服务端返回超时, 在step4, 读取头时等待超时.</p>
<p>http 连接池</p>
<ul>
<li><code>http.Transport.IdleConnTimeout</code></li>
<li><code>http.Transport.MaxIdleConns</code></li>
<li><code>http.Transport.MaxIdleConnsPerHost</code> 默认为2, 严重影响并发</li>
</ul>
<h4 id="server">server</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">server := &amp;http.Server{}
</span></span><span class="line"><span class="cl">server.Serve(listener)
</span></span></code></pre></td></tr></table>
</div>
</div><p>服务端步骤</p>
<ol>
<li>等待请求</li>
<li>TLS</li>
<li>read request headers</li>
<li>read request body</li>
<li>write response</li>
</ol>
<p>3个 timeout</p>
<ul>
<li><code>http.Sever.ReadHeadersTimeout</code></li>
<li><code>http.Server.ReadTimeout</code></li>
<li><code>http.TimeoutHandler</code></li>
<li><code>http.Server.IdleTimeout</code> keep-alive 请求可以保持多久</li>
</ul>
<p><code>TimeoutHanlder 包裹 handle 当处理超时时,返回503</code></p>
<p><img loading="lazy" src="./100mistake-server-timeout1-5.png" alt="100mistake-server-timeout1-5"  />
</p>
<p>如果都没有配置超时的话, 服务器就没有超时机制, 会一直等待客户端主动关闭连接.
当服务暴露给不信任客户端时, 至少需要配置 ReadTimeout 和 TimeoutHandler 避免资源被耗尽.</p>
<h3 id="82-对单元测试进行分类">82 对单元测试进行分类</h3>
<p>避免执行不需要单元测试, 提升测试效率.</p>
<ol>
<li>使用 tag <code>go test --tags=integration -v .</code></li>
<li>根据环境变量, 使用<code>testing.Skip()</code> 显示调用为什么跳过测试</li>
<li>使用 <code>testing.Short()</code> 判断当前执行模式, 跳过需要长时间耗时的测试 <code>go test -short -v .</code></li>
</ol>
<h3 id="83-测试启用---race">83 测试启用 &ndash;race</h3>
<p>编译时带 <code>--race</code> 会增加程序消耗</p>
<ul>
<li>内存提高5-10倍</li>
<li>运行时间2-20倍</li>
</ul>
<p>避免在生产环境使用, 在CI的时候使用</p>
<h3 id="84-test-的执行模式">84 test 的执行模式</h3>
<p>parallel</p>
<p><code>testing.T.Parallel()</code> 会先暂停, 等待顺序测试任务完成后, 继续执行.</p>
<p><code>go test - parallel 16 .</code> 并发执行测试</p>
<p>shuffle</p>
<p><code>go test -shuffle=on -v .</code> 打乱 go test 函数的执行顺序</p>
<h3 id="85-table-driven-表驱动测试">85 Table-driven 表驱动测试</h3>
<p><code>t.Run(name, func(t *testing.T) {})</code></p>
<p>执行子测试
<code>go test -run=TestFoo/subtest_1 -v</code></p>
<h3 id="86-避免测试中的-sleep">86 避免测试中的 sleep</h3>
<p>在并发场景下, 我们使用 <code>time.Sleep</code> 模拟, 任务处理耗时, 但是我们不知道时间是否足够</p>
<ol>
<li>使用多次尝试校验, retry</li>
<li>mock 对象使用消息通知校验</li>
</ol>
<h3 id="87-处理依赖时间测试">87 处理依赖时间测试</h3>
<ul>
<li>改变依赖, 造假数据</li>
<li>修改方法, 让接口传入时间</li>
</ul>
<h3 id="88-单测工具包">88 单测工具包</h3>
<p>http 相关</p>
<ul>
<li>httptest.NewServer</li>
<li>httptest.NewRequest</li>
</ul>
<p>iotest</p>
<h3 id="89-正确使用-benchmark-测试">89 正确使用 benchmark 测试</h3>
<ul>
<li>忽略耗时函数</li>
<li>忽略对硬件底层</li>
</ul>
<h3 id="90-单元测试的拓展功能">90 单元测试的拓展功能</h3>
<ul>
<li>TestMain</li>
<li>从不同的包测试 ( 重视包对外的开放功能)</li>
<li>cover 单测覆盖率</li>
</ul>
<h3 id="91-cpu-cache">91 CPU cache</h3>
<p>cpu 三级缓存</p>
<p><img loading="lazy" src="./100mistakecpucache.png" alt="100mistakecpucache"  />
</p>
<ul>
<li>cpu cache Line 加载的  locality of reference, 局部性和相关性</li>
<li>cache line 一般 64 bytes,</li>
</ul>
<p>CPU 内存加载预测</p>
<ul>
<li>Unit stride</li>
<li>Constant stride</li>
<li>Non-Unit stride</li>
</ul>
<h3 id="92-通过-padding-避免并发操作相同内存复制到不同cpu-core-中">92 通过 padding 避免并发操作相同内存复制到不同cpu core 中</h3>
<p>cpu 会有cache line 加载数据, 如果两个协程, 并发操作的不同的数据字段(在同一块cache line 大小内存中)
内存中. 这块内存会被同时加载到不同的cpu 核心的缓存中. 因为cpu MESI保证内存一致, 一边更新另一边会失效.</p>
<blockquote>
<p>When a cache line is shared across multiple cores and at least one goroutine is a writer, the entire cache line is invalidated.</p>
</blockquote>
<p>使用 pading , 将同时操作的内存分到不同cache line 中</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type result struct {
</span></span><span class="line"><span class="cl">	sumA int64
</span></span><span class="line"><span class="cl">	_ [56]byte // padding
</span></span><span class="line"><span class="cl">	sumB int64
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="93-考虑指令集优化">93 考虑指令集优化</h3>
<ul>
<li></li>
</ul>
<h3 id="94-内存对齐">94 内存对齐</h3>
<p>内存对齐可以减少结构体占用的内存大小.</p>
<p>结构体的内存对齐系数, 为各字段中最大的系数</p>
<p><a href="https://go.dev/ref/spec#Size%20and%20alignment%20guarantees">官方文档</a></p>
<h3 id="95-stack--heap">95 stack &amp;&amp; heap</h3>
<p>栈内存是不需要GC, 只是会根据栈的大小范围表示为不可用, 再次使用的时候, 新值直接覆盖旧值.</p>
<p>当变量内存分配到栈上, 且函数退出, 变量引用表示不可用 &ndash; 无法再次访问, 所以需要 堆.</p>
<p>堆的使用成本更大, 需要GC, 内存分配成本也更大.</p>
<h3 id="96-优化内存分配">96 优化内存分配</h3>
<ul>
<li>string.Builder 代替 +</li>
<li>避免 []byte 转 string</li>
<li>slice map 的初始化</li>
<li>结构体内存对齐</li>
<li>改变 interface 声明, 避免内存逃逸</li>
<li>sync.Pool</li>
<li>编译器优化, 避免 bytes-to-string 转化</li>
</ul>
<h3 id="97-编译器函数内联">97 编译器函数内联</h3>
<p>inline. 当调用的子函数较为简单时, 编译器会是将调用函数的内部实现嵌入当前调用点.</p>
<ul>
<li>避免函数的调用成本</li>
<li>可以使编译器进一步优化 (比如, 内存逃逸 直接分配到栈中)</li>
</ul>
<p>当子函数过为复杂时, 可以抽出子函数的复杂部分为另一个调用函数实现 mid inline. 让中间函数嵌入调用点.</p>
<h3 id="98-使用分析工具">98 使用分析工具</h3>
<ul>
<li>pprof</li>
<li>trace</li>
</ul>
<h3 id="99-gc">99 GC</h3>
<p>marks and sweep</p>
<ul>
<li>遍历所有对象, 标记是否在使用</li>
<li>遍历所以对象, 清除没有在使用的对象</li>
</ul>
<p>GOGC 配置 GC 的敏感度, 当 GOGC=100 时, 当堆内存容量涨100%时触发GC.</p>
<ul>
<li><a href="https://xargin.com/dynamic-gogc/">通过 GOGC 进行优化</a></li>
<li><a href="https://www.uber.com/en-TW/blog/how-we-saved-70k-cores-across-30-mission-critical-services/">uber 调优原文</a></li>
<li><a href="https://blog.ideawand.com/2020/08/01/go-gc-tuning-practice-1/">GOGC 调优</a></li>
</ul>
<h3 id="100-docker-和-k8s-资源分配对并发性能的影响">100 Docker 和 K8s 资源分配对并发性能的影响</h3>
<p>引用 <code>http://github.com/uber-go/automaxprocs</code> 自动设置 GOPROMAX</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang Gin</title>
      <link>https://ynikl.github.io/blog/golang-gin/</link>
      <pubDate>Sun, 01 Jan 2023 22:08:25 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-gin/</guid>
      <description>Golang Gin 框架的使用和理解 框架代码地址
中间的几个关键对象 Engine RouterGroup HandlerFunc Context Engine gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过New()或者Default()创建
New 不带任何中间件 Default 会带 logger 和 recover 通过 Engine.Use() 添加中间件到Engine的RouterGroup
Engine.Run 启动, 并绑定到参数的地址
RouterGroup 1 2 3 4 5 6 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 用于存储中间件的处理方法 &amp;ndash; 存储再 HandlersChain 里面, 即[]HandlerFunc
真正的路由地址存储在engine.trees &amp;ndash; 路由树, 检索请求地址和对应处理方法.
Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址. 目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树. 也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.</description>
      <content:encoded><![CDATA[<h1 id="golang-gin-框架的使用和理解">Golang Gin 框架的使用和理解</h1>
<p><a href="https://github.com/gin-gonic/gin">框架代码地址</a></p>
<h2 id="中间的几个关键对象">中间的几个关键对象</h2>
<ul>
<li>Engine</li>
<li>RouterGroup</li>
<li>HandlerFunc</li>
<li>Context</li>
</ul>
<h3 id="engine">Engine</h3>
<p>gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过<code>New()</code>或者<code>Default()</code>创建</p>
<ul>
<li><code>New</code> 不带任何中间件</li>
<li><code>Default</code> 会带 <code>logger</code> 和 <code>recover</code></li>
</ul>
<p>通过 <code>Engine.Use()</code> 添加中间件到Engine的<code>RouterGroup</code></p>
<p><code>Engine.Run</code> 启动, 并绑定到参数的地址</p>
<h3 id="routergroup">RouterGroup</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type RouterGroup struct {
</span></span><span class="line"><span class="cl">	Handlers HandlersChain
</span></span><span class="line"><span class="cl">	basePath string
</span></span><span class="line"><span class="cl">	engine   *Engine
</span></span><span class="line"><span class="cl">	root     bool
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>用于存储中间件的处理方法 &ndash; 存储再 <code>HandlersChain</code> 里面, 即<code>[]HandlerFunc</code></p>
<p>真正的路由地址存储在<code>engine.trees</code> &ndash; 路由树, 检索请求地址和对应处理方法.</p>
<p>Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址.
目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树.
也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">func</span> <span class="p">(</span><span class="n">group</span> <span class="o">*</span><span class="n">RouterGroup</span><span class="p">)</span> <span class="n">handle</span><span class="p">(</span><span class="n">httpMethod</span><span class="p">,</span> <span class="n">relativePath</span> <span class="n">string</span><span class="p">,</span> <span class="n">handlers</span> <span class="n">HandlersChain</span><span class="p">)</span> <span class="n">IRoutes</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="n">absolutePath</span> <span class="p">:</span><span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">calculateAbsolutePath</span><span class="p">(</span><span class="n">relativePath</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">handlers</span> <span class="o">=</span> <span class="n">group</span><span class="o">.</span><span class="n">combineHandlers</span><span class="p">(</span><span class="n">handlers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">group</span><span class="o">.</span><span class="n">engine</span><span class="o">.</span><span class="n">addRoute</span><span class="p">(</span><span class="n">httpMethod</span><span class="p">,</span> <span class="n">absolutePath</span><span class="p">,</span> <span class="n">handlers</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="n">group</span><span class="o">.</span><span class="n">returnObj</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注册路由之前, 先将当前的 http 处理方法, 与当前中间件配置合并, 再添加到engine.</p>
<h4 id="routergroup-1">RouterGroup</h4>
<p><code>RouterGroup.Group</code>	创建一个新的 <code>RouterGroup</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">group</span> <span class="o">*</span><span class="nx">RouterGroup</span><span class="p">)</span> <span class="nf">Group</span><span class="p">(</span><span class="nx">relativePath</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">handlers</span> <span class="o">...</span><span class="nx">HandlerFunc</span><span class="p">)</span> <span class="o">*</span><span class="nx">RouterGroup</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="o">&amp;</span><span class="nx">RouterGroup</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Handlers</span><span class="p">:</span> <span class="nx">group</span><span class="p">.</span><span class="nf">combineHandlers</span><span class="p">(</span><span class="nx">handlers</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">basePath</span><span class="p">:</span> <span class="nx">group</span><span class="p">.</span><span class="nf">calculateAbsolutePath</span><span class="p">(</span><span class="nx">relativePath</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="nx">engine</span><span class="p">:</span>   <span class="nx">group</span><span class="p">.</span><span class="nx">engine</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建新的 Group  时候,也会继承旧的 Group, 原先已经设置的 middleware. gin 框架不支持移除中间件的操作，所以在上层设置的中间件的时候一定要确保是公共 common 的</p>
<p>相似的路由捆绑在一块, 路由组写法, 可以做绑定相同中间件处理.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// Simple group: v1
</span></span><span class="line"><span class="cl">v1 := router.Group(&#34;/v1&#34;)
</span></span><span class="line"><span class="cl">{
</span></span><span class="line"><span class="cl">  v1.POST(&#34;/login&#34;, loginEndpoint)
</span></span><span class="line"><span class="cl">  v1.POST(&#34;/submit&#34;, submitEndpoint)
</span></span><span class="line"><span class="cl">  v1.POST(&#34;/read&#34;, readEndpoint)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>中间的花括号只起美化代码作用, 非必需</p>
<h3 id="handlerfunc">HandlerFunc</h3>
<p>中间件和请求处理方法的函数签名</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">Context</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>处理请求的时候, HandlerFunc 执行完毕 &ndash; 代表该请求处理结束</p>
<h3 id="context">Context</h3>
<p>gin 自己实现的 Context 结构</p>
<ul>
<li>在中间件中传递参数</li>
<li>控制调用流程</li>
<li>获取参数</li>
<li>返回结果</li>
</ul>
<p>Context 结构的重要组成部分介绍</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Context</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// 存储URL 参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Params</span>   <span class="nx">Params</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 写入请求的结果
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Writer</span>    <span class="nx">ResponseWriter</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 请求的所有处理方法集合
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">handlers</span> <span class="nx">HandlersChain</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 当前执行到第几个方法
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">index</span>    <span class="kt">int8</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 存储流转于中间件的参数式
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Keys</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="nx">any</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="在中间件中传递参数">在中间件中传递参数</h4>
<ul>
<li><code>context.Get</code></li>
<li><code>context.Set</code> 两个方法在中间件中传递参数</li>
</ul>
<h4 id="流程控制">流程控制</h4>
<ul>
<li><code>context.Next()</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Next</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">&lt;</span> <span class="nb">int8</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">handlers</span><span class="p">[</span><span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="p">](</span><span class="nx">c</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">index</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将当前代码执行点移交到下一个 <code>HandlerFunc</code> 具体流程看, <a href="#Middleware">Middleware</a></p>
<h4 id="获取参数">获取参数</h4>
<ul>
<li><code>context.Param()</code> 获取 Query Param 的字符串参数</li>
<li><code>context.Query()</code></li>
<li><code>context.QueryMap()</code> 或者 <code>context.PostFormMap</code> 获取 map 的参数</li>
<li><code>context.Bind</code> 将参数包含query参数和body参数解析之后, 反序列化到传入的结构体.
tag <code>binding:&quot;required&quot;</code> 如果没有对应参数会报错</li>
</ul>
<h4 id="调用结束">调用结束</h4>
<ul>
<li><code>conetxt.JSON</code> 以json的形式, 返回结果
举个例子: 如果是json的的化就是 <code>jsonBinding</code> 进行反序列化</li>
<li>报错 500 <code>context.AbortWithStatus()</code></li>
</ul>
<h4 id="cookie-操作">Cookie 操作</h4>
<ul>
<li><code>context.Cookie()</code></li>
<li><code>context.SetCookie()</code></li>
</ul>
<h3 id="middleware">Middleware</h3>
<p>符合 <a href="#HandlerFunc">HandlerFunc</a> 签名的函数. 就可以<code>Engine.Use</code>注册层路由. 路由设置
的处理函数, 在本质上可以称为中间件.</p>
<ol>
<li>gin 会按照 routegroup <code>Use</code> 中间件的先后顺序存储到路由表中</li>
<li>接收请求, 依次执行注册时设置的所有中间件函数.</li>
</ol>
<h4 id="next">Next</h4>
<p>调用流程图:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">middleware 1
</span></span><span class="line"><span class="cl">| - doing m1 work
</span></span><span class="line"><span class="cl">| - call Context.Next()
</span></span><span class="line"><span class="cl">|     - call middleware 2
</span></span><span class="line"><span class="cl">|       - doing m2 work
</span></span><span class="line"><span class="cl">|       - call Context.Next()
</span></span><span class="line"><span class="cl">|         - call middleware 3
</span></span><span class="line"><span class="cl">|         - - done m3
</span></span><span class="line"><span class="cl">|       - continue m2 work
</span></span><span class="line"><span class="cl">|     - - done m2 work
</span></span><span class="line"><span class="cl">| - coninue m1 work
</span></span><span class="line"><span class="cl">| - done 
</span></span><span class="line"><span class="cl">finish
</span></span></code></pre></td></tr></table>
</div>
</div><p>当调研 <code>Context.Next()</code> 时会调用下一个中间函数, 当下一个函数执行完成之后, 执行
代码会返回到原先调用 <code>Context.Next()</code>的地方 &ndash; 递归</p>
<h4 id="abort">Abort</h4>
<p>中间处理时可以调用 <code>Context.Abort()</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Context</span><span class="p">)</span> <span class="nf">Abort</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="nx">abortIndex</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>会将函数调用链的index指向一个超大整数 &ndash; 放弃后面所有的处理函数, 但是 <strong>调用Abort后, 同一个函数接下的代码还会继续执行</strong></p>
<h4 id="小demo">小demo</h4>
<p><a href="https://gist.github.com/ynikl/20b603bfd743d2540d482939ac87d133">demo</a></p>
<!-- raw HTML omitted -->
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span> <span class="o">:=</span> <span class="nx">gin</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">Use</span><span class="p">(</span><span class="nx">m1</span><span class="p">,</span> <span class="nx">m2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/greet&#34;</span><span class="p">,</span> <span class="nx">m3</span><span class="p">,</span> <span class="nx">greet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">GET</span><span class="p">(</span><span class="s">&#34;/abort&#34;</span><span class="p">,</span> <span class="nx">abort</span><span class="p">,</span> <span class="nx">m3</span><span class="p">,</span> <span class="nx">greet</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">eg</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="s">&#34;:8080&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">m1</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;before m1 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;after m1 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">m2</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\tbefore m2 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\tafter m2 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">m3</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\tbefore m3 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\tafter m3 next&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">abort</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\t\tbefore abort&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">Abort</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\t\tafter abort&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">greet</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">gin</span><span class="p">.</span><span class="nx">Context</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;\t\t\t\thow are you doing?&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nf">JSON</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="s">&#34;great&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接口 <code>/greet</code> 的输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">before m1 next
</span></span><span class="line"><span class="cl">        before m2 next
</span></span><span class="line"><span class="cl">                before m3 next
</span></span><span class="line"><span class="cl">                                how are you doing?
</span></span><span class="line"><span class="cl">                after m3 next
</span></span><span class="line"><span class="cl">        after m2 next
</span></span><span class="line"><span class="cl">after m1 next
</span></span></code></pre></td></tr></table>
</div>
</div><p>接口 <code>/abort</code> 的数据</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sh" data-lang="sh"><span class="line"><span class="cl">before m1 next
</span></span><span class="line"><span class="cl">        before m2 next
</span></span><span class="line"><span class="cl">                        before abort
</span></span><span class="line"><span class="cl">                        after abort
</span></span><span class="line"><span class="cl">        after m2 next
</span></span><span class="line"><span class="cl">after m1 next
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="其他">其他</h3>
<p>gin.H</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">gin</span><span class="p">.</span><span class="nx">H</span> <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}</span> 
</span></span><span class="line"><span class="cl"><span class="c1">// 常用于 engine.JSON() 时返回 json 数据
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="几个问题">几个问题</h2>
<h3 id="gin-的-context-有什么作用和怎么用">Gin 的 context 有什么作用和怎么用?</h3>
<p>context 是 Gin 代码请求流转的核心, 存储处理请求的所有必须参数</p>
<p>基本的使用方法:</p>
<ol>
<li>需要知道如何获取参数 &ndash; <code>Bind</code> 或者 <code>Param</code> 方法</li>
<li>控制处理函数流程 &ndash; <code>Next</code> 或者 <code>Abort</code> 方法</li>
<li>返回结果 &ndash; <code>JSON</code></li>
</ol>
<h3 id="gin-的整体框架流程是怎么样的-从接受到一个请求再到返回请求中间的流程">Gin 的整体框架流程是怎么样的? 从接受到一个请求再到返回请求中间的流程?</h3>
<p>请求的注册入口, <code>Engine.ServeHTTP</code></p>
<p>整体流程</p>
<ol>
<li>存储路由路径和注册的处理函数到&quot;路由树&quot; &ndash; <code>nodetree</code></li>
<li>接收请求</li>
<li>根据接收到的请求地址, 从路由树中取出注册的函数, 组成<code>HandlerChain</code> 函数处理链</li>
<li>把函数处理链赋值到<code>gin.Context</code>中</li>
<li>由<code>gin.Context</code>开始依次调用注册处理函数, 所以函数遍历完成, 处理结束</li>
<li>通过<code>gin.Context.Writer</code>写入http请求结果</li>
<li>请求结束</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang 是否需要为每个请求 New 一个 Client</title>
      <link>https://ynikl.github.io/blog/golang-client-reuse/</link>
      <pubDate>Mon, 19 Dec 2022 15:35:53 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-client-reuse/</guid>
      <description>背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致下游的 nginx 的连接数暴涨.
问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client
探索 在 StackOverflow 发现的相关答案
How to release http.Client in Go?
给的答案是建议复用 Client
The Client&amp;rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
http.Client 的结构体
1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time.</description>
      <content:encoded><![CDATA[<h2 id="背景">背景</h2>
<p>在改动旧代码的时候把, 一个使用全局 <code>http.Client</code> 的代码弄成了每一个请求会新 New
一个 <code>http.Client</code> 导致下游的 nginx 的连接数暴涨.</p>
<h2 id="问题">问题</h2>
<p>处理多个请求的时候, 是否需要为每个请求 New 一个 Client</p>
<h2 id="探索">探索</h2>
<p>在 StackOverflow 发现的相关答案</p>
<p><a href="https://stackoverflow.com/a/36688970/9992963">How to release http.Client in Go?</a></p>
<p>给的答案是建议复用 <code>Client</code></p>
<blockquote>
<p>The Client&rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.</p>
</blockquote>
<p>http.Client 的结构体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type Client struct {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	Transport RoundTripper
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	CheckRedirect func(req *Request, via []*Request) error
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	Jar CookieJar
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	Timeout time.Duration
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 <code>RoundTripper</code> 中实现了连接复用的逻辑</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type RoundTripper interface {
</span></span><span class="line"><span class="cl">	RoundTrip(*Request) (*Response, error)
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>中定义了 <code>RoundTrip</code> 方法, 提供客户端请求的时候调用.</p>
<p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=1;bpt=1;l=512?q=%2Fnet%2Fhttp%2Ftransport.go&amp;ss=go%2Fgo">调用地址</a></p>
<p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;l=95?q=%2Fnet%2Fhttp%2Ftransport.go&amp;ss=go%2Fgo">查看一下 Golang Transport 的基本实现</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type Transport struct {
</span></span><span class="line"><span class="cl">	idleMu       sync.Mutex
</span></span><span class="line"><span class="cl">	closeIdle    bool                                // user has requested to close all idle conns
</span></span><span class="line"><span class="cl">	idleConn     map[connectMethodKey][]*persistConn // most recently used at end
</span></span><span class="line"><span class="cl">	idleConnWait map[connectMethodKey]wantConnQueue  // waiting getConns
</span></span><span class="line"><span class="cl">	idleLRU      connLRU
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	connsPerHostMu   sync.Mutex
</span></span><span class="line"><span class="cl">	connsPerHost     map[connectMethodKey]int
</span></span><span class="line"><span class="cl">	connsPerHostWait map[connectMethodKey]wantConnQueue // waiting getConns
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	// 还有其他字段略
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>结构体中间有很多连接存储相关的字段.</p>
<p>在 http 请求调用 Transport 中间有一个关键方法 <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;bpv=1;bpt=1;l=1338">getConn</a> 获取一个连接</p>
<p>方法声明一个想要的连接地址, <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=1b2ad1d815ea8967c49b32d848b2992d0c588d88;l=1194">wantConn</a> 推入到 <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=0;bpt=1;l=1422">queueForDial</a></p>
<p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=1;bpt=1;l=1422">QueueForDial 方法</a>会判断时候<code>connsPerHost</code> 中间是否有当前的请求的缓存连接</p>
<ul>
<li>如果有直接拿来重复使用</li>
<li>如果没有, 就需要重新进行拨号</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	w.beforeDial()
</span></span><span class="line"><span class="cl">	if t.MaxConnsPerHost &lt;= 0 {
</span></span><span class="line"><span class="cl">		go t.dialConnFor(w)
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	t.connsPerHostMu.Lock()
</span></span><span class="line"><span class="cl">	defer t.connsPerHostMu.Unlock()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if n := t.connsPerHost[w.key]; n &lt; t.MaxConnsPerHost {
</span></span><span class="line"><span class="cl">		if t.connsPerHost == nil {
</span></span><span class="line"><span class="cl">			t.connsPerHost = make(map[connectMethodKey]int)
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		t.connsPerHost[w.key] = n + 1
</span></span><span class="line"><span class="cl">		go t.dialConnFor(w)
</span></span><span class="line"><span class="cl">		return
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	if t.connsPerHostWait == nil {
</span></span><span class="line"><span class="cl">		t.connsPerHostWait = make(map[connectMethodKey]wantConnQueue)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	q := t.connsPerHostWait[w.key]
</span></span><span class="line"><span class="cl">	q.cleanFront()
</span></span><span class="line"><span class="cl">	q.pushBack(w)
</span></span><span class="line"><span class="cl">	t.connsPerHostWait[w.key] = q
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="结论">结论</h2>
<p>重复使用 http.Client 可以达到 TCP 连接复用的效果</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>代码整洁架构</title>
      <link>https://ynikl.github.io/blog/clean-architectrue/</link>
      <pubDate>Mon, 05 Dec 2022 09:21:02 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/clean-architectrue/</guid>
      <description>代码整洁架构
核心思想 最重要的是依赖顺序需要内收 &amp;ndash; 业务逻辑不能依赖框架
分层 简单分层四层
Entities Use Cases Interface Adapters Framework and Drivers Entity 实体抽象层 我的理解应该是在公司业务, 或者项目领域上对于业务模型的抽象. 不容易改变 (除非公司 业务, 或者项目方向改变). 应该是与 领域驱动设计 不谋而合
Use Cases 使用场景层 业务使用场景, 应该是存放相关不同业务场景的具体实现流程
Interface Adapters 接口转化器层 负责 Use Cases 数据 与外部使用数据转换器实现.
比较特别的例子, 将 Use Cases 产生的数据与外部的 UI 表现层所需要的数据格式做转化.
Framework and Divers 数据库和框架层, 外部工具包接口依赖之类的.
依赖倒置 当遇到跨层依赖的时候, 内层需要引用到外层逻辑时: 比如, Use Case 要呈现 UI 数据结构 (Interface Adapters 层) 时, 不能直接引用 UI 层的数据模型.
而是, 通过依赖倒置. 将 UI 层的处理逻辑, 注入 Use Case 层进行处理, 实现目标.</description>
      <content:encoded><![CDATA[<p>代码整洁架构</p>
<h2 id="核心思想">核心思想</h2>
<p>最重要的是依赖顺序需要内收 &ndash; 业务逻辑不能依赖框架</p>
<h2 id="分层">分层</h2>
<p>简单分层四层</p>
<ul>
<li>Entities</li>
<li>Use Cases</li>
<li>Interface Adapters</li>
<li>Framework and Drivers</li>
</ul>
<h3 id="entity-实体抽象层">Entity 实体抽象层</h3>
<p>我的理解应该是在公司业务, 或者项目领域上对于业务模型的抽象. 不容易改变 (除非公司
业务, 或者项目方向改变). 应该是与 <em>领域驱动设计</em> 不谋而合</p>
<h3 id="use-cases-使用场景层">Use Cases 使用场景层</h3>
<p>业务使用场景, 应该是存放相关不同业务场景的具体实现流程</p>
<h3 id="interface-adapters-接口转化器层">Interface Adapters 接口转化器层</h3>
<p>负责 Use Cases 数据 与外部使用数据转换器实现.</p>
<p>比较特别的例子, 将 Use Cases 产生的数据与外部的 UI 表现层所需要的数据格式做转化.</p>
<h3 id="framework-and-divers">Framework and Divers</h3>
<p>数据库和框架层, 外部工具包接口依赖之类的.</p>
<h2 id="依赖倒置">依赖倒置</h2>
<p>当遇到跨层依赖的时候, 内层需要引用到外层逻辑时: 比如, Use Case 要呈现 UI 数据结构
(Interface Adapters 层) 时, 不能直接引用 UI 层的数据模型.</p>
<p>而是, 通过依赖倒置. 将 UI 层的处理逻辑, 注入 Use Case 层进行处理, 实现目标.</p>
<h2 id="golang-整洁模板">golang 整洁模板</h2>
<p>引用自 <a href="https://github.com/evrone/go-clean-template">golang clean template</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">├─cmd 应用入口
</span></span><span class="line"><span class="cl">│  └─app
</span></span><span class="line"><span class="cl">├─config
</span></span><span class="line"><span class="cl">├─docs // 存放文档
</span></span><span class="line"><span class="cl">├─internal
</span></span><span class="line"><span class="cl">│  ├─app
</span></span><span class="line"><span class="cl">│  ├─controller // 控制器
</span></span><span class="line"><span class="cl">│  │  ├─amqp_rpc
</span></span><span class="line"><span class="cl">│  │  └─http
</span></span><span class="line"><span class="cl">│  │      └─v1
</span></span><span class="line"><span class="cl">│  ├─entity // 实体层
</span></span><span class="line"><span class="cl">│  ├─middleware // 中间件
</span></span><span class="line"><span class="cl">│  └─usecase
</span></span><span class="line"><span class="cl">│      ├─repo // 数据库操作
</span></span><span class="line"><span class="cl">│      └─webapi // RESTful API
</span></span><span class="line"><span class="cl">├─migrations
</span></span><span class="line"><span class="cl">├─pkg //以被外部程序安全导入的包
</span></span><span class="line"><span class="cl">│  ├─crypto
</span></span><span class="line"><span class="cl">│  ├─httpresponse
</span></span><span class="line"><span class="cl">│  ├─httpserver
</span></span><span class="line"><span class="cl">│  ├─logger
</span></span><span class="line"><span class="cl">│  ├─mysql
</span></span><span class="line"><span class="cl">│  ├─postgres
</span></span><span class="line"><span class="cl">│  ├─rabbitmq
</span></span><span class="line"><span class="cl">│  └─redis
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考文章">参考文章</h2>
<ul>
<li><a href="https://www.artacode.com/post/golang/template/">结构架构介绍</a></li>
<li><a href="https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html">the clean architecture</a></li>
<li><a href="https://github.com/evrone/go-clean-template">goang clean template</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>go 使用 runtime 包进行内存占用分析</title>
      <link>https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/</link>
      <pubDate>Fri, 18 Nov 2022 19:27:35 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/</guid>
      <description>使用场景 写个demo, 想查看一下程序内部的内存占用情况.
使用方法 主角 runtime 包
对象 MemStats 方法 ReadMemStats demo 展示
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(&amp;amp;m) // For info on each, see: https://golang.</description>
      <content:encoded><![CDATA[<h3 id="使用场景">使用场景</h3>
<p>写个demo, 想查看一下程序内部的内存占用情况.</p>
<h3 id="使用方法">使用方法</h3>
<p>主角 runtime 包</p>
<ul>
<li>对象 <code>MemStats</code></li>
<li>方法 <code>ReadMemStats</code></li>
</ul>
<p>demo 展示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// PrintMemUsage outputs the current, total and OS memory being used. As well as the number 
</span></span></span><span class="line"><span class="cl"><span class="c1">// of garage collection cycles completed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">PrintMemUsage</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bToMb</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">b</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">m</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">MemStats</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// For info on each, see: https://golang.org/pkg/runtime/#MemStats
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Alloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Alloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tTotalAlloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">TotalAlloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tSys = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Sys</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tNumGC = %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">NumGC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://gist.github.com/j33ty/79e8b736141be19687f565ea4c6f4226">代码出处</a></p>
<h3 id="解释">解释</h3>
<h4 id="readmemstats">ReadMemStats</h4>
<p><code>runtime.ReadMemStats</code> 方法会读取到内存分配器的当前时刻最新的内存分配数据, 并将
其填充到传入参数的<code>MemStats</code> 的变量中.</p>
<p>可以充当一个内存快照, 用于进行对比.</p>
<h4 id="memstats-字段">MemStats 字段</h4>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">MemStats</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 当前堆上对象的内存分配大小, 同HeapAlloc字段, 单位 bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Alloc</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 历史总的累计分配内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">TotalAlloc</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从操作系统分配的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Sys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 记录指针索引性能, go 语言内部使用
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Lookups</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 堆上分配的对象数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Mallocs</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 堆上剩余的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">Frees</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">HeapAlloc</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从操作系统分配的 堆 内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 未使用的空闲内存分片大小 spans
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapIdle</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 使用中的内存分片大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 回退的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapReleased</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 堆上分配的对象数量
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">HeapObjects</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 栈上使用的内存片大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">StackInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 从操作系统分配的栈的内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">StackSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MSpanInuse is bytes of allocated mspan structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MSpanInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MSpanSys is bytes of memory obtained from the OS for mspan
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MSpanSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MCacheInuse is bytes of allocated mcache structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MCacheInuse</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// MCacheSys is bytes of memory obtained from the OS for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// mcache structures.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MCacheSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// BuckHashSys is bytes of memory in profiling bucket hash tables.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">BuckHashSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// GCSys is bytes of memory in garbage collection metadata.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">GCSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// OtherSys is bytes of memory in miscellaneous off-heap
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// runtime allocations.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">OtherSys</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 在多大的堆内存时, 触发GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NextGC</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 上次GC 时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">LastGC</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PauseTotalNs is the cumulative nanoseconds in GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stop-the-world pauses since the program started.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// During a stop-the-world pause, all goroutines are paused
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// and only the garbage collector can run.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PauseTotalNs</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PauseNs is a circular buffer of recent GC stop-the-world
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// pause times in nanoseconds.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// The most recent pause is at PauseNs[(NumGC+255)%256]. In
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// general, PauseNs[N%256] records the time paused in the most
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// recent N%256th GC cycle. There may be multiple pauses per
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// GC cycle; this is the sum of all pauses during a cycle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PauseNs</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// PauseEnd is a circular buffer of recent GC pause end times,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// as nanoseconds since 1970 (the UNIX epoch).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This buffer is filled the same way as PauseNs. There may be
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// multiple pauses per GC cycle; this records the end of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// last pause in a cycle.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">PauseEnd</span> <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// GC 次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NumGC</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 手动调用 GC 的次数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">NumForcedGC</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// GC 使用的 CPU 时间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">GCCPUFraction</span> <span class="kt">float64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 可以GC,一直是true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">EnableGC</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// BySize reports per-size class allocation statistics.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// BySize[N] gives statistics for allocations of size S where
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// BySize[N-1].Size &lt; S ≤ BySize[N].Size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// This does not report allocations larger than BySize[60].Size.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">BySize</span> <span class="p">[</span><span class="mi">61</span><span class="p">]</span><span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Size is the maximum byte size of an object in this
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// size class.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">Size</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Mallocs is the cumulative count of heap objects
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// allocated in this size class. The cumulative bytes
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// of allocation is Size*Mallocs. The number of live
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// objects in this size class is Mallocs - Frees.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">Mallocs</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="c1">// Frees is the cumulative count of heap objects freed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// in this size class.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">Frees</span> <span class="kt">uint64</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://pkg.go.dev/runtime#MemStats">源码出处</a></p>
<h3 id="我用于分析-map-的-delete-操作占用内存">我用于分析 map 的 delete 操作占用内存</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;fmt&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;runtime&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">m</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">][]</span><span class="kt">int</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">m</span><span class="p">[</span><span class="s">&#34;a&#34;</span><span class="p">]</span> <span class="p">=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1024</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nb">delete</span><span class="p">(</span><span class="nx">m</span><span class="p">,</span> <span class="s">&#34;a&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;make storage value&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mint</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="kt">int</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">30</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">1</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">2</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mint</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">GC</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">PrintMemUsage</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 注意: 需要引用, 避免被提前回收
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">m</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="nx">mint</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// go run main.go
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Outpu:
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 8192 MiB	TotalAlloc = 8192 MiB	Sys = 8464 MiB	NumGC = 0
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 0 MiB	TotalAlloc = 8192 MiB	Sys = 8465 MiB	NumGC = 2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// make storage value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 39168 MiB	TotalAlloc = 47360 MiB	Sys = 48898 MiB	NumGC = 3
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Alloc = 39168 MiB	TotalAlloc = 47360 MiB	Sys = 48898 MiB	NumGC = 4
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 0 2048
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">PrintMemUsage</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">bToMb</span> <span class="o">:=</span> <span class="kd">func</span><span class="p">(</span><span class="nx">b</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">b</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">m</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">MemStats</span>
</span></span><span class="line"><span class="cl">	<span class="nx">runtime</span><span class="p">.</span><span class="nf">ReadMemStats</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// For info on each, see: https://golang.org/pkg/runtime/#MemStats
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;Alloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Alloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tTotalAlloc = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">TotalAlloc</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tSys = %v MiB&#34;</span><span class="p">,</span> <span class="nf">bToMb</span><span class="p">(</span><span class="nx">m</span><span class="p">.</span><span class="nx">Sys</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;\tNumGC = %v\n&#34;</span><span class="p">,</span> <span class="nx">m</span><span class="p">.</span><span class="nx">NumGC</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>分析结果得出, 如果在 map 中存储的 value, 如果是引用值的话, 占用的内存是被 GC 回收
的. 但是, 如果是值类型如简单的<code>int</code>是不会被回收的.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang Minimal Version Selection 意识流翻译(仅开头)</title>
      <link>https://ynikl.github.io/blog/golang-minimal-version-selection/</link>
      <pubDate>Tue, 01 Nov 2022 00:15:50 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-minimal-version-selection/</guid>
      <description>原文: Minimal Version Selection
意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.
翻译: Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list). 为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持 编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.
版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:
构建当前的编译列表 升级所有模块到各自对应的最新版本 升级一个模块到对应的版本 降级一个模块到对应的版本 最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进 行升级, 降级, 添加或者移除模块.
这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易 理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖 是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只 用了几行 go 的代码就是实现了.
最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵 守语义化版本: 向前兼容的版本使用小版本号, 不向前兼容的版本使用大版本号.
对应的四种列表操作:
构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份. 升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表 升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入 时如果如果已经存在, 就是仅保存最新的版本 降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标 模块版本之下 这些操作简单, 高效, 且容易实现</description>
      <content:encoded><![CDATA[<p>原文: <a href="https://research.swtch.com/vgo-mvs#low-fidelity_builds">Minimal Version Selection</a></p>
<p>意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.</p>
<h1 id="翻译">翻译:</h1>
<p>Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list).
为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持
编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.</p>
<p>版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:</p>
<ol>
<li>构建当前的编译列表</li>
<li>升级所有模块到各自对应的最新版本</li>
<li>升级一个模块到对应的版本</li>
<li>降级一个模块到对应的版本</li>
</ol>
<p>最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进
行升级, 降级, 添加或者移除模块.</p>
<p>这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易
理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖
是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只
用了几行 go 的代码就是实现了.</p>
<p>最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵
守<a href="https://research.swtch.com/vgo-import">语义化版本</a>: 向前兼容的版本使用小版本号,
不向前兼容的版本使用大版本号.</p>
<p>对应的四种列表操作:</p>
<ol>
<li>构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份.</li>
<li>升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表</li>
<li>升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入
时如果如果已经存在, 就是仅保存最新的版本</li>
<li>降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标
模块版本之下</li>
</ol>
<p>这些操作简单, 高效, 且容易实现</p>
<p><strong>剩余内容 略</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang 解决依赖包版本冲突</title>
      <link>https://ynikl.github.io/blog/golang-find-module-conflict/</link>
      <pubDate>Mon, 31 Oct 2022 08:26:33 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-find-module-conflict/</guid>
      <description>遇到了 grpc 不遵循语义版本, 导致不同版本包之间的冲突.
更新了目标的版本模块之后, 编译一下就发现原先项目引用的 gozero 框架报错了. 搜索一下 相关的关键词,就可以定位到问题是 grpc 搞的鬼.
再找到对应的兼容版本, 升级到对应的版本就可以了.
go 依赖版本选择 [golang 的最小版本选择]https://ynikl.github.io/blog/golang-minimal-version-selection/
大体意思:
会选择当前编译需要依赖包的最高版本(使用语义化版本)
寻找依赖的原因 go mod why
寻找自己项目引用某个包的 最短引用路径, 导致会引用目标包的
1 go mod why google.golang.org/grpc 输出目标包的引用依赖层级
1 2 3 4 5 6 ❯ go mod why google.golang.org/grpc # google.golang.org/grpc hello/world/test git.test.cn/company-open/rpc-pkgs google.golang.org/grpc go mod graph
可以打印出, 模块的依赖图
1 2 3 4 5 6 example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example.</description>
      <content:encoded><![CDATA[<p>遇到了 grpc 不遵循语义版本, 导致<a href="https://github.com/weaveworks/common/issues/239">不同版本包之间的冲突</a>.</p>
<p>更新了目标的版本模块之后, 编译一下就发现原先项目引用的 gozero 框架报错了. 搜索一下
相关的关键词,就可以定位到问题是 grpc 搞的鬼.</p>
<p>再找到对应的兼容版本, 升级到对应的版本就可以了.</p>
<h2 id="go-依赖版本选择">go 依赖版本选择</h2>
<p>[golang 的最小版本选择]https://ynikl.github.io/blog/golang-minimal-version-selection/</p>
<p>大体意思:</p>
<p>会选择当前编译需要依赖包的最高版本(使用语义化版本)</p>
<h2 id="寻找依赖的原因">寻找依赖的原因</h2>
<p><a href="https://go.dev/ref/mod#go-mod-why">go mod why</a></p>
<p>寻找自己项目引用某个包的 <strong>最短引用路径</strong>, 导致会引用目标包的</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod why google.golang.org/grpc
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出目标包的引用依赖层级</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">❯ go mod why google.golang.org/grpc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># google.golang.org/grpc
</span></span><span class="line"><span class="cl">hello/world/test
</span></span><span class="line"><span class="cl">git.test.cn/company-open/rpc-pkgs
</span></span><span class="line"><span class="cl">google.golang.org/grpc
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://go.dev/ref/mod#go-mod-graph">go mod graph</a></p>
<p>可以打印出, 模块的依赖图</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">example.com/main example.com/a@v1.1.0
</span></span><span class="line"><span class="cl">example.com/main example.com/b@v1.2.0
</span></span><span class="line"><span class="cl">example.com/a@v1.1.0 example.com/b@v1.1.1
</span></span><span class="line"><span class="cl">example.com/a@v1.1.0 example.com/c@v1.3.0
</span></span><span class="line"><span class="cl">example.com/b@v1.1.0 example.com/c@v1.1.0
</span></span><span class="line"><span class="cl">example.com/b@v1.2.0 example.com/c@v1.2.0
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    
    <item>
      <title>Go  errgroup 的基本用法</title>
      <link>https://ynikl.github.io/blog/golang-errgroup/</link>
      <pubDate>Mon, 19 Sep 2022 09:19:31 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-errgroup/</guid>
      <description>实现并发控制 在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 channel 进行传入和传出.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { concurrencyNum := 10 limitCh := make(chan bool, concurrencyNum) wg := new(sync.WaitGroup) for i := 0; i &amp;lt; 100; i++ { limitCh &amp;lt;- true wg.Add(1) go func() { defer func() { &amp;lt;-limitCh wg.Done() }() time.Sleep(1 * time.Second) fmt.</description>
      <content:encoded><![CDATA[<h2 id="实现并发控制">实现并发控制</h2>
<p>在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 <code>channel</code>
进行传入和传出.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">concurrencyNum</span> <span class="o">:=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">limitCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">concurrencyNum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">limitCh</span> <span class="o">&lt;-</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="o">&lt;-</span><span class="nx">limitCh</span>
</span></span><span class="line"><span class="cl">				<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;do some things...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ok&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果如果中间运行代码有可能存在错误, 捕获错误. 有两种方法:</p>
<ul>
<li>声明一个 err channel 用于承接错误</li>
<li>声明一个外部 err 变量, 并通过互斥锁进行保护</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">concurrencyNum</span> <span class="p">:</span><span class="o">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="n">limitCh</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="ne">bool</span><span class="p">,</span> <span class="n">concurrencyNum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">errCh</span> <span class="p">:</span><span class="o">=</span> <span class="n">make</span><span class="p">(</span><span class="n">chan</span> <span class="n">error</span><span class="p">,</span> <span class="n">concurrencyNum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">var</span> <span class="n">externalErr</span> <span class="n">error</span>
</span></span><span class="line"><span class="cl">	<span class="n">wg</span> <span class="p">:</span><span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">sync</span><span class="o">.</span><span class="n">WaitGroup</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="n">i</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="o">&lt;-</span><span class="n">errCh</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="n">externalErr</span> <span class="o">=</span> <span class="n">err</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="n">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="n">wg</span><span class="o">.</span><span class="n">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="n">limitCh</span> <span class="o">&lt;-</span> <span class="bp">true</span>
</span></span><span class="line"><span class="cl">			<span class="n">go</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">defer</span> <span class="k">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="o">&lt;-</span><span class="n">limitCh</span>
</span></span><span class="line"><span class="cl">					<span class="n">wg</span><span class="o">.</span><span class="n">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				<span class="n">time</span><span class="o">.</span><span class="n">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="n">time</span><span class="o">.</span><span class="n">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&#34;do some things...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="n">rand</span><span class="o">.</span><span class="n">Intn</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">err</span> <span class="p">:</span><span class="o">=</span> <span class="n">errors</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="s2">&#34;this is a error&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">					<span class="n">errCh</span> <span class="o">&lt;-</span> <span class="n">err</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="n">wg</span><span class="o">.</span><span class="n">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&#34;ok&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="n">externalErr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个地放都写这么多代码, 就有了重复的感觉. 本质上就两点:</p>
<ul>
<li>通过 channel 控制并发数</li>
<li>通过 waitgroup 保证所有的协程都执行完毕</li>
<li>通过另一个 errchannel 接受中间执行的错误</li>
</ul>
<h2 id="errgroup"><code>errgroup</code></h2>
<p>可以通过使用, 官方的拓展包 <code>errgroup</code> 更快实现</p>
<p>声明 errgroup</p>
<ul>
<li>普通声明 <code>new(errgroup.Group)</code></li>
<li>使用 context <code>errgroup.WithContext</code></li>
</ul>
<p>限制开启的协程数据</p>
<p><code>eg.SetLimit(goroutineNum)</code></p>
<p>开启协程</p>
<ul>
<li><code>eg.Go</code></li>
<li><code>eg.TryGo</code></li>
</ul>
<p>整体代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	eg := new(errgroup.Group)
</span></span><span class="line"><span class="cl">	eg.SetLimit(10)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for i := 0; i &lt; 100; i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		eg.Go(func() error {
</span></span><span class="line"><span class="cl">			time.Sleep(1 * time.Second)
</span></span><span class="line"><span class="cl">			fmt.Println(&#34;hello go&#34;)
</span></span><span class="line"><span class="cl">			return nil
</span></span><span class="line"><span class="cl">		})
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	err := eg.Wait()
</span></span><span class="line"><span class="cl">	fmt.Println(&#34;done&#34;, err)
</span></span></code></pre></td></tr></table>
</div>
</div><p>目前有个使用场景没办法满足:</p>
<p>就是没办法在开启协程之前, 知道原先已经执行的协程是否有发生错误.
如果有发生错误的. 就停止再继续开启协程.</p>
<p>可以通过添加一个 外部的 errChannel , 覆盖到上面的需求.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何查看 golang 编译之后调用的源码方法</title>
      <link>https://ynikl.github.io/blog/golang-get-assembly-fn/</link>
      <pubDate>Sun, 18 Sep 2022 21:37:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-get-assembly-fn/</guid>
      <description>在 golang 中查看源码是比较方便的. 可以直接到 官方包文档中直接查看文档和跳转到源码
但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成 什么底层方法了.
比如, 我知道一些make(map[int]bool)是怎么实现的.
这时候就需要一些方法了. 引用一下鸟窝大佬的文章 总结一下三种方法:
go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile 产生的汇编代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 0x001c 00028 (main.go:5)	FUNCDATA	$1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB) 0x001c 00028 (main.go:5)	FUNCDATA	$2, main.main.stkobj(SB) 0x001c 00028 (main.go:6)	STP	(ZR, ZR), main.</description>
      <content:encoded><![CDATA[<p>在 golang 中查看源码是比较方便的. 可以直接到 <a href="https://pkg.go.dev/">官方包文档</a>中直接查看文档和跳转到源码</p>
<p>但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成
什么底层方法了.</p>
<p>比如, 我知道一些<code>make(map[int]bool)</code>是怎么实现的.</p>
<p>这时候就需要一些方法了. 引用一下<a href="https://colobu.com/2018/12/29/get-assembly-output-for-go-programs/">鸟窝大佬的文章</a>
总结一下三种方法:</p>
<ul>
<li><code>go tool compile -N -l -S makemap.go</code></li>
<li><code>go tool compile -N -l -S makemap.go</code></li>
<li><code>go tool compile -N -l -S makemap.go</code></li>
</ul>
<p><code>go tool compile</code> 产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	0x001c 00028 (main.go:5)	FUNCDATA	$1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB)
</span></span><span class="line"><span class="cl">	0x001c 00028 (main.go:5)	FUNCDATA	$2, main.main.stkobj(SB)
</span></span><span class="line"><span class="cl">	0x001c 00028 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-48(SP)
</span></span><span class="line"><span class="cl">	0x0020 00032 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-32(SP)
</span></span><span class="line"><span class="cl">	0x0024 00036 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-16(SP)
</span></span><span class="line"><span class="cl">	0x0028 00040 (main.go:6)	MOVD	$type.map[int]bool(SB), R0
</span></span><span class="line"><span class="cl">	0x0030 00048 (main.go:6)	MOVD	$100, R1
</span></span><span class="line"><span class="cl">	0x0034 00052 (main.go:6)	MOVD	$main..autotmp_4-48(SP), R2
</span></span><span class="line"><span class="cl">	0x0038 00056 (main.go:6)	PCDATA	$1, ZR
</span></span><span class="line"><span class="cl">	0x0038 00056 (main.go:6)	CALL	runtime.makemap(SB)
</span></span><span class="line"><span class="cl">	0x003c 00060 (main.go:6)	MOVD	R0, main.mp-112(SP)
</span></span><span class="line"><span class="cl">	0x0040 00064 (main.go:7)	MOVD	R0, R1
</span></span><span class="line"><span class="cl">	0x0044 00068 (main.go:7)	MOVD	ZR, R2
</span></span><span class="line"><span class="cl">	0x0048 00072 (main.go:7)	MOVD	$type.map[int]bool(SB), R0
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>go tool objdump</code>产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  main.go:6		0x10008a734		a907ffff		STP (ZR, ZR), 120(RSP)			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a738		90000160		ADRP 180224(PC), R0			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a73c		91100000		ADD $1024, R0, R0			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a740		d2800c81		MOVD $100, R1				
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a744		910163e2		ADD $88, RSP, R2			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a748		97fe0522		CALL runtime.makemap(SB)		
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a74c		f90023e0		MOVD R0, 64(RSP)			
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>go build -gcflags -S</code> 产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mp_10-32(SP)
</span></span><span class="line"><span class="cl">        0x0024 00036 (/Users/ian/play/map/main.go:6)    STP     (ZR, ZR), main..autotmp_10-16(SP)
</span></span><span class="line"><span class="cl">        0x0028 00040 (/Users/ian/play/map/main.go:6)    MOVD    $type.map[int]bool(SB), R0
</span></span><span class="line"><span class="cl">        0x0030 00048 (/Users/ian/play/map/main.go:6)    MOVD    $100, R1
</span></span><span class="line"><span class="cl">        0x0034 00052 (/Users/ian/play/map/main.go:6)    MOVD    $main..autotmp_10-48(SP), R2
</span></span><span class="line"><span class="cl">        0x0038 00056 (/Users/ian/play/map/main.go:6)    PCDATA  $1, ZR
</span></span><span class="line"><span class="cl">        0x0038 00056 (/Users/ian/play/map/main.go:6)    CALL    runtime.makemap(SB)
</span></span><span class="line"><span class="cl">        0x003c 00060 (/Users/ian/play/map/main.go:6)    MOVD    R0, main.mp-72(SP)
</span></span></code></pre></td></tr></table>
</div>
</div><p>大同小异, 根据源代码的行号(<code>mian.go:6</code>) 都可以从代码中看到,
调用<code>call</code> 了<code>makemap</code> 这个方法</p>
<p>我们在到<a href="https://cs.opensource.google/go/go/+/master:src/runtime/map.go;l=283?q=makemap&amp;ss=go%2Fgo">源码</a>中, 找到<code>makemap</code>方法, 就可以查看对应的源码了</p>
<h2 id="参考">参考</h2>
<p><a href="https://colobu.com/2018/12/29/get-assembly-output-for-go-programs/">得到Go程序的汇编代码的方法</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Content Disposition</title>
      <link>https://ynikl.github.io/blog/http-content-disposition/</link>
      <pubDate>Sun, 04 Sep 2022 21:32:24 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/http-content-disposition/</guid>
      <description>Content-Disposition 常见是用在 http 请求的 Response 的 Header 头部.
告诉请求客户端(浏览器) 如何处理内容;
Content-Disposition是在 MIME 标准定义的. http 中的用法只是其中的一小部分.
语法参数 inline 会在浏览器内部显示
1 Content-Disposition: inline attachment 会被保存成文件
1 Content-Disposition: attachment 后面可以跟 filename, 值为预设文件名称, 中间使用;分号隔开.
1 Content-Disposition: attachment; filename=&amp;#34;filename.jpg&amp;#34; 拓展参数, 有两个文件名称参数可选
filename* filename filename* 采用了 RFC 5987 中规定的编码方式, 假如两个参数都使用 filename* 的优先级更高
RFC 5987 该提议最终还是引用 RFC 2231 中的编码方式. 下面简单介绍一下语法
*星号用于标记该同名参数是支持该编码语法的, 就如( filename* 之于 filename) &#39;单个逗号用于分割 字符集名称 , 语言, 文件名称 %百分号用于标记编码方式, 参考RFC 2047, 所以文件名中不能有% 1 filename*=us-ascii&amp;#39;en-us&amp;#39;This%20is%20%2A%2A%2Afun%2A%2A%2A 使用us-ascii编码, en-us英语</description>
      <content:encoded><![CDATA[<p><code>Content-Disposition</code> 常见是用在 http 请求的 Response 的 Header 头部.</p>
<p>告诉请求客户端(浏览器) 如何处理内容;</p>
<p><code>Content-Disposition</code>是在 MIME 标准定义的. http 中的用法只是其中的一小部分.</p>
<h2 id="语法参数">语法参数</h2>
<h3 id="inline">inline</h3>
<p>会在浏览器内部显示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: inline
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="attachment">attachment</h3>
<p>会被保存成文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: attachment
</span></span></code></pre></td></tr></table>
</div>
</div><p>后面可以跟 filename, 值为预设文件名称, 中间使用<code>;</code>分号隔开.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: attachment; filename=&#34;filename.jpg&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>拓展参数, 有两个文件名称参数可选</p>
<ul>
<li>filename*</li>
<li>filename</li>
</ul>
<p><code>filename*</code> 采用了 RFC 5987 中规定的编码方式,
假如两个参数都使用 <code>filename*</code> 的优先级更高</p>
<h4 id="rfc-5987">RFC 5987</h4>
<p>该提议最终还是引用 <a href="https://www.rfc-editor.org/rfc/rfc2231#section-4">RFC 2231</a>
中的编码方式. 下面简单介绍一下语法</p>
<ul>
<li><code>*</code>星号用于标记该同名参数是支持该编码语法的, 就如( <code>filename*</code> 之于 <code>filename</code>)</li>
<li><code>'</code>单个逗号用于分割 <strong>字符集名称</strong> , <strong>语言</strong>, <strong>文件名称</strong></li>
<li><code>%</code>百分号用于标记编码方式, 参考<a href="https://www.rfc-editor.org/rfc/rfc2047">RFC 2047</a>, 所以文件名中不能有<code>%</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">filename*=us-ascii&#39;en-us&#39;This%20is%20%2A%2A%2Afun%2A%2A%2A
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>us-ascii</code>编码, <code>en-us</code>英语</p>
<h2 id="问题-下载文件名称乱码">问题: 下载文件名称乱码</h2>
<p>根据上面的知识, 就可以解决有的浏览器下载文件时中文名称乱码.</p>
<ul>
<li>Http 返回设置<code>Content-Disposition</code>值</li>
<li>使用 RFC 2231 的文件名称方式, 制定编码<code>utf-8</code></li>
<li>将文件名称移除<code>%</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">disposition</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;attachment;filename*=utf-8&#39;&#39;%s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">.</span><span class="nf">QueryEscape</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition">MDN</a>
<a href="https://www.rfc-editor.org/rfc/rfc2231#section-4">RFC 2231</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang Map 介绍</title>
      <link>https://ynikl.github.io/blog/golang-map/</link>
      <pubDate>Sat, 13 Aug 2022 14:14:30 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-map/</guid>
      <description>本想写一篇关于 golang 中 map 底层的文章， 但是发现已经了相当不错的文章 &amp;ndash; 字节跳动技术团队 - Golang 中 map 探究 这里只补充一下，缺少的 map 的删除操作
内部数据结构 初始化 map 是一个有&amp;quot;包含内容&amp;quot;的数据结构, 使用之前需要提前初始化, 即调用make
真正是调用源码是 runtime.makemap
获取数据 删除 源码地址
删除的关键代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Only clear key if there are pointers in it. // # 当 Key 是指针类型的时候会去清空指针 if t.key.ptrdata != 0 { if goarch.</description>
      <content:encoded><![CDATA[<p>本想写一篇关于 golang 中 map 底层的文章， 但是发现已经了相当不错的文章 &ndash;
<a href="https://mp.weixin.qq.com/s/UT8tydajjOUJkfc-Brcblw">字节跳动技术团队 - Golang 中 map 探究</a>
这里只补充一下，缺少的 map 的删除操作</p>
<h2 id="内部数据结构">内部数据结构</h2>
<h2 id="初始化">初始化</h2>
<p>map 是一个有&quot;包含内容&quot;的数据结构, 使用之前需要提前初始化, 即调用<code>make</code></p>
<p>真正是调用源码是 <a href="https://cs.opensource.google/go/go/+/master:src/runtime/map.go;l=283;bpv=1;bpt=1?q=makemap&amp;ss=go%2Fgo">runtime.makemap</a></p>
<h2 id="获取数据">获取数据</h2>
<h2 id="删除">删除</h2>
<p><a href="https://cs.opensource.google/go/go/+/master:src/runtime/map_fast64.go;drc=3e5c2c155645ebaed62e4481430c455045b0fff5;bpv=1;bpt=1;l=273?q=mapdelete_fast64&amp;ss=go%2Fgo">源码地址</a></p>
<p>删除的关键代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="c1">// Only clear key if there are pointers in it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// # 当 Key 是指针类型的时候会去清空指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">key</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">goarch</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="o">==</span> <span class="mi">8</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)(</span><span class="nx">k</span><span class="p">)</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="c1">// There are three ways to squeeze at one ore more 32 bit pointers into 64 bits.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="c1">// Just call memclrHasPointers instead of trying to handle all cases here.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>					<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="mi">8</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			
</span></span><span class="line"><span class="cl">			<span class="nx">e</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="mi">8</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">elemsize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// # 当 Value 为指针类型的时候, 指针为空, 解除引用 -&gt; GC
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">e</span><span class="p">,</span> <span class="nx">t</span><span class="p">.</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">			<span class="c1">// # 讲 hash 值标记为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nx">b</span><span class="p">.</span><span class="nx">tophash</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="p">=</span> <span class="nx">emptyOne</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述删除代码操作现象</p>
<ul>
<li>当<code>map</code>的<code>value</code>类型中包含引用类型, 删除对应的<code>key</code>之后, 经过GC就会释放占用的内存</li>
<li>当<code>map</code>的<code>value</code> 类型不包含引用类型, 删除对应的<code>key</code>之后, GC无法释放类型</li>
</ul>
<p>可以查看我自己的实验结果 {{}}</p>
https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/
<h2 id="扩容">扩容</h2>
<h2 id="参考">参考</h2>
<p><a href="https://mp.weixin.qq.com/s/UT8tydajjOUJkfc-Brcblw">Golang 中 map 探究</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>xorm 的 session 和 salve 的区别</title>
      <link>https://ynikl.github.io/blog/xorm-slave-newsseion/</link>
      <pubDate>Fri, 22 Jul 2022 19:08:05 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/xorm-slave-newsseion/</guid>
      <description>简单分析下xorm 里面 session 和 slave 里面 close 的代码
1 xorm.EngineGroup.Slave() Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用）） 如果这时候再调用 close 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。 如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 NewSsession 和 Close, 所以不在需要手动调用close 1 xorm.EngineGroup.NewSsession() 会返回一个xorm.Session对象, 对应我们数据库操作中的&amp;quot;会话事务&amp;quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交) 调用 close, 对清除 session 中未提交的事务和一些缓存的 sql 前置处理语句 对于普通 select 语句调不调用是没什么太大影响 (但是还是建议new之后调用close) </description>
      <content:encoded><![CDATA[<p>简单分析下xorm 里面 session 和 slave 里面 close 的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xorm.EngineGroup.Slave()
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用））</li>
<li>如果这时候再调用 <code>close</code> 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。</li>
<li>如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 <code>NewSsession</code> 和 <code>Close</code>, 所以不在需要手动调用<code>close</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xorm.EngineGroup.NewSsession()
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>会返回一个<code>xorm.Session</code>对象, 对应我们数据库操作中的&quot;会话事务&quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交)</li>
<li>调用 <code>close</code>, 对清除 session 中未提交的事务和一些缓存的 <code>sql</code> 前置处理语句</li>
<li>对于普通 <code>select</code> 语句调不调用是没什么太大影响 (但是还是建议<code>new</code>之后调用<code>close</code>)</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go中slice[i:j:k]第三个参数是做什么的</title>
      <link>https://ynikl.github.io/blog/golang-reslicing-slice/</link>
      <pubDate>Thu, 09 Jun 2022 23:52:30 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-reslicing-slice/</guid>
      <description>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.
简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:
1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:
array 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址
简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, &amp;ldquo;左闭右开原则&amp;rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即&amp;quot;cap(a) - low&amp;quot; low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt.</description>
      <content:encoded><![CDATA[<p>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.</p>
<h2 id="简单介绍-slice-的数据结构">简单介绍 slice 的数据结构</h2>
<p>首先, 介绍一下 golang 中切片的结构体:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type slice struct {
</span></span><span class="line"><span class="cl">	array unsafe.Pointer
</span></span><span class="line"><span class="cl">	len   int
</span></span><span class="line"><span class="cl">	cap   int
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>有三个字段:</p>
<ul>
<li>array 是切片所指向的底层数组数据</li>
<li>len 就是切片的长度</li>
<li>cap 即容量, 很明显</li>
</ul>
<p><a href="https://cs.opensource.google/go/go/+/master:src/runtime/slice.go;l=15?q=slice&amp;ss=go%2Fgo">源码地址</a></p>
<h2 id="简单版重切片-alowhigh">简单版重切片 <code>a[low:high]</code></h2>
<ul>
<li>接受切片中的开始下标和结束下标, &ldquo;左闭右开原则&rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值</li>
<li>新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即&quot;cap(a) - low&quot;</li>
<li>low 参数可以省略, 默认从 0 下标开始</li>
<li>high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [10]int{}
</span></span><span class="line"><span class="cl">oldSlice := a[:5]
</span></span><span class="line"><span class="cl">newSlice := a[2:4]
</span></span><span class="line"><span class="cl">fmt.Printf(&#34;b: len %d, cap %d, c: len %d, c:cap %d&#34;, len(b), cap(b), len(c), cap(c))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">输出:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b: len 5, cap 10, c: len 2, c:cap 8
</span></span></code></pre></td></tr></table>
</div>
</div><p>底层分配情况如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">底层数组       : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">旧切片容量: 10 : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">旧切片长度: 5  : [0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">新切片容量: 8  :     [0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">新切片长度: 2  :     [0 0]
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="完整版重切片-alowhighmax">完整版重切片 <code>a[low:high:max]</code></h2>
<p>完整版是为了补充简单版, 新切片会默认拥有从开始下标后的所有底层数组容量. 即新数组拥有修改全部数据底层能力 (<strong>重切片出来的不同切片, 在没有 append 操作触发重新分配底层数组的前提下, 指向的都是同一个数据, 修改数据相互可见</strong>)</p>
<ul>
<li>增加了 max 参数, 表示新切片可以获取到最大的原切片的容量大小.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [10]int{}
</span></span><span class="line"><span class="cl">oldSlice := a[:5]
</span></span><span class="line"><span class="cl">newSlice := a[2:4:6]
</span></span><span class="line"><span class="cl">fmt.Printf(&#34;b: len %d, cap %d, c: len %d, c:cap %d&#34;, len(b), cap(b), len(c), cap(c))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">输出:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b: len 5, cap 10, c: len 2, c:cap 4
</span></span></code></pre></td></tr></table>
</div>
</div><p>底层分配情况如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">底层数组       : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">旧切片容量:10  : [0 0 0 0 0 0 0 0 0 0] 
</span></span><span class="line"><span class="cl">旧切片长度:5   : [0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">新切片容量:4   :     [0 0 0 0] 
</span></span><span class="line"><span class="cl">新切片长度:2   :     [0 0]
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是, 如果 max 要求获取的容量大于旧数据容量. 可想而知, 那一定会 <code>panic</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[:</span><span class="mi">4</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">输出</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">panic</span><span class="p">:</span> <span class="nx">runtime</span> <span class="kt">error</span><span class="p">:</span> <span class="nx">slice</span> <span class="nx">bounds</span> <span class="nx">out</span> <span class="nx">of</span> <span class="k">range</span> <span class="p">[::</span><span class="mi">5</span><span class="p">]</span> <span class="nx">with</span> <span class="nx">capacity</span> <span class="mi">4</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以参数要求: <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/27938177/golang-slice-slicing-a-slice-with-sliceabc">stack overflow 问题1 简单版</a></li>
<li><a href="https://stackoverflow.com/questions/12768744/re-slicing-slices-in-golang/18911267#18911267">stack overflow 问题2 详细版</a></li>
<li><a href="https://go.dev/ref/spec#Slice_expressions">golang 官方文档</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>小窥 Go 中的 Modules</title>
      <link>https://ynikl.github.io/blog/go-modules/</link>
      <pubDate>Fri, 03 Jun 2022 18:16:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/go-modules/</guid>
      <description>是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =&amp;gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 &amp;gt; cat go.</description>
      <content:encoded><![CDATA[<h2 id="是什么">是什么</h2>
<p>Modules （下文称为模块）是 Go 语言设计用来管理依赖包。</p>
<p>在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。</p>
<p>模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在<code>go.mod</code>文件中。</p>
<h3 id="gomod-文件">go.mod 文件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">module example.com/my/thing
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">go 1.12
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">require example.com/other/thing v1.0.2
</span></span><span class="line"><span class="cl">require example.com/new/thing/v2 v2.3.4
</span></span><span class="line"><span class="cl">exclude example.com/old/thing v1.2.3
</span></span><span class="line"><span class="cl">replace example.com/bad/thing v1.4.5 =&gt; example.com/good/thing v1.4.5
</span></span><span class="line"><span class="cl">retract [v1.9.0, v1.9.5]
</span></span></code></pre></td></tr></table>
</div>
</div><p>文件中各行意思</p>
<ul>
<li>module 当前自己模块的名的完整路径</li>
<li>go 版本号</li>
<li>require 需要依赖的目标模块以及最小的版本号</li>
<li>exclude 排除目标模块的特定版本</li>
<li>replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块</li>
<li>retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况</li>
</ul>
<p><code>go.mod</code> 可以通过相关命令修改，也可以直接修改文件数据</p>
<h3 id="gosum-文件">go.sum 文件</h3>
<p>与<code>go.mod</code>经常在一起的会是一个<code>go.sum</code>文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; cat go.sum
</span></span><span class="line"><span class="cl">example.com/mod v1.0.0 h1:6Cz1EhbAk54HWaw6fhCpSPxWGjIMLuF9MlO4Ou568sQ=
</span></span><span class="line"><span class="cl">example.com/mod v1.0.0/go.mod h1:mgm3p5SY7FVOgVLVSXIYK9qk0umwLQLOG06xLpFUeTI=
</span></span></code></pre></td></tr></table>
</div>
</div><p>文件中以：模块路径 + 版本号 + hash算法名 + hash值 的组合写入</p>
<ul>
<li><code>example.com/mod</code> 是模块路径名</li>
<li>v1.0.0 是版本号，在第二行有是以<code>/go.mod</code>结尾，代表该 hash 值是对依赖模块本身的<code>go.mod</code>文件的 hash 值</li>
<li>h1: 代表使用的 hash 算法，代表 SHA-256</li>
<li>哈希值，没什么好说的了</li>
</ul>
<h3 id="module-cache">Module cache</h3>
<p>本地的目录，用户存放下载下来的的模块文件。</p>
<p>默认路径是在<code>$GOPAth/pkg/mod</code></p>
<p><a href="https://go.dev/ref/mod#module-cache">Module cache 文件夹详细说明</a></p>
<h3 id="语义化版本">语义化版本</h3>
<p>go 采用语义化版本 v1.18.1</p>
<p>一个模块的版本是不变的 —— 只要拉过一次模块，该模块就会存在缓存在<a href="https://proxy.golang.org/">Go 官方的模块服务</a>中，以后拉取改模块就会从官方的模块服务拉取，且该动作不可逆。</p>
<p>版本号 = &ldquo;v&rdquo; + 主版本号 + 小版本号 + 补丁号</p>
<ul>
<li>主版本号的增加后，小版本号和补丁号要重新置零。主版本号增加，代表该版本出现不向后兼容的改动。比如移除旧的包</li>
<li>小版本号增加后，补丁号重新置零。表示版本改动公共接口但是向后兼容的，比如增加一个函数</li>
<li>补丁号增加，表示该版本对公开接口没有改动。比如修改bug</li>
</ul>
<p>版本的后面可能还会增加一些提前发布的标识，比如 v1.18.1-beta v1.18.1-pre</p>
<p>当 go 的 模块没有声明发布版本的时候(比如拉取某分支做为模块)，go 就会自己生成 <a href="https://go.dev/ref/mod#pseudo-versions">伪版本</a>, 可以仅作了解。</p>
<p><strong>如果使用模块的版本号大于等于v2的时候，需要在引入包的后缀加上<code>/v2</code></strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import &#34;github.com/urfave/cli/v2&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="怎么用">怎么用</h2>
<h3 id="开启模块功能">开启模块功能</h3>
<p>模块功能的开启, 配置在环境变量<code>GO111MODULE</code></p>
<ul>
<li>=off, 忽略<code>GOPATH</code>路径下的<code>go.mod</code>文件，直接引用<code>GOPATH/src</code>中的包文件</li>
<li>=on，启用模块功能</li>
<li>=auto, 如果项目有<code>go.mod</code>文件启用，没有则是用<code>GOPATH</code>模式</li>
</ul>
<h3 id="常用命令快览">常用命令快览</h3>
<p><strong>go mod</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod init example.com/example/m1
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化当前文件夹，让其成为一个 module</p>
<p><strong>go get</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get -d example.com/example/m1@v1.2.3
</span></span></code></pre></td></tr></table>
</div>
</div><p>主要用法:修改当前项目的<code>go.mod</code>，引入新的依赖项目。</p>
<p><code>-d</code> 的标志，表示获取目标包之后，不进行本地编译或安装。Go 1.18 之后的默认行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get -d -u example.com/example/m1
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以用来升级依赖模块的版本，升级到最新版本。如果目标模块的新版的所依赖的其他模块也可能会一并升级。也可以指定版本<code>-u=patch</code></p>
<p>修改制定依赖版本的操作也可以通过制定后缀版本号实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get example.com/example/m1@v2.3.1
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>go mod edit</strong></p>
<p>通过指令修改<code>go.mod</code>文件，与直接修改<code>go.mod</code>效果一致</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod edit -replace example.com/a@v1.0.0=./a
</span></span></code></pre></td></tr></table>
</div>
</div><p>将某个模块引用指向本地。可以用来解决引用正在开发中，还没有发布过的模块</p>
<p><strong>go mod tidy</strong></p>
<p>根据项目的源码引用整理<code>go.mod</code>中的引用情况。添加缺少的依赖，或者移除冗余的依赖。</p>
<p><strong>go mod vendor</strong></p>
<p>将依赖一并放在自己项目的中，可以省去自己拉取依赖的很多麻烦，提高可用性。go 项目的根目录中的 vendor 文件夹就是用来干这个事的</p>
<p>将项目依赖移入<code>vendor</code>文件中，当存在了vendor文件夹，项目会使用vendor中的依赖。大于 1.14 版本需要指定参数<code>-mod=vendor</code>才会启用</p>
<p>本地修改之后模块版本之后需要，重新使用<code>go mod vendor</code>将新的依赖模块同步入<code>vendor</code>中。</p>
<p><strong>go mod verify</strong></p>
<p>用于检测模块再被下载之后入，模块中的代码是否有被修改过。</p>
<p>对源码文件的 hash，与当前文件的<code>go.sum</code>中的 hash 对比校验是否有被修改过。
如果<code>go.sum</code>中没有该模块的hash值，就会从<a href="https://sum.golang.org">checksum database</a> 中获取目标 hash 值。（除非设置了<code>GOPRIVATE</code>或者<code>GONOSUMDB</code>)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">❯ go mod verify
</span></span><span class="line"><span class="cl">github.com/ynikl/playmod v1.0.0: dir has been modified (/Users/ian/go/pkg/mod/github.com/ynikl/playmod@v1.0.0)
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述例子，源文件被我手动强制修改过，就会报错</p>
<p><strong>go mod why</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod why example.com/mod
</span></span></code></pre></td></tr></table>
</div>
</div><p>用于解释当前项目为什么会依赖某一个模块，输出项目对目标模块的依赖树图</p>
<p><strong>go list -m all</strong></p>
<p>可以用于输出当前项目依赖的所有模块</p>
<h3 id="mvs">MVS</h3>
<p><em>Minimal version selection</em>（MVS), 当引入的不同模块，又存在依赖与相同模块的（相同大版本，不同版本小版本）的时候。</p>
<p>在使用模块相关命令的时候，会选择所依赖的不同版本的中，构建项目所需要从最小版本。</p>
<p><img loading="lazy" src="mvs.png" alt="图片来源于官网"  />
</p>
<p>A.12 与 B1.2 分别需要 C1.3 和 C1.4 为了是项目能正常进行，需要使用 C1.4 版本</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://go.dev/ref/mod">官网Go Modules参考</a></li>
<li><a href="https://research.swtch.com/vgo-mvs">Minimal Version Seletion</a></li>
<li><a href="https://go.dev/blog/modules2019">官方介绍 Modules 博文</a></li>
<li><a href="https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#checksum-database">提议</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>并发与并行的区别</title>
      <link>https://ynikl.github.io/blog/concurrency-and-parallelism/</link>
      <pubDate>Tue, 31 May 2022 22:36:34 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/concurrency-and-parallelism/</guid>
      <description>举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。
并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构
并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。
Concurrency is not Parallelism by Rob Pike</description>
      <content:encoded><![CDATA[<p>举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。</p>
<p>并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构</p>
<p>并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。</p>
<p><a href="https://www.youtube.com/watch?v=oV9rvDllKEg&amp;list=WL&amp;index=5&amp;t=9s">Concurrency is not Parallelism by Rob Pike</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go-互斥锁的实现</title>
      <link>https://ynikl.github.io/blog/golang-sync_mutex/</link>
      <pubDate>Sun, 29 May 2022 20:52:35 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-sync_mutex/</guid>
      <description>Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法
Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。
Mutex 实现了一个 sync.Locker 接口, 该接口只有两个方法
Lock Unlock Mutex 锁有几种状态
mutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量
mutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态</description>
      <content:encoded><![CDATA[<h2 id="mutex-数据结构">Mutex 数据结构</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">state</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sema</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Mutex 使用过之后是不可被拷贝的</li>
<li>state 等于 0 值的时候才是无锁的状态</li>
<li>sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。</li>
</ul>
<p>Mutex 对象总共有三个公开方法</p>
<ul>
<li>Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞</li>
<li>TryLock</li>
<li>Unlock 解除互斥锁， <strong>解锁未锁定的互斥锁会发生panic</strong></li>
</ul>
<p>Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。</p>
<p>Mutex 实现了一个 <code>sync.Locker</code> 接口, 该接口只有两个方法</p>
<ul>
<li>Lock</li>
<li>Unlock</li>
</ul>
<p>Mutex 锁有几种状态</p>
<ul>
<li>mutexLocked = 1 已经锁定</li>
<li>mutexWoken = 2  表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量</li>
<li>mutexStarving = 4 当前锁已经进入了饥饿状态</li>
</ul>
<p>其他常量</p>
<ul>
<li>mutexWaiterShift = 3 统计的等待在<code>Mutex.state</code>字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving）</li>
<li>starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms</li>
</ul>
<h2 id="mutex-锁的竞争方式">Mutex 锁的竞争方式</h2>
<p>Mutex 锁有两种状态</p>
<ul>
<li>正常模式 normal</li>
<li>饥饿模式 starvation</li>
</ul>
<p>正常模式下，等待获取的锁的协程遵循先进先出的原则。</p>
<p>但是，当释放锁的时候如果有新协程进入获取锁代码的时候。因为新入协程本身已经运行在CPU上了，所以有抢占锁的优势。由于阻塞在等待队列上的协程，竞争不过新入协程。当等待时间操作 1ms，就会触发饥饿模式。</p>
<p>饥饿模式，进行互斥锁解锁的协程直接的将锁的所有权直接已经给等待队列的第一个协程。新进协程被禁止抢占互斥锁。</p>
<p>在转移所有权的时候，如果满足一下任意条件，则进入正常模式：</p>
<ul>
<li>锁的等待者只剩最后一个</li>
<li>等待时间小于1ms</li>
</ul>
<p>正常模式有利于更好的性能，饥饿模式则避免出现“饿死”情况。</p>
<h2 id="mutex-的方法详解">Mutex 的方法详解</h2>
<h3 id="lock">Lock</h3>
<p>第一步，通过调用 atomic 的 CAS 操作，尝试加锁，如果成功加锁直接返回</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked)
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果第一步失败，则代表该锁已经被加过锁，锁定了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="ne">Mutex</span><span class="p">)</span> <span class="n">lockSlow</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="err">当前协程的变量</span><span class="p">,</span> <span class="err">可以用于表示当前协程的状态</span>
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="err">用于统计锁的等待时长，是否进入饥饿模式</span>
</span></span><span class="line"><span class="cl">	<span class="k">var</span> <span class="n">waitStartTime</span> <span class="n">int64</span>
</span></span><span class="line"><span class="cl">	<span class="n">starving</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span> <span class="o">//</span> <span class="err">当前协程是否处于饥饿</span>
</span></span><span class="line"><span class="cl">	<span class="n">awoke</span> <span class="p">:</span><span class="o">=</span> <span class="bp">false</span> <span class="o">//</span> <span class="err">是否处于唤醒</span>
</span></span><span class="line"><span class="cl">	<span class="n">iter</span> <span class="p">:</span><span class="o">=</span> <span class="mi">0</span> <span class="o">//</span> <span class="err">统计自旋次数</span>
</span></span><span class="line"><span class="cl">	<span class="n">old</span> <span class="p">:</span><span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">state</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">//</span> <span class="err">进入自旋的状态条件，</span> <span class="o">**</span><span class="err">已经锁定</span><span class="o">**</span> <span class="err">且非饥饿状态。</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">old</span><span class="o">&amp;</span><span class="p">(</span><span class="n">mutexLocked</span><span class="o">|</span><span class="n">mutexStarving</span><span class="p">)</span> <span class="o">==</span> <span class="n">mutexLocked</span> <span class="o">&amp;&amp;</span> <span class="n">runtime_canSpin</span><span class="p">(</span><span class="n">iter</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">如果锁的状态</span> <span class="n">woken</span> <span class="err">字段未被标记，</span> <span class="err">将自身标记位唤醒，且将</span> <span class="ne">Mutex</span> <span class="err">的</span> <span class="n">woken</span> <span class="err">位标记位</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">当协程自己进入获取锁的第一候选人</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="o">!</span><span class="n">awoke</span> <span class="o">&amp;&amp;</span> <span class="n">old</span><span class="o">&amp;</span><span class="n">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">old</span><span class="o">&gt;&gt;</span><span class="n">mutexWaiterShift</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">				<span class="n">atomic</span><span class="o">.</span><span class="n">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">old</span><span class="o">|</span><span class="n">mutexWoken</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">awoke</span> <span class="o">=</span> <span class="bp">true</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="n">runtime_doSpin</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">控制自旋次数，大于</span><span class="mi">4</span><span class="err">次之后不进入自旋状态</span>
</span></span><span class="line"><span class="cl">			<span class="n">iter</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">获取最新的状态</span>
</span></span><span class="line"><span class="cl">			<span class="n">old</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">state</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="o">//</span> <span class="err">有可能，自旋自后已经解锁或者只是单纯不能自旋限制了。下面尝试通过</span> <span class="n">CAS</span> <span class="err">竞争锁。</span>
</span></span><span class="line"><span class="cl">		<span class="o">//</span> <span class="err">新值用于设置新的状态</span>
</span></span><span class="line"><span class="cl">		<span class="n">new</span> <span class="p">:</span><span class="o">=</span> <span class="n">old</span>
</span></span><span class="line"><span class="cl">		<span class="o">//</span> <span class="err">非饥饿状态才设置锁定</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">old</span><span class="o">&amp;</span><span class="n">mutexStarving</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">new</span> <span class="o">|=</span> <span class="n">mutexLocked</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">old</span><span class="o">&amp;</span><span class="p">(</span><span class="n">mutexLocked</span><span class="o">|</span><span class="n">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">等待者加</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">			<span class="n">new</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">mutexWaiterShift</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="o">//</span> <span class="err">当前协程是饥饿状态，尝试标记锁的新状态位饥饿状态。</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">starving</span> <span class="o">&amp;&amp;</span> <span class="n">old</span><span class="o">&amp;</span><span class="n">mutexLocked</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="n">new</span> <span class="o">|=</span> <span class="n">mutexStarving</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">awoke</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="n">The</span> <span class="n">goroutine</span> <span class="n">has</span> <span class="n">been</span> <span class="n">woken</span> <span class="n">from</span> <span class="n">sleep</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="n">so</span> <span class="n">we</span> <span class="n">need</span> <span class="n">to</span> <span class="n">reset</span> <span class="n">the</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">either</span> <span class="k">case</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="n">new</span><span class="o">&amp;</span><span class="n">mutexWoken</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="o">//</span> <span class="ne">Mutex</span> <span class="err">的唤醒位被抢走，出现不一致。协程变量的唤醒位应该与</span> <span class="ne">Mutex</span> <span class="err">的唤醒位一致</span>
</span></span><span class="line"><span class="cl">				<span class="n">throw</span><span class="p">(</span><span class="s2">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">标志</span> <span class="err">锁的唤醒位为</span><span class="mi">0</span>
</span></span><span class="line"><span class="cl">			<span class="n">new</span> <span class="o">&amp;^=</span> <span class="n">mutexWoken</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="o">//</span> <span class="n">CAS</span> <span class="err">尝试</span><span class="p">,</span> <span class="ne">Mutex</span> <span class="err">状态没有被变更</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">CompareAndSwapInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">非饥饿状态下，</span><span class="n">CAS</span> <span class="err">成功新的</span> <span class="n">new</span> <span class="err">字段中会有</span> <span class="n">mutexLocked</span> <span class="err">标记（在</span><span class="n">new下的第一个if</span><span class="err">）。当前协程获取到了互斥锁</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="n">old</span><span class="o">&amp;</span><span class="p">(</span><span class="n">mutexLocked</span><span class="o">|</span><span class="n">mutexStarving</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span> <span class="o">//</span> <span class="n">locked</span> <span class="n">the</span> <span class="n">mutex</span> <span class="n">with</span> <span class="n">CAS</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="n">queueLifo</span> <span class="err">表示该协程是否为第一次获取锁。如果中间被唤醒过，这放在等待队列头部</span>
</span></span><span class="line"><span class="cl">			<span class="n">queueLifo</span> <span class="p">:</span><span class="o">=</span> <span class="n">waitStartTime</span> <span class="o">!=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="n">waitStartTime</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="n">waitStartTime</span> <span class="o">=</span> <span class="n">runtime_nanotime</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">通过信号量，进入阻塞</span> 
</span></span><span class="line"><span class="cl">			<span class="n">runtime_SemacquireMutex</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">.</span><span class="n">sema</span><span class="p">,</span> <span class="n">queueLifo</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">进入饥饿模式</span>
</span></span><span class="line"><span class="cl">			<span class="n">starving</span> <span class="o">=</span> <span class="n">starving</span> <span class="o">||</span> <span class="n">runtime_nanotime</span><span class="p">()</span><span class="o">-</span><span class="n">waitStartTime</span> <span class="o">&gt;</span> <span class="n">starvationThresholdNs</span>
</span></span><span class="line"><span class="cl">			<span class="n">old</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">state</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">当前是饥饿模式</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="n">old</span><span class="o">&amp;</span><span class="n">mutexStarving</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="o">//</span> <span class="err">如果当前锁的状态位饥饿模式，但是当前协程可以执行的当前行代码，代表当前协程已经被从阻塞中唤醒。</span>
</span></span><span class="line"><span class="cl">				<span class="o">//</span> <span class="err">饥饿状态</span> <span class="o">+</span> <span class="err">被唤醒</span> <span class="o">=</span><span class="err">》当前锁已经已经到当前协程上</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="n">old</span><span class="o">&amp;</span><span class="p">(</span><span class="n">mutexLocked</span><span class="o">|</span><span class="n">mutexWoken</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">old</span><span class="o">&gt;&gt;</span><span class="n">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="o">//</span> <span class="err">检查状态一致</span>
</span></span><span class="line"><span class="cl">					<span class="n">throw</span><span class="p">(</span><span class="s2">&#34;sync: inconsistent mutex state&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="o">//</span> <span class="err">由当协程来设置最新的锁定状态</span>
</span></span><span class="line"><span class="cl">				<span class="n">delta</span> <span class="p">:</span><span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="n">mutexLocked</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">mutexWaiterShift</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="o">//</span> <span class="err">判断是否需要退出饥饿模式</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="o">!</span><span class="n">starving</span> <span class="o">||</span> <span class="n">old</span><span class="o">&gt;&gt;</span><span class="n">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="n">delta</span> <span class="o">-=</span> <span class="n">mutexStarving</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">				<span class="n">atomic</span><span class="o">.</span><span class="n">AddInt32</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">break</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">当前是正常模式，通过</span><span class="n">CAS自由竞争锁</span><span class="err">。</span>
</span></span><span class="line"><span class="cl">			<span class="n">awoke</span> <span class="o">=</span> <span class="bp">true</span>
</span></span><span class="line"><span class="cl">			<span class="n">iter</span> <span class="o">=</span> <span class="mi">0</span> <span class="o">//</span> <span class="err">重置计数</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">再来</span>
</span></span><span class="line"><span class="cl">			<span class="n">old</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">state</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>是否可以进入自旋状态代码解释<a href="https://cs.opensource.google/go/go/+/master:src/runtime/proc.go;l=6175?q=sync_runtime_canSpin&amp;ss=go%2Fgo">源码地址</a></p>
<h3 id="unlock">Unlock</h3>
<p>第一步直接减去 mutexLocked 标志位常量，如果 new 等于0结束——简单（锁一次开一次，easy）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">new := atomic.AddInt32(&amp;m.state, -mutexLocked)
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果 state 还不等于0（有协程等待，竞争锁）, 进入 unlockSlow</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="k">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="ne">Mutex</span><span class="p">)</span> <span class="n">unlockSlow</span><span class="p">(</span><span class="n">new</span> <span class="n">int32</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="err">上一步已经减过</span> <span class="n">locked</span> <span class="err">位，</span> <span class="err">在加上应该等于</span><span class="mi">1</span><span class="err">，否则不是正常解锁（解锁未锁定的锁）。</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">+</span><span class="n">mutexLocked</span><span class="p">)</span><span class="o">&amp;</span><span class="n">mutexLocked</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">fatal</span><span class="p">(</span><span class="s2">&#34;sync: unlock of unlocked mutex&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="o">//</span> <span class="err">正常模式</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="n">new</span><span class="o">&amp;</span><span class="n">mutexStarving</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">old</span> <span class="p">:</span><span class="o">=</span> <span class="n">new</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="n">If</span> <span class="n">there</span> <span class="n">are</span> <span class="n">no</span> <span class="n">waiters</span> <span class="ow">or</span> <span class="n">a</span> <span class="n">goroutine</span> <span class="n">has</span> <span class="n">already</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="n">been</span> <span class="n">woken</span> <span class="ow">or</span> <span class="n">grabbed</span> <span class="n">the</span> <span class="n">lock</span><span class="p">,</span> <span class="n">no</span> <span class="n">need</span> <span class="n">to</span> <span class="n">wake</span> <span class="n">anyone</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="n">In</span> <span class="n">starvation</span> <span class="n">mode</span> <span class="n">ownership</span> <span class="n">is</span> <span class="n">directly</span> <span class="n">handed</span> <span class="n">off</span> <span class="n">from</span> <span class="n">unlocking</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="n">goroutine</span> <span class="n">to</span> <span class="n">the</span> <span class="n">next</span> <span class="n">waiter</span><span class="o">.</span> <span class="n">We</span> <span class="n">are</span> <span class="ow">not</span> <span class="n">part</span> <span class="n">of</span> <span class="n">this</span> <span class="n">chain</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="n">since</span> <span class="n">we</span> <span class="n">did</span> <span class="ow">not</span> <span class="n">observe</span> <span class="n">mutexStarving</span> <span class="n">when</span> <span class="n">we</span> <span class="n">unlocked</span> <span class="n">the</span> <span class="n">mutex</span> <span class="n">above</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="n">So</span> <span class="n">get</span> <span class="n">off</span> <span class="n">the</span> <span class="n">way</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="err">没有等待协程无需通过信号量唤醒</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="mf">1.</span> <span class="err">如果</span> <span class="n">mutexLocked</span> <span class="err">位为</span><span class="mi">1</span><span class="err">，则代表锁已经被新入协程获取。</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="mf">2.</span> <span class="n">mutexWoken</span> <span class="err">代表协程有协程正在活动，无需再释放信号量</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="mf">3.</span> <span class="n">mutexStarving</span> <span class="err">锁的状态一直被抢占，才会导致当前位饥饿状态，无需在释放信号量</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="n">old</span><span class="o">&gt;&gt;</span><span class="n">mutexWaiterShift</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">old</span><span class="o">&amp;</span><span class="p">(</span><span class="n">mutexLocked</span><span class="o">|</span><span class="n">mutexWoken</span><span class="o">|</span><span class="n">mutexStarving</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="o">//</span> <span class="n">Grab</span> <span class="n">the</span> <span class="n">right</span> <span class="n">to</span> <span class="n">wake</span> <span class="n">someone</span><span class="o">.</span>
</span></span><span class="line"><span class="cl">			<span class="n">new</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">mutexWaiterShift</span><span class="p">)</span> <span class="o">|</span> <span class="n">mutexWoken</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="n">atomic</span><span class="o">.</span><span class="n">CompareAndSwapInt3</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">.</span><span class="n">state</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="o">//</span> <span class="err">信号量唤醒，各自竞争</span>
</span></span><span class="line"><span class="cl">				<span class="n">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">.</span><span class="n">sema</span><span class="p">,</span> <span class="bp">false</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">				<span class="k">return</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="n">old</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">state</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">//</span> <span class="err">饥饿模式，通过信号量直接移交当前</span><span class="n">CPU时间</span>
</span></span><span class="line"><span class="cl">		<span class="n">runtime_Semrelease</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">.</span><span class="n">sema</span><span class="p">,</span> <span class="bp">true</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span><span class="mi">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如何把锁移交给等待队列的协程？</p>
<p>使用 <code>Mutex.sema</code> 信号量实现锁转移</p>
<h2 id="参考">参考</h2>
<p><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18:src/sync/mutex.go;bpv=1;bpt=1">源代码地址sync.mutex.go</a>
<a href="https://pkg.go.dev/sync#Mutex">包说明文档</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Channel</title>
      <link>https://ynikl.github.io/blog/golang-channel/</link>
      <pubDate>Sat, 02 Apr 2022 10:09:22 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-channel/</guid>
      <description>Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本
channel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)
Do not communicate by sharing memory; instead, share memory by communicating.
channel 保证:
数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开 channel 的实现 channel 在内部实现的结构体为 runtime.hchan
有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe.</description>
      <content:encoded><![CDATA[<h1 id="go-中-channel-中用法和实现总结">Go 中 channel 中用法和实现总结</h1>
<p>以下分析和源码都是基于 go1.17 版本</p>
<h2 id="channel-简介">channel 简介</h2>
<p>Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (<strong>channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递</strong>)</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>channel 保证:</p>
<ol>
<li>数据的先入先出</li>
<li>并发情况下的数据安全</li>
<li>已经关闭的 channel 不可重开</li>
</ol>
<h2 id="channel-的实现">channel 的实现</h2>
<p>channel 在内部实现的结构体为 <code>runtime.hchan</code></p>
<ol>
<li>有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲.</li>
<li>有一把互斥锁<code>mutex</code>, 在并发情况下, 保护自身数据结构的一致性</li>
<li>有两个协程等待链表, 用于挂载因为<strong>发送/接收</strong>而阻塞在该 channel 上的协程</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// 当前 buffer 中有暂存着多少个数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 环形数组开始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">elemsize</span> <span class="kt">uint16</span>         <span class="c1">// channel 传输的元素大小, 用于计算内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">closed</span>   <span class="kt">uint32</span>         <span class="c1">// channel 是否已经关闭 0未关闭, 非0关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span>         <span class="c1">// element type # channel 元素的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sendx</span>    <span class="kt">uint</span>           <span class="c1">// 环形链表中, 发送数据存储的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">recvx</span>    <span class="kt">uint</span>           <span class="c1">// 环形链表中, 接受数据获取数据的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>          <span class="c1">// 阻塞在该 channel 等待获取数据的 Groutine 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>          <span class="c1">// 阻塞在该 channel 等待写入数据的 Groutine 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">lock</span> <span class="nx">mutex</span> <span class="c1">// # 互斥锁 用于保护自身数据变更
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化">初始化</h3>
<ol>
<li>channel 传递的元素不能太大</li>
<li>如果是空结构体或者无缓冲队列, 是不需要分配环形队列内存</li>
<li>如果传递数据类型有内含指针, 需要将环形队列分配到堆上</li>
</ol>
<p>内部实现函数<code>runtime.makechan</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// compiler checks this but be safe.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 编译器会校验channel元素的大小, 小于64KB. 若大于64KB, 编译器会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: invalid channel element type&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">hchanSize</span><span class="o">%</span><span class="nx">maxAlign</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">maxAlign</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: bad alignment&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">-</span><span class="nx">hchanSize</span> <span class="o">||</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// buf points into the same allocation, elemtype is persistent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Queue or element size is zero. # 无缓冲队列或者空结构体为传递值, 不需要额外分配队列内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Race detector uses this location for synchronization.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// # channel 元素不存在指针引导数据, 将环形数组分配在 hchan 后面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Elements do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Allocate hchan and buf in one call.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Elements contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankHchan</span><span class="p">)</span> <span class="c1">// # locakRankHchan 锁的等级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="关闭">关闭</h3>
<p>核心代码<code>runtime.closechan</code>更新自身数据结构中的关闭状态, 并 <strong>唤醒阻塞在 channel 上的所有协程</strong>. 被唤醒的协程(<code>sudog</code>)的 success 标识会被置为 false.</p>
<p>被唤醒的 写操作的协程, 也会发生panic. ( &ldquo;send on closed channel&rdquo; )</p>
<p>自身操作会发生 panic 的情况</p>
<ol>
<li>未初始化 channel</li>
<li>重复关闭 channel</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">closechan</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 未初始化的channel 会发生panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of nil channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 开始关闭, 锁定之后数据都进不来了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">glist</span> <span class="nx">gList</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// release all readers # 唤醒所有因为读取数据阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # [channel 唤醒协议总是设置params为sudog](https://github.com/golang/go/commit/30a68bfb806b5217932e280f5a5f521237e69077)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// release all writers (they will panic) # 唤醒所有因为写入数据阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Ready all Gs now that we&#39;ve dropped the channel lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 唤醒协程, 将协程加入调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="发送数据">发送数据</h3>
<p><strong>向已经关闭的 channel 发送数据会发生 panic</strong></p>
<p>数据流程:</p>
<ol>
<li>检查是否已经初始化</li>
<li>非阻塞写入数据, 检查数据是否已经满, 快速返回</li>
<li>是否已经关闭</li>
<li>检查 channel 中是否已经有等待获取数据而阻塞的协程,  如果有直接将数据发送给等待的协程.</li>
<li>channel 的 buffer 是否还有空间, 如果有将数据放置到 buffer 中, 返回</li>
<li>channel 的 buffer 已经满了, 根据是否为 select 操作, 判断是否需要将协程阻塞</li>
<li>当协程阻塞之后,  在被唤醒之后需要再检查一次, channel 是否已经关闭.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// # block 的参数是由是否在 select 中, 由编译过程决定的; 只有在select语句中block = true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 向未初始化的 channel 发送数据会永远阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanSendNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 带 select 的 channel 在数据已经满了情况直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">full</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 保护数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 先从接受协程队列中获取阻塞的协程, 直接将数据发送给阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Found a waiting receiver. We pass the value we want to send
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// directly to the receiver, bypassing the channel buffer (if any).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # channel 的 buffer 中还有剩余空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Space is available in the channel buffer. Enqueue the element to send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 环形队列, 当索引到最后从头开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 增加当前 channel buffer 存储的数据个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 发送数据的协程阻塞在当前 channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Block on the channel. Some receiver will complete our operation for us.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanSend</span><span class="p">,</span> <span class="nx">traceEvGoBlockSend</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Ensure the value being sent is kept alive until the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// receiver copies it out. The sudog has a pointer to the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack object, but sudogs aren&#39;t considered as roots of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack tracer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 协程被唤醒了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// someone woke us up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">closed</span> <span class="o">:=</span> <span class="p">!</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// # 挂载在协程上的发送协程会 panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">closed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="接收数据">接收数据</h3>
<p>与发送数据一样, 同样带着是否阻塞的参数. 在编译时,由是否有 select 操作决定. 核心代码<code>runtime.chanrecv</code></p>
<ol>
<li>不带 select 从未初始化的 channel 获取数据, 会永远阻塞</li>
<li><code>runtime.chanrecv</code> 返回值中, 第一个返回值<code>selected</code>表示在,select 语句中, 该 case 是否会被选中执行</li>
</ol>
<p>接收数据流程:</p>
<ol>
<li>检查是否已经初始化</li>
<li>检查非阻塞获取数据下, 是否可以直接返回</li>
<li>如果已经关闭的 channel 且没有已经没有缓冲数据, 返回数据类型的默认值.</li>
<li>检查有因发送数据阻塞在 channel 的协程, 如果没有 buffer, 直接从阻塞的协程中获取数据, 否则从 buffer 中获取数据数据, 将第一个阻塞的协程的数据放入 buffer 中.</li>
<li>如果缓冲 buffer 有数据, 则从buffer 中获取数据.</li>
<li>非阻塞操作, 直接返回. 否则协程进行阻塞.</li>
</ol>
<p>注意事项:</p>
<p><strong>当 select 一个 已经关闭的 channel 的时候, 该 case 会被疯狂输出, 导致cpu使用率上升</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// chanrecv receives on channel c and writes the received data to ep.
</span></span></span><span class="line"><span class="cl"><span class="c1">// ep may be nil, in which case received data is ignored.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If block == false and no elements are available, returns (false, false).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, if c is closed, zeros *ep and returns (true, false).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, fills in *ep with an element and returns (true, true).
</span></span></span><span class="line"><span class="cl"><span class="c1">// A non-nil ep must point to the heap or the caller&#39;s stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// select 情况下, selected = false, 不执行该 case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 非 select 会永远阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanReceiveNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 不加锁检查, 带 select 接收操作, 如果 channel 未关闭, 且没有可以获取的数据直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// After observing that the channel is not ready for receiving, we observe whether the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// channel is closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Reordering of these checks could lead to incorrect behavior when racing with a close.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// For example, if the channel was open and not empty, was closed, and then drained,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// reordered reads could incorrectly indicate &#34;open and empty&#34;. To prevent reordering,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// we use atomic loads for both checks, and rely on emptying and closing to happen in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// separate critical sections under the same lock.  This assumption fails when closing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// an unbuffered channel with a blocked send, but that is an error condition anyway.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Because a channel cannot be reopened, the later observation of the channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// being not closed implies that it was also not closed at the moment of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// first observation. We behave as if we observed the channel at that moment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// and report that the receive cannot proceed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The channel is irreversibly closed. Re-check whether the channel has any pending data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// to receive, which could have arrived between the empty and closed checks above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Sequential consistency is also required here, when racing with such a send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// The channel is irreversibly closed and empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// select 会选择改 case 疯狂输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// # 如果 channel 已经关闭, 且buffer 中已经没有数据了, 返回传输数据类型的默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// # 在返回的时候有可能刚好有数据会进来, 所以需要进行加锁操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The channel has been closed, but the channel&#39;s buffer have data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">		<span class="c1">// # 如果 channel 没有 buffer 会直接从阻塞中的发送数据协程中获取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// # 如果 channel 有 buffer. 当可以获取到因为发送数据而阻塞的协程时, 代表缓冲的 buffer 已经满了. 所以, 将从 buffer 中获取数据, 并将获取到的第一个阻塞协程, 的数据放入 buffer 尾端. 保证先入先出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Just found waiting sender with not closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Found a waiting sender. If buffer is size 0, receive value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// directly from sender. Otherwise, receive from head of queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// and add sender&#39;s value to the tail of the queue (both map to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// the same buffer slot because the queue is full).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 从 buffer 中获取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Receive directly from queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 非阻塞操作, 返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 将获取数据的协程阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// no sender available: block on this channel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanReceive</span><span class="p">,</span> <span class="nx">traceEvGoBlockRecv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// someone woke us up
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果是因为 channel的关闭 操作唤醒的, success 值为 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">success</span> <span class="o">:=</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">success</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="用法总结">用法总结</h2>
<p>初始化:</p>
<ol>
<li>避免对未初始化 channel 的进行读写操作, 可能会造成阻塞</li>
<li>在 select 语句中, 对已经关闭的 channel 可以赋予  <code>nil</code> 值, 避免 cpu 飙高</li>
</ol>
<p>关闭协程:</p>
<ol>
<li>关闭协程的动作, 应该由数据写入方操作</li>
<li>channel 当参数传递时, 尽可能带上操作方向(读取/写入), 编译器会保证, 单向写入协程不允许关闭</li>
<li>关闭的时候要确保所有的写入协程都已经操作完毕. 避免引起写入协程发生 panic</li>
</ol>
<p>在 channel 中阻塞的协程, 唤醒条件</p>
<ol>
<li>到达协程数据操作的目标, 写入 / 读取数据</li>
<li>channel 关闭</li>
</ol>
<h2 id="referrences">Referrences</h2>
<ol>
<li><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17:src/runtime/chan.go">Go官方源码</a></li>
<li><a href="https://go.dev/blog/codelab-share">Share Memory By Communication</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go 常用的命令汇总</title>
      <link>https://ynikl.github.io/blog/golang-cmd/</link>
      <pubDate>Fri, 01 Apr 2022 19:56:59 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/golang-cmd/</guid>
      <description>工具分类 go build 编译源代码文件
-race 编译出的目标程序，会启用数据竞争检测
go doc 查看包的文档(定义于doc.go的注释中), 于包中公开的函数签名
example
1 2 3 go doc go doc encoding/json go env 查看 go 相关的环境变量
1 2 3 4 5 # -w 设置环境变量 go env -w GOPAHT=&amp;#39;/some/path&amp;#39; # -u 恢复成默认设置 go env -u GOPATH go generate 扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”
注释的指令格式
//go:generate command argument...
ps: wire 也是利用命令, 生成依赖注入文件
go get 管理当前module依赖
1 2 3 4 5 6 7 8 # 添加依赖包 go get example.</description>
      <content:encoded><![CDATA[<h1 id="工具分类">工具分类</h1>
<h2 id="go-build">go build</h2>
<p>编译源代码文件</p>
<p><code>-race</code>
编译出的目标程序，会启用数据竞争检测</p>
<h2 id="go-doc">go doc</h2>
<p>查看包的文档(定义于<code>doc.go</code>的注释中), 于包中公开的函数签名</p>
<p>example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go doc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">go doc encoding/json
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-env">go env</h2>
<p>查看 go 相关的环境变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># -w 设置环境变量</span>
</span></span><span class="line"><span class="cl">go env -w <span class="nv">GOPAHT</span><span class="o">=</span><span class="s1">&#39;/some/path&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># -u 恢复成默认设置</span>
</span></span><span class="line"><span class="cl">go env -u GOPATH
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-generate">go generate</h2>
<p>扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”</p>
<p><strong>注释的指令格式</strong></p>
<p><code>//go:generate command argument...</code></p>
<p>ps: wire 也是利用命令, 生成依赖注入文件</p>
<h2 id="go-get">go get</h2>
<p>管理当前module依赖</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 添加依赖包
</span></span><span class="line"><span class="cl">go get example.com/pkg
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 指定包版本
</span></span><span class="line"><span class="cl">go get example.com/pkg@1.2.3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 移除依赖
</span></span><span class="line"><span class="cl">go get example.com/pkg@none
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-install">go install</h2>
<p>获取包文件，并编译和安装。可执行文件编译到<code>$GOBIN</code>路径下, 包文件编译到<code>$GOPATH/pkg</code></p>
<h2 id="go-list">go list</h2>
<p>列出包的数据信息</p>
<h2 id="go-mod">go mod</h2>
<p>管理 modules</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">edit	修改go.mod
</span></span><span class="line"><span class="cl">init	初始化
</span></span><span class="line"><span class="cl">tidy	自动补全依赖包
</span></span><span class="line"><span class="cl">vendor	生成一个所有依赖的vendor文件夹
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-test">go test</h2>
<p>跑单元测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go test -v .
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 指定函数
</span></span><span class="line"><span class="cl">go test -run 函数名
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 性能测试
</span></span><span class="line"><span class="cl">go test -v -bench . -benchtime 50s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 单元测试覆盖率
</span></span><span class="line"><span class="cl">go test -cover
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 强制重新跑测试, 不使用缓存的结果 source: https://stackoverflow.com/a/48882892/9992963
</span></span><span class="line"><span class="cl">go test -count=1
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-tool">go tool</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="c1"># 不带参数，显示工具列表</span>
</span></span><span class="line"><span class="cl"><span class="n">go</span> <span class="k">tool</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="compile">compile</h3>
<p>使用<code>go tool compile -N -l -S main.go</code>生成汇编代码</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
