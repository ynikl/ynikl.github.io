<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.111.1"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>潜水员的咖啡小屋</title><meta name=keywords content="Blog,Books,Posts"><meta name=description content="发发牢骚"><meta name=author content="潜水员"><link rel=canonical href=https://ynikl.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><link rel=icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ynikl.github.io/index.xml><link rel=alternate type=application/json href=https://ynikl.github.io/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-35FCVN7C8X"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-35FCVN7C8X",{anonymize_ip:!1})}</script><meta property="og:title" content="潜水员的咖啡小屋"><meta property="og:description" content="发发牢骚"><meta property="og:type" content="website"><meta property="og:url" content="https://ynikl.github.io/"><meta property="og:image" content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="潜水员的咖啡小屋"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="潜水员的咖啡小屋"><meta name=twitter:description content="发发牢骚"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"潜水员的咖啡小屋","url":"https://ynikl.github.io/","description":"发发牢骚","thumbnailUrl":"https://ynikl.github.io/apple-touch-icon.png","sameAs":["https://ynikl.github.io/index.xml","https://twitter.com/k35402","https://stackoverflow.com/users/12519166/gilfoyle","https://github.com/ynikl","https://www.douban.com/people/ynikl/"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ynikl.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ynikl.github.io/apple-touch-icon_hu580d61a4745e72e64f2a76fb3eea3190_18715_0x35_resize_box_3.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ynikl.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://ynikl.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://ynikl.github.io/books/ title=books><span>books</span></a></li><li><a href=https://ynikl.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://ynikl.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ynikl.github.io/me/ title=me?><span>me?</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>设计模式 -- 策略模式</h2></header><div class=entry-content><p>场景 在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.
比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.
分析 优点:
将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象 在不同策略之间划清界限 增加单独策略的可测试性 缺点:
后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动 会带来的问题:
可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力 总结:
在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).
实现流程 主要的思想, 我觉得还是 面向接口编程
分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(interface) 将算法或策略剥离成独立的策略对象, 并实现上述抽象接口 主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略"插入"(plugin)流程, 调用, 获取结果, ok. 参考 refactoringguru - strategy</p></div><footer class=entry-footer><span title='2022-06-08 19:50:42 +0800 +0800'>June 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 设计模式 -- 策略模式" href=https://ynikl.github.io/posts/strategy-pattern/></a></article><article class=post-entry><header class=entry-header><h2>计算机中的：大端和小端</h2></header><div class=entry-content><p>大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”
大端的优势是高位计算，和可读性 小端的优势的低位运算 各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。
以上是阅读阮一峰的博文-字节序探析：大端与小端的比较的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。
参考连接 阮一峰的博文-字节序探析：大端与小端的比较</p></div><footer class=entry-footer><span title='2022-06-04 00:19:23 +0800 +0800'>June 4, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 计算机中的：大端和小端" href=https://ynikl.github.io/posts/endianness/></a></article><article class=post-entry><header class=entry-header><h2>小窥 Go 中的 Modules</h2></header><div class=entry-content><p>是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 > cat go....</p></div><footer class=entry-footer><span title='2022-06-03 18:16:55 +0800 +0800'>June 3, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 小窥 Go 中的 Modules" href=https://ynikl.github.io/blog/go-modules/></a></article><article class=post-entry><header class=entry-header><h2>Mysql 不支持事务嵌套</h2></header><div class=entry-content><p>mysql 在事务中再开启事务，前一个事务会被自动提交
stackoverflow</p></div><footer class=entry-footer><span title='2022-06-02 16:16:58 +0800 +0800'>June 2, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Mysql 不支持事务嵌套" href=https://ynikl.github.io/posts/mysql-nested-transactions/></a></article><article class=post-entry><header class=entry-header><h2>并发与并行的区别</h2></header><div class=entry-content><p>举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。
并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构
并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。
Concurrency is not Parallelism by Rob Pike</p></div><footer class=entry-footer><span title='2022-05-31 22:36:34 +0800 +0800'>May 31, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 并发与并行的区别" href=https://ynikl.github.io/posts/concurrency-and-parallelism/></a></article><article class=post-entry><header class=entry-header><h2>如何做决定——遗憾最小化</h2></header><div class=entry-content><p>读Randy’s的博客遗憾最小化框架有感
在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定
做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾
Jeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。
Bezos的视频地址 Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁
Ask yourself: in 10 years from now, will you be proud of having done this? … Do things that your future self will be proud, is my motto for the time being.</p></div><footer class=entry-footer><span title='2022-05-30 19:17:51 +0800 +0800'>May 30, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 如何做决定——遗憾最小化" href=https://ynikl.github.io/posts/how-make-decisions/></a></article><article class=post-entry><header class=entry-header><h2>Go-互斥锁的实现</h2></header><div class=entry-content><p>Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法
Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。
Mutex 实现了一个 sync.Locker 接口, 该接口只有两个方法
Lock Unlock Mutex 锁有几种状态
mutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量
mutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态...</p></div><footer class=entry-footer><span title='2022-05-29 20:52:35 +0800 +0800'>May 29, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Go-互斥锁的实现" href=https://ynikl.github.io/blog/golang-sync_mutex/></a></article><article class=post-entry><header class=entry-header><h2>我为什么要学微服务</h2></header><div class=entry-content><p>为什么学 高学习产出转化比 助力下一份工作 公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。 后端架构转变的主流方向, 有利于再次找工作。
怎么学 想要学习好一个技术，就需要有想学习这门技术的动力。
首先要对它有较全面的理解：
我们为什么要学习这门技术 技术的使用场景，以及使用的优势和劣势 现在该技术在大环境中的使用情况 再开始学习技术本身。
针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。
具体方法：
我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。 使用 go-zero 框架完成一个练手项目开发。</p></div><footer class=entry-footer><span title='2022-05-26 13:29:55 +0800 +0800'>May 26, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 我为什么要学微服务" href=https://ynikl.github.io/posts/2022/0526-why-learn-microservices/></a></article><article class=post-entry><header class=entry-header><h2>富兰克林自传读后感</h2></header><div class=entry-content><p>富兰克林自传
富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。
年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。
摘录富兰克林十三美德：
节制:食不过饱，饮酒不醉； 寡言:言必于人于己有益，避免无益的聊天； 生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做； 决心:当做必做；决心要做的事应坚持不懈； 俭朴:用钱必须于人或于己有益，换言之，切戒浪费； 勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动； 诚恳:不欺骗人；思想要纯洁公正；说话也要如此； 公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务； 适度:避免极端；人若给你应得的处罚，你当容忍之； 清洁:身体、衣服和住所力求清洁； 镇静:勿因小事或普遍不可避免的事故而惊慌失措； 贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉； 谦虚:仿效耶稣和苏格拉底。</p></div><footer class=entry-footer><span title='2022-05-25 23:14:12 +0800 +0800'>May 25, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 富兰克林自传读后感" href=https://ynikl.github.io/books/autobiography-benjamin_franklin/></a></article><article class=post-entry><header class=entry-header><h2>【翻译】使用 Godoc 给 go 代码添加文档</h2></header><div class=entry-content><p>在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。
原文章地址 Godoc: documenting Go code
Go 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。
所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。
godoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。
godoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc"相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。
使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的Fprint函数的注释。
1 2 3 4 // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered....</p></div><footer class=entry-footer><span title='2022-05-25 16:11:10 +0800 +0800'>May 25, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 【翻译】使用 Godoc 给 go 代码添加文档" href=https://ynikl.github.io/blog/golang-godoc-documenting-go-code/></a></article><article class=post-entry><header class=entry-header><h2>IP表示中 / 代表的意思</h2></header><div class=entry-content><p>IP 中斜杠表示的是子网掩码的位数
例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000</p></div><footer class=entry-footer><span title='2022-05-23 22:01:03 +0800 +0800'>May 23, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to IP表示中 / 代表的意思" href=https://ynikl.github.io/posts/cs-the-slash-meaning-of-ip/></a></article><article class=post-entry><header class=entry-header><h2>Five Class Programer</h2></header><div class=entry-content><p>以前有一段时间, 怀疑过自己"软件工程师"和以前工程意义上的"工程师"有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的见识书中看了一个五级工程师的概念, 算是解惑了我做为一个"码农"和工程师的区别.
(图片来源于图书截图)
第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围. 第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程. 第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维. 第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样. 第一级工程师: 开创一个行业的鼻祖. 能够改变世界. 反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.
所以我自己应该就是 5.0, 五级工程师, 五流程序员.</p></div><footer class=entry-footer><span title='2022-05-15 17:11:57 +0800 +0800'>May 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Five Class Programer" href=https://ynikl.github.io/posts/five-class-engineer/></a></article><article class=post-entry><header class=entry-header><h2>Hugo 如何使用已经发布文章做为相对URL</h2></header><div class=entry-content><p>hugo 的默认内容都是在 content/ 路径下方
在 markdown 文章中使用 { {&lt; ref "/blog/my-first-post.md" >}}(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带/ 是表示从 content/ 目录下的下一个绝对路径
1 [我的文章]({ {&lt; ref "/blog/my-first-post.md" }}) 记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错
hugo官方文档</p></div><footer class=entry-footer><span title='2022-05-15 16:33:13 +0800 +0800'>May 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Hugo 如何使用已经发布文章做为相对URL" href=https://ynikl.github.io/posts/hugo_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%BF%9E%E6%8E%A5/></a></article><article class=post-entry><header class=entry-header><h2>My first Post</h2></header><div class=entry-content><p>我的第一篇杂文
阅读了卡片写作笔记法, 和Show Your Work之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.
原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.</p></div><footer class=entry-footer><span title='2022-05-15 16:14:09 +0800 +0800'>May 15, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to My first Post" href=https://ynikl.github.io/posts/my-first-post/></a></article><article class=post-entry><header class=entry-header><h2>见识</h2></header><div class=entry-content><p>见识:豆瓣地址
个人评分: 8.0 分
前辈用他的智慧和经验, 告诉我们如何更好地活着.
为什么读这本书 很多到了中年的人会有这样的体会： 自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。
为了这一句话, 读这一本书. 自己的作为一个普工程序员, 在技术浪潮的最后端被拖着走. 本根不需要到中年, 今年是我从事程序员工作的第四年, 我已经被感受到了被"命"限制住 的感觉了.
书中讲了什么 作者分享了他对商业, 技术, 职业, 创业, 金钱, 读书的观点和看法
用提出了商业的本质是"消费"的观点, 剖析了现在主流的"共享经济", 带我们用商业的本质眼光, 去看哪些形式的共享经济是真正的"共享经济", 哪些只是噱头炒概念的而已. 分析了IOT, 和数字跟踪技术, 区块链, 众筹等.
介绍了新科技公司的创业过程中的一些普世经验. 如何选取赛道, 如何发挥自己小公司的优势, 如何在科技浪潮中存活下来, 以及中如何招聘优秀员工.
关于在职场如何招聘到优秀的员工, 又可以引申到自己如何成为一个优秀的员工, 作者也给出了答案.
树立完成的职业思维, 带着发展的目光选择岗位 在职业思维下主动和积极的面对工作 打开自己思维格局, 多去了解行业大局 有了不错的收入之后, 就涉及到了, 如何树立一个正确的金钱观. 要对自己收入有一个正确的认识, 避免过度追求提高收入, 进而牺牲了自己的健康, 家庭等. (现在经常听到我们的工友, 猝死就是这方面没有正确面对)
下半篇, 作者开始就上升到了人生态度问题. 以一个正确的心态, 面对生活, 面对婚姻, 面对死亡. 分清楚自己生活中的 “西瓜和芝麻”, 避免习惯于低层次的追求, 会影响我们的心志.
最后文中讲述对大学生的建议 (我已经错过了), 阐述沟通的重要性, 以及介绍了拉里·佩奇名人, 巴菲特的非凡"见识"....</p></div><footer class=entry-footer><span title='2022-05-14 21:06:07 +0800 +0800'>May 14, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 见识" href=https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/></a></article><article class=post-entry><header class=entry-header><h2>Show Your Work</h2></header><div class=entry-content><p>Show Your Work 读书总结 概括 我为什么要读这本书
如何提高自己的影响力
这本书怎样影响了我
打算开始分享计划, 学习如何分享, 讲述故事. 计划"学术假"
书中的三句精华句子
You find time the same place you find spare change: in the nooks and crannies On the spectrum of creative work, the difference between the mediocre and the good is vast. Mediocrity is, however, still on the spectrum; you can move from mediocre to good in increments. The real gap is between doing nothing and doing something You can turn your flow into stock 三句话总结本书...</p></div><footer class=entry-footer><span title='2022-04-30 17:22:23 +0800 +0800'>April 30, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Show Your Work" href=https://ynikl.github.io/books/showyourwork/></a></article><article class=post-entry><header class=entry-header><h2>Docker 基本使用</h2></header><div class=entry-content><p>启动一个容器 打个样
1 docker run -itd --rm --name hello image_name – it 将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式
–rm 当容器停止之后, 会自动删除改容器
外挂文件夹 参数 -v docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash
与容器交互 进入容器 docker attach
exec
docker -it exec CONTAIN_NAME bash
exex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯. 加上 -it, 进入交互的终端模式
查看日志 docker logs CONTAINER 可以查看容器日志
-f 可以持续输出容器内部的最新日志
管理容器 启动
1 docker start CONTAINER 暂停
1 docker stop CONTAINER 提交
1 docker commit --author="ian" CONTAINER NEW-IMAGENAME:TAG 管理镜像 查看所有的镜像列表...</p></div><footer class=entry-footer><span title='2022-04-07 13:34:55 +0800 +0800'>April 7, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Docker 基本使用" href=https://ynikl.github.io/blog/docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2>Channel</h2></header><div class=entry-content><p>Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本
channel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)
Do not communicate by sharing memory; instead, share memory by communicating.
channel 保证:
数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开 channel 的实现 channel 在内部实现的结构体为 runtime.hchan
有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe....</p></div><footer class=entry-footer><span title='2022-04-02 10:09:22 +0800 +0800'>April 2, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Channel" href=https://ynikl.github.io/blog/golang-channel/></a></article><article class=post-entry><header class=entry-header><h2>提升文字留存率</h2></header><div class=entry-content><p>如何提高自己的所编写的文字留存问题? 自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意. 然后就会把已经写下的文字和内容删除掉.</p></div><footer class=entry-footer><span title='2022-04-02 09:58:23 +0800 +0800'>April 2, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 提升文字留存率" href=https://ynikl.github.io/posts/%E6%8F%90%E5%8D%87%E6%96%87%E5%AD%97%E7%95%99%E5%AD%98%E7%8E%87/></a></article><article class=post-entry><header class=entry-header><h2>Go 常用的命令汇总</h2></header><div class=entry-content><p>工具分类 go build 编译源代码文件
-race 编译出的目标程序，会启用数据竞争检测
go doc 查看包的文档(定义于doc.go的注释中), 于包中公开的函数签名
example
1 2 3 go doc go doc encoding/json go env 查看 go 相关的环境变量
1 2 3 4 5 # -w 设置环境变量 go env -w GOPAHT='/some/path' # -u 恢复成默认设置 go env -u GOPATH go generate 扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”
注释的指令格式
//go:generate command argument...
ps: wire 也是利用命令, 生成依赖注入文件
go get 管理当前module依赖
1 2 3 4 5 6 7 8 # 添加依赖包 go get example....</p></div><footer class=entry-footer><span title='2022-04-01 19:56:59 +0800 +0800'>April 1, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Go 常用的命令汇总" href=https://ynikl.github.io/blog/golang-cmd/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ynikl.github.io/page/2/>« Prev Page</a>
<a class=next href=https://ynikl.github.io/page/4/>Next Page »</a></nav></footer></main><footer class=footer><span>2022 Ian Lin All rights reserved</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>