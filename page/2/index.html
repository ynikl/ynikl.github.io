<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.106.0"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>潜水员的咖啡小屋</title><meta name=keywords content="Blog,Books,Posts"><meta name=description content="发发牢骚"><meta name=author content="潜水员"><link rel=canonical href=https://ynikl.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><link rel=icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ynikl.github.io/index.xml><link rel=alternate type=application/json href=https://ynikl.github.io/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-35FCVN7C8X"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-35FCVN7C8X",{anonymize_ip:!1})}</script><meta property="og:title" content="潜水员的咖啡小屋"><meta property="og:description" content="发发牢骚"><meta property="og:type" content="website"><meta property="og:url" content="https://ynikl.github.io/"><meta property="og:image" content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="潜水员的咖啡小屋"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="潜水员的咖啡小屋"><meta name=twitter:description content="发发牢骚"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"潜水员的咖啡小屋","url":"https://ynikl.github.io/","description":"发发牢骚","thumbnailUrl":"https://ynikl.github.io/apple-touch-icon.png","sameAs":["https://ynikl.github.io/index.xml","https://twitter.com/k35402","https://stackoverflow.com/users/12519166/gilfoyle","https://github.com/ynikl","https://www.douban.com/people/ynikl/"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ynikl.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ynikl.github.io/apple-touch-icon_hu580d61a4745e72e64f2a76fb3eea3190_18715_0x35_resize_box_3.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ynikl.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://ynikl.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://ynikl.github.io/books/ title=books><span>books</span></a></li><li><a href=https://ynikl.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://ynikl.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ynikl.github.io/me/ title=me?><span>me?</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>Mysql- 数据类型 - 日期</h2></header><div class=entry-content><p>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期类型 空间 JSON 日期类型 Mysql 支持的数据类型
DATE TIME DATETIME TIMESTAMP YEAR Date 只存储日期数据, 不包含时间. YYYY-MM-DD, 范围是从 ‘1000-01-01’ to ‘9999-12-31’
DateTime 存储日期, 也存储时间 'YYYY-MM-DD hh:mm:ss'
范围是从'1000-01-01 00:00:00’ to ‘9999-12-31 23:59:59’
TIMESTAMP 存储Unix时间戳数据 会受到服务器时区影响– 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之 时区环境变量设置 范围 ‘1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC.
相关函数:
FROM_UNIXTIME 把 Unix 时间戳转化成日期 UNIX_TIMESTAMP 把日期转化成 Unix 时间戳 YEAR 显示形式 YYYY, 可选显示位数YYYY(M)
默认4位显示 ‘1991’ TIME 只有时间部分,没有日期部分 hh:mm:ss, 范围从 ‘-838:59:59’ 到 ‘838:59:59’...</p></div><footer class=entry-footer><span title='2022-07-31 17:49:46 +0800 +0800'>July 31, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Mysql- 数据类型 - 日期" href=https://ynikl.github.io/blog/mysql-data-type-date/></a></article><article class=post-entry><header class=entry-header><h2>xorm 的 session 和 salve 的区别</h2></header><div class=entry-content><p>简单分析下xorm 里面 session 和 slave 里面 close 的代码
1 xorm.EngineGroup.Slave() Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用）） 如果这时候再调用 close 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。 如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 NewSsession 和 Close, 所以不在需要手动调用close 1 xorm.EngineGroup.NewSsession() 会返回一个xorm.Session对象, 对应我们数据库操作中的"会话事务", 是否自动提交之类选项.(未手动开始事务时,都是自动提交) 调用 close, 对清除 session 中未提交的事务和一些缓存的 sql 前置处理语句 对于普通 select 语句调不调用是没什么太大影响 (但是还是建议new之后调用close)</p></div><footer class=entry-footer><span title='2022-07-22 19:08:05 +0800 +0800'>July 22, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to xorm 的 session 和 salve 的区别" href=https://ynikl.github.io/posts/xorm-slave-newsseion/></a></article><article class=post-entry><header class=entry-header><h2>Make 的基本使用</h2></header><div class=entry-content><p>想自己整理一篇基本的 make 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.
阮一峰文章地址
如果不写 c, 主要理解就几个概念就可以使用了
target 可以用来当作想要执行的命令集的名称 .PHONY: 可以用来声明命令集名称 recipes 实际执行的命令集合 介绍一下我自己的应用场景 我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.
case 1: 简化本地编译和测试, 自动做 setup 和 teardown
当我想要尝试一下整个项目是否编译
1 2 3 4 .PHONY: build build: go build . rm -rf [PROJECT NAME] 使用上面的 makefile, 我就只需要 make build, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 build 一下
case 2: git 提交代码自动化操作
当我想要把我代码推送到, 测试分支, 进行集成测试
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ....</p></div><footer class=entry-footer><span title='2022-07-10 17:47:42 +0800 +0800'>July 10, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Make 的基本使用" href=https://ynikl.github.io/posts/makefile-basic-use/></a></article><article class=post-entry><header class=entry-header><h2>RabbitMQ 基本入门实践</h2></header><div class=entry-content><p>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.
介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件
消息中间件的作用
解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释
Producer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型
fanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:...</p></div><footer class=entry-footer><span title='2022-07-09 16:43:26 +0800 +0800'>July 9, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to RabbitMQ 基本入门实践" href=https://ynikl.github.io/blog/rabbitmq-learning-note/></a></article><article class=post-entry><header class=entry-header><h2>Life Is Not Short</h2></header><div class=entry-content><p>The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.
life if not short</p></div><footer class=entry-footer><span title='2022-07-01 08:55:44 +0800 +0800'>July 1, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Life Is Not Short" href=https://ynikl.github.io/posts/life-is-not-short/></a></article><article class=post-entry><header class=entry-header><h2>我理解的微服务 -- 读《微服务设计模式》总结</h2></header><div class=entry-content><p>微服务是针对公司某一复杂业务程序实现的设计模式, 与巨石架构(Monolith)是相对的.
微服务对应的应该是公司业务能力层级上的拆分与设计, 为了减少业务之间的耦合而导致相互拖累, 在对外业务能力不变的情况下, 在应用内部将能力拆分成一些微小服务. 也可以理解为是对巨石架构进行"解耦".
举个例子: 原先公司做的是一个外卖系统, 这个系统中可能包含了客户下单, 商家接单, 骑手配送等功能. 但是全部都打包在一个程序中. 发版时, 可能客户下单功能修改了功能, 导致商家没办法接单了. 或者商家接单功能实现的有问题, 导致整个应用程序挂掉, 现在用户下不了单, 骑手也没法接单, 整个公司的业务就瘫痪了. 然后, 在客户下单-商家接单-骑手配送这个大业务流程不变的情况下, 我们在外卖系统内部, 分成了多个服务, 各个服务之间使用 API 松耦合通信, 隔离影响. 比如, 客户下单服务, 专门处理客户下单这一业务, 并将生成的订单推送到消息代理 (如:kafka) 或直接推送给其他服务等, 它只要能保证完成它的职责即可. 后者, 就可以称之为 “微服务架构”. 当然, 这只是一个例子, 实际情况会更加复杂.
在«微服务设计模式» 中对微服务的定义:
将应用程序构建为松耦合, 可独立部署的一组服务
书中也对"微"的大小给了定义:
大小的定义为能够由小团队开发服务
不用刻意地去追求服务的大小. 微服务的落地, 往往就会伴随着, 组织结构和开发的流程的改变, 由不同的 小团队 独立负某一服务.
像我们现在如果提到微服务, 就经常也会提到一些微服务框架 go-zero, go-micro 或者基础设施 docker, k8s 或者工具 gRPC, prometheus 之类的.
像这种框架和组件之类的只是一种技术工具. 他们并不能定义微服务, 他们可能只是为了克服微服务架构设计带来的某一些缺陷, 或者与微服务结合可以发挥出更大的价值....</p></div><footer class=entry-footer><span title='2022-06-19 22:20:56 +0800 +0800'>June 19, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 我理解的微服务 -- 读《微服务设计模式》总结" href=https://ynikl.github.io/books/miscroservices-patterns/></a></article><article class=post-entry><header class=entry-header><h2>什么是 "胶水代码"</h2></header><div class=entry-content><p>胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 连接 两个 不兼容 的组件, 或是两个不兼容的服务.
胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.
参考 Quora 回答 wiki</p></div><footer class=entry-footer><span title='2022-06-18 20:04:38 +0800 +0800'>June 18, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label='post link to 什么是 "胶水代码"' href=https://ynikl.github.io/posts/what-is-glue-code/></a></article><article class=post-entry><header class=entry-header><h2>Go中slice[i:j:k]第三个参数是做什么的</h2></header><div class=entry-content><p>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.
简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:
1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:
array 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址
简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, “左闭右开原则” 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即"cap(a) - low" low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt....</p></div><footer class=entry-footer><span title='2022-06-09 23:52:30 +0800 +0800'>June 9, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Go中slice[i:j:k]第三个参数是做什么的" href=https://ynikl.github.io/blog/golang-reslicing-slice/></a></article><article class=post-entry><header class=entry-header><h2>我们为何选择 XXX 技术方案</h2></header><div class=entry-content><p>一个完善的方案的需要考虑的三个方面
当前需求 理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。
结果上下文 好处：当前方案的好处，解决了什么 弊端: 什么是它不能解决的 问题：引入什么新的问题 与其他方案的关系 前导：当前方案是怎么演变出来。 后续：当前方案会引入什么新问题，有什么后续的解决方案 替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案 参考《微服务设计模式》的1.6.2"模式和模式语言", 相对减少了模式关系中的泛化和特化。</p></div><footer class=entry-footer><span title='2022-06-08 20:15:26 +0800 +0800'>June 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 我们为何选择 XXX 技术方案" href=https://ynikl.github.io/posts/thinking-choosing-tech/></a></article><article class=post-entry><header class=entry-header><h2>设计模式 -- 策略模式</h2></header><div class=entry-content><p>场景 在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.
比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.
分析 优点:
将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象 在不同策略之间划清界限 增加单独策略的可测试性 缺点:
后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动 会带来的问题:
可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力 总结:
在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).
实现流程 主要的思想, 我觉得还是 面向接口编程
分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(interface) 将算法或策略剥离成独立的策略对象, 并实现上述抽象接口 主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略"插入"(plugin)流程, 调用, 获取结果, ok. 参考 refactoringguru - strategy</p></div><footer class=entry-footer><span title='2022-06-08 19:50:42 +0800 +0800'>June 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 设计模式 -- 策略模式" href=https://ynikl.github.io/posts/strategy-pattern/></a></article><article class=post-entry><header class=entry-header><h2>计算机中的：大端和小端</h2></header><div class=entry-content><p>大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”
大端的优势是高位计算，和可读性 小端的优势的低位运算 各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。
以上是阅读阮一峰的博文-字节序探析：大端与小端的比较的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。
参考连接 阮一峰的博文-字节序探析：大端与小端的比较</p></div><footer class=entry-footer><span title='2022-06-04 00:19:23 +0800 +0800'>June 4, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 计算机中的：大端和小端" href=https://ynikl.github.io/posts/endianness/></a></article><article class=post-entry><header class=entry-header><h2>小窥 Go 中的 Modules</h2></header><div class=entry-content><p>是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 > cat go....</p></div><footer class=entry-footer><span title='2022-06-03 18:16:55 +0800 +0800'>June 3, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 小窥 Go 中的 Modules" href=https://ynikl.github.io/blog/go-modules/></a></article><article class=post-entry><header class=entry-header><h2>Mysql 不支持事务嵌套</h2></header><div class=entry-content><p>mysql 在事务中再开启事务，前一个事务会被自动提交
stackoverflow</p></div><footer class=entry-footer><span title='2022-06-02 16:16:58 +0800 +0800'>June 2, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Mysql 不支持事务嵌套" href=https://ynikl.github.io/posts/mysql-nested-transactions/></a></article><article class=post-entry><header class=entry-header><h2>并发与并行的区别</h2></header><div class=entry-content><p>举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。
并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构
并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。
Concurrency is not Parallelism by Rob Pike</p></div><footer class=entry-footer><span title='2022-05-31 22:36:34 +0800 +0800'>May 31, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 并发与并行的区别" href=https://ynikl.github.io/posts/concurrency-and-parallelism/></a></article><article class=post-entry><header class=entry-header><h2>如何做决定——遗憾最小化</h2></header><div class=entry-content><p>读Randy’s的博客遗憾最小化框架有感
在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定
做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾
Jeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。
Bezos的视频地址 Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁
Ask yourself: in 10 years from now, will you be proud of having done this? … Do things that your future self will be proud, is my motto for the time being.</p></div><footer class=entry-footer><span title='2022-05-30 19:17:51 +0800 +0800'>May 30, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 如何做决定——遗憾最小化" href=https://ynikl.github.io/posts/how-make-decisions/></a></article><article class=post-entry><header class=entry-header><h2>Go-互斥锁的实现</h2></header><div class=entry-content><p>Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法
Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。
Mutex 实现了一个 sync.Locker 接口, 该接口只有两个方法
Lock Unlock Mutex 锁有几种状态
mutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量
mutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态...</p></div><footer class=entry-footer><span title='2022-05-29 20:52:35 +0800 +0800'>May 29, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Go-互斥锁的实现" href=https://ynikl.github.io/blog/golang-sync_mutex/></a></article><article class=post-entry><header class=entry-header><h2>我为什么要学微服务</h2></header><div class=entry-content><p>为什么学 高学习产出转化比 助力下一份工作 公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。 后端架构转变的主流方向, 有利于再次找工作。
怎么学 想要学习好一个技术，就需要有想学习这门技术的动力。
首先要对它有较全面的理解：
我们为什么要学习这门技术 技术的使用场景，以及使用的优势和劣势 现在该技术在大环境中的使用情况 再开始学习技术本身。
针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。
具体方法：
我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。 使用 go-zero 框架完成一个练手项目开发。</p></div><footer class=entry-footer><span title='2022-05-26 13:29:55 +0800 +0800'>May 26, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 我为什么要学微服务" href=https://ynikl.github.io/posts/2022/0526-why-learn-microservices/></a></article><article class=post-entry><header class=entry-header><h2>富兰克林自传读后感</h2></header><div class=entry-content><p>富兰克林自传
富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。
年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。
摘录富兰克林十三美德：
节制:食不过饱，饮酒不醉； 寡言:言必于人于己有益，避免无益的聊天； 生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做； 决心:当做必做；决心要做的事应坚持不懈； 俭朴:用钱必须于人或于己有益，换言之，切戒浪费； 勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动； 诚恳:不欺骗人；思想要纯洁公正；说话也要如此； 公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务； 适度:避免极端；人若给你应得的处罚，你当容忍之； 清洁:身体、衣服和住所力求清洁； 镇静:勿因小事或普遍不可避免的事故而惊慌失措； 贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉； 谦虚:仿效耶稣和苏格拉底。</p></div><footer class=entry-footer><span title='2022-05-25 23:14:12 +0800 +0800'>May 25, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 富兰克林自传读后感" href=https://ynikl.github.io/books/autobiography-benjamin_franklin/></a></article><article class=post-entry><header class=entry-header><h2>【翻译】使用 Godoc 给 go 代码添加文档</h2></header><div class=entry-content><p>在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。
原文章地址 Godoc: documenting Go code
Go 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。
所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。
godoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。
godoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc"相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。
使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的Fprint函数的注释。
1 2 3 4 // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered....</p></div><footer class=entry-footer><span title='2022-05-25 16:11:10 +0800 +0800'>May 25, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 【翻译】使用 Godoc 给 go 代码添加文档" href=https://ynikl.github.io/blog/golang-godoc-documenting-go-code/></a></article><article class=post-entry><header class=entry-header><h2>IP表示中 / 代表的意思</h2></header><div class=entry-content><p>IP 中斜杠表示的是子网掩码的位数
例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000</p></div><footer class=entry-footer><span title='2022-05-23 22:01:03 +0800 +0800'>May 23, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to IP表示中 / 代表的意思" href=https://ynikl.github.io/posts/cs-the-slash-meaning-of-ip/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ynikl.github.io/>« Prev Page</a>
<a class=next href=https://ynikl.github.io/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>2022 Ian Lin All rights reserved</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>