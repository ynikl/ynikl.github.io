<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.134.2"><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>潜水员的咖啡小屋</title>
<meta name=keywords content="Blog,Books,Posts"><meta name=description content="发发牢骚"><meta name=author content="潜水员"><link rel=canonical href=https://ynikl.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><link rel=icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ynikl.github.io/index.xml><link rel=alternate type=application/json href=https://ynikl.github.io/index.json><link rel=alternate hreflang=en href=https://ynikl.github.io/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-35FCVN7C8X"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-35FCVN7C8X")}</script><meta property="og:title" content="潜水员的咖啡小屋"><meta property="og:description" content="发发牢骚"><meta property="og:type" content="website"><meta property="og:url" content="https://ynikl.github.io/"><meta property="og:image" content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="潜水员的咖啡小屋"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="潜水员的咖啡小屋"><meta name=twitter:description content="发发牢骚"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"潜水员的咖啡小屋","url":"https://ynikl.github.io/","description":"发发牢骚","thumbnailUrl":"https://ynikl.github.io/apple-touch-icon.png","sameAs":["https://ynikl.github.io/index.xml","https://twitter.com/k35402","https://stackoverflow.com/users/12519166/gilfoyle","https://github.com/ynikl","https://www.douban.com/people/ynikl/"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ynikl.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ynikl.github.io/apple-touch-icon_hu14773585917063522190.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://ynikl.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://ynikl.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://ynikl.github.io/books/ title=books><span>books</span></a></li><li><a href=https://ynikl.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://ynikl.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ynikl.github.io/me/ title=me?><span>me?</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>你为什么而工作</h2></header><div class=entry-content><p>总结 现状 国富论中的分工合作, 把每个人的工作都进行了细化, 每个人都只能聚焦到眼前的一点点事情. 提升了增体生产效率. 人们失去对增体工作流程的感知, 更加不容易感受到工作所带来的成就感. 不能感知到自己的工作给别人带去了什么.
“一个人把金属线拉长，另一个人将它拉直，第三个人将其切断，第四个人将它削尖，第五个人将顶端切磨好跟头部相接……我曾经目睹过只雇用十位工人的这种小型生产工厂……他们一天最多能生产48 000枚大头针，但如果不采用分工合作的方式，而是由一个人来完成所有工序，那么他们每个人连20枚都完成不了。”
改善 个人: 发现自己的工作的能给别人带来什么, 寻找自己工作的意义. 自己如何看待一份工作是自己决定的. 是工作, 还是职业, 还是使命.
企业:
对员工提供保障, 充分的薪资 分配工作保留充分的自主性 一个充满价值感的工作环境 文摘 “对于那些从工作中获得成就感的人，他们将工作当成事业来经营，并且沉浸其中，尽管并不总是这种状态，但毫无疑问，工作对于他们来说至关重要。对这些人来说，工作中充满挑战，而正是这种挑战性，迫使他们远离舒适和懈怠，不断磨炼和提升自我”
“认为自己从工作中获取了某种掌控感，他们在工作中努力地锻炼自身的自主性和判断力，并借此不断提高自己的工作技能和专业水准。他们孜孜不倦地学习新东西，无论是作为员工还是作为个体的人，都能持续不断地获取自身的发展。”
“从事工作也是出于社交的需要。工作中个体常常作为团队成员一起完成任务，即使是独立工作或工作闲暇时，仍然有许多与他人打交道的社交机会。”
“有时是因为个人从事的工作非常有意义。他们的工作可能正在改变着世界，让他人的生活变得更加美好，更加有意义”
“事实上，当我们谈论一个人是因为钱而工作时，我们并不仅仅是在客观描述，而是夹杂了批判的情感在内”
“流程化的工作方式意味着除了钱之外，他们真的找不到促使其工作的其他理由”
“工作助力个人的成长和发展、工作中被上级和同事欣赏和褒扬、工作中他人尊重和赞同自己的意见和看法、感觉自己所做的工作意义重大、在工作中可以结交好友。所有这些回答都是调查中收集到的反馈。然而，对于绝大多数的职场人士来说，工作更像是无奈之举，他们也并没有积极向上的工作动力。为什么会出现这种情况”
“长期以来我们一直信奉着一项经济准则，而这项准则也被诸多心理学理论所支持，那就是如果你想让他人替你做事，无论是员工、学生、政府官员，还是你自己的孩子，你都得让他们“有所得”，因为人们做事情是因为“有利可图”
国富论
“想过尽可能舒适的生活是每个人的天性，如果一个人从事某项繁重工作和他不做所获得的报酬没有任何差别的话，那么他就会粗心马虎地应付差事，而政府也默认这种行事原则。”
“一个人把金属线拉长，另一个人将它拉直，第三个人将其切断，第四个人将它削尖，第五个人将顶端切磨好跟头部相接……我曾经目睹过只雇用十位工人的这种小型生产工厂……他们一天最多能生产48 000枚大头针，但如果不采用分工合作的方式，而是由一个人来完成所有工序，那么他们每个人连20枚都完成不了。”
“你或许会问为什么会有人愿意在亚当·斯密所描写的大头针工厂中年复一年日复一日地做着将针头和针组合在一起这种简单重复的工作。对此，亚当·斯密给出的回答是：“人们当然并不享受大头针工厂中的这种工作，但他们同样也不愿意在其他任何地方工作。”
“人们愿意工作的唯一原因是工作所带来的报酬。只要能够获得令人满意的报酬，工作内容便无关紧要。”
良好的工作环境是可以影响在其中的员工的心态
“说人类是未完成进化的动物。他指的是所谓人类的天性，很大一部分是周围社会环境的产物，这本身便是人类的天性。这部分人类天性更多是被“创造”出来的，而不是被“发现”的”
流水线的工作导致了员工的自主权利被削减
“流水线分工所带来的一个重要但常被人忽略的后果便是将工作的掌控权从员工的手中转移到了那些管理流水线的主管们手中”
“一种观点认为，我们大多数人相信只有某些种类的工作才会让人觉得充满挑战具有意义，能提供不断学习和成长的机会。如果我们坚守这种观点的话，那么这类好工作可能只属于少数人，如律师、医生、银行家、教师、软件开发人员、公司首席执行官等。对于其他人来说，工作就是“饭碗”。情况就是如此，对你我亦然”
“另一种观点则认为，每一种工作都有可能让人获得满足感。但问题在于常规化、流水线式的工作更容易带来稳定的生产效率”
工作 -> 职业 -> 使命
“正如劳动心理学研究专家皮特所指出的那样，为了让我们对自己的工作满意，我们有必要给自己从事的工作赋予意义” “当人们将自己做的事情仅仅当成一份养家糊口的“工作”来看待的时候，人们很难从工作中获得自主性，也很难从中获取成就感。当人们将工作仅仅看作为了生存必须要做的事情时，人们只在乎报酬，如果其他工作能提供更高的报酬，那么他们随时可能换工作。他们迫不及待地想要退休，也并不鼓励和希望他们的朋友或孩子像他们那样，重蹈他们的覆辙。这种现象也正是亚当·斯密关于工作的观点的具体体现” “当人们将从事的工作视为“使命”时，他们的满意度和成就感是最高的。对这些人来说，工作是生命中最重要的一部分，他们愿意将自己奉献给工作，工作彰显了他们生存的意义，他们深信自己的工作能让世界变得更加美好”
员工的使命感
“如果工作中缺少自主性、意义和满意度，工作具有的“使命感”就会减少，从事这项工作的满意度也会下降，员工也不会把这份工作做得很好”
“其实，你不一定非要在一个救死扶伤的组织内工作，以寻求工作的意义和目标。你只需要找一份能提高人们生活质量的工作就行。”
工作的成就感
“仅仅因为目睹了他们的努力给他人带来的幸福，他们的工作效率便提高了两倍。这就是赋予工作的意义后产生的巨大能量。”
“亚当·斯密描述的那些在大头针工厂中工作的工人也应该试图在内心告诉自己，自己做的事情是有意义和有追求的。也就是说，并不需要耗费太多，就能将几乎任何一份工作变得富有意义。这样做不仅对职工有好处，对服务的客户和员工所在的组织都是有益处的。”
提供完善的工作保障，这些有助于提高员工的忠诚度和信任度。 团队自我管理，分散决策权，给予员工很高的自主权和自我管理权。这同样也能提高员工对组织的信任，同时也减少了管理监督员工的人力成本。 提供给员工高于行业标准的薪酬，让员工觉得自己很有价值。但他们并不怎么依靠个人激励机制去诱导员工努力工作。当公司盈利时，所有的员工都参与利润分成。员工和公司是一个完整的“利益团体”。 完善的培训体系。无论是新员工，还是老员工，都经过系统专业的培训。这种对员工的培训是公司的一种投资形式，同样有利于培养员工的忠诚和信任。长期系统的培训也让员工不断面临新的挑战，不断提高自己的技能。普费弗还对各国的培训时长进行了对比，同样是汽车行业，日本对刚入职的新员工的平均培训时长为364个小时，欧洲是178个小时，而美国只有21个小时。 评估职工的表现，但不过度评估。公司相信员工会努力工作，也相信员工在接受足够的培训后都会成功。 极力强调公司的目标和愿景，并非首席执行官一时兴起的想法，而是将公司的使命渗透至公司上上下下的具体实践中。” “正如普费弗教授所描述的，应对竞争压力的下意识反应——裁员、加强对员工的管理和监视、催促员工加快进度等举措只会不断降低工作效率和员工的工作满意度，让情况变得更加糟糕”
“她的核心观点是当人们处于一种积极向上的情绪状态中时，他们更富有想象力和创造力，他们具有弗雷德里克松所称的“更加宽广和具有建设性的与世界互动的方式”。相反，当人们处于一种消极负面的情绪状态中时，他们更容易变得保守，想坐享其成，时时担心出错或把事情弄砸。危险让我们的视野变得更加狭窄”
现行的比较盛行的措施
“有两套规范的理论用于管理那些对工作不感兴趣的员工，一个是物质激励（工资），另一个是对流水线工作的严密监视，正所谓胡萝卜加大棒。令人惊奇的是，杰弗里·普费弗认为这两种方法对员工工作满意度都有负面效应。但是这两种方法是企业最先采用的，它们不仅让后勤工作人员和流水线上的工人无法拥有令他们满意的工作，同时由于这两种方法不断受到公司高层人员的青睐，因而在这两种方法的管理下，任何工作都有可能被毁掉，成为糟糕的工作。”
如果原先是通过道德进行约束(接送儿童迟到), 变成了通过罚款约束, 就上升到了金钱的交易的层面, 交了罚款就理所应当地迟到了. 但是, 这个也要看对象的素质程度 – 修养以及金钱能力.
...</p></div><footer class=entry-footer>&lt;span title='2023-02-09 09:02:40 +0800 +0800'>February 9, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to 你为什么而工作" href=https://ynikl.github.io/books/why-we-work/></a></article><article class=post-entry><header class=entry-header><h2>周一清晨的领导课</h2></header><div class=entry-content><p>承担责任 承担责任, 把目光聚焦于未来, 解决问题
与承担责任截然相反的是，把某人或某件事作为导致你所面临的问题的责备对象。当 然，总会有某人或某事是应当受责备的，但真正的领导者只会花时间来解决问题，而不是责 备别人。
“当你横加责备时，你的注意力集中在过去。如果你承担了责任，你才会将眼光投向未 来。杰夫，无论如何，只有在你承担了所有的责任之后，你才能做好计划来达到自己的目标。
“我想让你明白的第一个道理是，你应当控制自己来应对环境。如果你不再责备——甚 至避免这个词从你的口中说出来，你就会积极做出某些改变了。”
和 [[books/ShowYourWork]] 这中表达的意思一样, 思想和计划需要落到文字
“你到家后把这些都写在这个笔记本上。”托尼向我建议，“记住，当你把这些都写下来 时，你便做出了实施的承诺。如果你只是口头上告诉我你想做什么，就不会对你构成约束。”
明确团队的使命 明确团队的目标, 我们是一个怎么样的团队, 我们要做完成什么事情. 确保大家对目标的理解是一致的, 大家都清楚自己职责事情的优先级. 也需要让上级知道当前团队的目标. 上下一致, 齐心协力.
我建议你花时间你管理下属一样来管理一下你的老板。搞清楚她对你有什么样的期 望，告诉你对她有什么样的期望。你知道她的要事是什么吗?她知道你的要事是什么吗?也 许你们应该谈一谈，要想完成你的首要事务，就要弄清楚你们双方应当如何彼此协助
如果员工有离职的意向, 就要反思是不是自己出了问题, 团队出了问题
下属们一般不会因为这些原因而离职。他们 之所以离开，是因为上司不能令他们满意。在炒公司鱿鱼之前，他们已经先炒了上司的鱿鱼。 我不是说这是你们公司中的实际情况，我的意思是说，在多数情况下，老板是员工离职的主 要原因。
避免管理黑洞 逃离信息差, 与下属保持联系.
管理黑洞, 让团队感到困惑的事情
让团队感到迷惑的某些事情， 成了令许多经理掉下去的陷阱，”他说，“我把它称为‘管理黑洞’，这里的事与表面看上去 的有所不同。此外，有时人们总免不了要陷入管理黑洞。
团队的组成
大多数团队包含三种类型的雇员。有些是超级明星——富有经 验和学识，想在岗位上发挥最佳作用的人。有些是中层星——他们也许还不具备超级明星所 拥有的经验，或者也许以前他们是超级明星，由于某些原因，现在失去了争第一的动力;最 后一种我称之为流星:他们尽量逃避责任，希望担子越轻越好。 “在典型的团队中，有 30%的超级明星，50%的中层星，20%的流星。
坚持正确 制定原则 – 正确的事情, 当你对问题感到困惑的时候, 就参考你原则, 你就知道你应该怎么做.
如果现在你没有一套行为准则或业绩标准的话，就很难知道怎样做才是对的。就目前 情况看这个不成问题……至少从你的话来判断，这不是什么问题。 “当你陷入危机时——就像你现在的境况似的——就很难判断什么是‘对的’。我发现 最佳决策一般都是在发生危机之前做出的。你可以想清楚些，权衡一下两者的利弊
忽视问题是在拿自己正直的口碑冒险。如果你不再正直，你就不能建立以及保持别人 对你的信任——这是人际关系的根本所在
就像想树立一个正确的企业文化, 如果坚定想要建立[[企业文化]], 那么任何违反企业文化的人都应该被开除 (不管这是一位多么优秀的员工)
雇佣合适的员工 寻找合适的员工, “合适” 可以有很多种定义, 不同处事风格, 不同的个性的团队成员, 都会给团队带来不一样的色彩
...</p></div><footer class=entry-footer>&lt;span title='2023-01-28 23:42:27 +0800 +0800'>January 28, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to 周一清晨的领导课" href=https://ynikl.github.io/books/monday-morning-mentoring/></a></article><article class=post-entry><header class=entry-header><h2>The Power of Habit</h2></header><div class=entry-content><p>习惯的力量 什么是习惯 习惯是我们可以不假思索就会完成的一系列动作, 是我们在生物进化过程的中的产物. 由 暗示, 行为, 奖励 三步组成. 我们接受到某种暗示, 潜意识开始渴望获得奖励, 不由自主地开始了习惯行为, 并内心渴望着得到奖励.
“科学家说习惯之所以出现，是因为大脑一直在寻找可以省力的方式”
“第一步，存在着一个暗示，能让大脑进入某种自动行为模式，并决定使用哪种习惯。第二步，存在一个惯常行为，这可以是身体、思维或情感方面的。第三步则是奖赏，这让你的大脑辨别出是否应该记下这个回路，以备将来之用”
“习惯从来都不会消失，它们已经被嵌入了大脑的结构中，而这对我们来说是莫大的优势，因为如果我们每次放完假后都要重新学习如何开车，那可就太糟糕了”
“这种心理的基础是两条基本规律： 第一，找出一种简单又明显的暗示。 第二，清楚地说明有哪些奖赏。”
用 白速得 牙膏的广告, 展示了利用人们习惯的影响, 让大家渴望得到一口漂亮的牙齿, 养成刷牙的习惯.
“看看“白速得”吧。他发现了一种暗示——垢膜，以及一个奖赏——漂亮的牙齿，这使千百万人开始了每天的固定活动——刷牙”
“这解释了为什么习惯如此强大：它们能够创造出神经渴求。在大部分时间里，这些渴求是逐渐产生的，而我们确实没有意识到它们的存在，所以往往看不到它们的影响”
大家如果把手机的震动关闭了, 那可能就不会再有去查看手机的冲动了.
“换言之，如果有人关了震动，也就是消除了暗示，那么大家可能就会一直工作，而不会想去查看未读消息）。”
对奖励的渴望 “92%的参与者说他们习惯性锻炼是因为这让他们“感觉很好”，他们变得越来越期盼并渴求运动时产生的内啡肽和其他神经化学物质。在另一组人中，67%的人说锻炼让他们有一种“成就感”，他们从追踪自己的运动表现中渴求一种经常出现的胜利感。这种自我奖赏足够让体育活动变成一种习惯。”
“暗示加上奖赏本身并不足以让新习惯长期持续。只有你的大脑开始预期奖赏，渴求内啡肽的分泌或成就感时，你才会自觉地在每天早上绑好跑鞋鞋带。而暗示除了能够触发惯常行为，还必须能够触发人对即将到来的奖赏的渴求”
“他们创造了渴求感，让消费者产生了所有东西在有亮闪闪的外观的同时，也有好闻的味道的欲望，这让纺必适在市场上大卖”
“消费者需要一些信号告诉他们这种产品是有效的，我们可以随意调整牙膏的口感，可以是蓝莓味、绿茶味，而只要有那种凉丝丝的刺激感，大家就觉得牙齿刷干净了。这种刺激感并不会让牙膏的效果更好，但可以说服大家牙膏有效。”
“是渴求在驱动着习惯。找到触发渴求的方式让创造新习惯变得更容易。现在是这样，100年之前也是如此。每天晚上，数百万人在刷牙，就是为了获得那种刺激感。每天早上，数百万人穿上跑鞋，就是想获得他们渴求的大量内啡肽。等他们回到家，打扫了厨房或卧室后，有些人又会喷点儿纺必适来满足自己对那种气味的渴求”
习惯是可以改变的 “习惯是一种分为三个步骤的回路，由暗示、惯常行为和奖赏组成，邓吉想做的只是调整中间那个步骤，即惯常行为。根据经验，他知道如果新行为模式的开头和结尾存在一个人熟悉的东西，那么就更容易说服这个人接受新的行为模式。”
习惯是可以替代的.
“这就是黄金法则；如果你用同样的暗示，提供同样的奖赏，你就可以换掉惯常行为，改变自己的习惯。如果暗示和奖赏不变，几乎所有的习惯都是可以被改变的。”
匿名戒酒会通过自我反省和倾诉, 寻找自己形成习惯的内心的渴求的真正因素
这个项目要找的是哪些渴求感在驱使着你的习惯回路。通常来说，喝醉本身并不属于渴求。酗酒者之所以想喝酒，是因为酒让他们能逃避现实，放松心情，又有人陪伴，而且缓解焦虑，情感也得到释放。或许他们想喝杯鸡尾酒来忘记烦心事，但并不一定想“买醉”。酒精的物理作用往往是嗜酒成瘾这个习惯回路中最次要的奖赏之一。
暗示和奖赏不变, 替换掉中间的行为, 我们就可以改变习惯
“旧的暗示和对奖赏的渴求仍在那里，随时准备反击。只有当酗酒者养成了利用以前的暗示和让他们感到熟悉进而有宽慰感的新的惯常行为时，他们才能永久戒酒。”
“这种让病人描述引发他们习惯性行为的暗示的做法，叫做意识训练，正如匿名戒酒互助社坚持让酗酒者找出酗酒的暗示，这是相反习惯训练的第一步”
更深层次的信仰达成, 也是说是一种精神上的奖励
“研究人员发现，起作用的并不是上帝，而是信仰本身。一旦人们学会信仰某种东西，这种信仰就会扩展到生活的其他方面，直到他们开始相信自己能改变。信仰是将改造过的习惯回路变成永久性行为的要素。”
在做之前, 我们要对自己有信心
“但我们的确知道，为了永久改变习惯，人们必须相信改变是可能的”
如果只是一刀斩断习惯, 那么过程将会是痛苦的
“如果你想减肥，就应了解自己的习惯，看看为什么每天休息时，自己都会离开办公桌去吃点心？然后，每到休息时，就找朋友去散步，或到他们办公桌那里闲聊，而不是去咖啡厅，或者加入一个跟踪减肥过程的小组，还可以找一个跟你一样，想在手边放一些苹果而不是薯片的伙伴” “事实一目了然：如果你想改变一个习惯，你必须找另一个惯常行为替代”
企业习惯 在商业上, 一家公司的习惯, 就可以说是这家公司的核心价值观, 就是企业文化. 真正的企业价值是需要所有人都有着一致的认可才行, 当我们在工作上遇到一些有疑惑的事情, 我们可以不假思索地参考我们的企业习惯去处理事情, 这种才能说明, 我们的企业文化有真正的落地.
“一些习惯比起其他习惯在重塑商业和生活方式上更有影响力，它们就是“核心习惯”，影响着人们的工作、饮食、玩乐、消费和沟通方式。核心习惯能启动一个进程，久而久之将改变一切。”
“个人有习惯；组织则有惯例”
...</p></div><footer class=entry-footer>&lt;span title='2023-01-28 13:14:06 +0800 +0800'>January 28, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to The Power of Habit" href=https://ynikl.github.io/books/the-power-of-habit/></a></article><article class=post-entry><header class=entry-header><h2>Golang Gin</h2></header><div class=entry-content><p>Golang Gin 框架的使用和理解 框架代码地址
中间的几个关键对象 Engine RouterGroup HandlerFunc Context Engine gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过New()或者Default()创建
New 不带任何中间件 Default 会带 logger 和 recover 通过 Engine.Use() 添加中间件到Engine的RouterGroup
Engine.Run 启动, 并绑定到参数的地址
RouterGroup 1 2 3 4 5 6 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 用于存储中间件的处理方法 – 存储再 HandlersChain 里面, 即[]HandlerFunc
真正的路由地址存储在engine.trees – 路由树, 检索请求地址和对应处理方法.
Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址. 目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树. 也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.
...</p></div><footer class=entry-footer>&lt;span title='2023-01-01 22:08:25 +0800 +0800'>January 1, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;4 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to Golang Gin" href=https://ynikl.github.io/blog/golang-gin/></a></article><article class=post-entry><header class=entry-header><h2>Mysql 快速备份数据</h2></header><div class=entry-content><p>1 2 CREATE TABLE dbto.table_name like dbfrom.table_name; insert into dbto.table_name select * from dbfrom.table_name; 原文</p></div><footer class=entry-footer>&lt;span title='2022-12-20 10:55:10 +0800 +0800'>December 20, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to Mysql 快速备份数据" href=https://ynikl.github.io/blog/mysql-quick-backup-data/></a></article><article class=post-entry><header class=entry-header><h2>Golang 是否需要为每个请求 New 一个 Client</h2></header><div class=entry-content><p>背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致下游的 nginx 的连接数暴涨.
问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client
探索 在 StackOverflow 发现的相关答案
How to release http.Client in Go?
给的答案是建议复用 Client
The Client’s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
http.Client 的结构体
1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time.Duration } 在 RoundTripper 中实现了连接复用的逻辑
...</p></div><footer class=entry-footer>&lt;span title='2022-12-19 15:35:53 +0800 +0800'>December 19, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to Golang 是否需要为每个请求 New 一个 Client" href=https://ynikl.github.io/blog/golang-client-reuse/></a></article><article class=post-entry><header class=entry-header><h2>查看 Linux 的负载情况</h2></header><div class=entry-content><p>查看负载 系统平均负载
1 uptime 那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。 如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。
查看内存信息 1 free -h 查看 cpu 型号
1 cat /proc/cpuinfo | grep 'physical id' | sort | uniq | wc -l 核数
1 cat /proc/cpuinfo |grep "cores"|uniq|awk '{print $4}' 参考文章 https://www.eet-china.com/mp/a87720.html https://colobu.com/2019/02/22/how-to-find-cpu-cores-in-linux/ https://wangchujiang.com/linux-command/c/uptime.html</p></div><footer class=entry-footer>&lt;span title='2022-12-16 14:31:33 +0800 +0800'>December 16, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to 查看 Linux 的负载情况" href=https://ynikl.github.io/blog/linux-server-device-info/></a></article><article class=post-entry><header class=entry-header><h2>Git 查看文件指定范围的修改记录</h2></header><div class=entry-content><p>查看一个文件指定范围内的所有修改记录
1 git log -p -2 -L1081,+5:'hello/world.go' -p -2 或者 --patch -2
往前展示两个 commit 的 diff . 在 git 中 commit 和 patch 是同一个意思参考下文.
git commands patching
A few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches.
-L 语法 -L&lt;start>,&lt;end>:&lt;file>, -L:&lt;funcname>:&lt;file>
限制指定查看范围.</p></div><footer class=entry-footer>&lt;span title='2022-12-12 15:29:36 +0800 +0800'>December 12, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to Git 查看文件指定范围的修改记录" href=https://ynikl.github.io/blog/git-view-change-log-in-specifie-line/></a></article><article class=post-entry><header class=entry-header><h2>代码整洁架构</h2></header><div class=entry-content><p>代码整洁架构
核心思想 最重要的是依赖顺序需要内收 – 业务逻辑不能依赖框架
分层 简单分层四层
Entities Use Cases Interface Adapters Framework and Drivers Entity 实体抽象层 我的理解应该是在公司业务, 或者项目领域上对于业务模型的抽象. 不容易改变 (除非公司 业务, 或者项目方向改变). 应该是与 领域驱动设计 不谋而合
Use Cases 使用场景层 业务使用场景, 应该是存放相关不同业务场景的具体实现流程
Interface Adapters 接口转化器层 负责 Use Cases 数据 与外部使用数据转换器实现.
比较特别的例子, 将 Use Cases 产生的数据与外部的 UI 表现层所需要的数据格式做转化.
Framework and Divers 数据库和框架层, 外部工具包接口依赖之类的.
依赖倒置 当遇到跨层依赖的时候, 内层需要引用到外层逻辑时: 比如, Use Case 要呈现 UI 数据结构 (Interface Adapters 层) 时, 不能直接引用 UI 层的数据模型.
而是, 通过依赖倒置. 将 UI 层的处理逻辑, 注入 Use Case 层进行处理, 实现目标.
...</p></div><footer class=entry-footer>&lt;span title='2022-12-05 09:21:02 +0800 +0800'>December 5, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to 代码整洁架构" href=https://ynikl.github.io/blog/clean-architectrue/></a></article><article class=post-entry><header class=entry-header><h2>小狗钱钱</h2></header><div class=entry-content><p>我为什么要读这本书? 检讨自己, 学习理财的相关知识
曾经读完了 穷爸爸富爸爸 在那一段时间内有开始理财的想法, 后续又随的物欲的上涨, 开始过度超前消费, 让自己陷入了债务危机
这本书怎样影响了我? 开始编写梦想日记和成功日记 理解了"鹅"的故事, 开始做储蓄, 划分支出 作为一个陷入"债务危机"的人的自救 72 小时定律: 决定做一件事情要在72个小时内完成 72 公式: 投资 / 年利率 = 本金翻一倍需要的年数; 通货膨胀价值减半需要的年数 书中的三句精华句子? “：“吉娅，你真的认真找过工作了吗？我是说，你有没有用一整个下午的时间来考虑如何挣到钱的问题呢？” – 很多时候你觉得你思考过了, 但是你真的花费了足够的时间思考了吗? “他用一种恳切的目光望着我，说：“我生命中出现了最美好的东西，是因为我做了原本不敢做的事。” – 确实如此, 要去尝试自己所不敢做的事情 总结本书 通俗易懂, 醍醐灌顶 陷入债务危机的人的自救方法
销毁信用支付: 信用支付会比现金消费花的钱更多 尽可能少偿还贷款: 避免再次借贷, 弥补空缺 偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费. 书摘 “可是，这正是许多没有钱的人爱犯的错误。他们总是有那么多紧急的事情要做，以至于没有时间来关注重要的事情。”
“钱钱对我点了点头，说：“困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟”
理解重要不紧急的事情
“很简单。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。” ”
陷入债务危机的人的自救方法
销毁信用支付: 信用支付会比现金消费花的钱更多 尽可能少偿还贷款: 避免再次借贷, 弥补空缺 偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费. “鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。”
“我叹道：“要在‘鹅’和愿望之间作取舍真难！” “你根本不用放弃任何一个。两件事可以同时进行。”金先生微笑着说，“比如你挣了10马克，那么你可以分配一下这笔钱，把其中的大部分存入银行，然后把一部分放入你的梦想储蓄罐，剩下的当作零花钱。”
“所有人都希望自己变得富有一些，只是有些人的这一愿望更为强烈，而有些人却假装自己满足于现在的生活。事实上，大多数人都希望自己更幸福、更成功，也想拥有更多的钱”
“可是假如我们缺钱的话，钱就会变得格外重要。你回想一下那次我们差点淹死在河里的情形，当时我们想的只是必须从河里爬上来，其他的一切都变得无关紧要了”
“中国的智者老子说过：‘天下难事，必作于易；天下大事，必作于细”
“第一，我建议你拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。”
“没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西”
...</p></div><footer class=entry-footer>&lt;span title='2022-11-27 13:56:17 +0800 +0800'>November 27, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to 小狗钱钱" href=https://ynikl.github.io/books/ein-hund-namens-money/></a></article><article class=post-entry><header class=entry-header><h2>go 使用 runtime 包进行内存占用分析</h2></header><div class=entry-content><p>使用场景 写个demo, 想查看一下程序内部的内存占用情况.
使用方法 主角 runtime 包
对象 MemStats 方法 ReadMemStats demo 展示
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(&amp;m) // For info on each, see: https://golang.org/pkg/runtime/#MemStats fmt.Printf("Alloc = %v MiB", bToMb(m.Alloc)) fmt.Printf("\tTotalAlloc = %v MiB", bToMb(m.TotalAlloc)) fmt.Printf("\tSys = %v MiB", bToMb(m.Sys)) fmt.Printf("\tNumGC = %v\n", m.NumGC) } 代码出处
...</p></div><footer class=entry-footer>&lt;span title='2022-11-18 19:27:35 +0800 +0800'>November 18, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;5 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to go 使用 runtime 包进行内存占用分析" href=https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/></a></article><article class=post-entry><header class=entry-header><h2>Asking the Right Questions</h2></header><div class=entry-content><p>概括 我为什么要读这本书? 养成一个批判性的看待问题方式.
这本书怎样影响了我? 了解了一些常见的经典辩证错误, 比如: 人身攻击, 虚假两难, 完美解决方案 看待一个问题之前, 要想想这个问题, 关我什么事. 对于一些问题的论述会更加注意和小心 书中的三句精华句子? 一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？” 结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。 常见的谬论
人身攻击谬误（ad hominem fallacy）: 人身攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。 滑坡谬误: 指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件发生。 追求完美解决方案谬误: 指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种解决方案根本就不应该采用。 偷换概念谬误:一旦你看到一个关键词或短语在论证中不止一次出现，检查一下看看其意思有没有发生改变，如果意思发生改变，就要警惕偷换概念谬误。 权威谬误: 除非我们知道这些权威对这一论题拥有特别的专门知识，否则我们就要将这个理由视为谬误。这种类型的谬误叫做诉诸可疑权威谬误（appeal to questionable authority fallacy）。 虚假的两难选择: 世界上只有两种人——一种人表演，另一种人观看。” 要让这样的陈述成立，我们必须假设只有这两种选择，是不是这样呢？当然不是！作者创造了一种虚假的两难选择（false dilemma）。 乱扣帽子谬误: 当有人宣称他们发现了导致某个行为的原因，而实际上他们所做的不过是为这种行为起了个名字而已，我们要对这种乱扣帽子谬误[7]（explaining by naming fallacy）保持警惕。 循环论证谬误[1]（begging the question fauacy）。 错误类比谬误指有人提出一个类比，其中却存在重要而又相关的不同点。 过度简化因果关系谬误: 如果持论者不能考虑到各种原因的复杂性，他们就犯了过度简化因果关系谬误[1]（causal oversimplication fallacy）。 事后归因谬误[1]（全称为"post hoc, ergo propter hoc fallacy"，拉丁文的意思是“在这之后，所以是因为这个的谬误”。） 三句话总结本书 书摘 一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？”
小贴士：价值观指的是人们认为较有价值而没有明说出来的观点。它们树立了一定的行为准则，据此我们来衡量人类行为的品质高下。
一厢情愿的思维之所以常常挥之不去，是因为我们否认一切的思维方式常常出现。
描述性论题是指对过去、现在或将来的各种描述的精确与否提出的问题。
我们将这些问题称为规定性论题（prescriptive issues）。社会论争通常都属于规定性论题。
问一问“作者是在对什么事件进行回应”常常能帮你找出一篇文章的中心论题。
但是，当论题并没有直截了当地说出来时，最有效的方法就是先找准结论。很多情况下，在你能确认论题之前都得先找出结论来。
结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。
...</p></div><footer class=entry-footer>&lt;span title='2022-11-17 22:53:21 +0800 +0800'>November 17, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to Asking the Right Questions" href=https://ynikl.github.io/books/asking-the-right-questions/></a></article><article class=post-entry><header class=entry-header><h2>Linux 文件系统简单操作流程</h2></header><div class=entry-content><p>文件系统原理 BIOS：启动主动运行的韧体，会认识第一个可启动的装置 MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序； 启动管理程序(boot loader)：一支可读取核心文件来运行的软件； 相关命令 查看磁盘信息 1 fdisk -l macOS
1 diskutil list 查看磁盘用量
1 df -h 查看文件大小
1 du -h 新磁盘的安装流程 对磁盘进行分割，以创建可用的 partition ； 对该 partition 进行格式化( format )，以创建系统可用的 filesystem； 在 Linux 系统上，需要创建挂载点 ( 亦即是目录 )，并将他挂载上来； 操作磁盘分区, fdisk 后面跟具体的物理磁盘
1 fdisk /dev/hdc 创建一个ext4文件系统
1 mkfs -t ext4 /dev/vdb1 挂载磁盘分区
1 2 mkdir /mnt/hdc6 mount /dev/hdc6 /mnt/hdc6 参考 Linux 磁盘与文件系统管理</p></div><footer class=entry-footer>&lt;span title='2022-11-05 13:52:16 +0800 +0800'>November 5, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to Linux 文件系统简单操作流程" href=https://ynikl.github.io/blog/linux-filesystem/></a></article><article class=post-entry><header class=entry-header><h2>Golang Minimal Version Selection 意识流翻译(仅开头)</h2></header><div class=entry-content><p>原文: Minimal Version Selection
意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.
翻译: Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list). 为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持 编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.
版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:
构建当前的编译列表 升级所有模块到各自对应的最新版本 升级一个模块到对应的版本 降级一个模块到对应的版本 最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进 行升级, 降级, 添加或者移除模块.
这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易 理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖 是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只 用了几行 go 的代码就是实现了.
最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵 守语义化版本: 向前兼容的版本使用小版本号, 不向前兼容的版本使用大版本号.
对应的四种列表操作:
构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份. 升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表 升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入 时如果如果已经存在, 就是仅保存最新的版本 降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标 模块版本之下 这些操作简单, 高效, 且容易实现
剩余内容 略
...</p></div><footer class=entry-footer>&lt;span title='2022-11-01 00:15:50 +0800 +0800'>November 1, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to Golang Minimal Version Selection 意识流翻译(仅开头)" href=https://ynikl.github.io/blog/golang-minimal-version-selection/></a></article><article class=post-entry><header class=entry-header><h2>Golang 解决依赖包版本冲突</h2></header><div class=entry-content><p>遇到了 grpc 不遵循语义版本, 导致不同版本包之间的冲突.
更新了目标的版本模块之后, 编译一下就发现原先项目引用的 gozero 框架报错了. 搜索一下 相关的关键词,就可以定位到问题是 grpc 搞的鬼.
再找到对应的兼容版本, 升级到对应的版本就可以了.
go 依赖版本选择 [golang 的最小版本选择]https://ynikl.github.io/blog/golang-minimal-version-selection/
大体意思:
会选择当前编译需要依赖包的最高版本(使用语义化版本)
寻找依赖的原因 go mod why
寻找自己项目引用某个包的 最短引用路径, 导致会引用目标包的
1 go mod why google.golang.org/grpc 输出目标包的引用依赖层级
1 2 3 4 5 6 ❯ go mod why google.golang.org/grpc # google.golang.org/grpc hello/world/test git.test.cn/company-open/rpc-pkgs google.golang.org/grpc go mod graph
可以打印出, 模块的依赖图
1 2 3 4 5 6 example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example.com/b@v1.2.0 example.com/c@v1.2.0</p></div><footer class=entry-footer>&lt;span title='2022-10-31 08:26:33 +0800 +0800'>October 31, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to Golang 解决依赖包版本冲突" href=https://ynikl.github.io/blog/golang-find-module-conflict/></a></article><article class=post-entry><header class=entry-header><h2>Python 基本语法快速学习</h2></header><div class=entry-content><p>学习路径 数据结构 流程控制 代码组织 工程化 数据结构 strings int list tuple dictionary 如何查看一个基本的类型对象拥有的方法
1 2 3 name = "ada" dir(name) dir 获取对象的属性
字符串 1 name = "ada lovelace" 拼接, 用+
1 2 3 first_name = "ada" last_name = "lovelace" full_name = first_name + " " + last_name 声明字符串中 '单引号和" 双引号没有区别, 可以用来相互替换 多行字串使用'''连续三个单引号或双引号声明 字符串格式化
format
1 2 3 >>> 'Hey {name}, there is a 0x{errno:x} error!'.format( ... name=name, errno=errno) 'Hey Bob, there is a 0xbadc0ffee error!' ‘f’string 模版
...</p></div><footer class=entry-footer>&lt;span title='2022-10-09 17:34:39 +0800 +0800'>October 9, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;3 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to Python 基本语法快速学习" href=https://ynikl.github.io/blog/python-basic-quick/></a></article><article class=post-entry><header class=entry-header><h2>乐观锁和悲观锁</h2></header><div class=entry-content><p>乐观锁和悲观锁 首先, 乐观锁和悲观锁和本身并不是一种具体锁.
而是一种编程的并发控制思想. 原名应该叫做乐观并发控制(Optimistic concurrency control) 简称 OCC 和 悲观并发控制(Pessimistic Concurrency Control) 简称 PCC
什么是锁 维基百科对锁的定义
In computer science, a lock or mutex (from mutual exclusion) is a synchronization primitive: a mechanism that enforces limits on access to a resource when there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy, and with a variety of possible methods there exists multiple unique implementations for different applications.
...</p></div><footer class=entry-footer>&lt;span title='2022-10-02 14:05:43 +0800 +0800'>October 2, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to 乐观锁和悲观锁" href=https://ynikl.github.io/blog/cs-optimitic-concurrency-control/></a></article><article class=post-entry><header class=entry-header><h2>高效程序员的45个习惯</h2></header><div class=entry-content><p>我的总结 对于功能, 业务, 代码逻辑, 不要只停留在表面, 要进一步地去思考为什么 保持开放的心态, 尊重他人的意见, 勇于承认自己的"不知道". 去思考他人为什么这么想 保持学习, 拥抱变化 有时间观念, 把控项目进度. 控制有规律的开发节奏, 不要让自己经常加班. 每天下班都能完成一天的任务. 让真正的软件用户做决策, 保持定期沟通, 让用户一直确认自己想要的东西 让工具替代人力, 实现自动化 控制代码质量, 简单, 清晰, 内聚 团队内部保持沟通 – 站会, 及时反映变化. 遇到问题及时求救, 保持向上反馈. 不要辜负人家的预期 深入思考, 保持开发, 拥抱变化, 保持沟通, 注重质量, 保持学习, 自动化.
书本原文 深度思考问题
“拙劣的代码工人会这样不假思索地改完代码，然后快速转向下一个问题。 优秀的程序员会挖掘更深一层，尽力去理解为什么这里必须要加1，更重要的是，他会想明白会产生什么其他影响。”
“在一本流行的管理图书《第五项修炼》中，作者建议，在理解一个问题的时候，需要渐次地问5个以上的“为什么”。这听起来就像退回到了4岁，那时对一切都充满着好奇。它是很好的方式，进一步挖掘简单直白的答案，通过这个路线，设想就会更加接近事实真相。”
当你问“为什么”的时候，也许你会被反问：“为什么你问这个问题？”在提问之前，想好你提问的理由，这会有助于你问出恰当的问题。
保持开发, 承认自己的不知道
“这个，我不知道”是一个好的起点，应该由此进行更进一步的调查，而不应在此戛然结束。”
“如果你对答案不满意，那么看看你是否可以改变问题。”
“作为第1步的理解代码，往往是最难的。如果别人给你的代码很容易理解，接下来的工作就省心多了”
尊重他人的意见
“孤立非常危险，不要让开发人员完全孤立地编写代码（见第155页，习惯40）。如果团队成员花些时间阅读其他同事写的代码，他们就能确保代码是可读和可理解的，并且不会随意加入这些“+1或-1”的代码。阅读代码的频率越高越好。实行代码复审 ，不仅有助于代码更好理解，而且是发现bug最有效的方法之一。”
“用Les Brown的一句话说就是：“你不需要很出色才能起步，但是你必须起步才能变得很出色。”
“如果你是一个有远见的人，就一定要特别尊重别人的意见。你是一个掌舵者，一定要把握方向，深思熟虑，吸取各方的意见。”
保持学习
“谁会帮助你保持步伐前进呢？在一个企业化的社会中，只有一个人会为你负责——你自己。是否能跟上变化，完全取决于你自己”
“跟踪技术变化 。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯”
拥抱变化, 交付用户想要的软件
“敏捷的根本之一就是拥抱变化。既然变化是永恒的，你有可能一直使用相同的技术和工具吗？”
“真正的敌人是变化。软件开发如战争，形势的变化快速而又剧烈。固守昨天的计划而无视环境的变化会带来灾难。”
“不要在前期做大量的设计”并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事”
时间观念
“许多的敏捷技巧来源于时间盒——设定一个短时的期限，为任务设定不能延长的最终期限。你可以选择放弃其他方面的任务，但是最终期限是不变的。你可能不知道完成所有的任务需要多少个时间盒，但每个时间盒必须是短期的、有限的，并且要完成具体的目标”
“如果在你工作的时候没有一个固定的最终期限（例如一天的结束），就应该好好想想了。它会让你的工作有一个节奏，在每天下班的时候，提交所有的工作，开心地收工。这样，明天就能开始新的内容，解决下一系列难题”
“有人说，上帝发明了时间，就是为了防止所有事情同时发生。因此我们需要更具远见，保持不同的开发节奏，这样敏捷项目的所有事情就不会突然同时发生，也不会随机发生，时间也不会不可预知。”
...</p></div><footer class=entry-footer>&lt;span title='2022-09-30 13:41:00 +0800 +0800'>September 30, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;1 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to 高效程序员的45个习惯" href=https://ynikl.github.io/books/practices_of_an_agile_developer/></a></article><article class=post-entry><header class=entry-header><h2>Go errgroup 的基本用法</h2></header><div class=entry-content><p>实现并发控制 在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 channel 进行传入和传出.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { concurrencyNum := 10 limitCh := make(chan bool, concurrencyNum) wg := new(sync.WaitGroup) for i := 0; i &lt; 100; i++ { limitCh &lt;- true wg.Add(1) go func() { defer func() { &lt;-limitCh wg.Done() }() time.Sleep(1 * time.Second) fmt.Println("do some things...") }() } wg.Wait() fmt.Println("ok") } 如果如果中间运行代码有可能存在错误, 捕获错误. 有两种方法:
...</p></div><footer class=entry-footer>&lt;span title='2022-09-19 09:19:31 +0800 +0800'>September 19, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to Go  errgroup 的基本用法" href=https://ynikl.github.io/blog/golang-errgroup/></a></article><article class=post-entry><header class=entry-header><h2>如何查看 golang 编译之后调用的源码方法</h2></header><div class=entry-content><p>在 golang 中查看源码是比较方便的. 可以直接到 官方包文档中直接查看文档和跳转到源码
但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成 什么底层方法了.
比如, 我知道一些make(map[int]bool)是怎么实现的.
这时候就需要一些方法了. 引用一下鸟窝大佬的文章 总结一下三种方法:
go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile 产生的汇编代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 0x001c 00028 (main.go:5) FUNCDATA $1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB) 0x001c 00028 (main.go:5) FUNCDATA $2, main.main.stkobj(SB) 0x001c 00028 (main.go:6) STP (ZR, ZR), main..autotmp_4-48(SP) 0x0020 00032 (main.go:6) STP (ZR, ZR), main..autotmp_4-32(SP) 0x0024 00036 (main.go:6) STP (ZR, ZR), main..autotmp_4-16(SP) 0x0028 00040 (main.go:6) MOVD $type.map[int]bool(SB), R0 0x0030 00048 (main.go:6) MOVD $100, R1 0x0034 00052 (main.go:6) MOVD $main..autotmp_4-48(SP), R2 0x0038 00056 (main.go:6) PCDATA $1, ZR 0x0038 00056 (main.go:6) CALL runtime.makemap(SB) 0x003c 00060 (main.go:6) MOVD R0, main.mp-112(SP) 0x0040 00064 (main.go:7) MOVD R0, R1 0x0044 00068 (main.go:7) MOVD ZR, R2 0x0048 00072 (main.go:7) MOVD $type.map[int]bool(SB), R0 go tool objdump产生的汇编代码
...</p></div><footer class=entry-footer>&lt;span title='2022-09-18 21:37:55 +0800 +0800'>September 18, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;潜水员</footer><a class=entry-link aria-label="post link to 如何查看 golang 编译之后调用的源码方法" href=https://ynikl.github.io/blog/golang-get-assembly-fn/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ynikl.github.io/>« Prev Page</a>
<a class=next href=https://ynikl.github.io/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>2022 Ian Lin All rights reserved</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>