<!doctype html><html lang=en dir=auto><head><meta name=generator content="Hugo 0.111.3"><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>潜水员的咖啡小屋</title><meta name=keywords content="Blog,Books,Posts"><meta name=description content="发发牢骚"><meta name=author content="潜水员"><link rel=canonical href=https://ynikl.github.io/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><link rel=icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ynikl.github.io/index.xml><link rel=alternate type=application/json href=https://ynikl.github.io/index.json><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-35FCVN7C8X"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-35FCVN7C8X",{anonymize_ip:!1})}</script><meta property="og:title" content="潜水员的咖啡小屋"><meta property="og:description" content="发发牢骚"><meta property="og:type" content="website"><meta property="og:url" content="https://ynikl.github.io/"><meta property="og:image" content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="潜水员的咖啡小屋"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="潜水员的咖啡小屋"><meta name=twitter:description content="发发牢骚"><script type=application/ld+json>{"@context":"https://schema.org","@type":"Organization","name":"潜水员的咖啡小屋","url":"https://ynikl.github.io/","description":"发发牢骚","thumbnailUrl":"https://ynikl.github.io/apple-touch-icon.png","sameAs":["https://ynikl.github.io/index.xml","https://twitter.com/k35402","https://stackoverflow.com/users/12519166/gilfoyle","https://github.com/ynikl","https://www.douban.com/people/ynikl/"]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ynikl.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ynikl.github.io/apple-touch-icon_hu580d61a4745e72e64f2a76fb3eea3190_18715_0x35_resize_box_3.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ynikl.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://ynikl.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://ynikl.github.io/books/ title=books><span>books</span></a></li><li><a href=https://ynikl.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://ynikl.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ynikl.github.io/me/ title=me?><span>me?</span></a></li></ul></nav></header><main class=main><article class=post-entry><header class=entry-header><h2>Go errgroup 的基本用法</h2></header><div class=entry-content><p>实现并发控制 在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 channel 进行传入和传出.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { concurrencyNum := 10 limitCh := make(chan bool, concurrencyNum) wg := new(sync.WaitGroup) for i := 0; i &lt; 100; i++ { limitCh &lt;- true wg.Add(1) go func() { defer func() { &lt;-limitCh wg.Done() }() time.Sleep(1 * time.Second) fmt....</p></div><footer class=entry-footer><span title='2022-09-19 09:19:31 +0800 +0800'>September 19, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Go  errgroup 的基本用法" href=https://ynikl.github.io/blog/golang-errgroup/></a></article><article class=post-entry><header class=entry-header><h2>如何查看 golang 编译之后调用的源码方法</h2></header><div class=entry-content><p>在 golang 中查看源码是比较方便的. 可以直接到 官方包文档中直接查看文档和跳转到源码
但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成 什么底层方法了.
比如, 我知道一些make(map[int]bool)是怎么实现的.
这时候就需要一些方法了. 引用一下鸟窝大佬的文章 总结一下三种方法:
go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile 产生的汇编代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 0x001c 00028 (main.go:5) FUNCDATA $1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB) 0x001c 00028 (main.go:5) FUNCDATA $2, main.main.stkobj(SB) 0x001c 00028 (main.go:6) STP (ZR, ZR), main....</p></div><footer class=entry-footer><span title='2022-09-18 21:37:55 +0800 +0800'>September 18, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 如何查看 golang 编译之后调用的源码方法" href=https://ynikl.github.io/blog/golang-get-assembly-fn/></a></article><article class=post-entry><header class=entry-header><h2>我与地坛</h2></header><div class=entry-content><p>概括 我为什么要读这本书? 我觉得生活挺无聊, 人生活着没有什么意义. 听说在这本书中会有人生的意义
这本书怎样影响了我? 看清楚自己之所以活着, 就如史铁生所说, 就是还想得到什么. 并不是如我嘴上所说的: “人生活着没什么意义” 打算更加大胆地去追求自己想要"得到"的东西 看清楚做某一件事情的意义 – 不只是看重结果, 也要去看重过程 书中的三句精华句子? 可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望 只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。 世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。 上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。 此岸永远是残缺的，否则彼岸就要坍塌。 三句话总结本书 尊重不完美, 不要抱怨, 不断地去追求完美 看清楚自己想要得到什么 人生不能只看重目的, 要去享受这个过程. 书摘 在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。
树干上留着一只蝉蜕，寂寞如一间空屋；露水在草叶上滚动，聚集，压弯了草叶轰然坠地摔开万道金光。”“
上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。
剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。
看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。
就命运而言，休论公道。
其实总共只有三个问题交替着来骚扰我，来陪伴我。第一个是要不要去死，第二个是为什么活，第三个，我干吗要写作。
人为什么活着？因为人想活着，说到底是这么回事，人真正的名字叫做：欲望。
可我为什么还想活呢？因为你还想得到点儿什么，你觉得你还是可以得到点儿什么的，比如说爱情，比如说价值感之类，人真正的名字叫欲望。
结果你又发表了几篇，并且出了一点儿小名，可这时你越来越感到恐慌。我忽然觉得自己活得像个人质，刚刚有点儿像个人了却又过了头，
人都忍不住要为生存找一些牢靠的理由。你不担心你会枯竭了？我不知道，不过我想，活着的问题在死前是完不了的。
就算是三个月！我平白地相信这样一个期限。
多年以后才听一位无名的哲人说过：危卧病榻，难有无神论者。
但在命运的混沌之点，人自然会忽略着科学，向虚暝之中寄托一份虔敬的祈盼。
机会不在外面在心里，结婚的机会有可能在外边，可爱情的机会只能在心里
那位台湾作家三毛说得对：爱如禅，不能说不能说，一说就错。
别人告诉我，她昏迷前的最后一句话是：“我那个有病的儿子和我那个还未成年的女儿……”
砌墙盖房，不单为避风雨，因为大家都有些秘密，其次当然还有一些钱财。秘密，不信你去慢慢推想，它是趣味的爹娘。
千万别把运动和能量，以及和时空分割开来理解。我随即得了启发：也千万别把人和意义分割开来理解。不是人有欲望，而是人即欲望。
如今想来，分明就是为了一个“轻”字：珍宝转眼被处理成垃圾，一段生命轻得飘散了，没有了，以为是什么原来什么也不是，轻易、简单、灰飞烟灭。一段生命之轻，威胁了生命全面之重，惶茫往灵魂里渗透：是不是生命的所有段落都会落此下场啊？人的根本恐惧就在这个“轻”字上，比如歧视和漠视，比如嘲笑，比如穷人手里作废的股票，比如失恋和死亡。轻，最是可怕。
艰苦的生活需要希望，鲜活的生命需要爱情，数不完的日子和数不完的心事，都要诉说。
也许是因为人缺了什么就更喜欢什么吧，我的两条腿一动不能动，却是个体育迷。
上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。
我希望既有一个健美的躯体又有一个了悟人生意义的灵魂，我希望二者兼得。
难道我们不该对灵魂有了残疾的人，比对肢体有了残疾的人，给予更多的同情和爱吗？
既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？
有知识不能只是有对物的知识，而是得有对人的了悟。
我们也完全可以把你以后的生活设计得无比顺利，但这样下去我们是不是绕了一圈又回到那不祥的阴影中去了？你将再没有企盼了吗？再没有新的追求了吗？那么你的心路是不是又在荒芜，于是你的幸福感又要老化、萎缩、枯竭了呢？
只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。
一个只想（只想！）使过程精彩的人是无法被剥夺的，因为死神也无法将一个精彩的过程变成不精彩的过程，因为坏运也无法阻挡你去创造一个精彩的过程，相反你可以把死亡也变成一个精彩的过程，相反坏运更利于你去创造精彩的过程。
过程！对，生命的意义就在于你能创造这过程的美好与精彩，生命的价值就在于你能够镇静而又激动地欣赏这过程的美丽与悲壮。
有位大物理学家说过：“物理学不告诉我们世界是什么，而是告诉我们关于世界我们能够谈论什么。”
历史难免是一部御制经典，文学要弥补它，所以看重的是那些沉默的心魂。
佛嘛，心中无佛什么事都敢干。
丑弱的人和圆满的神之间，是信者永远的路。...</p></div><footer class=entry-footer><span title='2022-08-23 13:25:15 +0800 +0800'>August 23, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 我与地坛" href=https://ynikl.github.io/books/%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B/></a></article><article class=post-entry><header class=entry-header><h2>FFmpeg 基本使用</h2></header><div class=entry-content><p>最近接手公司一个视频相关项目, 也是使用ffmpeg工具. 需要快速了解下.
概念 码率, 帧率, 文件大小 帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.
interlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i progressive: 现代整页整页呈现, 描述单位p: 60p 码率(bit rate) :视频一秒中有多少位, 决定视频的质量
ABR: 平均码率 CBR: 常量码率 VBR: 动态码率 文件大小 = 视频文件 + 音频文件
视频文件 = 码率 * 时间(s) / 8 音频文件 = 码率 * 时间(s) / 8
文件格式 不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers) 可以存储声音或者视频数据.
相关缩写 encoding (E) decoding (D) video (V) audio (A) subtitles (S) 文件元数据 metadata 描述媒体文件自身的信息, 比如:...</p></div><footer class=entry-footer><span title='2022-08-19 00:14:54 +0800 +0800'>August 19, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to FFmpeg 基本使用" href=https://ynikl.github.io/blog/ffmpeg-basics/></a></article><article class=post-entry><header class=entry-header><h2>Redis 用于做分布式锁</h2></header><div class=entry-content><p>操作 演进 加锁后进程挂掉了 加锁成功之后, 进程挂掉了没有进行解锁操作. 导致进入死锁状态.
引入 expire 设置超时时长, 自动释放 key
1 2 3 4 5 6 7 8 > setnx lock:key true > OK > expire lock:key 5 " ... do something critical ... > del lock:codehole 加锁动作 到 expire 之间挂掉了 redis 2.8 之后支持 set 拓展指令
1 > set lock:key true ex 5 nx 加锁互斥锁, 并同时设置超时时长
执行超时, 被其他进程获取到了锁 加锁之后, 本身进程执行时间超过了预先设置的 expire 的时间. 就会导致锁被提前释放.
解决方案:
尽量不要用与锁住时间教长的任务, 尝试缩小锁定的"关键区域" 续锁 (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间 执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁 Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。 – Redis深度历险...</p></div><footer class=entry-footer><span title='2022-08-18 12:18:53 +0800 +0800'>August 18, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Redis 用于做分布式锁" href=https://ynikl.github.io/blog/redis-do-distributed-lock/></a></article><article class=post-entry><header class=entry-header><h2>Golang Map 介绍</h2></header><div class=entry-content><p>本想写一篇关于 golang 中 map 底层的文章， 但是发现已经了相当不错的文章 – 字节跳动技术团队 - Golang 中 map 探究 这里只补充一下，缺少的 map 的删除操作
内部数据结构 初始化 map 是一个有"包含内容"的数据结构, 使用之前需要提前初始化, 即调用make
真正是调用源码是 runtime.makemap
获取数据 删除 源码地址
删除的关键代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Only clear key if there are pointers in it. // # 当 Key 是指针类型的时候会去清空指针 if t.key.ptrdata != 0 { if goarch....</p></div><footer class=entry-footer><span title='2022-08-13 14:14:30 +0800 +0800'>August 13, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Golang Map 介绍" href=https://ynikl.github.io/blog/golang-map/></a></article><article class=post-entry><header class=entry-header><h2>巴菲特致股东的信</h2></header><div class=entry-content><p>概括 我为什么要读这本书? Youtuber 推荐, 好奇金融相关的知识
这本书怎样影响了我? 不要轻易地去触碰股市, 直到我真正的理解它.
书中的三句精华句子? 一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力 他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误 活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。 三句话总结本书 投资的时候要看重的公司的内在价值而不是市场先生的报价 减少交易次数 努力地去看透事情的本质 书摘 笔记摘自
巴菲特致股东的信：投资者和公司高管教程（原书第4版）
【美】沃伦E.巴菲特
关于巴菲特一生的成功秘诀，已经有无数人做出了评价，我个人认为可以归结为八个字：与时俱进，良性循环
“与坏人打交道，做成一笔好生意，这样的事情，我从来没有遇见过。”巴菲特的这句名言令人深思
从别人的故事里，找到自己的人生启发，这就是读书的意义所在
广受尊重的投资家兼作家菲尔·费雪（即菲利普·费雪，Phil Fisher）曾经将公司吸引股东的策略比喻为餐馆吸引顾客的策略。 一家餐馆可以定位于特定的食客阶层——喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困惑，最终离开。
应该可以直接与公司CEO进行沟通，得到他现在和未来如何对企业进行估值的看法
如果我们对一只股票有良好的长期预期，那么短期的价格波动对我们来说毫无意义，除非有人报给我们一个非常有吸引力的价格。
芒格和我无法向你承诺结果。但我们可以保证，只要你是我们的合伙人，在任何时段，你的金融资产和我们自己的资产将完全保持一致的成长
为了达成目标，我们的首选是直接持有一系列多元化的企业，从中获得稳定的现金流和持续的高于市场平均水平的资本回报
从整体和长期来看，我们希望那些未体现的盈利，通过资本增值的形式体现在我们的内在价值里
巴菲特以及伯克希尔避免进行预测，因为这是一种糟糕的管理习惯，经常会导致管理人粉饰报表
但是任何短期的压力都不应以牺牲长期竞争力为代价
一场大会的毫无建树是由于参与股东们更在意自己在台上的表现，而不是关心公司运营的状况
在伯克希尔公司，我们通常会换位思考，设想如果我们自己处于股东的位置，应该得到什么样的信息，我们会从这样的角度向股东披露完整的报告
这种打假活动针对的目标是公司信息披露行为中的“选择性披露”，近些年来，这种选择性披露行为像癌症一样蔓延。的确，信息的选择性披露已经成为大型公司的一种标准化的行为
CEO们预测公司增长速度，是骗人的和危险的。当然，他们是被分析师和公司自己的投资者关系部门怂恿裹挟着这么做。但他们应该拒绝，因为这样预测多了会招致麻烦。
厨房里如果有蟑螂，绝不可能只有一只
在一个由一群和事佬组成的董事会里，不太可能会有人提出更换CEO的提议。同样，也不可能对CEO提议的公司并购活动提出质疑
毕竟，没有人会喜欢去洗外面租来的车
除了要维持独立性，董事们也必须具备丰富的商业经验，以股东利益为导向，以及在公司拥有真正的利益
在收购之前，他们就已是商界的管理明星，已经证明了自己在各自领域中的才华，我们的主要贡献就是让他们自由发挥天分，不给他们添乱
“如果我们雇用的都是比我们矮的人，我们将成为一家侏儒公司；但如果我们雇用的都是比我们高的人，我们会成为一家巨人公司。”
我们希望我们的经理人队伍考虑什么是重要的，而不是考虑什么被认为是重要的。
当投资的时候，我们将自己视为企业分析师——而不是市场分析师，不是宏观经济分析师，甚至不是证券分析师。
他说你应该将市场报价想象为一个名叫“市场先生”的人
如果你不懂得你的公司，不能比市场先生更准确地评估你的公司，你就不要参与这场游戏
就像人们打牌时说的：“如果玩了30分钟，你还不知道谁是倒霉蛋，有可能就是你。
一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力
有些人会在不同市场间倒手，意图赚取差价。你不必感到惊讶，从业者为此选了一个法语词汇：套利。
如果需要同时做很多事情，就像同时将很多烙铁放在火中，人们就必须花大量的时间，既要监控交易的过程，又要监控市场股价的波动。这不是芒格和我所想的生活模式。（如果只是为了赚钱而整天盯着股票行情，这种生活有什么意义可言？
在完全忽视股价的情况下，一家拥有子公司的母公司，如果子公司长期表现优异，母公司是不可能出售子公司的。“为什么要卖出？”CEO会问，“难道要我卖出皇冠上的宝石吗
应该评估是否在其预期的持股期间，其投资的税后收益总和（包括他卖出所得）会带给他至少在投资开始之初同等的购买力，加上合理的利率因素
一个视力平平的人，没有必要在干草堆里寻找绣花针。
我们的座右铭是：“如果你一开始就取得了成功，那么，不必再做测试。
很多大名鼎鼎的基金管理人现在关注的是其他基金管理人未来几天干什么，而不是关注企业未来几年干什么。对于他们而言，股票仅仅是游戏中的筹码，就像大富翁游戏中，如同顶针和熨斗一样的道具
我们的目标是发现那些价格合理的杰出公司，而不是价格便宜的平庸公司
最值得拥有的公司是，那些在一个一直延伸的时期周期里，可以不断利用增量资本获得很高回报率的公司
他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误
二级市场经常周期性地被大量傻瓜所主导，会持续设定一个“清算”价格。无论这个价格多么愚蠢，它是股票或债券持有者需要或希望卖出的价格，总是有这样的机会出现
无论什么样的天才或努力，有些事情总是需要时间。即便你能让九个女人同时怀孕，也不可能让她们在一个月的时间里生出小宝宝。）
但我更喜欢一个确定的良好结果，而不是一个期望的伟大结果。
在企业内部，有一种看不见的力量足以压倒一切，我们可以称其为“惯性驱使”或“机构强迫症”
如果我们在资产负债表上使用适当的负债，可以在安全的前提下增加一些盈利
信用就像氧气。此二者，在充足的时候，人们不会注意到它们的存在；当它们消失的时候，人们才会发现它们的重要性
当年花1美元可以买到的东西，今天要花7美元以上。因此，即便一个不用交税的机构，也必须在同期从债券上获得4.3%的年化利息收入，才能维持其购买力不变。如果这些机构的管理人将任何的利息部分视为“收入”的话，他们一定是在和自己开玩笑
即使在最混乱的经济环境中，美国国债也是唯一靠得住的流动性良好的投资对象
大多数人宁愿去死，也不愿意思考。很多人就是这样
巨大的负债可以让管理层前所未有地专注工作，就像在汽车方向盘上装一把匕首，可以提高司机的注意力一样
衍生品还可能造成连锁反应式的风险，因为很多保险公司或再保险公司将它们的风险分散给其他保险公司...</p></div><footer class=entry-footer><span title='2022-08-08 13:27:29 +0800 +0800'>August 8, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 巴菲特致股东的信" href=https://ynikl.github.io/books/%E5%B7%B4%E8%8F%B2%E7%89%B9%E8%87%B4%E8%82%A1%E4%B8%9C%E7%9A%84%E4%BF%A1/></a></article><article class=post-entry><header class=entry-header><h2>Mysql- 数据类型 - 数字</h2></header><div class=entry-content><p>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期和时间 空间 JSON 数字类型 整数类型 Interger 类型 存储大小 bytes 其他别名 TinyInt 1 bool, boolean = tinyint(1) SmallInt 2 MediumInt 3 Int 4 BigInt 8 int(M) 表示显示宽度, 最大显示宽度为(255), M 与存储空间的大小无关. 空间大小由具体类型决定.
如果具体数值达不到宽度, 左边就会用0值补齐至 M 位.
浮点 ( Floating-Point ) 类型 存储 补充 范围 Float 4 bytes 单精度 Double 8 bytes 双精度 Float(p) p 表示小数点后的精度位数
Float(M, D) Mysql 语法: M表示总显示位数, D表示小数点后个数 – 由Mysql自己做约分处理. Mysql 8.0 后废弃该语法.
定点 ( Fixed-Point ) 用于需要准备保存字段数据, 如金钱相关字段....</p></div><footer class=entry-footer><span title='2022-07-31 17:49:46 +0800 +0800'>July 31, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Mysql- 数据类型 - 数字" href=https://ynikl.github.io/blog/mysql-data-type-numbers/></a></article><article class=post-entry><header class=entry-header><h2>Mysql- 数据类型 - 日期</h2></header><div class=entry-content><p>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期类型 空间 JSON 日期类型 Mysql 支持的数据类型
DATE TIME DATETIME TIMESTAMP YEAR Date 只存储日期数据, 不包含时间. YYYY-MM-DD, 范围是从 ‘1000-01-01’ to ‘9999-12-31’
DateTime 存储日期, 也存储时间 'YYYY-MM-DD hh:mm:ss'
范围是从'1000-01-01 00:00:00’ to ‘9999-12-31 23:59:59’
TIMESTAMP 存储Unix时间戳数据 会受到服务器时区影响– 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之 时区环境变量设置 范围 ‘1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC.
相关函数:
FROM_UNIXTIME 把 Unix 时间戳转化成日期 UNIX_TIMESTAMP 把日期转化成 Unix 时间戳 YEAR 显示形式 YYYY, 可选显示位数YYYY(M)
默认4位显示 ‘1991’ TIME 只有时间部分,没有日期部分 hh:mm:ss, 范围从 ‘-838:59:59’ 到 ‘838:59:59’...</p></div><footer class=entry-footer><span title='2022-07-31 17:49:46 +0800 +0800'>July 31, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Mysql- 数据类型 - 日期" href=https://ynikl.github.io/blog/mysql-data-type-date/></a></article><article class=post-entry><header class=entry-header><h2>RabbitMQ 基本入门实践</h2></header><div class=entry-content><p>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.
介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件
消息中间件的作用
解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释
Producer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型
fanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:...</p></div><footer class=entry-footer><span title='2022-07-09 16:43:26 +0800 +0800'>July 9, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to RabbitMQ 基本入门实践" href=https://ynikl.github.io/blog/rabbitmq-learning-note/></a></article><article class=post-entry><header class=entry-header><h2>我理解的微服务 -- 读《微服务设计模式》总结</h2></header><div class=entry-content><p>微服务是针对公司某一复杂业务程序实现的设计模式, 与巨石架构(Monolith)是相对的.
微服务对应的应该是公司业务能力层级上的拆分与设计, 为了减少业务之间的耦合而导致相互拖累, 在对外业务能力不变的情况下, 在应用内部将能力拆分成一些微小服务. 也可以理解为是对巨石架构进行"解耦".
举个例子: 原先公司做的是一个外卖系统, 这个系统中可能包含了客户下单, 商家接单, 骑手配送等功能. 但是全部都打包在一个程序中. 发版时, 可能客户下单功能修改了功能, 导致商家没办法接单了. 或者商家接单功能实现的有问题, 导致整个应用程序挂掉, 现在用户下不了单, 骑手也没法接单, 整个公司的业务就瘫痪了. 然后, 在客户下单-商家接单-骑手配送这个大业务流程不变的情况下, 我们在外卖系统内部, 分成了多个服务, 各个服务之间使用 API 松耦合通信, 隔离影响. 比如, 客户下单服务, 专门处理客户下单这一业务, 并将生成的订单推送到消息代理 (如:kafka) 或直接推送给其他服务等, 它只要能保证完成它的职责即可. 后者, 就可以称之为 “微服务架构”. 当然, 这只是一个例子, 实际情况会更加复杂.
在«微服务设计模式» 中对微服务的定义:
将应用程序构建为松耦合, 可独立部署的一组服务
书中也对"微"的大小给了定义:
大小的定义为能够由小团队开发服务
不用刻意地去追求服务的大小. 微服务的落地, 往往就会伴随着, 组织结构和开发的流程的改变, 由不同的 小团队 独立负某一服务.
像我们现在如果提到微服务, 就经常也会提到一些微服务框架 go-zero, go-micro 或者基础设施 docker, k8s 或者工具 gRPC, prometheus 之类的.
像这种框架和组件之类的只是一种技术工具. 他们并不能定义微服务, 他们可能只是为了克服微服务架构设计带来的某一些缺陷, 或者与微服务结合可以发挥出更大的价值....</p></div><footer class=entry-footer><span title='2022-06-19 22:20:56 +0800 +0800'>June 19, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 我理解的微服务 -- 读《微服务设计模式》总结" href=https://ynikl.github.io/books/miscroservices-patterns/></a></article><article class=post-entry><header class=entry-header><h2>Go中slice[i:j:k]第三个参数是做什么的</h2></header><div class=entry-content><p>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.
简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:
1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:
array 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址
简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, “左闭右开原则” 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即"cap(a) - low" low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt....</p></div><footer class=entry-footer><span title='2022-06-09 23:52:30 +0800 +0800'>June 9, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Go中slice[i:j:k]第三个参数是做什么的" href=https://ynikl.github.io/blog/golang-reslicing-slice/></a></article><article class=post-entry><header class=entry-header><h2>小窥 Go 中的 Modules</h2></header><div class=entry-content><p>是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 > cat go....</p></div><footer class=entry-footer><span title='2022-06-03 18:16:55 +0800 +0800'>June 3, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 小窥 Go 中的 Modules" href=https://ynikl.github.io/blog/go-modules/></a></article><article class=post-entry><header class=entry-header><h2>Go-互斥锁的实现</h2></header><div class=entry-content><p>Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法
Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。
Mutex 实现了一个 sync.Locker 接口, 该接口只有两个方法
Lock Unlock Mutex 锁有几种状态
mutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量
mutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态...</p></div><footer class=entry-footer><span title='2022-05-29 20:52:35 +0800 +0800'>May 29, 2022</span>&nbsp;·&nbsp;4 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Go-互斥锁的实现" href=https://ynikl.github.io/blog/golang-sync_mutex/></a></article><article class=post-entry><header class=entry-header><h2>富兰克林自传读后感</h2></header><div class=entry-content><p>富兰克林自传
富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。
年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。
摘录富兰克林十三美德：
节制:食不过饱，饮酒不醉； 寡言:言必于人于己有益，避免无益的聊天； 生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做； 决心:当做必做；决心要做的事应坚持不懈； 俭朴:用钱必须于人或于己有益，换言之，切戒浪费； 勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动； 诚恳:不欺骗人；思想要纯洁公正；说话也要如此； 公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务； 适度:避免极端；人若给你应得的处罚，你当容忍之； 清洁:身体、衣服和住所力求清洁； 镇静:勿因小事或普遍不可避免的事故而惊慌失措； 贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉； 谦虚:仿效耶稣和苏格拉底。</p></div><footer class=entry-footer><span title='2022-05-25 23:14:12 +0800 +0800'>May 25, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 富兰克林自传读后感" href=https://ynikl.github.io/books/autobiography-benjamin_franklin/></a></article><article class=post-entry><header class=entry-header><h2>【翻译】使用 Godoc 给 go 代码添加文档</h2></header><div class=entry-content><p>在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。
原文章地址 Godoc: documenting Go code
Go 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。
所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。
godoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。
godoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc"相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。
使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的Fprint函数的注释。
1 2 3 4 // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered....</p></div><footer class=entry-footer><span title='2022-05-25 16:11:10 +0800 +0800'>May 25, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 【翻译】使用 Godoc 给 go 代码添加文档" href=https://ynikl.github.io/blog/golang-godoc-documenting-go-code/></a></article><article class=post-entry><header class=entry-header><h2>见识</h2></header><div class=entry-content><p>见识:豆瓣地址
个人评分: 8.0 分
前辈用他的智慧和经验, 告诉我们如何更好地活着.
为什么读这本书 很多到了中年的人会有这样的体会： 自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。
为了这一句话, 读这一本书. 自己的作为一个普工程序员, 在技术浪潮的最后端被拖着走. 本根不需要到中年, 今年是我从事程序员工作的第四年, 我已经被感受到了被"命"限制住 的感觉了.
书中讲了什么 作者分享了他对商业, 技术, 职业, 创业, 金钱, 读书的观点和看法
用提出了商业的本质是"消费"的观点, 剖析了现在主流的"共享经济", 带我们用商业的本质眼光, 去看哪些形式的共享经济是真正的"共享经济", 哪些只是噱头炒概念的而已. 分析了IOT, 和数字跟踪技术, 区块链, 众筹等.
介绍了新科技公司的创业过程中的一些普世经验. 如何选取赛道, 如何发挥自己小公司的优势, 如何在科技浪潮中存活下来, 以及中如何招聘优秀员工.
关于在职场如何招聘到优秀的员工, 又可以引申到自己如何成为一个优秀的员工, 作者也给出了答案.
树立完成的职业思维, 带着发展的目光选择岗位 在职业思维下主动和积极的面对工作 打开自己思维格局, 多去了解行业大局 有了不错的收入之后, 就涉及到了, 如何树立一个正确的金钱观. 要对自己收入有一个正确的认识, 避免过度追求提高收入, 进而牺牲了自己的健康, 家庭等. (现在经常听到我们的工友, 猝死就是这方面没有正确面对)
下半篇, 作者开始就上升到了人生态度问题. 以一个正确的心态, 面对生活, 面对婚姻, 面对死亡. 分清楚自己生活中的 “西瓜和芝麻”, 避免习惯于低层次的追求, 会影响我们的心志.
最后文中讲述对大学生的建议 (我已经错过了), 阐述沟通的重要性, 以及介绍了拉里·佩奇名人, 巴菲特的非凡"见识"....</p></div><footer class=entry-footer><span title='2022-05-14 21:06:07 +0800 +0800'>May 14, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 见识" href=https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/></a></article><article class=post-entry><header class=entry-header><h2>Show Your Work</h2></header><div class=entry-content><p>Show Your Work 读书总结 概括 我为什么要读这本书
如何提高自己的影响力
这本书怎样影响了我
打算开始分享计划, 学习如何分享, 讲述故事. 计划"学术假"
书中的三句精华句子
You find time the same place you find spare change: in the nooks and crannies On the spectrum of creative work, the difference between the mediocre and the good is vast. Mediocrity is, however, still on the spectrum; you can move from mediocre to good in increments. The real gap is between doing nothing and doing something You can turn your flow into stock 三句话总结本书...</p></div><footer class=entry-footer><span title='2022-04-30 17:22:23 +0800 +0800'>April 30, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Show Your Work" href=https://ynikl.github.io/books/showyourwork/></a></article><article class=post-entry><header class=entry-header><h2>Docker 基本使用</h2></header><div class=entry-content><p>启动一个容器 打个样
1 docker run -itd --rm --name hello image_name – it 将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式
–rm 当容器停止之后, 会自动删除改容器
外挂文件夹 参数 -v docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash
与容器交互 进入容器 docker attach
exec
docker -it exec CONTAIN_NAME bash
exex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯. 加上 -it, 进入交互的终端模式
查看日志 docker logs CONTAINER 可以查看容器日志
-f 可以持续输出容器内部的最新日志
管理容器 启动
1 docker start CONTAINER 暂停
1 docker stop CONTAINER 提交
1 docker commit --author="ian" CONTAINER NEW-IMAGENAME:TAG 管理镜像 查看所有的镜像列表...</p></div><footer class=entry-footer><span title='2022-04-07 13:34:55 +0800 +0800'>April 7, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Docker 基本使用" href=https://ynikl.github.io/blog/docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/></a></article><article class=post-entry><header class=entry-header><h2>Channel</h2></header><div class=entry-content><p>Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本
channel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)
Do not communicate by sharing memory; instead, share memory by communicating.
channel 保证:
数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开 channel 的实现 channel 在内部实现的结构体为 runtime.hchan
有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe....</p></div><footer class=entry-footer><span title='2022-04-02 10:09:22 +0800 +0800'>April 2, 2022</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Channel" href=https://ynikl.github.io/blog/golang-channel/></a></article><footer class=page-footer><nav class=pagination><a class=prev href=https://ynikl.github.io/>« Prev Page</a>
<a class=next href=https://ynikl.github.io/page/3/>Next Page »</a></nav></footer></main><footer class=footer><span>2022 Ian Lin All rights reserved</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>