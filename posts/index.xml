<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on 潜水员的咖啡小屋</title>
    <link>https://ynikl.github.io/posts/</link>
    <description>Recent content in Posts on 潜水员的咖啡小屋</description>
    <image>
      <url>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>gilfoyle.k@outlook.com (潜水员)</managingEditor>
    <webMaster>gilfoyle.k@outlook.com (潜水员)</webMaster>
    <copyright>2022 Ian Lin All rights reserved</copyright>
    <lastBuildDate>Sat, 05 Nov 2022 13:52:16 +0800</lastBuildDate><atom:link href="https://ynikl.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Linux 文件系统简单操作流程</title>
      <link>https://ynikl.github.io/posts/linux-filesystem/</link>
      <pubDate>Sat, 05 Nov 2022 13:52:16 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/linux-filesystem/</guid>
      <description>文件系统原理 BIOS：启动主动运行的韧体，会认识第一个可启动的装置 MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序； 启动管理程序(boot loader)：一支可读取核心文件来运行的软件； 相关命令 查看磁盘信息 1 fdisk -l macOS
1 diskutil list 查看磁盘用量
1 df -h 查看文件大小
1 du -h 新磁盘的安装流程 对磁盘进行分割，以创建可用的 partition ； 对该 partition 进行格式化( format )，以创建系统可用的 filesystem； 在 Linux 系统上，需要创建挂载点 ( 亦即是目录 )，并将他挂载上来； 操作磁盘分区, fdisk 后面跟具体的物理磁盘
1 fdisk /dev/hdc 创建一个ext4文件系统
1 mkfs -t ext4 /dev/vdb1 挂载磁盘分区
1 2 mkdir /mnt/hdc6 mount /dev/hdc6 /mnt/hdc6 参考 Linux 磁盘与文件系统管理</description>
      <content:encoded><![CDATA[<h2 id="文件系统原理">文件系统原理</h2>
<ul>
<li>BIOS：启动主动运行的韧体，会认识第一个可启动的装置</li>
<li>MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序；</li>
<li>启动管理程序(boot loader)：一支可读取核心文件来运行的软件；</li>
</ul>
<h2 id="相关命令">相关命令</h2>
<h3 id="查看磁盘信息">查看磁盘信息</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">fdisk -l
</span></span></code></pre></td></tr></table>
</div>
</div><p>macOS</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">diskutil list
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看磁盘用量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">df -h
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看文件大小</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">du -h
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="新磁盘的安装流程">新磁盘的安装流程</h3>
<ol>
<li>对磁盘进行分割，以创建可用的 partition ；</li>
<li>对该 partition 进行格式化( format )，以创建系统可用的 filesystem；</li>
<li>在 Linux 系统上，需要创建挂载点 ( 亦即是目录 )，并将他挂载上来；</li>
</ol>
<p>操作磁盘分区, fdisk 后面跟具体的物理磁盘</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">fdisk /dev/hdc
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建一个ext4文件系统</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mkfs -t ext4 /dev/vdb1
</span></span></code></pre></td></tr></table>
</div>
</div><p>挂载磁盘分区</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mkdir /mnt/hdc6
</span></span><span class="line"><span class="cl">mount /dev/hdc6 /mnt/hdc6
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="http://cn.linux.vbird.org/linux_basic/0230filesystem.php#filesys_1">Linux 磁盘与文件系统管理</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Golang Minimal Version Selection 意识流翻译(仅开头)</title>
      <link>https://ynikl.github.io/posts/golang-minimal-version-selection/</link>
      <pubDate>Tue, 01 Nov 2022 00:15:50 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/golang-minimal-version-selection/</guid>
      <description>原文: Minimal Version Selection
意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.
翻译: Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list). 为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持 编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.
版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:
构建当前的编译列表 升级所有模块到各自对应的最新版本 升级一个模块到对应的版本 降级一个模块到对应的版本 最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进 行升级, 降级, 添加或者移除模块.
这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易 理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖 是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只 用了几行 go 的代码就是实现了.
最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵 守语义化版本: 向前兼容的版本使用小版本号, 不向前兼容的版本使用大版本号.
对应的四种列表操作:
构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份. 升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表 升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入 时如果如果已经存在, 就是仅保存最新的版本 降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标 模块版本之下 这些操作简单, 高效, 且容易实现</description>
      <content:encoded><![CDATA[<p>原文: <a href="https://research.swtch.com/vgo-mvs#low-fidelity_builds">Minimal Version Selection</a></p>
<p>意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.</p>
<h1 id="翻译">翻译:</h1>
<p>Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list).
为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持
编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.</p>
<p>版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:</p>
<ol>
<li>构建当前的编译列表</li>
<li>升级所有模块到各自对应的最新版本</li>
<li>升级一个模块到对应的版本</li>
<li>降级一个模块到对应的版本</li>
</ol>
<p>最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进
行升级, 降级, 添加或者移除模块.</p>
<p>这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易
理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖
是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只
用了几行 go 的代码就是实现了.</p>
<p>最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵
守<a href="https://research.swtch.com/vgo-import">语义化版本</a>: 向前兼容的版本使用小版本号,
不向前兼容的版本使用大版本号.</p>
<p>对应的四种列表操作:</p>
<ol>
<li>构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份.</li>
<li>升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表</li>
<li>升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入
时如果如果已经存在, 就是仅保存最新的版本</li>
<li>降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标
模块版本之下</li>
</ol>
<p>这些操作简单, 高效, 且容易实现</p>
<p><strong>剩余内容 略</strong></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go  errgroup 的基本用法</title>
      <link>https://ynikl.github.io/posts/go-errgroup/</link>
      <pubDate>Mon, 19 Sep 2022 09:19:31 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/go-errgroup/</guid>
      <description>实现并发控制 在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 channel 进行传入和传出.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { concurrencyNum := 10 limitCh := make(chan bool, concurrencyNum) wg := new(sync.WaitGroup) for i := 0; i &amp;lt; 100; i++ { limitCh &amp;lt;- true wg.Add(1) go func() { defer func() { &amp;lt;-limitCh wg.Done() }() time.Sleep(1 * time.Second) fmt.</description>
      <content:encoded><![CDATA[<h2 id="实现并发控制">实现并发控制</h2>
<p>在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 <code>channel</code>
进行传入和传出.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">concurrencyNum</span> <span class="o">:=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="nx">limitCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">concurrencyNum</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">sync</span><span class="p">.</span><span class="nx">WaitGroup</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">100</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">limitCh</span> <span class="o">&lt;-</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="nx">wg</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="o">&lt;-</span><span class="nx">limitCh</span>
</span></span><span class="line"><span class="cl">				<span class="nx">wg</span><span class="p">.</span><span class="nf">Done</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;do some things...&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">wg</span><span class="p">.</span><span class="nf">Wait</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;ok&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果如果中间运行代码有可能存在错误, 捕获错误. 有两种方法:</p>
<ul>
<li>声明一个 err channel 用于承接错误</li>
<li>声明一个外部 err 变量, 并通过互斥锁进行保护</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func main() {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	concurrencyNum := 10
</span></span><span class="line"><span class="cl">	limitCh := make(chan bool, concurrencyNum)
</span></span><span class="line"><span class="cl">	errCh := make(chan error, concurrencyNum)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	var externalErr error
</span></span><span class="line"><span class="cl">	wg := new(sync.WaitGroup)
</span></span><span class="line"><span class="cl">	func() {
</span></span><span class="line"><span class="cl">		for i := 0; i &lt; 100; i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			select {
</span></span><span class="line"><span class="cl">			case err := &lt;-errCh:
</span></span><span class="line"><span class="cl">				externalErr = err
</span></span><span class="line"><span class="cl">				return
</span></span><span class="line"><span class="cl">			default:
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">			wg.Add(1)
</span></span><span class="line"><span class="cl">			limitCh &lt;- true
</span></span><span class="line"><span class="cl">			go func() {
</span></span><span class="line"><span class="cl">				defer func() {
</span></span><span class="line"><span class="cl">					&lt;-limitCh
</span></span><span class="line"><span class="cl">					wg.Done()
</span></span><span class="line"><span class="cl">				}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">				time.Sleep(1 * time.Second)
</span></span><span class="line"><span class="cl">				fmt.Println(&#34;do some things...&#34;)
</span></span><span class="line"><span class="cl">				if rand.Intn(5) == 1 {
</span></span><span class="line"><span class="cl">					err := errors.New(&#34;this is a error&#34;)
</span></span><span class="line"><span class="cl">					errCh &lt;- err
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">			}()
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}()
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	wg.Wait()
</span></span><span class="line"><span class="cl">	fmt.Println(&#34;ok&#34;)
</span></span><span class="line"><span class="cl">	fmt.Println(externalErr)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个地放都写这么多代码, 就有了重复的感觉. 本质上就两点:</p>
<ul>
<li>通过 channel 控制并发数</li>
<li>通过 waitgroup 保证所有的协程都执行完毕</li>
<li>通过另一个 errchannel 接受中间执行的错误</li>
</ul>
<h2 id="errgroup"><code>errgroup</code></h2>
<p>可以通过使用, 官方的拓展包 <code>errgroup</code> 更快实现</p>
<p>声明 errgroup</p>
<ul>
<li>普通声明 <code>new(errgroup.Group)</code></li>
<li>使用 context <code>errgroup.WithContext</code></li>
</ul>
<p>限制开启的协程数据</p>
<p><code>eg.SetLimit(goroutineNum)</code></p>
<p>开启协程</p>
<ul>
<li><code>eg.Go</code></li>
<li><code>eg.TryGo</code></li>
</ul>
<p>整体代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	eg := new(errgroup.Group)
</span></span><span class="line"><span class="cl">	eg.SetLimit(10)
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	for i := 0; i &lt; 100; i++ {
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		eg.Go(func() error {
</span></span><span class="line"><span class="cl">			time.Sleep(1 * time.Second)
</span></span><span class="line"><span class="cl">			fmt.Println(&#34;hello go&#34;)
</span></span><span class="line"><span class="cl">			return nil
</span></span><span class="line"><span class="cl">		})
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	err := eg.Wait()
</span></span><span class="line"><span class="cl">	fmt.Println(&#34;done&#34;, err)
</span></span></code></pre></td></tr></table>
</div>
</div><p>目前有个使用场景没办法满足:</p>
<p>就是没办法在开启协程之前, 知道原先已经执行的协程是否有发生错误.
如果有发生错误的. 就停止再继续开启协程.</p>
<p>可以通过添加一个 外部的 errChannel , 覆盖到上面的需求.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何查看 golang 编译之后调用的源码方法</title>
      <link>https://ynikl.github.io/posts/go-get-assembly-fn/</link>
      <pubDate>Sun, 18 Sep 2022 21:37:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/go-get-assembly-fn/</guid>
      <description>在 golang 中查看源码是比较方便的. 可以直接到 官方包文档中直接查看文档和跳转到源码
但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成 什么底层方法了.
比如, 我知道一些make(map[int]bool)是怎么实现的.
这时候就需要一些方法了. 引用一下鸟窝大佬的文章 总结一下三种方法:
go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile 产生的汇编代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 0x001c 00028 (main.go:5)	FUNCDATA	$1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB) 0x001c 00028 (main.go:5)	FUNCDATA	$2, main.main.stkobj(SB) 0x001c 00028 (main.go:6)	STP	(ZR, ZR), main.</description>
      <content:encoded><![CDATA[<p>在 golang 中查看源码是比较方便的. 可以直接到 <a href="https://pkg.go.dev/">官方包文档</a>中直接查看文档和跳转到源码</p>
<p>但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成
什么底层方法了.</p>
<p>比如, 我知道一些<code>make(map[int]bool)</code>是怎么实现的.</p>
<p>这时候就需要一些方法了. 引用一下<a href="https://colobu.com/2018/12/29/get-assembly-output-for-go-programs/">鸟窝大佬的文章</a>
总结一下三种方法:</p>
<ul>
<li><code>go tool compile -N -l -S makemap.go</code></li>
<li><code>go tool compile -N -l -S makemap.go</code></li>
<li><code>go tool compile -N -l -S makemap.go</code></li>
</ul>
<p><code>go tool compile</code> 产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	0x001c 00028 (main.go:5)	FUNCDATA	$1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB)
</span></span><span class="line"><span class="cl">	0x001c 00028 (main.go:5)	FUNCDATA	$2, main.main.stkobj(SB)
</span></span><span class="line"><span class="cl">	0x001c 00028 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-48(SP)
</span></span><span class="line"><span class="cl">	0x0020 00032 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-32(SP)
</span></span><span class="line"><span class="cl">	0x0024 00036 (main.go:6)	STP	(ZR, ZR), main..autotmp_4-16(SP)
</span></span><span class="line"><span class="cl">	0x0028 00040 (main.go:6)	MOVD	$type.map[int]bool(SB), R0
</span></span><span class="line"><span class="cl">	0x0030 00048 (main.go:6)	MOVD	$100, R1
</span></span><span class="line"><span class="cl">	0x0034 00052 (main.go:6)	MOVD	$main..autotmp_4-48(SP), R2
</span></span><span class="line"><span class="cl">	0x0038 00056 (main.go:6)	PCDATA	$1, ZR
</span></span><span class="line"><span class="cl">	0x0038 00056 (main.go:6)	CALL	runtime.makemap(SB)
</span></span><span class="line"><span class="cl">	0x003c 00060 (main.go:6)	MOVD	R0, main.mp-112(SP)
</span></span><span class="line"><span class="cl">	0x0040 00064 (main.go:7)	MOVD	R0, R1
</span></span><span class="line"><span class="cl">	0x0044 00068 (main.go:7)	MOVD	ZR, R2
</span></span><span class="line"><span class="cl">	0x0048 00072 (main.go:7)	MOVD	$type.map[int]bool(SB), R0
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>go tool objdump</code>产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">  main.go:6		0x10008a734		a907ffff		STP (ZR, ZR), 120(RSP)			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a738		90000160		ADRP 180224(PC), R0			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a73c		91100000		ADD $1024, R0, R0			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a740		d2800c81		MOVD $100, R1				
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a744		910163e2		ADD $88, RSP, R2			
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a748		97fe0522		CALL runtime.makemap(SB)		
</span></span><span class="line"><span class="cl">  main.go:6		0x10008a74c		f90023e0		MOVD R0, 64(RSP)			
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>go build -gcflags -S</code> 产生的汇编代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mp_10-32(SP)
</span></span><span class="line"><span class="cl">        0x0024 00036 (/Users/ian/play/map/main.go:6)    STP     (ZR, ZR), main..autotmp_10-16(SP)
</span></span><span class="line"><span class="cl">        0x0028 00040 (/Users/ian/play/map/main.go:6)    MOVD    $type.map[int]bool(SB), R0
</span></span><span class="line"><span class="cl">        0x0030 00048 (/Users/ian/play/map/main.go:6)    MOVD    $100, R1
</span></span><span class="line"><span class="cl">        0x0034 00052 (/Users/ian/play/map/main.go:6)    MOVD    $main..autotmp_10-48(SP), R2
</span></span><span class="line"><span class="cl">        0x0038 00056 (/Users/ian/play/map/main.go:6)    PCDATA  $1, ZR
</span></span><span class="line"><span class="cl">        0x0038 00056 (/Users/ian/play/map/main.go:6)    CALL    runtime.makemap(SB)
</span></span><span class="line"><span class="cl">        0x003c 00060 (/Users/ian/play/map/main.go:6)    MOVD    R0, main.mp-72(SP)
</span></span></code></pre></td></tr></table>
</div>
</div><p>大同小异, 根据源代码的行号(<code>mian.go:6</code>) 都可以从代码中看到,
调用<code>call</code> 了<code>makemap</code> 这个方法</p>
<p>我们在到<a href="https://cs.opensource.google/go/go/+/master:src/runtime/map.go;l=283?q=makemap&amp;ss=go%2Fgo">源码</a>中, 找到<code>makemap</code>方法, 就可以查看对应的源码了</p>
<h2 id="参考">参考</h2>
<p><a href="https://colobu.com/2018/12/29/get-assembly-output-for-go-programs/">得到Go程序的汇编代码的方法</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Content Disposition</title>
      <link>https://ynikl.github.io/posts/http-content-disposition/</link>
      <pubDate>Sun, 04 Sep 2022 21:32:24 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/http-content-disposition/</guid>
      <description>Content-Disposition 常见是用在 http 请求的 Response 的 Header 头部.
告诉请求客户端(浏览器) 如何处理内容;
Content-Disposition是在 MIME 标准定义的. http 中的用法只是其中的一小部分.
语法参数 inline 会在浏览器内部显示
1 Content-Disposition: inline attachment 会被保存成文件
1 Content-Disposition: attachment 后面可以跟 filename, 值为预设文件名称, 中间使用;分号隔开.
1 Content-Disposition: attachment; filename=&amp;#34;filename.jpg&amp;#34; 拓展参数, 有两个文件名称参数可选
filename* filename filename* 采用了 RFC 5987 中规定的编码方式, 假如两个参数都使用 filename* 的优先级更高
RFC 5987 该提议最终还是引用 RFC 2231 中的编码方式. 下面简单介绍一下语法
*星号用于标记该同名参数是支持该编码语法的, 就如( filename* 之于 filename) &#39;单个逗号用于分割 字符集名称 , 语言, 文件名称 %百分号用于标记编码方式, 参考RFC 2047, 所以文件名中不能有% 1 filename*=us-ascii&amp;#39;en-us&amp;#39;This%20is%20%2A%2A%2Afun%2A%2A%2A 使用us-ascii编码, en-us英语</description>
      <content:encoded><![CDATA[<p><code>Content-Disposition</code> 常见是用在 http 请求的 Response 的 Header 头部.</p>
<p>告诉请求客户端(浏览器) 如何处理内容;</p>
<p><code>Content-Disposition</code>是在 MIME 标准定义的. http 中的用法只是其中的一小部分.</p>
<h2 id="语法参数">语法参数</h2>
<h3 id="inline">inline</h3>
<p>会在浏览器内部显示</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: inline
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="attachment">attachment</h3>
<p>会被保存成文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: attachment
</span></span></code></pre></td></tr></table>
</div>
</div><p>后面可以跟 filename, 值为预设文件名称, 中间使用<code>;</code>分号隔开.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Content-Disposition: attachment; filename=&#34;filename.jpg&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><p>拓展参数, 有两个文件名称参数可选</p>
<ul>
<li>filename*</li>
<li>filename</li>
</ul>
<p><code>filename*</code> 采用了 RFC 5987 中规定的编码方式,
假如两个参数都使用 <code>filename*</code> 的优先级更高</p>
<h4 id="rfc-5987">RFC 5987</h4>
<p>该提议最终还是引用 <a href="https://www.rfc-editor.org/rfc/rfc2231#section-4">RFC 2231</a>
中的编码方式. 下面简单介绍一下语法</p>
<ul>
<li><code>*</code>星号用于标记该同名参数是支持该编码语法的, 就如( <code>filename*</code> 之于 <code>filename</code>)</li>
<li><code>'</code>单个逗号用于分割 <strong>字符集名称</strong> , <strong>语言</strong>, <strong>文件名称</strong></li>
<li><code>%</code>百分号用于标记编码方式, 参考<a href="https://www.rfc-editor.org/rfc/rfc2047">RFC 2047</a>, 所以文件名中不能有<code>%</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">filename*=us-ascii&#39;en-us&#39;This%20is%20%2A%2A%2Afun%2A%2A%2A
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用<code>us-ascii</code>编码, <code>en-us</code>英语</p>
<h2 id="问题-下载文件名称乱码">问题: 下载文件名称乱码</h2>
<p>根据上面的知识, 就可以解决有的浏览器下载文件时中文名称乱码.</p>
<ul>
<li>Http 返回设置<code>Content-Disposition</code>值</li>
<li>使用 RFC 2231 的文件名称方式, 制定编码<code>utf-8</code></li>
<li>将文件名称移除<code>%</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">disposition</span> <span class="o">:=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;attachment;filename*=utf-8&#39;&#39;%s&#34;</span><span class="p">,</span> <span class="nx">url</span><span class="p">.</span><span class="nf">QueryEscape</span><span class="p">(</span><span class="nx">name</span><span class="p">))</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Disposition">MDN</a>
<a href="https://www.rfc-editor.org/rfc/rfc2231#section-4">RFC 2231</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>The Chinese Mayor</title>
      <link>https://ynikl.github.io/posts/the-chinese-mayor/</link>
      <pubDate>Tue, 30 Aug 2022 14:06:10 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/the-chinese-mayor/</guid>
      <description>豆瓣因为涉及敏感词不让写, 干脆就写到这里来 (我也没写啥不好的呀 QAQ).
真正的现实，都是充满着矛盾。对万事万物保持一颗敬畏的心.
一方面是平民老百姓承受着流离失所的痛苦，一方面他们又可以从老破房子住到新的高楼“不破不立”，改善环境。 既要看到痛苦，也要看到改善。看外该电影， 更加让我懂得，看待事情要怀着敬畏之心，事情都是有双面性的。
总得来说，还是觉得耿属于“好市长”，在中国经济飞速发展的过程中，为人民干实事，坚定自己的立场，倾听民声（市民赌在司令部门口申诉问题的场景给我印象极深）。</description>
      <content:encoded><![CDATA[<p>豆瓣因为涉及敏感词不让写, 干脆就写到这里来 (我也没写啥不好的呀 QAQ).</p>
<p>真正的现实，都是充满着矛盾。对万事万物保持一颗敬畏的心.</p>
<p>一方面是平民老百姓承受着流离失所的痛苦，一方面他们又可以从老破房子住到新的高楼“不破不立”，改善环境。
既要看到痛苦，也要看到改善。看外该电影， 更加让我懂得，看待事情要怀着敬畏之心，事情都是有双面性的。</p>
<p>总得来说，还是觉得耿属于“好市长”，在中国经济飞速发展的过程中，为人民干实事，坚定自己的立场，倾听民声（市民赌在司令部门口申诉问题的场景给我印象极深）。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>CI/CD</title>
      <link>https://ynikl.github.io/posts/ci-cd/</link>
      <pubDate>Sun, 14 Aug 2022 15:27:33 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/ci-cd/</guid>
      <description>CI 自动化发布流程 可重复 可快速回滚 发布流程快速 在合并的时候可以对代码进行快速验证 CD 部署流程平台化 一键部署 总结 所谓的 CI/CD 就是通过自动化操作, 比如自动化测试, 自动化部署. 使用项目拥有快速上线的能力 &amp;ndash; 可以快速验证, 快速回滚, 快速发布.</description>
      <content:encoded><![CDATA[<h2 id="ci">CI</h2>
<ul>
<li>自动化发布流程</li>
<li>可重复</li>
<li>可快速回滚</li>
<li>发布流程快速</li>
<li>在合并的时候可以对代码进行快速验证</li>
</ul>
<h2 id="cd">CD</h2>
<ul>
<li>部署流程平台化</li>
<li>一键部署</li>
</ul>
<h2 id="总结">总结</h2>
<p>所谓的 CI/CD 就是通过自动化操作, 比如自动化测试, 自动化部署. 使用项目拥有快速上线的能力 &ndash; 可以快速验证, 快速回滚, 快速发布.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>活着的意义</title>
      <link>https://ynikl.github.io/posts/the-meaning-of-living/</link>
      <pubDate>Tue, 09 Aug 2022 23:40:37 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/the-meaning-of-living/</guid>
      <description>我觉得人生活着没有意义，但是我又为什么还活着呢？今天， 刚好看到了史铁生的《我与地坛》里面给了我答案
可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望</description>
      <content:encoded><![CDATA[<p>我觉得人生活着没有意义，但是我又为什么还活着呢？今天， 刚好看到了史铁生的《我与地坛》里面给了我答案</p>
<blockquote>
<p>可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>xorm 的 session 和 salve 的区别</title>
      <link>https://ynikl.github.io/posts/xorm-slave-newsseion/</link>
      <pubDate>Fri, 22 Jul 2022 19:08:05 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/xorm-slave-newsseion/</guid>
      <description>简单分析下xorm 里面 session 和 slave 里面 close 的代码
1 xorm.EngineGroup.Slave() Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用）） 如果这时候再调用 close 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。 如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 NewSsession 和 Close, 所以不在需要手动调用close 1 xorm.EngineGroup.NewSsession() 会返回一个xorm.Session对象, 对应我们数据库操作中的&amp;quot;会话事务&amp;quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交) 调用 close, 对清除 session 中未提交的事务和一些缓存的 sql 前置处理语句 对于普通 select 语句调不调用是没什么太大影响 (但是还是建议new之后调用close) </description>
      <content:encoded><![CDATA[<p>简单分析下xorm 里面 session 和 slave 里面 close 的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xorm.EngineGroup.Slave()
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用））</li>
<li>如果这时候再调用 <code>close</code> 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。</li>
<li>如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 <code>NewSsession</code> 和 <code>Close</code>, 所以不在需要手动调用<code>close</code></li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">xorm.EngineGroup.NewSsession()
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>会返回一个<code>xorm.Session</code>对象, 对应我们数据库操作中的&quot;会话事务&quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交)</li>
<li>调用 <code>close</code>, 对清除 session 中未提交的事务和一些缓存的 <code>sql</code> 前置处理语句</li>
<li>对于普通 <code>select</code> 语句调不调用是没什么太大影响 (但是还是建议<code>new</code>之后调用<code>close</code>)</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Make 的基本使用</title>
      <link>https://ynikl.github.io/posts/makefile-basic-use/</link>
      <pubDate>Sun, 10 Jul 2022 17:47:42 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/makefile-basic-use/</guid>
      <description>想自己整理一篇基本的 make 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.
阮一峰文章地址
如果不写 c, 主要理解就几个概念就可以使用了
target 可以用来当作想要执行的命令集的名称 .PHONY: 可以用来声明命令集名称 recipes 实际执行的命令集合 介绍一下我自己的应用场景 我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.
case 1: 简化本地编译和测试, 自动做 setup 和 teardown
当我想要尝试一下整个项目是否编译
1 2 3 4 .PHONY: build build: go build . rm -rf [PROJECT NAME] 使用上面的 makefile, 我就只需要 make build, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 build 一下
case 2: git 提交代码自动化操作
当我想要把我代码推送到, 测试分支, 进行集成测试
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .</description>
      <content:encoded><![CDATA[<p>想自己整理一篇基本的 <code>make</code> 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.</p>
<p><a href="https://www.ruanyifeng.com/blog/2015/02/make.html">阮一峰文章地址</a></p>
<p>如果不写 c, 主要理解就几个概念就可以使用了</p>
<ul>
<li>target 可以用来当作想要执行的命令集的名称</li>
<li>.PHONY:  可以用来声明命令集名称</li>
<li>recipes 实际执行的命令集合</li>
</ul>
<h2 id="介绍一下我自己的应用场景">介绍一下我自己的应用场景</h2>
<p>我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.</p>
<p>case 1: 简化本地编译和测试, 自动做 <code>setup</code> 和 <code>teardown</code></p>
<p>当我想要尝试一下整个项目是否编译</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="p">.</span><span class="nx">PHONY</span><span class="p">:</span> <span class="nx">build</span>
</span></span><span class="line"><span class="cl"><span class="nx">build</span><span class="p">:</span> 
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="nx">build</span> <span class="p">.</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rm</span> <span class="o">-</span><span class="nx">rf</span> <span class="p">[</span><span class="nx">PROJECT</span> <span class="nx">NAME</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用上面的 <code>makefile</code>, 我就只需要 <code>make build</code>, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 <code>build</code> 一下</p>
<p>case 2: git 提交代码自动化操作</p>
<p>当我想要把我代码推送到, 测试分支, 进行集成测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">.PHONY: dev
</span></span><span class="line"><span class="cl">ProjectName=&#34;Your Project Name&#34;
</span></span><span class="line"><span class="cl">TargetBranch=&#34;Your want to merge branch&#34;
</span></span><span class="line"><span class="cl">CurBranch=$(shell git branch --show-current)
</span></span><span class="line"><span class="cl">dev:
</span></span><span class="line"><span class="cl">	go build .
</span></span><span class="line"><span class="cl">	rm -f $(ProjectName)
</span></span><span class="line"><span class="cl">	git add .
</span></span><span class="line"><span class="cl">	git commit -m $(msg)
</span></span><span class="line"><span class="cl">	git push
</span></span><span class="line"><span class="cl">	git checkout ${DevBranch}
</span></span><span class="line"><span class="cl">	git pull --rebase
</span></span><span class="line"><span class="cl">	git merge ${CurBranch} -m &#34;Merge branch &#39;${CurBranch}&#39; into ${DevBranch}&#34;
</span></span><span class="line"><span class="cl">	go build
</span></span><span class="line"><span class="cl">	rm -f $(ProjectName) 
</span></span><span class="line"><span class="cl">	git push
</span></span><span class="line"><span class="cl">	git checkout ${CurBranch}
</span></span></code></pre></td></tr></table>
</div>
</div><p>简化 git 的操作流程, 现在只需要<code>make dev</code>就可以完成, 还可以在合并之前和之后增加测试, 我自己目前知识简单的 <code>build</code> 下而已 QAQ.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Life Is Not Short</title>
      <link>https://ynikl.github.io/posts/life-is-not-short/</link>
      <pubDate>Fri, 01 Jul 2022 08:55:44 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/life-is-not-short/</guid>
      <description>The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.
life if not short</description>
      <content:encoded><![CDATA[<blockquote>
<p>The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.</p>
</blockquote>
<p><a href="https://dkb.show/post/life-is-not-short">life if not short</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>什么是 &#34;胶水代码&#34;</title>
      <link>https://ynikl.github.io/posts/what-is-glue-code/</link>
      <pubDate>Sat, 18 Jun 2022 20:04:38 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/what-is-glue-code/</guid>
      <description>胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 连接 两个 不兼容 的组件, 或是两个不兼容的服务.
胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.
参考 Quora 回答 wiki</description>
      <content:encoded><![CDATA[<p>胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 <strong>连接</strong> 两个 <strong>不兼容</strong> 的组件, 或是两个不兼容的服务.</p>
<p>胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.</p>
<h2 id="参考">参考</h2>
<p><a href="https://www.quora.com/What-is-glue-code">Quora 回答</a>
<a href="https://en.wikipedia.org/wiki/Glue_code">wiki</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go中slice[i:j:k]第三个参数是做什么的</title>
      <link>https://ynikl.github.io/posts/golang-reslicing-slice/</link>
      <pubDate>Thu, 09 Jun 2022 23:52:30 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/golang-reslicing-slice/</guid>
      <description>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.
简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:
1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:
array 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址
简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, &amp;ldquo;左闭右开原则&amp;rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即&amp;quot;cap(a) - low&amp;quot; low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt.</description>
      <content:encoded><![CDATA[<p>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.</p>
<h2 id="简单介绍-slice-的数据结构">简单介绍 slice 的数据结构</h2>
<p>首先, 介绍一下 golang 中切片的结构体:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">type slice struct {
</span></span><span class="line"><span class="cl">	array unsafe.Pointer
</span></span><span class="line"><span class="cl">	len   int
</span></span><span class="line"><span class="cl">	cap   int
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>有三个字段:</p>
<ul>
<li>array 是切片所指向的底层数组数据</li>
<li>len 就是切片的长度</li>
<li>cap 即容量, 很明显</li>
</ul>
<p><a href="https://cs.opensource.google/go/go/+/master:src/runtime/slice.go;l=15?q=slice&amp;ss=go%2Fgo">源码地址</a></p>
<h2 id="简单版重切片-alowhigh">简单版重切片 <code>a[low:high]</code></h2>
<ul>
<li>接受切片中的开始下标和结束下标, &ldquo;左闭右开原则&rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值</li>
<li>新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即&quot;cap(a) - low&quot;</li>
<li>low 参数可以省略, 默认从 0 下标开始</li>
<li>high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [10]int{}
</span></span><span class="line"><span class="cl">oldSlice := a[:5]
</span></span><span class="line"><span class="cl">newSlice := a[2:4]
</span></span><span class="line"><span class="cl">fmt.Printf(&#34;b: len %d, cap %d, c: len %d, c:cap %d&#34;, len(b), cap(b), len(c), cap(c))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">输出:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b: len 5, cap 10, c: len 2, c:cap 8
</span></span></code></pre></td></tr></table>
</div>
</div><p>底层分配情况如下:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">底层数组       : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">旧切片容量: 10 : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">旧切片长度: 5  : [0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">新切片容量: 8  :     [0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">新切片长度: 2  :     [0 0]
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="完整版重切片-alowhighmax">完整版重切片 <code>a[low:high:max]</code></h2>
<p>完整版是为了补充简单版, 新切片会默认拥有从开始下标后的所有底层数组容量. 即新数组拥有修改全部数据底层能力 (<strong>重切片出来的不同切片, 在没有 append 操作触发重新分配底层数组的前提下, 指向的都是同一个数据, 修改数据相互可见</strong>)</p>
<ul>
<li>增加了 max 参数, 表示新切片可以获取到最大的原切片的容量大小.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">a := [10]int{}
</span></span><span class="line"><span class="cl">oldSlice := a[:5]
</span></span><span class="line"><span class="cl">newSlice := a[2:4:6]
</span></span><span class="line"><span class="cl">fmt.Printf(&#34;b: len %d, cap %d, c: len %d, c:cap %d&#34;, len(b), cap(b), len(c), cap(c))
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">输出:
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">b: len 5, cap 10, c: len 2, c:cap 4
</span></span></code></pre></td></tr></table>
</div>
</div><p>底层分配情况如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">底层数组       : [0 0 0 0 0 0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">旧切片容量:10  : [0 0 0 0 0 0 0 0 0 0] 
</span></span><span class="line"><span class="cl">旧切片长度:5   : [0 0 0 0 0]
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">新切片容量:4   :     [0 0 0 0] 
</span></span><span class="line"><span class="cl">新切片长度:2   :     [0 0]
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是, 如果 max 要求获取的容量大于旧数据容量. 可想而知, 那一定会 <code>panic</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">a</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
</span></span><span class="line"><span class="cl"><span class="nx">b</span> <span class="o">:=</span> <span class="nx">a</span><span class="p">[:</span><span class="mi">4</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
</span></span><span class="line"><span class="cl"><span class="nx">c</span> <span class="o">:=</span> <span class="nx">b</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">输出</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">panic</span><span class="p">:</span> <span class="nx">runtime</span> <span class="kt">error</span><span class="p">:</span> <span class="nx">slice</span> <span class="nx">bounds</span> <span class="nx">out</span> <span class="nx">of</span> <span class="k">range</span> <span class="p">[::</span><span class="mi">5</span><span class="p">]</span> <span class="nx">with</span> <span class="nx">capacity</span> <span class="mi">4</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以参数要求: <code>0 &lt;= low &lt;= high &lt;= max &lt;= cap(a)</code></p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://stackoverflow.com/questions/27938177/golang-slice-slicing-a-slice-with-sliceabc">stack overflow 问题1 简单版</a></li>
<li><a href="https://stackoverflow.com/questions/12768744/re-slicing-slices-in-golang/18911267#18911267">stack overflow 问题2 详细版</a></li>
<li><a href="https://go.dev/ref/spec#Slice_expressions">golang 官方文档</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>我们为何选择 XXX 技术方案</title>
      <link>https://ynikl.github.io/posts/thinking-choosing-tech/</link>
      <pubDate>Wed, 08 Jun 2022 20:15:26 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/thinking-choosing-tech/</guid>
      <description>一个完善的方案的需要考虑的三个方面
当前需求 理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。
结果上下文 好处：当前方案的好处，解决了什么 弊端: 什么是它不能解决的 问题：引入什么新的问题 与其他方案的关系 前导：当前方案是怎么演变出来。 后续：当前方案会引入什么新问题，有什么后续的解决方案 替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案 参考《微服务设计模式》的1.6.2&amp;quot;模式和模式语言&amp;quot;, 相对减少了模式关系中的泛化和特化。</description>
      <content:encoded><![CDATA[<p>一个完善的方案的需要考虑的三个方面</p>
<ol>
<li>当前需求</li>
</ol>
<p>理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。</p>
<ol start="2">
<li>结果上下文</li>
</ol>
<ul>
<li>好处：当前方案的好处，解决了什么</li>
<li>弊端: 什么是它不能解决的</li>
<li>问题：引入什么新的问题</li>
</ul>
<ol start="3">
<li>与其他方案的关系</li>
</ol>
<ul>
<li>前导：当前方案是怎么演变出来。</li>
<li>后续：当前方案会引入什么新问题，有什么后续的解决方案</li>
<li>替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案</li>
</ul>
<p>参考《微服务设计模式》的1.6.2&quot;模式和模式语言&quot;, 相对减少了模式关系中的泛化和特化。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>设计模式 -- 策略模式</title>
      <link>https://ynikl.github.io/posts/strategy-pattern/</link>
      <pubDate>Wed, 08 Jun 2022 19:50:42 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/strategy-pattern/</guid>
      <description>场景 在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.
比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.
分析 优点:
将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象 在不同策略之间划清界限 增加单独策略的可测试性 缺点:
后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动 会带来的问题:
可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力 总结:
在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).
实现流程 主要的思想, 我觉得还是 面向接口编程
分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(interface) 将算法或策略剥离成独立的策略对象, 并实现上述抽象接口 主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略&amp;quot;插入&amp;quot;(plugin)流程, 调用, 获取结果, ok. 参考 refactoringguru - strategy </description>
      <content:encoded><![CDATA[<h2 id="场景">场景</h2>
<p>在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.</p>
<p>比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.</p>
<h2 id="分析">分析</h2>
<p>优点:</p>
<ul>
<li>将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象</li>
<li>在不同策略之间划清界限</li>
<li>增加单独策略的可测试性</li>
</ul>
<p>缺点:</p>
<ul>
<li>后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动</li>
</ul>
<p>会带来的问题:</p>
<ul>
<li>可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力</li>
</ul>
<p>总结:</p>
<p>在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).</p>
<h2 id="实现流程">实现流程</h2>
<p>主要的思想, 我觉得还是 <strong>面向接口编程</strong></p>
<ol>
<li>分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(<strong>interface</strong>)</li>
<li>将算法或策略剥离成独立的策略对象, 并实现上述抽象接口</li>
<li>主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略&quot;插入&quot;(plugin)流程, 调用, 获取结果, ok.</li>
</ol>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://refactoringguru.cn/design-patterns/strategy">refactoringguru - strategy</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>计算机中的：大端和小端</title>
      <link>https://ynikl.github.io/posts/endianness/</link>
      <pubDate>Sat, 04 Jun 2022 00:19:23 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/endianness/</guid>
      <description>大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”
大端的优势是高位计算，和可读性 小端的优势的低位运算 各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。
以上是阅读阮一峰的博文-字节序探析：大端与小端的比较的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。
参考连接 阮一峰的博文-字节序探析：大端与小端的比较 </description>
      <content:encoded><![CDATA[<p>大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”</p>
<ul>
<li>大端的优势是高位计算，和可读性</li>
<li>小端的优势的低位运算</li>
</ul>
<p>各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。</p>
<p>以上是阅读<a href="https://www.ruanyinfeng.com/blog/2022/06/endianness-analysis.html">阮一峰的博文-字节序探析：大端与小端的比较</a>的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。</p>
<h2 id="参考连接">参考连接</h2>
<ul>
<li><a href="https://www.ruanyinfeng.com/blog/2022/06/endianness-analysis.html">阮一峰的博文-字节序探析：大端与小端的比较</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql 不支持事务嵌套</title>
      <link>https://ynikl.github.io/posts/mysql-nested-transactions/</link>
      <pubDate>Thu, 02 Jun 2022 16:16:58 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/mysql-nested-transactions/</guid>
      <description>mysql 在事务中再开启事务，前一个事务会被自动提交
stackoverflow</description>
      <content:encoded><![CDATA[<p>mysql 在事务中再开启事务，前一个事务会被自动提交</p>
<p><a href="https://stackoverflow.com/questions/1306869/are-nested-transactions-allowed-in-mysql">stackoverflow</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>并发与并行的区别</title>
      <link>https://ynikl.github.io/posts/concurrency-and-parallelism/</link>
      <pubDate>Tue, 31 May 2022 22:36:34 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/concurrency-and-parallelism/</guid>
      <description>举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。
并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构
并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。
Concurrency is not Parallelism by Rob Pike</description>
      <content:encoded><![CDATA[<p>举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。</p>
<p>并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构</p>
<p>并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。</p>
<p><a href="https://www.youtube.com/watch?v=oV9rvDllKEg&amp;list=WL&amp;index=5&amp;t=9s">Concurrency is not Parallelism by Rob Pike</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>如何做决定——遗憾最小化</title>
      <link>https://ynikl.github.io/posts/how-make-decisions/</link>
      <pubDate>Mon, 30 May 2022 19:17:51 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/how-make-decisions/</guid>
      <description>读Randy&amp;rsquo;s的博客遗憾最小化框架有感
在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定
做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾
Jeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。
Bezos的视频地址 Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁
Ask yourself: in 10 years from now, will you be proud of having done this? &amp;hellip; Do things that your future self will be proud, is my motto for the time being.</description>
      <content:encoded><![CDATA[<p>读Randy&rsquo;s的博客<a href="https://lutaonan.com/blog/regret-minimization-framework/">遗憾最小化框架</a>有感</p>
<p><em>在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定</em></p>
<p><strong>做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾</strong></p>
<blockquote>
<p>Jeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。</p>
</blockquote>
<p><a href="https://www.youtube.com/watch?v=jwG_qR6XmDQ&amp;ab_channel=MickyThompson">Bezos的视频地址</a>
Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁</p>
<blockquote>
<p>Ask yourself: in 10 years from now, will you be proud of having done this? &hellip; Do things that your future self will be proud, is my motto for the time being.</p>
</blockquote>
]]></content:encoded>
    </item>
    
    <item>
      <title>我为什么要学微服务</title>
      <link>https://ynikl.github.io/posts/2022/0526-why-learn-microservices/</link>
      <pubDate>Thu, 26 May 2022 13:29:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/2022/0526-why-learn-microservices/</guid>
      <description>为什么学 高学习产出转化比 助力下一份工作 公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。 后端架构转变的主流方向, 有利于再次找工作。
怎么学 想要学习好一个技术，就需要有想学习这门技术的动力。
首先要对它有较全面的理解：
我们为什么要学习这门技术 技术的使用场景，以及使用的优势和劣势 现在该技术在大环境中的使用情况 再开始学习技术本身。
针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。
具体方法：
我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。 使用 go-zero 框架完成一个练手项目开发。 </description>
      <content:encoded><![CDATA[<h2 id="为什么学">为什么学</h2>
<ol>
<li>高学习产出转化比</li>
<li>助力下一份工作</li>
</ol>
<p>公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。
后端架构转变的主流方向, 有利于再次找工作。</p>
<h2 id="怎么学">怎么学</h2>
<p>想要学习好一个技术，就需要有想学习这门技术的动力。</p>
<p>首先要对它有较全面的理解：</p>
<ol>
<li>我们为什么要学习这门技术</li>
<li>技术的使用场景，以及使用的优势和劣势</li>
<li>现在该技术在大环境中的使用情况</li>
</ol>
<p>再开始学习技术本身。</p>
<p>针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。</p>
<p>具体方法：</p>
<ol>
<li>我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。</li>
<li>使用 <code>go-zero</code> 框架完成一个练手项目开发。</li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>IP表示中 / 代表的意思</title>
      <link>https://ynikl.github.io/posts/cs-the-slash-meaning-of-ip/</link>
      <pubDate>Mon, 23 May 2022 22:01:03 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/cs-the-slash-meaning-of-ip/</guid>
      <description>IP 中斜杠表示的是子网掩码的位数
例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000</description>
      <content:encoded><![CDATA[<p>IP 中斜杠表示的是子网掩码的位数</p>
<p>例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Five Class Programer</title>
      <link>https://ynikl.github.io/posts/five-class-engineer/</link>
      <pubDate>Sun, 15 May 2022 17:11:57 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/five-class-engineer/</guid>
      <description>以前有一段时间, 怀疑过自己&amp;quot;软件工程师&amp;quot;和以前工程意义上的&amp;quot;工程师&amp;quot;有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的见识书中看了一个五级工程师的概念, 算是解惑了我做为一个&amp;quot;码农&amp;quot;和工程师的区别.
(图片来源于图书截图)
第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围. 第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程. 第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维. 第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样. 第一级工程师: 开创一个行业的鼻祖. 能够改变世界. 反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.
所以我自己应该就是 5.0, 五级工程师, 五流程序员.</description>
      <content:encoded><![CDATA[<p>以前有一段时间, 怀疑过自己&quot;软件工程师&quot;和以前工程意义上的&quot;工程师&quot;有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的<a href="https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/">见识</a>书中看了一个五级工程师的概念, 算是解惑了我做为一个&quot;码农&quot;和工程师的区别.</p>
<p><img loading="lazy" src="five_class_engineer.png" alt="五级工程师"  />

(图片来源于图书截图)</p>
<ul>
<li>第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围.</li>
<li>第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程.</li>
<li>第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维.</li>
<li>第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样.</li>
<li>第一级工程师: 开创一个行业的鼻祖. 能够改变世界.</li>
</ul>
<p>反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.</p>
<p>所以我自己应该就是 5.0, 五级工程师, 五流程序员.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Hugo 如何使用已经发布文章做为相对URL</title>
      <link>https://ynikl.github.io/posts/hugo_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%BF%9E%E6%8E%A5/</link>
      <pubDate>Sun, 15 May 2022 16:33:13 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/hugo_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%BF%9E%E6%8E%A5/</guid>
      <description>hugo 的默认内容都是在 content/ 路径下方
在 markdown 文章中使用 { {&amp;lt; ref &amp;quot;/blog/my-first-post.md&amp;quot; &amp;gt;}}(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带/ 是表示从 content/ 目录下的下一个绝对路径
1 [我的文章]({ {&amp;lt; ref &amp;#34;/blog/my-first-post.md&amp;#34; }}) 记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错
hugo官方文档</description>
      <content:encoded><![CDATA[<p>hugo 的默认内容都是在 <code>content/</code> 路径下方</p>
<p>在 markdown 文章中使用 <code>{ {&lt; ref &quot;/blog/my-first-post.md&quot; &gt;}}</code>(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带<code>/</code> 是表示从 <code>content/</code> 目录下的下一个绝对路径</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[我的文章]({ {&lt; ref &#34;/blog/my-first-post.md&#34; }})
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错</strong></p>
<p><a href="https://gohugo.io/content-management/cross-references/">hugo官方文档</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>My first Post</title>
      <link>https://ynikl.github.io/posts/my-first-post/</link>
      <pubDate>Sun, 15 May 2022 16:14:09 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/my-first-post/</guid>
      <description>我的第一篇杂文
阅读了卡片写作笔记法, 和Show Your Work之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.
原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.</description>
      <content:encoded><![CDATA[<p>我的第一篇杂文</p>
<p>阅读了<a href="https://book.douban.com/subject/35503571/">卡片写作笔记法</a>, 和<a href="https://ynikl.github.io/books/showyourwork/" title="about me">Show Your Work</a>之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.</p>
<p>原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>提升文字留存率</title>
      <link>https://ynikl.github.io/posts/%E6%8F%90%E5%8D%87%E6%96%87%E5%AD%97%E7%95%99%E5%AD%98%E7%8E%87/</link>
      <pubDate>Sat, 02 Apr 2022 09:58:23 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/posts/%E6%8F%90%E5%8D%87%E6%96%87%E5%AD%97%E7%95%99%E5%AD%98%E7%8E%87/</guid>
      <description>如何提高自己的所编写的文字留存问题? 自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意. 然后就会把已经写下的文字和内容删除掉.</description>
      <content:encoded><![CDATA[<p>如何提高自己的所编写的文字留存问题?
自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意.
然后就会把已经写下的文字和内容删除掉.</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
