<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang 100 mistake 的简单读书笔记 | 潜水员的咖啡小屋</title>
<meta name=keywords content="golang"><meta name=description content="variable shadowing
init
弊端

初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序
影响测试， 会在测试之前执行
获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试）

什么时候使用

避免错误产生没有err
不会产生全局变量

getters and setters
如果只是简单获取值的话，就不应该用
方法命名

获取值 Balance 而不是 （ GetBalance)
设置值 SetBalance

interface pollution
interface 的价值

通用的方法（ 如排序）
解耦
限制实体行为（仅提供特定方法）

只要在当我们真正用到的时候才去创建
we should create an interface when we need it, not when we foresee that we could need it
interface 抽象 是通过发现的，而不是通过创造的

生产端接口声明，与实现放在同一个包中
消费端接口声明，与使用interface的放在同一个包中

Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。
准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。
return interfaceBe conservative in what you do, be liberal in fr
Be conservative in what you do, be liberal in what you accept from others."><meta name=author content="潜水员"><link rel=canonical href=https://ynikl.github.io/books/golang-100mistake/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ynikl.github.io/books/golang-100mistake/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-35FCVN7C8X"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-35FCVN7C8X")}</script><meta property="og:title" content="Golang 100 mistake 的简单读书笔记"><meta property="og:description" content="variable shadowing
init
弊端

初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序
影响测试， 会在测试之前执行
获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试）

什么时候使用

避免错误产生没有err
不会产生全局变量

getters and setters
如果只是简单获取值的话，就不应该用
方法命名

获取值 Balance 而不是 （ GetBalance)
设置值 SetBalance

interface pollution
interface 的价值

通用的方法（ 如排序）
解耦
限制实体行为（仅提供特定方法）

只要在当我们真正用到的时候才去创建
we should create an interface when we need it, not when we foresee that we could need it
interface 抽象 是通过发现的，而不是通过创造的

生产端接口声明，与实现放在同一个包中
消费端接口声明，与使用interface的放在同一个包中

Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。
准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。
return interfaceBe conservative in what you do, be liberal in fr
Be conservative in what you do, be liberal in what you accept from others."><meta property="og:type" content="article"><meta property="og:url" content="https://ynikl.github.io/books/golang-100mistake/"><meta property="og:image" content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="books"><meta property="article:published_time" content="2023-05-25T12:10:53+08:00"><meta property="article:modified_time" content="2023-05-25T12:10:53+08:00"><meta property="og:site_name" content="潜水员的咖啡小屋"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang 100 mistake 的简单读书笔记"><meta name=twitter:description content="variable shadowing
init
弊端

初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序
影响测试， 会在测试之前执行
获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试）

什么时候使用

避免错误产生没有err
不会产生全局变量

getters and setters
如果只是简单获取值的话，就不应该用
方法命名

获取值 Balance 而不是 （ GetBalance)
设置值 SetBalance

interface pollution
interface 的价值

通用的方法（ 如排序）
解耦
限制实体行为（仅提供特定方法）

只要在当我们真正用到的时候才去创建
we should create an interface when we need it, not when we foresee that we could need it
interface 抽象 是通过发现的，而不是通过创造的

生产端接口声明，与实现放在同一个包中
消费端接口声明，与使用interface的放在同一个包中

Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。
准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。
return interfaceBe conservative in what you do, be liberal in fr
Be conservative in what you do, be liberal in what you accept from others."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Books","item":"https://ynikl.github.io/books/"},{"@type":"ListItem","position":2,"name":"Golang 100 mistake 的简单读书笔记","item":"https://ynikl.github.io/books/golang-100mistake/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang 100 mistake 的简单读书笔记","name":"Golang 100 mistake 的简单读书笔记","description":"variable shadowing init 弊端\n初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序 影响测试， 会在测试之前执行 获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试） 什么时候使用\n避免错误产生没有err 不会产生全局变量 getters and setters 如果只是简单获取值的话，就不应该用\n方法命名\n获取值 Balance 而不是 （ GetBalance) 设置值 SetBalance interface pollution interface 的价值\n通用的方法（ 如排序） 解耦 限制实体行为（仅提供特定方法） 只要在当我们真正用到的时候才去创建\nwe should create an interface when we need it, not when we foresee that we could need it\ninterface 抽象 是通过发现的，而不是通过创造的\n生产端接口声明，与实现放在同一个包中 消费端接口声明，与使用interface的放在同一个包中 Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。\n准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。\nreturn interfaceBe conservative in what you do, be liberal in fr Be conservative in what you do, be liberal in what you accept from others.\n","keywords":["golang"],"articleBody":"variable shadowing init 弊端\n初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序 影响测试， 会在测试之前执行 获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试） 什么时候使用\n避免错误产生没有err 不会产生全局变量 getters and setters 如果只是简单获取值的话，就不应该用\n方法命名\n获取值 Balance 而不是 （ GetBalance) 设置值 SetBalance interface pollution interface 的价值\n通用的方法（ 如排序） 解耦 限制实体行为（仅提供特定方法） 只要在当我们真正用到的时候才去创建\nwe should create an interface when we need it, not when we foresee that we could need it\ninterface 抽象 是通过发现的，而不是通过创造的\n生产端接口声明，与实现放在同一个包中 消费端接口声明，与使用interface的放在同一个包中 Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。\n准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。\nreturn interfaceBe conservative in what you do, be liberal in fr Be conservative in what you do, be liberal in what you accept from others.\n对自己依赖别人的功能保守，对自己赋予别人的能力保持开放\n尽量接收 interface 尽量返回 结构体 正常 consumer 定义接口， 就会造成循环引用\n如果 是现房new 的时候返回 interface 就会变成，由实现方来限制了限制了客户端使用接口消费的抽象组合方式\nConfuse Generics 限制 constraint， 可以是一下两种\n接口 任意类型 ~int， 限制 底层类型\nembbding 错误使用将底层的方法公开出来\ntype client struct { sync.Mutex // 错误地将 Lock() 和 Unlock() 方法暴露给客户端了 protectData map[string]string }\nFunctional Options Parttern\n定义闭包声明函数，更新和修改配置， 有几个好处\n使用默认配置时， 避免声明空的 cfg 参数结构体 通过闭包延迟 err 的处理， 聚合在客户端内部 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 type options struct { port *int } type Option func(opt options) error func WithPort(port int) Option { return func(opt options) error { opt.port = port } } func NewServer(c client, opts ...Option) { var cfg options for _, op := range opts { err := op(cfg) if err != nil { } } } func main() { NewServer(http.DefaultClient, WihtPort(8080)) } 12 Project Organization project-layout\nWe should minimize what should be exported as much as possible to reduce the coupling between pack-\nages and keep unnecessary exported elements hidden.\n包的成员，非必要不公开。\n13 Utility Package 创建类似与 common ， utility, base， shared 等没有意义的包名，共享一些工具类代码。\n14 Ignoring Package name collisions 避免包名和变量名冲突\n使用不同的变量名redisClient 对引用的包取别名 redisPkg 15 Missing code documentation exported 的公开变量 都需要进行文档备注 Deprecated: // Package 的说明应该在 doc.go 文件 // Package 包名开头 与 Go 代码声明有空行间隔 会被忽略 16 Not using linters 17 Creating confusion with octal literal 错误使用 010， 表示八进制\n0b 二进制 0x 十六进制 0i 虚数 18 Integer Overflow 整形溢出， 多注意\n19 floating points 20 slice length and capactity the slice length is the number of available elements in the slice,\nwhereas the slice capacity is the number of elements in the backing arra\n长度是 slice 可用的长度， 容量是slice底层数据的长度\n22 slice empty and nil slice nil\n不需要分配内存， nil slice 是 empty slice empty slice\n长度等于 0 23 check slice by nil 通过 list == nil 判断 slice 是否为空，是错误的\n要通过长度判断 len(list)判断 slice 是否为空。\n24 copy slice 赋值数量为最小两个slice 之间最小长度\n复制之前应该，注意复制的目标数组的长度\nsrc := []int{0, 1, 2} dst := make([]int, len(src)) copy(dst, src) fmt.Println(dst)\n不同的复制方式\nsrc := []int{0, 1, 2} dst := append([]int(nil), src…)\n25 切片更新添加数据副作用 s1 := []int{1,2,3} s2 := s1[1:2] s3 := append(s2, 10}\n// Output: // s1 [1, 2, 10]\n26 slice 导致内存泄露 使用切变承接输入的大数据数组， 获取小部分数据。\n小数据的slice， 仍然会指向大数组的空间，内存占用仍会较高。\n需要重新声明 slice， 使用copy 复制需要的数据。\nGC 不会回收 slice 已经分配但没有使用的空间。\n27 Map 初始化 load factor overflowed\nmake(map, hint_size) 初始化 map, 带预计大小, 可以避免map 在插入的时候, 需要复制.\n获取足够的内存 重新平衡分配元素到各个bucket 28 map memory leaks A map can only grow and have more buckets; it never shrinks.\nGC 可以回收 map 的元素, 但是无法回收 map 本身占用的空间大小.\n解决方法\n创建副本, 创建一个新的map, 复制现有的值, 释放原有的map map的value 存放 指针, 缩小每一个空的bucket 占用的空间大小 (指针空间 8bytes or 4bytes) 29 值比较  Booleans—Compare whether two Booleans are equal.\n Numerics (int, float, and complex types)—Compare whether two numerics are equal.\nStrings—Compare whether two strings are equal.\n Channels—Compare whether two channels were created by the same call to\nmake or if both are nil.\n Interfaces—Compare whether two interfaces have identical dynamic types and\nequal dynamic values or if both are nil.\n Pointers—Compare whether two pointers point to the same value in memory or\nif both are nil.\n Structs and arrays—Compare whether they are composed of similar types.\n对比方法\n简单通过 == 对比, 无法处理复杂类型 reflect.DeepEuqal 有性能瓶颈 自己实现对比方法, 参考已经有标准库, 如bytes.Compare 30 copy value in range 在 range 遍历的过程中, 是值复制\n31 range expresion evaluated for i, v := range exp exp 针对不同类型表达式, 会在 开始执行 loop 之前, 对exp 进行复制\nslice range 会在开始range的时候, 计算slice 的长度和容量, 并创建一个临时的 slice\n![[Pasted image 20230221093451.png]]\n1 2 3 4 5 s := []int{0, 1, 2} for i := 0; i \u003c len(s); i++ { s = append(s, 10) } 会无限执行下去, 因为 len 是每次执行的时候都会计算一次\nchannel 与slice 一样, 同样会在开始的时候为 channel 创建一个临时变量.\n1 2 3 4 5 6 ch := ch1 for v := range ch { fmt.Println(v) ch = ch2 } 这个在range 这替换的动作是无效的, range 的仍然是ch1\narray 1 2 3 4 5 6 7 a := [3]int{0, 1, 2} for i, v := range a { a[2] = 10 if i == 2 { fmt.Println(v) } } 会对 a 整个数据进行复制, 输出是2, 原数组不变\n修改原数组方案\n使用 index , 访问和修改数据 对数据取指针方法 for i, v := range \u0026a 32 range 过程中使用 遍历元素的指针 1 2 3 for _, customer := range customers { s.m[customer.ID] = \u0026customer } \u0026customer 指向的是 range 复制出来的内存\n33 对 map 数据的错误消费 依赖 map 的顺序， map 的数据是无序的 在遍历过程中继续插入新的数据， 结果是不可预测的。有可能会被遍历到，也有可能会被跳过 34 break 层的错误理解 break 对 for, select, switch 三个语句的最内层生效\n1 2 3 4 5 6 for i := 0; i \u003c 5; i++ { switch i { case 2: break } } 没有中断， 结果正常遍历。\n可以使用 Label 达到中断 for 的方式， 标准库也经常采用该种写法。\n35 在 for 中使用 defer 36 没有理解 rune string 是一个结构体, 有两个字段\nA pointer to an immutable byte sequence 长度 Unicode 是字符集 Utf-8 是编码方式\nRune 是 Unicode 的字符集表示，相当于一个字符, golang 使用utf-8编码方式， 所以一个rune 是1-4个字节 bytes.\n1 type rune = int32 len()函数返回的是 bytes 的长度\n37 对 string 的错误遍历 获取字符串的字符个数 utf8.RuneCountInString\n获取字符串的第i个字符\n如果是纯ascii码字符串，直接通过str[i]获取。 获取出来的是 bytes 编码需要转成字符 如果存在非ascii 字符 通过 for i, c := range str遍历获取到第 i 个 rune 字符， 和 c 字符编码 通过索引获取， 需要先强制转化成 []rune(str)[i] 可以直接获取字符串的第 i 个 rune 字符 38 对 TrimRight / TrimSuffix 混淆 strings.TrimRight 是从右到开始移除所有符合的字符集，直到遇到第一个不符合的字符 TrimSuffix 是移除整个字符串\n39 使用 += 字符串拼接 使用 += 拼接一系列字符串，会造成内存分配频繁，因为每一个字串都是不变的。 推荐使用 strings.Builder\n40 冗余转化成字符串 所有的字符串操作 strings 包， 在 bytes 包都会有相对应的替换方法，没有必要将 bytes 转化成 string 在进行操作。\n41 subString 导致内存泄露 substring 生成的 新字符串与旧字符串指向同一块内存，原理同slice\n42 方法值接受者和指针接收者 pointer receiver\n需要修改对象数据 接收者包含不能copy的对象，如 sync 接收者为大对象 value receiver\n不修改接收者 接收者为 map, channel 接收者为小对象， 基础类型 43 命名的返回参数 用处\n增加代码可读性， 如果无法增加可读性，就不需要命名 提前初始化变量 使用 naked return 的提前是函数短小，太长的函数会降低可读性，需要一直记住变量 不应改混着使用 naked return 和 带参数return 44 返回了未赋值的命名 err 1 2 3 4 5 6 func name(ctx context.Context) (a,b int, err error) { if ctx.Err() != nil { // err is nil return 0, 0, err } } 45 interface 返回 non-nil 1 2 3 4 5 func Validate() error { var m *MutilErrorStruct return m } // 返回值 err != nil 永远为true nil 的结构体， 在返回 interface 的函数之后就永远不等于 nil ![[Pasted image 20230309221827.png]]\n解决方案，永远明确地返回 nil\n1 2 3 4 if m != nil { return m } return nil 46 不用使用文件名作为参数 使用 io.Reader 做为参数, 替代文件有两种好处\n方法的具体实现可以与数据源的类型无关, 文件, 或者http, 或者sock 方便测试, 无法因为测试而创建一堆文件 47 defer 参数的计算 defer 在代码执行到的时候会, 立刻使用当前函数的参数的变量值, 包括方法的接收者作为参数.\n48 panic 什么时候应该panic\na pure programmer error ( 程序员编码错误 ) 依赖初始化失败 49 Error Wrap 什么时候使用 Error Wrap\n添加额外的信息 标记为某一特定的错误类型 处理的信息的多种选择\n直接返回错误 自定义错误类型 fmt.Errorf + %w wrap 错误 fmt.Errorf + %v 包含错误文字 50 用 as 检查Err类型 通过 wrap 的 error 需要使用 error.As(err, \u0026targetErrorStruct{}) 判断是否为目标结构体\n51 erros.Is 制定 error 错误信息的原则:\n可以预测的错误使用制定错误变量 ErrFoo = errors.New(\"foo\") 无法预测的错误,使用指定错误类型 type BarError struct 使用 error.Is(err, sql.ErrNoRows) 判断错误是否为指定的错误类型.\n52 多次处理同一个错误 一个错误多次重复打日志, 会让调试更加艰难.\n打印错误也是一种错误的处理方式. 所有, 要么选择打印错误, 要么选择向上抛出错误. 不要两者同时.\n向上层函数抛出错误的时候, 需要通过 WrapErr 附加上当前的额外错误信息\n53 明确忽略的 error 使用 _ 接收返回的error, 明确表示不处理, 错误\n1 2 _ = funcReturnErr() 建议再加上注释说明为什么不处理函数错误\n54 处理 defer 函数返回的错误 记得要处理 defer 的函数返回的错误, 至少需要显示忽略\n55 并发和并行 并发的重点是可以处理多项事务的设计结构, 并行是多项事务可以同时进行处理.\nConcurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once. —Rob Pike\n并发并不代表多件事务真正意义上的\"同时进行\", 同时进行是并行, 并发主要处理阻塞的流程 优化\n56 并发 不一定更快 过小的切分任务, 会让时间消耗在创建和消费协程上, 并没有真正的提高\"并行\"能力.\n57 通道和互斥锁 通道的底层也是互斥锁.\n当协程之间需要传递信息, 或者数据, 使用通道 – 互斥锁的更高抽象\n58 数据竞争(data race) 和条件竞争(race condition) 数据竞争:\n同时有多个协程同时访问统一块内存, 且至少有一个协程正在写入数据\n条件竞争:\n事件发生的先后顺序不可控制, 无法控制协程的执行先后顺序, 导致结果不可控.\n59 区分任务类型 (计算密集或者 I/O密集型) 如果是计算密集型, goroutine 的并发上线应该采用 runtime.GOMAXPROCS(0)\n过多的协程, 可能导致创建过得的 M, 就会出现多个 M 在一个 cpu 核心 中疯狂切换.\n60 Conetxt Deadline 设置超时时间 context.WithTimeout 传递取消消息 context.WithCancel 传递值 context.WithValue context.Err 会返回解释, 为何context.Done关闭 传递值时, key 不直接使用 string 是为了避免, 冲突覆盖.\nThe provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables’ static type should be a pointer or interface.\n疑惑的时候就使用 context.TODO\nWhen in doubt about which context to use, we should use context.TODO() instead of passing an empty context with context.Background.\n61 传递 context 62 关心 goroutine 什么时候停止 关心 goroutine 持有的文件描述符是否被正确的关闭 注意协程持有的资源\n63 注意 goroutine 获取循环变量 64 select 是随机, case 先后顺序不保证优先级. 65 消息型 channel 消息型 channel 的数据结构应该使用 make(chan struct{}) 空结构体, 编程惯例, 提醒 接收者, 传递的消息是没有任何意义的.\n66 使用 nil channel 在使用 select 的时候, 当 channel 已经 close 掉后, 就可以将channel 设置成 nil , 让该 case 条件进入堵塞状态\n67 分清 buffed and unbeffed channel 的使用场景 68 string format 的副作用 如果有协程正在更新 ctx, context的值的话, 就会出现数据竞争, fmt 读取ctx的内部值\nctxKey := fmt.Sprintf(\"%v\", ctx)\nfmt 会读取 string() 的方法, 应注意该方法中的读写锁是否会造成死锁.\n69 append 的数据竞争 slice 更新和读取不通的index时不会出问题.\nmap 操作时存在更新, 无论key是否相同有可能产生冲突. 因为, map 的底层是数组, 不同的 key 也有可能指向相同的数组\n70 71 wg.Add 在协程开启前 72 sycn.cond 73 errgroup 74 sync 包不能被复制, 要小心值复制 75 time.Duration 的时间单位是 纳秒 标准使用\n1 1 * time.Second 76 time.Afte 导致内存泄露 方法内部实现的协程, 需要等到时间到了, 才会释放资源, 所以不要在循环中调用.\n77 结构体 序列化和反序列化 结构体嵌套 直接嵌入未命名的结构体, 可能会使用sub embedding struct 的序列化接口方法, 导致bug\n1 2 3 4 type a struct { ID int time.Time } a 结构体再序列化的时候会使用 time.Time 的MarshalJSON()的方法\n使用命名结构体接入 重新实现接口方法 time 的对比 time 内部包含 wall clock 和 montonic clock 字段, 返回序列化后的 time 对象, 不包含 montonic clock 直接对比, 会不相同\nThe general rule is that the wall clock is for telling time and the monotonic clock is for measuring time.\n可以使用 time.Equal 方法 或者使用 Truncate 移除 monotonic clock 数值 map map[string]any 数值反序列化后类型都为 float64\n78 SQL 错误 sql.Open sql.Open() 不一定是与数据库服务建立了连接, 具体还是需要看 驱动 实现, 可以通过 ping 方法, 强制建立连接\nsql 连接池的配置 sql 连接状态分两种\n使用者 idle 等待使用, 已创建但没有再使用 sql 连接池配置\nSetMaxOpenConns 最大连接数量, 考虑到下游服务的性能 SetMaxIdleConn 在并发高时适当增加, 避免创建耗时 SetConnMaxIdleTime 并发增加之后, 维持多久销毁连接 SetConnMaxLifetime 不希望一个连接持续过久 sql.prepared 语句 高效: 更加高效, 避免 SQL 重复编译 安全: 避免SQL注入 string 处理 null 值 使用指针声明 *string 使用 sql.NullString 类型 rows.Err 错误捕获 79 资源关闭 实现 io.Closer 的临时资源需要 及时 close\nhttp 请求的客户端, respBody 需要close sql.Rows os.File 80 http handle 忘记 return 81 使用 默认http client 和 server client http 的请求步骤\ndial tls 握手 send read header read body 4个超时配置\nnet.Dialer.Timeout 建立连接超时 http.Transport.TLSHandshakeTimeout TLS 握手超时 http.Transport.ResponseHeaderTimeout 等待服务返回头此时 http.Client.Timeout 这个请求的时间限制, from 上述步骤1到5 net/http: request canceled (Client.Timeout exceeded while awaiting headers) 报错 服务端返回超时, 在step4, 读取头时等待超时.\nhttp 连接池\nhttp.Transport.IdleConnTimeout http.Transport.MaxIdleConns http.Transport.MaxIdleConnsPerHost 默认为2, 严重影响并发 server 1 2 server := \u0026http.Server{} server.Serve(listener) 服务端步骤\n等待请求 TLS read request headers read request body write response 3个 timeout\nhttp.Sever.ReadHeadersTimeout http.Server.ReadTimeout http.TimeoutHandler http.Server.IdleTimeout keep-alive 请求可以保持多久 TimeoutHanlder 包裹 handle 当处理超时时,返回503\n如果都没有配置超时的话, 服务器就没有超时机制, 会一直等待客户端主动关闭连接. 当服务暴露给不信任客户端时, 至少需要配置 ReadTimeout 和 TimeoutHandler 避免资源被耗尽.\n82 对单元测试进行分类 避免执行不需要单元测试, 提升测试效率.\n使用 tag go test --tags=integration -v . 根据环境变量, 使用testing.Skip() 显示调用为什么跳过测试 使用 testing.Short() 判断当前执行模式, 跳过需要长时间耗时的测试 go test -short -v . 83 测试启用 –race 编译时带 --race 会增加程序消耗\n内存提高5-10倍 运行时间2-20倍 避免在生产环境使用, 在CI的时候使用\n84 test 的执行模式 parallel\ntesting.T.Parallel() 会先暂停, 等待顺序测试任务完成后, 继续执行.\ngo test - parallel 16 . 并发执行测试\nshuffle\ngo test -shuffle=on -v . 打乱 go test 函数的执行顺序\n85 Table-driven 表驱动测试 t.Run(name, func(t *testing.T) {})\n执行子测试 go test -run=TestFoo/subtest_1 -v\n86 避免测试中的 sleep 在并发场景下, 我们使用 time.Sleep 模拟, 任务处理耗时, 但是我们不知道时间是否足够\n使用多次尝试校验, retry mock 对象使用消息通知校验 87 处理依赖时间测试 改变依赖, 造假数据 修改方法, 让接口传入时间 88 单测工具包 http 相关\nhttptest.NewServer httptest.NewRequest iotest\n89 正确使用 benchmark 测试 忽略耗时函数 忽略对硬件底层 90 单元测试的拓展功能 TestMain 从不同的包测试 ( 重视包对外的开放功能) cover 单测覆盖率 91 CPU cache cpu 三级缓存\ncpu cache Line 加载的 locality of reference, 局部性和相关性 cache line 一般 64 bytes, CPU 内存加载预测\nUnit stride Constant stride Non-Unit stride 92 通过 padding 避免并发操作相同内存复制到不同cpu core 中 cpu 会有cache line 加载数据, 如果两个协程, 并发操作的不同的数据字段(在同一块cache line 大小内存中) 内存中. 这块内存会被同时加载到不同的cpu 核心的缓存中. 因为cpu MESI保证内存一致, 一边更新另一边会失效.\nWhen a cache line is shared across multiple cores and at least one goroutine is a writer, the entire cache line is invalidated.\n使用 pading , 将同时操作的内存分到不同cache line 中\n1 2 3 4 5 type result struct { sumA int64 _ [56]byte // padding sumB int64 } 93 考虑指令集优化 94 内存对齐 内存对齐可以减少结构体占用的内存大小.\n结构体的内存对齐系数, 为各字段中最大的系数\n官方文档\n95 stack \u0026\u0026 heap 栈内存是不需要GC, 只是会根据栈的大小范围表示为不可用, 再次使用的时候, 新值直接覆盖旧值.\n当变量内存分配到栈上, 且函数退出, 变量引用表示不可用 – 无法再次访问, 所以需要 堆.\n堆的使用成本更大, 需要GC, 内存分配成本也更大.\n96 优化内存分配 string.Builder 代替 + 避免 []byte 转 string slice map 的初始化 结构体内存对齐 改变 interface 声明, 避免内存逃逸 sync.Pool 编译器优化, 避免 bytes-to-string 转化 97 编译器函数内联 inline. 当调用的子函数较为简单时, 编译器会是将调用函数的内部实现嵌入当前调用点.\n避免函数的调用成本 可以使编译器进一步优化 (比如, 内存逃逸 直接分配到栈中) 当子函数过为复杂时, 可以抽出子函数的复杂部分为另一个调用函数实现 mid inline. 让中间函数嵌入调用点.\n98 使用分析工具 pprof trace 99 GC marks and sweep\n遍历所有对象, 标记是否在使用 遍历所以对象, 清除没有在使用的对象 GOGC 配置 GC 的敏感度, 当 GOGC=100 时, 当堆内存容量涨100%时触发GC.\n通过 GOGC 进行优化 uber 调优原文 GOGC 调优 100 Docker 和 K8s 资源分配对并发性能的影响 引用 http://github.com/uber-go/automaxprocs 自动设置 GOPROMAX\n","wordCount":"2001","inLanguage":"en","datePublished":"2023-05-25T12:10:53+08:00","dateModified":"2023-05-25T12:10:53+08:00","author":{"@type":"Person","name":"潜水员"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ynikl.github.io/books/golang-100mistake/"},"publisher":{"@type":"Organization","name":"潜水员的咖啡小屋","logo":{"@type":"ImageObject","url":"https://ynikl.github.io/apple-touch-icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ynikl.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ynikl.github.io/apple-touch-icon_hu14773585917063522190.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://ynikl.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://ynikl.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://ynikl.github.io/books/ title=books><span>books</span></a></li><li><a href=https://ynikl.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://ynikl.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ynikl.github.io/me/ title=me?><span>me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ynikl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ynikl.github.io/books/>Books</a></div><h1 class=post-title>Golang 100 mistake 的简单读书笔记</h1><div class=post-meta>&lt;span title='2023-05-25 12:10:53 +0800 +0800'>May 25, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;10 min&amp;nbsp;·&amp;nbsp;潜水员&nbsp;|&nbsp;<a href=https://github.com/ynikl/ynikl.github.io/tree/main/content/books/golang-100mistake/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h3 id=variable-shadowing>variable shadowing<a hidden class=anchor aria-hidden=true href=#variable-shadowing>#</a></h3><h3 id=init>init<a hidden class=anchor aria-hidden=true href=#init>#</a></h3><p>弊端</p><ol><li>初始化 error 的处理, 不应该是包自己用 panic 捕获错误终止程序，而是调用来决定是否应该终止程序</li><li>影响测试， 会在测试之前执行</li><li>获取执行数据，需要通过全局变量（ 全局变量弊端：1. 会被修改，2. 影响测试）</li></ol><p>什么时候使用</p><ol><li>避免错误产生没有err</li><li>不会产生全局变量</li></ol><h3 id=getters-and-setters>getters and setters<a hidden class=anchor aria-hidden=true href=#getters-and-setters>#</a></h3><p>如果只是简单获取值的话，就不应该用</p><p>方法命名</p><ul><li>获取值 Balance 而不是 （ GetBalance)</li><li>设置值 SetBalance</li></ul><h3 id=interface-pollution>interface pollution<a hidden class=anchor aria-hidden=true href=#interface-pollution>#</a></h3><p>interface 的价值</p><ul><li>通用的方法（ 如排序）</li><li>解耦</li><li>限制实体行为（仅提供特定方法）</li></ul><p>只要在当我们真正用到的时候才去创建</p><p>we should create an interface when we need it, not when we foresee that we could need it</p><p>interface 抽象 是通过发现的，而不是通过创造的</p><ul><li>生产端接口声明，与实现放在同一个包中</li><li>消费端接口声明，与使用interface的放在同一个包中</li></ul><p>Interface 是通过发现的，符合使用者的需求（与其他语言最大区别就是 Interface 为隐式实现）所以大部分接口应该是是消费端接口声明。</p><p>准备库定义生产端声明，可以提供自定义接口的能力。 生产端接口要尽量简洁。</p><h3 id=return-interfacebe-conservative-in-what-you-do-be-liberal-in-fr>return interfaceBe conservative in what you do, be liberal in fr<a hidden class=anchor aria-hidden=true href=#return-interfacebe-conservative-in-what-you-do-be-liberal-in-fr>#</a></h3><p>Be conservative in what you do, be liberal in what you accept from others.</p><p>对自己依赖别人的功能保守，对自己赋予别人的能力保持开放</p><ul><li>尽量接收 interface</li><li>尽量返回 结构体</li></ul><p>正常 consumer 定义接口， 就会造成循环引用</p><p><img loading=lazy src=https://cdn.nlark.com/yuque/0/2023/png/12365435/1674099857741-bb77c007-cc4e-4f15-abd7-16bf11de95c5.png alt></p><p>如果 是现房new 的时候返回 interface 就会变成，由实现方来限制了限制了客户端使用接口消费的抽象组合方式</p><h3 id=confuse-generics>Confuse Generics<a hidden class=anchor aria-hidden=true href=#confuse-generics>#</a></h3><p>限制 constraint， 可以是一下两种</p><ul><li>接口</li><li>任意类型</li></ul><p>~int， 限制 底层类型</p><h3 id=embbding>embbding<a hidden class=anchor aria-hidden=true href=#embbding>#</a></h3><p>错误使用将底层的方法公开出来</p><p>type client struct {
sync.Mutex // 错误地将 Lock() 和 Unlock() 方法暴露给客户端了
protectData map[string]string
}</p><p>Functional Options Parttern</p><p>定义闭包声明函数，更新和修改配置， 有几个好处</p><ul><li>使用默认配置时， 避免声明空的 cfg 参数结构体</li><li>通过闭包延迟 err 的处理， 聚合在客户端内部</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=n>type</span> <span class=n>options</span> <span class=n>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>port</span> <span class=o>*</span><span class=ne>int</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>type</span> <span class=n>Option</span> <span class=k>func</span><span class=p>(</span><span class=n>opt</span> <span class=n>options</span><span class=p>)</span> <span class=n>error</span> 
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>func</span> <span class=n>WithPort</span><span class=p>(</span><span class=n>port</span> <span class=ne>int</span><span class=p>)</span> <span class=n>Option</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>return</span> <span class=k>func</span><span class=p>(</span><span class=n>opt</span> <span class=n>options</span><span class=p>)</span> <span class=n>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=n>opt</span><span class=o>.</span><span class=n>port</span> <span class=o>=</span> <span class=n>port</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>func</span> <span class=n>NewServer</span><span class=p>(</span><span class=n>c</span> <span class=n>client</span><span class=p>,</span> <span class=n>opts</span> <span class=o>...</span><span class=n>Option</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>var</span> <span class=n>cfg</span> <span class=n>options</span>
</span></span><span class=line><span class=cl>    <span class=k>for</span> <span class=n>_</span><span class=p>,</span> <span class=n>op</span> <span class=p>:</span><span class=o>=</span> <span class=nb>range</span> <span class=n>opts</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>       	<span class=n>err</span> <span class=p>:</span><span class=o>=</span> <span class=n>op</span><span class=p>(</span><span class=n>cfg</span><span class=p>)</span>
</span></span><span class=line><span class=cl>        <span class=k>if</span> <span class=n>err</span> <span class=o>!=</span> <span class=n>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>            
</span></span><span class=line><span class=cl>        <span class=p>}</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>func</span> <span class=n>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>NewServer</span><span class=p>(</span><span class=n>http</span><span class=o>.</span><span class=n>DefaultClient</span><span class=p>,</span> <span class=n>WihtPort</span><span class=p>(</span><span class=mi>8080</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=12-project-organization>12 Project Organization<a hidden class=anchor aria-hidden=true href=#12-project-organization>#</a></h3><p><a href=https://github.com/golang-standards/project-layout>project-layout</a></p><p>We should minimize what should be exported as much as possible to reduce the coupling between pack-<br>ages and keep unnecessary exported elements hidden.</p><p>包的成员，非必要不公开。</p><h3 id=13-utility-package>13 Utility Package<a hidden class=anchor aria-hidden=true href=#13-utility-package>#</a></h3><p>创建类似与 common ， utility, base， shared 等没有意义的包名，共享一些工具类代码。</p><h3 id=14-ignoring-package-name-collisions>14 Ignoring Package name collisions<a hidden class=anchor aria-hidden=true href=#14-ignoring-package-name-collisions>#</a></h3><p>避免包名和变量名冲突</p><ul><li>使用不同的变量名<code>redisClient</code></li><li>对引用的包取别名 <code>redisPkg</code></li></ul><h3 id=15-missing-code-documentation>15 Missing code documentation<a hidden class=anchor aria-hidden=true href=#15-missing-code-documentation>#</a></h3><ol><li>exported 的公开变量 都需要进行文档备注</li><li><code>Deprecated: //</code></li><li>Package 的说明应该在 <code>doc.go</code> 文件 <code>// Package 包名</code>开头</li><li>与 Go 代码声明有空行间隔 会被忽略</li></ol><h3 id=16-not-using-linters>16 Not using linters<a hidden class=anchor aria-hidden=true href=#16-not-using-linters>#</a></h3><h3 id=17-creating-confusion-with-octal-literal>17 Creating confusion with octal literal<a hidden class=anchor aria-hidden=true href=#17-creating-confusion-with-octal-literal>#</a></h3><p>错误使用 010， 表示八进制</p><ul><li>0b 二进制</li><li>0x 十六进制</li><li>0i 虚数</li></ul><h3 id=18-integer-overflow>18 Integer Overflow<a hidden class=anchor aria-hidden=true href=#18-integer-overflow>#</a></h3><p>整形溢出， 多注意</p><h3 id=19-floating-points>19 floating points<a hidden class=anchor aria-hidden=true href=#19-floating-points>#</a></h3><h3 id=20-slice-length-and-capactity>20 slice length and capactity<a hidden class=anchor aria-hidden=true href=#20-slice-length-and-capactity>#</a></h3><p>the slice length is the number of available elements in the slice,<br>whereas the slice capacity is the number of elements in the backing arra</p><p>长度是 slice 可用的长度， 容量是slice底层数据的长度</p><h3 id=22-slice-empty-and-nil>22 slice empty and nil<a hidden class=anchor aria-hidden=true href=#22-slice-empty-and-nil>#</a></h3><p>slice nil</p><ul><li>不需要分配内存， nil slice 是 empty slice</li></ul><p>empty slice</p><ul><li>长度等于 0</li></ul><h3 id=23-check-slice-by-nil>23 check slice by nil<a hidden class=anchor aria-hidden=true href=#23-check-slice-by-nil>#</a></h3><p>通过 <code>list == nil</code> 判断 slice 是否为空，是错误的</p><p>要通过长度判断 <code>len(list)</code>判断 slice 是否为空。</p><h3 id=24-copy-slice>24 copy slice<a hidden class=anchor aria-hidden=true href=#24-copy-slice>#</a></h3><p>赋值数量为最小两个slice 之间最小长度</p><p>复制之前应该，注意复制的目标数组的长度</p><p>src := []int{0, 1, 2}
dst := make([]int, len(src))
copy(dst, src)
fmt.Println(dst)</p><p>不同的复制方式</p><p>src := []int{0, 1, 2}
dst := append([]int(nil), src&mldr;)</p><h3 id=25-切片更新添加数据副作用>25 切片更新添加数据副作用<a hidden class=anchor aria-hidden=true href=#25-切片更新添加数据副作用>#</a></h3><p>s1 := []int{1,2,3}
s2 := s1[1:2]
s3 := append(s2, 10}</p><p>// Output:
// s1 [1, 2, 10]</p><h3 id=26-slice-导致内存泄露>26 slice 导致内存泄露<a hidden class=anchor aria-hidden=true href=#26-slice-导致内存泄露>#</a></h3><p>使用切变承接输入的大数据数组， 获取小部分数据。</p><p>小数据的slice， 仍然会指向大数组的空间，内存占用仍会较高。</p><p>需要重新声明 slice， 使用copy 复制需要的数据。</p><p>GC 不会回收 slice 已经分配但没有使用的空间。</p><h3 id=27--map-初始化>27 Map 初始化<a hidden class=anchor aria-hidden=true href=#27--map-初始化>#</a></h3><p><code>load factor</code>
<code>overflowed</code></p><p>make(map, hint_size)
初始化 map, 带预计大小, 可以避免map 在插入的时候, 需要复制.</p><ul><li>获取足够的内存</li><li>重新平衡分配元素到各个bucket</li></ul><h3 id=28-map-memory-leaks>28 map memory leaks<a hidden class=anchor aria-hidden=true href=#28-map-memory-leaks>#</a></h3><p><code>A map can only grow and have more buckets; it never shrinks.</code></p><p>GC 可以回收 map 的元素, 但是无法回收 map 本身占用的空间大小.</p><p>解决方法</p><ul><li>创建副本, 创建一个新的map, 复制现有的值, 释放原有的map</li><li>map的value 存放 指针, 缩小每一个空的bucket 占用的空间大小 (指针空间 8bytes or 4bytes)</li></ul><h3 id=29-值比较>29 值比较<a hidden class=anchor aria-hidden=true href=#29-值比较>#</a></h3><p> Booleans—Compare whether two Booleans are equal.<br> Numerics (int, float, and complex types)—Compare whether two numerics are equal.</p><ul><li><p> Strings—Compare whether two strings are equal.</p></li><li><p>  Channels—Compare whether two channels were created by the same call to</p><p>make or if both are nil.</p></li><li><p>  Interfaces—Compare whether two interfaces have identical dynamic types and</p><p>equal dynamic values or if both are nil.</p></li><li><p>  Pointers—Compare whether two pointers point to the same value in memory or</p><p>if both are nil.</p></li><li><p>  Structs and arrays—Compare whether they are composed of similar types.</p></li></ul><p>对比方法</p><ul><li>简单通过 <code>==</code> 对比, 无法处理复杂类型</li><li><code>reflect.DeepEuqal</code> 有性能瓶颈</li><li>自己实现对比方法, 参考已经有标准库, 如<code>bytes.Compare</code></li></ul><h3 id=30-copy-value-in-range>30 copy value in range<a hidden class=anchor aria-hidden=true href=#30-copy-value-in-range>#</a></h3><p>在 <code>range</code> 遍历的过程中, 是值复制</p><h3 id=31-range-expresion-evaluated>31 range expresion evaluated<a hidden class=anchor aria-hidden=true href=#31-range-expresion-evaluated>#</a></h3><p><code>for i, v := range exp</code>
exp 针对不同类型表达式, 会在 开始执行 loop 之前, 对exp 进行复制</p><h4 id=slice>slice<a hidden class=anchor aria-hidden=true href=#slice>#</a></h4><p>range 会在开始range的时候, 计算slice 的长度和容量, 并创建一个临时的 slice</p><p>![[Pasted image 20230221093451.png]]</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>s := []int{0, 1, 2}
</span></span><span class=line><span class=cl>for i := 0; i &lt; len(s); i++ {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    s = append(s, 10)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>会无限执行下去, 因为 <code>len</code> 是每次执行的时候都会计算一次</p><h4 id=channel>channel<a hidden class=anchor aria-hidden=true href=#channel>#</a></h4><p>与slice 一样, 同样会在开始的时候为 channel 创建一个临时变量.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>ch := ch1
</span></span><span class=line><span class=cl>for v := range ch {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>    fmt.Println(v)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>ch = ch2 }
</span></span></code></pre></td></tr></table></div></div><p>这个在range 这替换的动作是无效的, range 的仍然是ch1</p><h4 id=array>array<a hidden class=anchor aria-hidden=true href=#array>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>a := [3]int{0, 1, 2}
</span></span><span class=line><span class=cl>for i, v := range a {
</span></span><span class=line><span class=cl>    a[2] = 10
</span></span><span class=line><span class=cl>    if i == 2 {
</span></span><span class=line><span class=cl>        fmt.Println(v)
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>会对 a 整个数据进行复制, 输出是2, 原数组不变</p><p>修改原数组方案</p><ul><li>使用 index , 访问和修改数据</li><li>对数据取指针方法 <code>for i, v := range &amp;a</code></li></ul><h3 id=32-range-过程中使用-遍历元素的指针>32 range 过程中使用 遍历元素的指针<a hidden class=anchor aria-hidden=true href=#32-range-过程中使用-遍历元素的指针>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for _, customer := range customers {
</span></span><span class=line><span class=cl>        s.m[customer.ID] = &amp;customer
</span></span><span class=line><span class=cl>    }
</span></span></code></pre></td></tr></table></div></div><p><code>&amp;customer</code> 指向的是 range 复制出来的内存</p><h3 id=33-对-map-数据的错误消费>33 对 map 数据的错误消费<a hidden class=anchor aria-hidden=true href=#33-对-map-数据的错误消费>#</a></h3><ol><li>依赖 map 的顺序， map 的数据是无序的</li><li>在遍历过程中继续插入新的数据， 结果是不可预测的。有可能会被遍历到，也有可能会被跳过</li></ol><h3 id=34-break-层的错误理解>34 break 层的错误理解<a hidden class=anchor aria-hidden=true href=#34-break-层的错误理解>#</a></h3><p>break 对 for, select, switch 三个语句的最内层生效</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>for i := 0; i &lt; 5; i++ {
</span></span><span class=line><span class=cl>	switch i {
</span></span><span class=line><span class=cl>	case 2:
</span></span><span class=line><span class=cl>	break
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>没有中断， 结果正常遍历。</p><p>可以使用 Label 达到中断 for 的方式， 标准库也经常采用该种写法。</p><h3 id=35-在-for-中使用-defer>35 在 for 中使用 defer<a hidden class=anchor aria-hidden=true href=#35-在-for-中使用-defer>#</a></h3><h3 id=36-没有理解-rune>36 没有理解 rune<a hidden class=anchor aria-hidden=true href=#36-没有理解-rune>#</a></h3><p>string 是一个结构体, 有两个字段</p><ul><li>A pointer to an immutable byte sequence</li><li>长度</li></ul><p>Unicode 是字符集
Utf-8 是编码方式</p><p>Rune 是 Unicode 的字符集表示，相当于一个字符, golang 使用utf-8编码方式， 所以一个rune 是1-4个字节 bytes.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type rune = int32
</span></span></code></pre></td></tr></table></div></div><p><code>len()</code>函数返回的是 bytes 的长度</p><h3 id=37-对-string-的错误遍历>37 对 string 的错误遍历<a hidden class=anchor aria-hidden=true href=#37-对-string-的错误遍历>#</a></h3><p>获取字符串的字符个数 <code>utf8.RuneCountInString</code></p><p>获取字符串的第i个字符</p><ol><li>如果是纯ascii码字符串，直接通过str[i]获取。 获取出来的是 bytes 编码需要转成字符</li><li>如果存在非ascii 字符<ol><li>通过 <code>for i, c := range str</code>遍历获取到第 i 个 rune 字符， 和 c 字符编码</li><li>通过索引获取， 需要先强制转化成 <code>[]rune(str)[i]</code> 可以直接获取字符串的第 i 个 rune 字符</li></ol></li></ol><h3 id=38-对-trimright--trimsuffix-混淆>38 对 TrimRight / TrimSuffix 混淆<a hidden class=anchor aria-hidden=true href=#38-对-trimright--trimsuffix-混淆>#</a></h3><p>strings.TrimRight 是从右到开始移除所有符合的字符集，直到遇到第一个不符合的字符
TrimSuffix 是移除整个字符串</p><h3 id=39-使用--字符串拼接>39 使用 += 字符串拼接<a hidden class=anchor aria-hidden=true href=#39-使用--字符串拼接>#</a></h3><p>使用 += 拼接一系列字符串，会造成内存分配频繁，因为每一个字串都是不变的。
推荐使用 <code>strings.Builder</code></p><h3 id=40-冗余转化成字符串>40 冗余转化成字符串<a hidden class=anchor aria-hidden=true href=#40-冗余转化成字符串>#</a></h3><p>所有的字符串操作 strings 包， 在 bytes 包都会有相对应的替换方法，没有必要将 bytes 转化成 string 在进行操作。</p><h3 id=41-substring-导致内存泄露>41 subString 导致内存泄露<a hidden class=anchor aria-hidden=true href=#41-substring-导致内存泄露>#</a></h3><p>substring 生成的 新字符串与旧字符串指向同一块内存，原理同slice</p><h3 id=42-方法值接受者和指针接收者>42 方法值接受者和指针接收者<a hidden class=anchor aria-hidden=true href=#42-方法值接受者和指针接收者>#</a></h3><p>pointer receiver</p><ul><li>需要修改对象数据</li><li>接收者包含不能copy的对象，如 sync</li><li>接收者为大对象</li></ul><p>value receiver</p><ul><li>不修改接收者</li><li>接收者为 map, channel</li><li>接收者为小对象， 基础类型</li></ul><h3 id=43-命名的返回参数>43 命名的返回参数<a hidden class=anchor aria-hidden=true href=#43-命名的返回参数>#</a></h3><p>用处</p><ol><li>增加代码可读性， 如果无法增加可读性，就不需要命名</li><li>提前初始化变量</li><li>使用 naked return 的提前是函数短小，太长的函数会降低可读性，需要一直记住变量</li><li>不应改混着使用 naked return 和 带参数return</li></ol><h3 id=44-返回了未赋值的命名-err>44 返回了未赋值的命名 err<a hidden class=anchor aria-hidden=true href=#44-返回了未赋值的命名-err>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>func</span> <span class=n>name</span><span class=p>(</span><span class=n>ctx</span> <span class=n>context</span><span class=o>.</span><span class=n>Context</span><span class=p>)</span> <span class=p>(</span><span class=n>a</span><span class=p>,</span><span class=n>b</span> <span class=ne>int</span><span class=p>,</span> <span class=n>err</span> <span class=n>error</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>if</span> <span class=n>ctx</span><span class=o>.</span><span class=n>Err</span><span class=p>()</span> <span class=o>!=</span> <span class=n>nil</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=o>//</span> <span class=n>err</span> <span class=n>is</span> <span class=n>nil</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=mi>0</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>err</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=45-interface-返回-non-nil>45 interface 返回 non-nil<a hidden class=anchor aria-hidden=true href=#45-interface-返回-non-nil>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>func</span> <span class=n>Validate</span><span class=p>()</span> <span class=n>error</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>var</span> <span class=n>m</span> <span class=o>*</span><span class=n>MutilErrorStruct</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>m</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=o>//</span> <span class=err>返回值</span> <span class=n>err</span> <span class=o>!=</span> <span class=n>nil</span> <span class=err>永远为</span><span class=bp>true</span>
</span></span></code></pre></td></tr></table></div></div><p>nil 的结构体， 在返回 interface 的函数之后就永远不等于 nil
![[Pasted image 20230309221827.png]]</p><p>解决方案，永远明确地返回 nil</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>if m != nil {
</span></span><span class=line><span class=cl>	return m
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>return nil
</span></span></code></pre></td></tr></table></div></div><h3 id=46-不用使用文件名作为参数>46 不用使用文件名作为参数<a hidden class=anchor aria-hidden=true href=#46-不用使用文件名作为参数>#</a></h3><p>使用 io.Reader 做为参数, 替代文件有两种好处</p><ol><li>方法的具体实现可以与数据源的类型无关, 文件, 或者http, 或者sock</li><li>方便测试, 无法因为测试而创建一堆文件</li></ol><h3 id=47-defer-参数的计算>47 defer 参数的计算<a hidden class=anchor aria-hidden=true href=#47-defer-参数的计算>#</a></h3><p>defer 在代码执行到的时候会, 立刻使用当前函数的参数的变量值, 包括方法的接收者作为参数.</p><h3 id=48-panic>48 panic<a hidden class=anchor aria-hidden=true href=#48-panic>#</a></h3><p>什么时候应该panic</p><ul><li>a pure programmer error ( 程序员编码错误 )</li><li>依赖初始化失败</li></ul><h3 id=49-error-wrap>49 Error Wrap<a hidden class=anchor aria-hidden=true href=#49-error-wrap>#</a></h3><p>什么时候使用 Error Wrap</p><ul><li>添加额外的信息</li><li>标记为某一特定的错误类型</li></ul><p>处理的信息的多种选择</p><ul><li>直接返回错误</li><li>自定义错误类型</li><li>fmt.Errorf + %w wrap 错误</li><li>fmt.Errorf + %v 包含错误文字</li></ul><p><img loading=lazy src=https://s2.loli.net/2023/03/21/CPdiq867VhUcAwW.png alt=错误处理的多种选择></p><h3 id=50-用-as-检查err类型>50 用 as 检查Err类型<a hidden class=anchor aria-hidden=true href=#50-用-as-检查err类型>#</a></h3><p>通过 wrap 的 error 需要使用 <code>error.As(err, &amp;targetErrorStruct{})</code> 判断是否为目标结构体</p><h3 id=51-errosis>51 erros.Is<a hidden class=anchor aria-hidden=true href=#51-errosis>#</a></h3><p>制定 error 错误信息的原则:</p><ol><li>可以预测的错误使用制定错误变量 <code>ErrFoo = errors.New("foo")</code></li><li>无法预测的错误,使用指定错误类型 <code>type BarError struct</code></li></ol><p>使用 <code>error.Is(err, sql.ErrNoRows)</code> 判断错误是否为指定的错误类型.</p><h3 id=52-多次处理同一个错误>52 多次处理同一个错误<a hidden class=anchor aria-hidden=true href=#52-多次处理同一个错误>#</a></h3><p>一个错误多次重复打日志, 会让调试更加艰难.</p><blockquote><p>打印错误也是一种错误的处理方式. 所有, 要么选择打印错误, 要么选择向上抛出错误.
不要两者同时.</p></blockquote><p>向上层函数抛出错误的时候, 需要通过 WrapErr 附加上当前的额外错误信息</p><h3 id=53-明确忽略的-error>53 明确忽略的 error<a hidden class=anchor aria-hidden=true href=#53-明确忽略的-error>#</a></h3><p>使用 <code>_</code> 接收返回的error, 明确表示不处理, 错误</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>
</span></span><span class=line><span class=cl> _ = funcReturnErr()
</span></span></code></pre></td></tr></table></div></div><p>建议再加上注释说明为什么不处理函数错误</p><h3 id=54-处理-defer-函数返回的错误>54 处理 defer 函数返回的错误<a hidden class=anchor aria-hidden=true href=#54-处理-defer-函数返回的错误>#</a></h3><p>记得要处理 defer 的函数返回的错误, 至少需要显示忽略</p><h3 id=55-并发和并行>55 并发和并行<a hidden class=anchor aria-hidden=true href=#55-并发和并行>#</a></h3><p>并发的重点是可以处理多项事务的设计结构, 并行是多项事务可以同时进行处理.</p><blockquote><p>Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once.
—Rob Pike</p></blockquote><p>并发并不代表多件事务真正意义上的"同时进行", 同时进行是并行, 并发主要处理阻塞的流程
优化</p><h3 id=56-并发-不一定更快>56 并发 不一定更快<a hidden class=anchor aria-hidden=true href=#56-并发-不一定更快>#</a></h3><p>过小的切分任务, 会让时间消耗在创建和消费协程上, 并没有真正的提高"并行"能力.</p><h3 id=57-通道和互斥锁>57 通道和互斥锁<a hidden class=anchor aria-hidden=true href=#57-通道和互斥锁>#</a></h3><p>通道的底层也是互斥锁.</p><p>当协程之间需要传递信息, 或者数据, 使用通道 &ndash; 互斥锁的更高抽象</p><h3 id=58-数据竞争data-race-和条件竞争race-condition>58 数据竞争(data race) 和条件竞争(race condition)<a hidden class=anchor aria-hidden=true href=#58-数据竞争data-race-和条件竞争race-condition>#</a></h3><p>数据竞争:</p><p>同时有多个协程同时访问统一块内存, 且至少有一个协程正在写入数据</p><p>条件竞争:</p><p>事件发生的先后顺序不可控制, 无法控制协程的执行先后顺序, 导致结果不可控.</p><h3 id=59-区分任务类型-计算密集或者-io密集型>59 区分任务类型 (计算密集或者 I/O密集型)<a hidden class=anchor aria-hidden=true href=#59-区分任务类型-计算密集或者-io密集型>#</a></h3><p>如果是计算密集型, goroutine 的并发上线应该采用 <code>runtime.GOMAXPROCS(0)</code></p><p>过多的协程, 可能导致创建过得的 M, 就会出现多个 M 在一个 cpu 核心 中疯狂切换.</p><h3 id=60-conetxt>60 Conetxt<a hidden class=anchor aria-hidden=true href=#60-conetxt>#</a></h3><ul><li>Deadline 设置超时时间 <code>context.WithTimeout</code></li><li>传递取消消息 <code>context.WithCancel</code></li><li>传递值 <code>context.WithValue</code></li><li><code>context.Err</code> 会返回解释, 为何<code>context.Done</code>关闭</li></ul><p>传递值时, key 不直接使用 string 是为了避免, 冲突覆盖.</p><blockquote><p>The provided key must be comparable and should not be of type string or any other built-in type to avoid collisions between packages using context. Users of WithValue should define their own types for keys. To avoid allocating when assigning to an interface{}, context keys often have concrete type struct{}. Alternatively, exported context key variables&rsquo; static type should be a pointer or interface.</p></blockquote><p>疑惑的时候就使用 <code>context.TODO</code></p><blockquote><p>When in doubt about which context to use, we should use context.TODO() instead of passing an empty context with context.Background.</p></blockquote><h3 id=61-传递-context>61 传递 context<a hidden class=anchor aria-hidden=true href=#61-传递-context>#</a></h3><h3 id=62-关心-goroutine-什么时候停止>62 关心 goroutine 什么时候停止<a hidden class=anchor aria-hidden=true href=#62-关心-goroutine-什么时候停止>#</a></h3><p>关心 goroutine 持有的文件描述符是否被正确的关闭
注意协程持有的资源</p><h3 id=63-注意-goroutine-获取循环变量>63 注意 goroutine 获取循环变量<a hidden class=anchor aria-hidden=true href=#63-注意-goroutine-获取循环变量>#</a></h3><h3 id=64-select-是随机-case-先后顺序不保证优先级>64 select 是随机, case 先后顺序不保证优先级.<a hidden class=anchor aria-hidden=true href=#64-select-是随机-case-先后顺序不保证优先级>#</a></h3><h3 id=65-消息型-channel>65 消息型 channel<a hidden class=anchor aria-hidden=true href=#65-消息型-channel>#</a></h3><p>消息型 channel 的数据结构应该使用 <code>make(chan struct{})</code> 空结构体, 编程惯例, 提醒
接收者, 传递的消息是没有任何意义的.</p><h3 id=66-使用-nil-channel>66 使用 nil channel<a hidden class=anchor aria-hidden=true href=#66-使用-nil-channel>#</a></h3><p>在使用 select 的时候, 当 channel 已经 close 掉后, 就可以将channel 设置成 <code>nil</code> ,
让该 case 条件进入堵塞状态</p><h3 id=67-分清-buffed-and-unbeffed-channel-的使用场景>67 分清 buffed and unbeffed channel 的使用场景<a hidden class=anchor aria-hidden=true href=#67-分清-buffed-and-unbeffed-channel-的使用场景>#</a></h3><h3 id=68-string-format-的副作用>68 string format 的副作用<a hidden class=anchor aria-hidden=true href=#68-string-format-的副作用>#</a></h3><p>如果有协程正在更新 ctx, context的值的话, 就会出现数据竞争, fmt 读取ctx的内部值</p><p><code>ctxKey := fmt.Sprintf("%v", ctx)</code></p><p>fmt 会读取 <code>string()</code> 的方法, 应注意该方法中的读写锁是否会造成死锁.</p><h3 id=69-append-的数据竞争>69 append 的数据竞争<a hidden class=anchor aria-hidden=true href=#69-append-的数据竞争>#</a></h3><p>slice 更新和读取不通的index时不会出问题.</p><p>map 操作时存在更新, 无论key是否相同有可能产生冲突. 因为, map 的底层是数组, 不同的
key 也有可能指向相同的数组</p><h3 id=70>70<a hidden class=anchor aria-hidden=true href=#70>#</a></h3><h3 id=71-wgadd-在协程开启前>71 wg.Add 在协程开启前<a hidden class=anchor aria-hidden=true href=#71-wgadd-在协程开启前>#</a></h3><h3 id=72-sycncond>72 sycn.cond<a hidden class=anchor aria-hidden=true href=#72-sycncond>#</a></h3><h3 id=73-errgroup>73 errgroup<a hidden class=anchor aria-hidden=true href=#73-errgroup>#</a></h3><h3 id=74-sync-包不能被复制-要小心值复制>74 sync 包不能被复制, 要小心值复制<a hidden class=anchor aria-hidden=true href=#74-sync-包不能被复制-要小心值复制>#</a></h3><h3 id=75-timeduration-的时间单位是-纳秒>75 time.Duration 的时间单位是 纳秒<a hidden class=anchor aria-hidden=true href=#75-timeduration-的时间单位是-纳秒>#</a></h3><p>标准使用</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>1 * time.Second
</span></span></code></pre></td></tr></table></div></div><h3 id=76-timeafte-导致内存泄露>76 time.Afte 导致内存泄露<a hidden class=anchor aria-hidden=true href=#76-timeafte-导致内存泄露>#</a></h3><p>方法内部实现的协程, 需要等到时间到了, 才会释放资源, 所以不要在循环中调用.</p><h3 id=77-结构体-序列化和反序列化>77 结构体 序列化和反序列化<a hidden class=anchor aria-hidden=true href=#77-结构体-序列化和反序列化>#</a></h3><h4 id=结构体嵌套>结构体嵌套<a hidden class=anchor aria-hidden=true href=#结构体嵌套>#</a></h4><p>直接嵌入未命名的结构体, 可能会使用sub embedding struct 的序列化接口方法, 导致bug</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type a struct {
</span></span><span class=line><span class=cl>ID int 
</span></span><span class=line><span class=cl>time.Time
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>a 结构体再序列化的时候会使用 <code>time.Time</code> 的<code>MarshalJSON()</code>的方法</p><ul><li>使用命名结构体接入</li><li>重新实现接口方法</li></ul><h4 id=time-的对比>time 的对比<a hidden class=anchor aria-hidden=true href=#time-的对比>#</a></h4><p>time 内部包含 wall clock 和 montonic clock 字段, 返回序列化后的 time 对象, 不包含
montonic clock 直接对比, 会不相同</p><blockquote><p>The general rule is that the wall clock is for telling time and the monotonic clock is for measuring time.</p></blockquote><ul><li>可以使用 <code>time.Equal</code> 方法</li><li>或者使用 <code>Truncate</code> 移除 monotonic clock 数值</li></ul><h4 id=map>map<a hidden class=anchor aria-hidden=true href=#map>#</a></h4><p><code>map[string]any</code> 数值反序列化后类型都为 float64</p><h3 id=78-sql-错误>78 SQL 错误<a hidden class=anchor aria-hidden=true href=#78-sql-错误>#</a></h3><h4 id=sqlopen>sql.Open<a hidden class=anchor aria-hidden=true href=#sqlopen>#</a></h4><p><code>sql.Open()</code> 不一定是与数据库服务建立了连接, 具体还是需要看 驱动 实现, 可以通过
ping 方法, 强制建立连接</p><h4 id=sql-连接池的配置>sql 连接池的配置<a hidden class=anchor aria-hidden=true href=#sql-连接池的配置>#</a></h4><p>sql 连接状态分两种</p><ul><li>使用者</li><li>idle 等待使用, 已创建但没有再使用</li></ul><p>sql 连接池配置</p><ul><li>SetMaxOpenConns 最大连接数量, 考虑到下游服务的性能</li><li>SetMaxIdleConn 在并发高时适当增加, 避免创建耗时</li><li>SetConnMaxIdleTime 并发增加之后, 维持多久销毁连接</li><li>SetConnMaxLifetime 不希望一个连接持续过久</li></ul><h4 id=sqlprepared-语句>sql.prepared 语句<a hidden class=anchor aria-hidden=true href=#sqlprepared-语句>#</a></h4><ul><li>高效: 更加高效, 避免 SQL 重复编译</li><li>安全: 避免SQL注入</li></ul><h4 id=string-处理-null-值>string 处理 null 值<a hidden class=anchor aria-hidden=true href=#string-处理-null-值>#</a></h4><ul><li>使用指针声明 <code>*string</code></li><li>使用 <code>sql.NullString</code> 类型</li></ul><h4 id=rowserr-错误捕获>rows.Err 错误捕获<a hidden class=anchor aria-hidden=true href=#rowserr-错误捕获>#</a></h4><h3 id=79-资源关闭>79 资源关闭<a hidden class=anchor aria-hidden=true href=#79-资源关闭>#</a></h3><p>实现 <code>io.Closer</code> 的临时资源需要 及时 close</p><ul><li>http 请求的客户端, respBody 需要close</li><li>sql.Rows</li><li>os.File</li></ul><h3 id=80-http-handle-忘记-return>80 http handle 忘记 return<a hidden class=anchor aria-hidden=true href=#80-http-handle-忘记-return>#</a></h3><h3 id=81-使用-默认http-client-和-server>81 使用 默认http client 和 server<a hidden class=anchor aria-hidden=true href=#81-使用-默认http-client-和-server>#</a></h3><h4 id=client>client<a hidden class=anchor aria-hidden=true href=#client>#</a></h4><p>http 的请求步骤</p><ol><li>dial</li><li>tls 握手</li><li>send</li><li>read header</li><li>read body</li></ol><p><img loading=lazy src=./100mistake-http-step1to5.png alt=100mistake-http-step1to5></p><p>4个超时配置</p><ol><li><code>net.Dialer.Timeout</code> 建立连接超时</li><li><code>http.Transport.TLSHandshakeTimeout</code> TLS 握手超时</li><li><code>http.Transport.ResponseHeaderTimeout</code> 等待服务返回头此时</li><li><code>http.Client.Timeout</code> 这个请求的时间限制, from 上述步骤1到5</li></ol><p><code>net/http: request canceled (Client.Timeout exceeded while awaiting headers)</code> 报错
服务端返回超时, 在step4, 读取头时等待超时.</p><p>http 连接池</p><ul><li><code>http.Transport.IdleConnTimeout</code></li><li><code>http.Transport.MaxIdleConns</code></li><li><code>http.Transport.MaxIdleConnsPerHost</code> 默认为2, 严重影响并发</li></ul><h4 id=server>server<a hidden class=anchor aria-hidden=true href=#server>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>server := &amp;http.Server{}
</span></span><span class=line><span class=cl>server.Serve(listener)
</span></span></code></pre></td></tr></table></div></div><p>服务端步骤</p><ol><li>等待请求</li><li>TLS</li><li>read request headers</li><li>read request body</li><li>write response</li></ol><p>3个 timeout</p><ul><li><code>http.Sever.ReadHeadersTimeout</code></li><li><code>http.Server.ReadTimeout</code></li><li><code>http.TimeoutHandler</code></li><li><code>http.Server.IdleTimeout</code> keep-alive 请求可以保持多久</li></ul><p><code>TimeoutHanlder 包裹 handle 当处理超时时,返回503</code></p><p><img loading=lazy src=./100mistake-server-timeout1-5.png alt=100mistake-server-timeout1-5></p><p>如果都没有配置超时的话, 服务器就没有超时机制, 会一直等待客户端主动关闭连接.
当服务暴露给不信任客户端时, 至少需要配置 ReadTimeout 和 TimeoutHandler 避免资源被耗尽.</p><h3 id=82-对单元测试进行分类>82 对单元测试进行分类<a hidden class=anchor aria-hidden=true href=#82-对单元测试进行分类>#</a></h3><p>避免执行不需要单元测试, 提升测试效率.</p><ol><li>使用 tag <code>go test --tags=integration -v .</code></li><li>根据环境变量, 使用<code>testing.Skip()</code> 显示调用为什么跳过测试</li><li>使用 <code>testing.Short()</code> 判断当前执行模式, 跳过需要长时间耗时的测试 <code>go test -short -v .</code></li></ol><h3 id=83-测试启用---race>83 测试启用 &ndash;race<a hidden class=anchor aria-hidden=true href=#83-测试启用---race>#</a></h3><p>编译时带 <code>--race</code> 会增加程序消耗</p><ul><li>内存提高5-10倍</li><li>运行时间2-20倍</li></ul><p>避免在生产环境使用, 在CI的时候使用</p><h3 id=84-test-的执行模式>84 test 的执行模式<a hidden class=anchor aria-hidden=true href=#84-test-的执行模式>#</a></h3><p>parallel</p><p><code>testing.T.Parallel()</code> 会先暂停, 等待顺序测试任务完成后, 继续执行.</p><p><code>go test - parallel 16 .</code> 并发执行测试</p><p>shuffle</p><p><code>go test -shuffle=on -v .</code> 打乱 go test 函数的执行顺序</p><h3 id=85-table-driven-表驱动测试>85 Table-driven 表驱动测试<a hidden class=anchor aria-hidden=true href=#85-table-driven-表驱动测试>#</a></h3><p><code>t.Run(name, func(t *testing.T) {})</code></p><p>执行子测试
<code>go test -run=TestFoo/subtest_1 -v</code></p><h3 id=86-避免测试中的-sleep>86 避免测试中的 sleep<a hidden class=anchor aria-hidden=true href=#86-避免测试中的-sleep>#</a></h3><p>在并发场景下, 我们使用 <code>time.Sleep</code> 模拟, 任务处理耗时, 但是我们不知道时间是否足够</p><ol><li>使用多次尝试校验, retry</li><li>mock 对象使用消息通知校验</li></ol><h3 id=87-处理依赖时间测试>87 处理依赖时间测试<a hidden class=anchor aria-hidden=true href=#87-处理依赖时间测试>#</a></h3><ul><li>改变依赖, 造假数据</li><li>修改方法, 让接口传入时间</li></ul><h3 id=88-单测工具包>88 单测工具包<a hidden class=anchor aria-hidden=true href=#88-单测工具包>#</a></h3><p>http 相关</p><ul><li>httptest.NewServer</li><li>httptest.NewRequest</li></ul><p>iotest</p><h3 id=89-正确使用-benchmark-测试>89 正确使用 benchmark 测试<a hidden class=anchor aria-hidden=true href=#89-正确使用-benchmark-测试>#</a></h3><ul><li>忽略耗时函数</li><li>忽略对硬件底层</li></ul><h3 id=90-单元测试的拓展功能>90 单元测试的拓展功能<a hidden class=anchor aria-hidden=true href=#90-单元测试的拓展功能>#</a></h3><ul><li>TestMain</li><li>从不同的包测试 ( 重视包对外的开放功能)</li><li>cover 单测覆盖率</li></ul><h3 id=91-cpu-cache>91 CPU cache<a hidden class=anchor aria-hidden=true href=#91-cpu-cache>#</a></h3><p>cpu 三级缓存</p><p><img loading=lazy src=./100mistakecpucache.png alt=100mistakecpucache></p><ul><li>cpu cache Line 加载的 locality of reference, 局部性和相关性</li><li>cache line 一般 64 bytes,</li></ul><p>CPU 内存加载预测</p><ul><li>Unit stride</li><li>Constant stride</li><li>Non-Unit stride</li></ul><h3 id=92-通过-padding-避免并发操作相同内存复制到不同cpu-core-中>92 通过 padding 避免并发操作相同内存复制到不同cpu core 中<a hidden class=anchor aria-hidden=true href=#92-通过-padding-避免并发操作相同内存复制到不同cpu-core-中>#</a></h3><p>cpu 会有cache line 加载数据, 如果两个协程, 并发操作的不同的数据字段(在同一块cache line 大小内存中)
内存中. 这块内存会被同时加载到不同的cpu 核心的缓存中. 因为cpu MESI保证内存一致, 一边更新另一边会失效.</p><blockquote><p>When a cache line is shared across multiple cores and at least one goroutine is a writer, the entire cache line is invalidated.</p></blockquote><p>使用 pading , 将同时操作的内存分到不同cache line 中</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type result struct {
</span></span><span class=line><span class=cl>	sumA int64
</span></span><span class=line><span class=cl>	_ [56]byte // padding
</span></span><span class=line><span class=cl>	sumB int64
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h3 id=93-考虑指令集优化>93 考虑指令集优化<a hidden class=anchor aria-hidden=true href=#93-考虑指令集优化>#</a></h3><ul><li></li></ul><h3 id=94-内存对齐>94 内存对齐<a hidden class=anchor aria-hidden=true href=#94-内存对齐>#</a></h3><p>内存对齐可以减少结构体占用的内存大小.</p><p>结构体的内存对齐系数, 为各字段中最大的系数</p><p><a href=https://go.dev/ref/spec#Size%20and%20alignment%20guarantees>官方文档</a></p><h3 id=95-stack--heap>95 stack && heap<a hidden class=anchor aria-hidden=true href=#95-stack--heap>#</a></h3><p>栈内存是不需要GC, 只是会根据栈的大小范围表示为不可用, 再次使用的时候, 新值直接覆盖旧值.</p><p>当变量内存分配到栈上, 且函数退出, 变量引用表示不可用 &ndash; 无法再次访问, 所以需要 堆.</p><p>堆的使用成本更大, 需要GC, 内存分配成本也更大.</p><h3 id=96-优化内存分配>96 优化内存分配<a hidden class=anchor aria-hidden=true href=#96-优化内存分配>#</a></h3><ul><li>string.Builder 代替 +</li><li>避免 []byte 转 string</li><li>slice map 的初始化</li><li>结构体内存对齐</li><li>改变 interface 声明, 避免内存逃逸</li><li>sync.Pool</li><li>编译器优化, 避免 bytes-to-string 转化</li></ul><h3 id=97-编译器函数内联>97 编译器函数内联<a hidden class=anchor aria-hidden=true href=#97-编译器函数内联>#</a></h3><p>inline. 当调用的子函数较为简单时, 编译器会是将调用函数的内部实现嵌入当前调用点.</p><ul><li>避免函数的调用成本</li><li>可以使编译器进一步优化 (比如, 内存逃逸 直接分配到栈中)</li></ul><p>当子函数过为复杂时, 可以抽出子函数的复杂部分为另一个调用函数实现 mid inline. 让中间函数嵌入调用点.</p><h3 id=98-使用分析工具>98 使用分析工具<a hidden class=anchor aria-hidden=true href=#98-使用分析工具>#</a></h3><ul><li>pprof</li><li>trace</li></ul><h3 id=99-gc>99 GC<a hidden class=anchor aria-hidden=true href=#99-gc>#</a></h3><p>marks and sweep</p><ul><li>遍历所有对象, 标记是否在使用</li><li>遍历所以对象, 清除没有在使用的对象</li></ul><p>GOGC 配置 GC 的敏感度, 当 GOGC=100 时, 当堆内存容量涨100%时触发GC.</p><ul><li><a href=https://xargin.com/dynamic-gogc/>通过 GOGC 进行优化</a></li><li><a href=https://www.uber.com/en-TW/blog/how-we-saved-70k-cores-across-30-mission-critical-services/>uber 调优原文</a></li><li><a href=https://blog.ideawand.com/2020/08/01/go-gc-tuning-practice-1/>GOGC 调优</a></li></ul><h3 id=100-docker-和-k8s-资源分配对并发性能的影响>100 Docker 和 K8s 资源分配对并发性能的影响<a hidden class=anchor aria-hidden=true href=#100-docker-和-k8s-资源分配对并发性能的影响>#</a></h3><p>引用 <code>http://github.com/uber-go/automaxprocs</code> 自动设置 GOPROMAX</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ynikl.github.io/tags/golang/>Golang</a></li></ul><nav class=paginav><a class=prev href=https://ynikl.github.io/blog/golang-100mistake/><span class=title>« Prev Page</span><br><span>Golang 100 mistake 的简单读书笔记</span>
</a><a class=next href=https://ynikl.github.io/blog/mysql-partition/><span class=title>Next Page »</span><br><span>Mysql 分区</span></a></nav></footer><script src=https://utteranc.es/client.js repo=ynikl/ynikl.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>2022 Ian Lin All rights reserved</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>