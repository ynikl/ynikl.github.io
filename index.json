[{"content":"豆瓣因为涉及敏感词不让写, 干脆就写到这里来 (我也没写啥不好的呀 QAQ).\n真正的现实，都是充满着矛盾。对万事万物保持一颗敬畏的心.\n一方面是平民老百姓承受着流离失所的痛苦，一方面他们又可以从老破房子住到新的高楼“不破不立”，改善环境。 既要看到痛苦，也要看到改善。看外该电影， 更加让我懂得，看待事情要怀着敬畏之心，事情都是有双面性的。\n总得来说，还是觉得耿属于“好市长”，在中国经济飞速发展的过程中，为人民干实事，坚定自己的立场，倾听民声（市民赌在司令部门口申诉问题的场景给我印象极深）。\n","permalink":"https://ynikl.github.io/posts/the-chinese-mayor/","summary":"豆瓣因为涉及敏感词不让写, 干脆就写到这里来 (我也没写啥不好的呀 QAQ).\n真正的现实，都是充满着矛盾。对万事万物保持一颗敬畏的心.\n一方面是平民老百姓承受着流离失所的痛苦，一方面他们又可以从老破房子住到新的高楼“不破不立”，改善环境。 既要看到痛苦，也要看到改善。看外该电影， 更加让我懂得，看待事情要怀着敬畏之心，事情都是有双面性的。\n总得来说，还是觉得耿属于“好市长”，在中国经济飞速发展的过程中，为人民干实事，坚定自己的立场，倾听民声（市民赌在司令部门口申诉问题的场景给我印象极深）。","title":"The Chinese Mayor"},{"content":"概括 我为什么要读这本书? 我觉得生活挺无聊, 人生活着没有什么意义. 听说在这本书中会有人生的意义\n这本书怎样影响了我? 看清楚自己之所以活着, 就如史铁生所说, 就是还想得到什么. 并不是如我嘴上所说的: \u0026ldquo;人生活着没什么意义\u0026rdquo; 打算更加大胆地去追求自己想要\u0026quot;得到\u0026quot;的东西 看清楚做某一件事情的意义 \u0026ndash; 不只是看重结果, 也要去看重过程 书中的三句精华句子? 可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望 只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。 世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。 上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。 此岸永远是残缺的，否则彼岸就要坍塌。 三句话总结本书 尊重不完美, 不要抱怨, 不断地去追求完美 看清楚自己想要得到什么 人生不能只看重目的, 要去享受这个过程. 书摘 在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。\n树干上留着一只蝉蜕，寂寞如一间空屋；露水在草叶上滚动，聚集，压弯了草叶轰然坠地摔开万道金光。”“\n上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。\n剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。\n看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。\n就命运而言，休论公道。\n其实总共只有三个问题交替着来骚扰我，来陪伴我。第一个是要不要去死，第二个是为什么活，第三个，我干吗要写作。\n人为什么活着？因为人想活着，说到底是这么回事，人真正的名字叫做：欲望。\n可我为什么还想活呢？因为你还想得到点儿什么，你觉得你还是可以得到点儿什么的，比如说爱情，比如说价值感之类，人真正的名字叫欲望。\n结果你又发表了几篇，并且出了一点儿小名，可这时你越来越感到恐慌。我忽然觉得自己活得像个人质，刚刚有点儿像个人了却又过了头，\n人都忍不住要为生存找一些牢靠的理由。你不担心你会枯竭了？我不知道，不过我想，活着的问题在死前是完不了的。\n就算是三个月！我平白地相信这样一个期限。\n多年以后才听一位无名的哲人说过：危卧病榻，难有无神论者。\n但在命运的混沌之点，人自然会忽略着科学，向虚暝之中寄托一份虔敬的祈盼。\n机会不在外面在心里，结婚的机会有可能在外边，可爱情的机会只能在心里\n那位台湾作家三毛说得对：爱如禅，不能说不能说，一说就错。\n别人告诉我，她昏迷前的最后一句话是：“我那个有病的儿子和我那个还未成年的女儿……”\n砌墙盖房，不单为避风雨，因为大家都有些秘密，其次当然还有一些钱财。秘密，不信你去慢慢推想，它是趣味的爹娘。\n千万别把运动和能量，以及和时空分割开来理解。我随即得了启发：也千万别把人和意义分割开来理解。不是人有欲望，而是人即欲望。\n如今想来，分明就是为了一个“轻”字：珍宝转眼被处理成垃圾，一段生命轻得飘散了，没有了，以为是什么原来什么也不是，轻易、简单、灰飞烟灭。一段生命之轻，威胁了生命全面之重，惶茫往灵魂里渗透：是不是生命的所有段落都会落此下场啊？人的根本恐惧就在这个“轻”字上，比如歧视和漠视，比如嘲笑，比如穷人手里作废的股票，比如失恋和死亡。轻，最是可怕。\n艰苦的生活需要希望，鲜活的生命需要爱情，数不完的日子和数不完的心事，都要诉说。\n也许是因为人缺了什么就更喜欢什么吧，我的两条腿一动不能动，却是个体育迷。\n上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。\n我希望既有一个健美的躯体又有一个了悟人生意义的灵魂，我希望二者兼得。\n难道我们不该对灵魂有了残疾的人，比对肢体有了残疾的人，给予更多的同情和爱吗？\n既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？\n有知识不能只是有对物的知识，而是得有对人的了悟。\n我们也完全可以把你以后的生活设计得无比顺利，但这样下去我们是不是绕了一圈又回到那不祥的阴影中去了？你将再没有企盼了吗？再没有新的追求了吗？那么你的心路是不是又在荒芜，于是你的幸福感又要老化、萎缩、枯竭了呢？\n只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。\n一个只想（只想！）使过程精彩的人是无法被剥夺的，因为死神也无法将一个精彩的过程变成不精彩的过程，因为坏运也无法阻挡你去创造一个精彩的过程，相反你可以把死亡也变成一个精彩的过程，相反坏运更利于你去创造精彩的过程。\n过程！对，生命的意义就在于你能创造这过程的美好与精彩，生命的价值就在于你能够镇静而又激动地欣赏这过程的美丽与悲壮。\n有位大物理学家说过：“物理学不告诉我们世界是什么，而是告诉我们关于世界我们能够谈论什么。”\n历史难免是一部御制经典，文学要弥补它，所以看重的是那些沉默的心魂。\n佛嘛，心中无佛什么事都敢干。\n丑弱的人和圆满的神之间，是信者永远的路。\n此岸永远是残缺的，否则彼岸就要坍塌。\n历史，这两个字，可能包含着任何你想得到和想不到的危险，可能给你带来任何想得到和想不到的灾难。\n那个年代的人都懂得，话说到这儿最好止步；历史，这两个字，可能包含着任何你想得到和想不到的危险，可能给你带来任何想得到和想不到的灾难。\n家长们把“耐克”一类颠来倒去地看，说：“啥东西，值得这么贵？”他们不懂，春天是不能这样计算的。\n大人们其实忘了，春天莫不如此，各位年轻时也是一样。\n世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。\n我想，那就不必再去地坛寻找安静，莫如在安静中寻找地坛。\n","permalink":"https://ynikl.github.io/books/%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B/","summary":"概括 我为什么要读这本书? 我觉得生活挺无聊, 人生活着没有什么意义. 听说在这本书中会有人生的意义\n这本书怎样影响了我? 看清楚自己之所以活着, 就如史铁生所说, 就是还想得到什么. 并不是如我嘴上所说的: \u0026ldquo;人生活着没什么意义\u0026rdquo; 打算更加大胆地去追求自己想要\u0026quot;得到\u0026quot;的东西 看清楚做某一件事情的意义 \u0026ndash; 不只是看重结果, 也要去看重过程 书中的三句精华句子? 可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望 只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。 世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。 上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。 此岸永远是残缺的，否则彼岸就要坍塌。 三句话总结本书 尊重不完美, 不要抱怨, 不断地去追求完美 看清楚自己想要得到什么 人生不能只看重目的, 要去享受这个过程. 书摘 在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。\n树干上留着一只蝉蜕，寂寞如一间空屋；露水在草叶上滚动，聚集，压弯了草叶轰然坠地摔开万道金光。”“\n上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。\n剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。\n看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。\n就命运而言，休论公道。\n其实总共只有三个问题交替着来骚扰我，来陪伴我。第一个是要不要去死，第二个是为什么活，第三个，我干吗要写作。\n人为什么活着？因为人想活着，说到底是这么回事，人真正的名字叫做：欲望。\n可我为什么还想活呢？因为你还想得到点儿什么，你觉得你还是可以得到点儿什么的，比如说爱情，比如说价值感之类，人真正的名字叫欲望。\n结果你又发表了几篇，并且出了一点儿小名，可这时你越来越感到恐慌。我忽然觉得自己活得像个人质，刚刚有点儿像个人了却又过了头，\n人都忍不住要为生存找一些牢靠的理由。你不担心你会枯竭了？我不知道，不过我想，活着的问题在死前是完不了的。\n就算是三个月！我平白地相信这样一个期限。\n多年以后才听一位无名的哲人说过：危卧病榻，难有无神论者。\n但在命运的混沌之点，人自然会忽略着科学，向虚暝之中寄托一份虔敬的祈盼。\n机会不在外面在心里，结婚的机会有可能在外边，可爱情的机会只能在心里\n那位台湾作家三毛说得对：爱如禅，不能说不能说，一说就错。\n别人告诉我，她昏迷前的最后一句话是：“我那个有病的儿子和我那个还未成年的女儿……”\n砌墙盖房，不单为避风雨，因为大家都有些秘密，其次当然还有一些钱财。秘密，不信你去慢慢推想，它是趣味的爹娘。\n千万别把运动和能量，以及和时空分割开来理解。我随即得了启发：也千万别把人和意义分割开来理解。不是人有欲望，而是人即欲望。\n如今想来，分明就是为了一个“轻”字：珍宝转眼被处理成垃圾，一段生命轻得飘散了，没有了，以为是什么原来什么也不是，轻易、简单、灰飞烟灭。一段生命之轻，威胁了生命全面之重，惶茫往灵魂里渗透：是不是生命的所有段落都会落此下场啊？人的根本恐惧就在这个“轻”字上，比如歧视和漠视，比如嘲笑，比如穷人手里作废的股票，比如失恋和死亡。轻，最是可怕。\n艰苦的生活需要希望，鲜活的生命需要爱情，数不完的日子和数不完的心事，都要诉说。\n也许是因为人缺了什么就更喜欢什么吧，我的两条腿一动不能动，却是个体育迷。\n上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。\n我希望既有一个健美的躯体又有一个了悟人生意义的灵魂，我希望二者兼得。\n难道我们不该对灵魂有了残疾的人，比对肢体有了残疾的人，给予更多的同情和爱吗？\n既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？\n有知识不能只是有对物的知识，而是得有对人的了悟。\n我们也完全可以把你以后的生活设计得无比顺利，但这样下去我们是不是绕了一圈又回到那不祥的阴影中去了？你将再没有企盼了吗？再没有新的追求了吗？那么你的心路是不是又在荒芜，于是你的幸福感又要老化、萎缩、枯竭了呢？\n只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。\n一个只想（只想！）使过程精彩的人是无法被剥夺的，因为死神也无法将一个精彩的过程变成不精彩的过程，因为坏运也无法阻挡你去创造一个精彩的过程，相反你可以把死亡也变成一个精彩的过程，相反坏运更利于你去创造精彩的过程。\n过程！对，生命的意义就在于你能创造这过程的美好与精彩，生命的价值就在于你能够镇静而又激动地欣赏这过程的美丽与悲壮。\n有位大物理学家说过：“物理学不告诉我们世界是什么，而是告诉我们关于世界我们能够谈论什么。”\n历史难免是一部御制经典，文学要弥补它，所以看重的是那些沉默的心魂。\n佛嘛，心中无佛什么事都敢干。\n丑弱的人和圆满的神之间，是信者永远的路。","title":"我与地坛"},{"content":"最近接手公司一个视频相关项目, 也是使用ffmpeg工具. 需要快速了解下.\n概念 码率, 帧率, 文件大小 帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.\ninterlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i progressive: 现代整页整页呈现, 描述单位p: 60p 码率(bit rate) :视频一秒中有多少位, 决定视频的质量\nABR: 平均码率 CBR: 常量码率 VBR: 动态码率 文件大小 = 视频文件 + 音频文件\n视频文件 = 码率 * 时间(s) / 8 音频文件 = 码率 * 时间(s) / 8\n文件格式 不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers) 可以存储声音或者视频数据.\n相关缩写 encoding (E) decoding (D) video (V) audio (A) subtitles (S) 文件元数据 metadata 描述媒体文件自身的信息, 比如:\n1 2 3 4 5 6 7 8 9 10 Metadata: publisher : Ninja Tune track : 1 album : Ninja Tuna artist : Mr. Scruff album_artist : Mr. Scruff title : Kalimba genre : Electronic composer : A. Carthy and A. Kingslow date : 2008 声音 数字音频是通过对声音的模拟信息, 抽样且用数据信号表示.\n音频使用 bit depths 来表示声音的解析度:\n8bit, 12bit, 14bit \u0026hellip;\n声音的样本频率用 Hz 表示\n8000Hz, 11025Hz, 16000Hz \u0026hellip;\nFFmpeg 其他套件 ffplay 播放器 ffprobe 查看媒体文件的信息 ffserver 流服务器 使用 通用参数 -i 输入源, 可以是文件也可以是 url\n-vf option for video filters -af option for audio filters.\n-filter_complex 当多个输入源的时候使用\n-y 输出文件会强制覆盖已经存在的文件\n帮助 1 2 3 4 5 \u0026#34; 查看支持格式 ffmpeg -formats \u0026#34; 编解码器 ffmpeg -codecs 调整帧率 1 ffmpeg -i input.avi -r 30 output.mp4 调整码率 1 ffmpeg -i input.avi -b:v 1500k output.mp4 缩放视频大小 s : w x h 参数 宽乘以高 1 2 3 4 5 \u0026#34; 缩小分辨率 ffmpeg -i input.avi -s 640x480 output.avi \u0026#34; 扩大分辨率 ffmpeg -i input.mpg -vf scale=iw/PHI:ih/PHI output.mp4 旋转, 翻转 旋转\n1 ffmpeg -i CMYK.avi -vf transpose=2 CMYK_transposed.avi 竖直翻转\n1 ffmpeg -i meta.mp4 -vf vflip output_flip.mp4 裁切 裁切视频的画中画, 裁切视频的中心 1/2 的视频\n1 ffmpeg -i input.avi -vf crop=iw/2:ih/2 output.avi 模糊化 模糊化\n1 ffmpeg -i input.mpg -vf boxblur=1.5:1 output.mp4 锐化\n1 ffmpeg -i input -vf unsharp output.mp4 叠加 1 ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output 裁剪 获取一个时间段内的音频 -t 参数为秒\n1 ffmpeg -i input.mp4 -t 180 output_3_min.mp4 --ss 设置开始时间点 ( seek from start, 从视频开始过多少秒开始操作)\n1 2 \u0026#34; 直接截断开头3分钟 ffmpeg -i input.mp4 -ss 180 output_without_start_3.mp4 截取某一段时间视频\n1 2 \u0026#34; 截取第4分钟, 一分钟视频 ffmpeg -i input.mp4 -ss 180 -t 60 clip_4th_min.mp4 图片操作 从视频中截取某一帧\n1 ffmpeg -i videoclip.avi -ss 01:23:45 image.jpg 翻转图片\n1 2 3 4 5 ffmpeg -i orange.jpg -vf hflip orange_hflip.jpg ffmpeg -i orange.jpg -vf vflip orange_vflip.jpg \u0026#34; transpose [0, 1, 2, 3] ffmpeg -i image.png -vf transpose=1 image_rotated.png 转换图片格式\n1 ffmpeg -i illustration.png illustration.jpg 格式转化 格式转化流程:\nDemuxer (分解复用) : 将合成信号恢复成原本独立的信号数据 Decoder (解码器) : 解码 Encoder (编码器) : 编码 Muxer ( _ ): 将多个信号数据合并\n1 2 3 4 ffmpeg -y -i input.avi output.mp4 \u0026#34; 改变格式, 但不更改编解码方式 ffmpeg -i input.avi -q 1 -c copy output.mov 混音 将两个声合成一个文件\n1 ffmpeg -i demo.mp3 -i louder_sound.aac -filter_complex amix=inputs=2 sounds.wav 加强耳机的立体声效果\n1 ffmpeg -i music.mp3 -af earwax -q 1 music_headphones.mp3 参考 FFmpeg Basics 2012 by Frantisek Korbel ","permalink":"https://ynikl.github.io/blog/ffmpeg-basics/","summary":"最近接手公司一个视频相关项目, 也是使用ffmpeg工具. 需要快速了解下.\n概念 码率, 帧率, 文件大小 帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.\ninterlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i progressive: 现代整页整页呈现, 描述单位p: 60p 码率(bit rate) :视频一秒中有多少位, 决定视频的质量\nABR: 平均码率 CBR: 常量码率 VBR: 动态码率 文件大小 = 视频文件 + 音频文件\n视频文件 = 码率 * 时间(s) / 8 音频文件 = 码率 * 时间(s) / 8\n文件格式 不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers) 可以存储声音或者视频数据.\n相关缩写 encoding (E) decoding (D) video (V) audio (A) subtitles (S) 文件元数据 metadata 描述媒体文件自身的信息, 比如:","title":"FFmpeg 基本使用"},{"content":"操作 演进 加锁后进程挂掉了 加锁成功之后, 进程挂掉了没有进行解锁操作. 导致进入死锁状态.\n引入 expire 设置超时时长, 自动释放 key\n1 2 3 4 5 6 7 8 \u0026gt; setnx lock:key true \u0026gt; OK \u0026gt; expire lock:key 5 \u0026#34; ... do something critical ... \u0026gt; del lock:codehole 加锁动作 到 expire 之间挂掉了 redis 2.8 之后支持 set 拓展指令\n1 \u0026gt; set lock:key true ex 5 nx 加锁互斥锁, 并同时设置超时时长\n执行超时, 被其他进程获取到了锁 加锁之后, 本身进程执行时间超过了预先设置的 expire 的时间. 就会导致锁被提前释放.\n解决方案:\n尽量不要用与锁住时间教长的任务, 尝试缩小锁定的\u0026quot;关键区域\u0026quot; 续锁 (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间 执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁 Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。 \u0026ndash; Redis深度历险\n解决方案: 给加锁的 key 设置随机数的value, 删除之前先匹配是否一致再删除\n匹配和删除动作之间的原子性可以用 Lua 脚本保证\n1 2 3 4 5 6 # delifequals if redis.call(\u0026#34;get\u0026#34;,KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;del\u0026#34;,KEYS[1]) else return 0 end 可重入锁 利用线程的本地变量(Threadloacl), 维护锁的持有计数, 实现支持多次加锁, 多次解锁\n参考 Redis 深度历险 阿里二面：Redis分布式锁过期了但业务还没有执行完，怎么办 ","permalink":"https://ynikl.github.io/blog/redis-do-distributed-lock/","summary":"操作 演进 加锁后进程挂掉了 加锁成功之后, 进程挂掉了没有进行解锁操作. 导致进入死锁状态.\n引入 expire 设置超时时长, 自动释放 key\n1 2 3 4 5 6 7 8 \u0026gt; setnx lock:key true \u0026gt; OK \u0026gt; expire lock:key 5 \u0026#34; ... do something critical ... \u0026gt; del lock:codehole 加锁动作 到 expire 之间挂掉了 redis 2.8 之后支持 set 拓展指令\n1 \u0026gt; set lock:key true ex 5 nx 加锁互斥锁, 并同时设置超时时长\n执行超时, 被其他进程获取到了锁 加锁之后, 本身进程执行时间超过了预先设置的 expire 的时间. 就会导致锁被提前释放.\n解决方案:\n尽量不要用与锁住时间教长的任务, 尝试缩小锁定的\u0026quot;关键区域\u0026quot; 续锁 (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间 执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁 Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。 \u0026ndash; Redis深度历险","title":"Redis 用于做分布式锁"},{"content":"CI 自动化发布流程 可重复 可快速回滚 发布流程快速 在合并的时候可以对代码进行快速验证 CD 部署流程平台化 一键部署 总结 所谓的 CI/CD 就是通过自动化操作, 比如自动化测试, 自动化部署. 使用项目拥有快速上线的能力 \u0026ndash; 可以快速验证, 快速回滚, 快速发布.\n","permalink":"https://ynikl.github.io/posts/ci-cd/","summary":"CI 自动化发布流程 可重复 可快速回滚 发布流程快速 在合并的时候可以对代码进行快速验证 CD 部署流程平台化 一键部署 总结 所谓的 CI/CD 就是通过自动化操作, 比如自动化测试, 自动化部署. 使用项目拥有快速上线的能力 \u0026ndash; 可以快速验证, 快速回滚, 快速发布.","title":"CI/CD"},{"content":"我觉得人生活着没有意义，但是我又为什么还活着呢？今天， 刚好看到了史铁生的《我与地坛》里面给了我答案\n可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望\n","permalink":"https://ynikl.github.io/posts/the-meaning-of-living/","summary":"我觉得人生活着没有意义，但是我又为什么还活着呢？今天， 刚好看到了史铁生的《我与地坛》里面给了我答案\n可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望","title":"活着的意义"},{"content":"概括 我为什么要读这本书? Youtuber 推荐, 好奇金融相关的知识\n这本书怎样影响了我? 不要轻易地去触碰股市, 直到我真正的理解它.\n书中的三句精华句子? 一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力 他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误 活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。 三句话总结本书 投资的时候要看重的公司的内在价值而不是市场先生的报价 减少交易次数 努力地去看透事情的本质 书摘 笔记摘自\n巴菲特致股东的信：投资者和公司高管教程（原书第4版）\n【美】沃伦E.巴菲特\n关于巴菲特一生的成功秘诀，已经有无数人做出了评价，我个人认为可以归结为八个字：与时俱进，良性循环\n“与坏人打交道，做成一笔好生意，这样的事情，我从来没有遇见过。”巴菲特的这句名言令人深思\n从别人的故事里，找到自己的人生启发，这就是读书的意义所在\n广受尊重的投资家兼作家菲尔·费雪（即菲利普·费雪，Phil Fisher）曾经将公司吸引股东的策略比喻为餐馆吸引顾客的策略。 一家餐馆可以定位于特定的食客阶层——喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困惑，最终离开。\n应该可以直接与公司CEO进行沟通，得到他现在和未来如何对企业进行估值的看法\n如果我们对一只股票有良好的长期预期，那么短期的价格波动对我们来说毫无意义，除非有人报给我们一个非常有吸引力的价格。\n芒格和我无法向你承诺结果。但我们可以保证，只要你是我们的合伙人，在任何时段，你的金融资产和我们自己的资产将完全保持一致的成长\n为了达成目标，我们的首选是直接持有一系列多元化的企业，从中获得稳定的现金流和持续的高于市场平均水平的资本回报\n从整体和长期来看，我们希望那些未体现的盈利，通过资本增值的形式体现在我们的内在价值里\n巴菲特以及伯克希尔避免进行预测，因为这是一种糟糕的管理习惯，经常会导致管理人粉饰报表\n但是任何短期的压力都不应以牺牲长期竞争力为代价\n一场大会的毫无建树是由于参与股东们更在意自己在台上的表现，而不是关心公司运营的状况\n在伯克希尔公司，我们通常会换位思考，设想如果我们自己处于股东的位置，应该得到什么样的信息，我们会从这样的角度向股东披露完整的报告\n这种打假活动针对的目标是公司信息披露行为中的“选择性披露”，近些年来，这种选择性披露行为像癌症一样蔓延。的确，信息的选择性披露已经成为大型公司的一种标准化的行为\nCEO们预测公司增长速度，是骗人的和危险的。当然，他们是被分析师和公司自己的投资者关系部门怂恿裹挟着这么做。但他们应该拒绝，因为这样预测多了会招致麻烦。\n厨房里如果有蟑螂，绝不可能只有一只\n在一个由一群和事佬组成的董事会里，不太可能会有人提出更换CEO的提议。同样，也不可能对CEO提议的公司并购活动提出质疑\n毕竟，没有人会喜欢去洗外面租来的车\n除了要维持独立性，董事们也必须具备丰富的商业经验，以股东利益为导向，以及在公司拥有真正的利益\n在收购之前，他们就已是商界的管理明星，已经证明了自己在各自领域中的才华，我们的主要贡献就是让他们自由发挥天分，不给他们添乱\n“如果我们雇用的都是比我们矮的人，我们将成为一家侏儒公司；但如果我们雇用的都是比我们高的人，我们会成为一家巨人公司。”\n我们希望我们的经理人队伍考虑什么是重要的，而不是考虑什么被认为是重要的。\n当投资的时候，我们将自己视为企业分析师——而不是市场分析师，不是宏观经济分析师，甚至不是证券分析师。\n他说你应该将市场报价想象为一个名叫“市场先生”的人\n如果你不懂得你的公司，不能比市场先生更准确地评估你的公司，你就不要参与这场游戏\n就像人们打牌时说的：“如果玩了30分钟，你还不知道谁是倒霉蛋，有可能就是你。\n一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力\n有些人会在不同市场间倒手，意图赚取差价。你不必感到惊讶，从业者为此选了一个法语词汇：套利。\n如果需要同时做很多事情，就像同时将很多烙铁放在火中，人们就必须花大量的时间，既要监控交易的过程，又要监控市场股价的波动。这不是芒格和我所想的生活模式。（如果只是为了赚钱而整天盯着股票行情，这种生活有什么意义可言？\n在完全忽视股价的情况下，一家拥有子公司的母公司，如果子公司长期表现优异，母公司是不可能出售子公司的。“为什么要卖出？”CEO会问，“难道要我卖出皇冠上的宝石吗\n应该评估是否在其预期的持股期间，其投资的税后收益总和（包括他卖出所得）会带给他至少在投资开始之初同等的购买力，加上合理的利率因素\n一个视力平平的人，没有必要在干草堆里寻找绣花针。\n我们的座右铭是：“如果你一开始就取得了成功，那么，不必再做测试。\n很多大名鼎鼎的基金管理人现在关注的是其他基金管理人未来几天干什么，而不是关注企业未来几年干什么。对于他们而言，股票仅仅是游戏中的筹码，就像大富翁游戏中，如同顶针和熨斗一样的道具\n我们的目标是发现那些价格合理的杰出公司，而不是价格便宜的平庸公司\n最值得拥有的公司是，那些在一个一直延伸的时期周期里，可以不断利用增量资本获得很高回报率的公司\n他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误\n二级市场经常周期性地被大量傻瓜所主导，会持续设定一个“清算”价格。无论这个价格多么愚蠢，它是股票或债券持有者需要或希望卖出的价格，总是有这样的机会出现\n无论什么样的天才或努力，有些事情总是需要时间。即便你能让九个女人同时怀孕，也不可能让她们在一个月的时间里生出小宝宝。）\n但我更喜欢一个确定的良好结果，而不是一个期望的伟大结果。\n在企业内部，有一种看不见的力量足以压倒一切，我们可以称其为“惯性驱使”或“机构强迫症”\n如果我们在资产负债表上使用适当的负债，可以在安全的前提下增加一些盈利\n信用就像氧气。此二者，在充足的时候，人们不会注意到它们的存在；当它们消失的时候，人们才会发现它们的重要性\n当年花1美元可以买到的东西，今天要花7美元以上。因此，即便一个不用交税的机构，也必须在同期从债券上获得4.3%的年化利息收入，才能维持其购买力不变。如果这些机构的管理人将任何的利息部分视为“收入”的话，他们一定是在和自己开玩笑\n即使在最混乱的经济环境中，美国国债也是唯一靠得住的流动性良好的投资对象\n大多数人宁愿去死，也不愿意思考。很多人就是这样\n巨大的负债可以让管理层前所未有地专注工作，就像在汽车方向盘上装一把匕首，可以提高司机的注意力一样\n衍生品还可能造成连锁反应式的风险，因为很多保险公司或再保险公司将它们的风险分散给其他保险公司\n“世俗的智慧告诉我们，循规蹈矩的失败，可能比标新立异的成功，更有利于保全名声\n这场愚蠢游戏的核心是，人们通常都认为房屋的价格肯定会随着时间而上升，任何的下降都是可以忽略不计的。这个前提几乎贯穿于任何房屋的交易行为和交易价格中\n借贷者将钱借给那些以他们的收入根本还不起钱的人，借款者很愉快地签署这些合同。借贷双方都寄希望于“房价的上升”，以弥补这项“不可能完成的任务”所带来的缺口。\n.\u0026gt; 但是，居住和使用应作为买房时的首要动机，而不应该将购房视作升值盈利或再融资的手段。同时，购房时应该考虑与收入相匹配，量力而行。\n投资者的整体回报，随着交易频率的上升而减少。\n道琼斯在20世纪的100年中，从65.73点上升到11497.12点，相当于年化复合回报率5.3%（当然，投资者在此期间还能收到分红。）在接下来21世纪的100年中，为了达到同样的回报率，道琼斯指数必须——你需要深呼一口气——达到2011011.23点。也就是说，到21世纪末，道琼斯将以200万点收盘，但看看本世纪初的前六年，道琼斯指数几乎原地没动。\n活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。这实际上是对股东们征收的重税，虽然只是一个人决定“换个位子”，虽然支付的对象是金融机构，而不是华盛顿\n并不是所有的收益都是在同等的情况下创造的。在很多公司，尤其是那些具有高资产/利润比特征的公司里，通货膨胀会侵蚀财报中显示的部分甚至全部收益。这个会被通胀侵蚀的收益部分，我们称之为“受限定收益”，不能被用于派发红利，以利于公司保持其经济竞争地位。\n如果再投资能获得高回报，就应该保留收益进行再投资；如果回报低下，就应该分红\n除非它们经历了极其巨大的惊人的单位成长，杰出的公司一定会产生大量的富余现金。如果公司将这些收益投在那些回报低下的业务，公司的整体留存资本的表现可能依然会很卓越，因为，核心业务部分的回报非凡。这就像高尔夫比赛中，职业选手和业余选手的混合赛，即便队伍中的业余选手都是没有希望的笨蛋，但整个球队的表现还是不错，因为得分主要来源于其中的职业选手\n如果一家公司的股票价格远低于其内在价值，通常在这个时候，回购最有意义\n首先，一家公司有充足的现金以备运营和流动性之需；其次，股价远低于保守计算的内在价值\n以及那些冲着分拆预期而来的买家，毫无疑问将会稀释现有股东群体的质量\n过度活跃的股市是企业的扒手。\n我们采取的方式就像一个人寻找合适的另一半一样：保持积极、兴趣、开放的心态，但不能着急\n桑塔亚娜（Santayana）曾说：“当你忘却了目标，狂热会让你付出很多倍的努力\n我们试图避免一些小动作——“如果一些事情不值得做，也就不值得做好。\n诺亚法则：重要的是建造方舟，而不是预测大雨\n我们喜欢与那些热爱自家公司的人做生意，而不仅仅是因为喜欢钱（虽然，我们也可以理解他为何喜欢）。当这种附加的情感存在时，它是一个信号，让人可以发现企业所具有的重要品质：不做假账，以产品为荣，尊重客户，以及一群忠诚的、有强烈方向感的人。与此相反的情况，也是真的。当\n","permalink":"https://ynikl.github.io/books/%E5%B7%B4%E8%8F%B2%E7%89%B9%E8%87%B4%E8%82%A1%E4%B8%9C%E7%9A%84%E4%BF%A1/","summary":"概括 我为什么要读这本书? Youtuber 推荐, 好奇金融相关的知识\n这本书怎样影响了我? 不要轻易地去触碰股市, 直到我真正的理解它.\n书中的三句精华句子? 一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力 他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误 活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。 三句话总结本书 投资的时候要看重的公司的内在价值而不是市场先生的报价 减少交易次数 努力地去看透事情的本质 书摘 笔记摘自\n巴菲特致股东的信：投资者和公司高管教程（原书第4版）\n【美】沃伦E.巴菲特\n关于巴菲特一生的成功秘诀，已经有无数人做出了评价，我个人认为可以归结为八个字：与时俱进，良性循环\n“与坏人打交道，做成一笔好生意，这样的事情，我从来没有遇见过。”巴菲特的这句名言令人深思\n从别人的故事里，找到自己的人生启发，这就是读书的意义所在\n广受尊重的投资家兼作家菲尔·费雪（即菲利普·费雪，Phil Fisher）曾经将公司吸引股东的策略比喻为餐馆吸引顾客的策略。 一家餐馆可以定位于特定的食客阶层——喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困惑，最终离开。\n应该可以直接与公司CEO进行沟通，得到他现在和未来如何对企业进行估值的看法\n如果我们对一只股票有良好的长期预期，那么短期的价格波动对我们来说毫无意义，除非有人报给我们一个非常有吸引力的价格。\n芒格和我无法向你承诺结果。但我们可以保证，只要你是我们的合伙人，在任何时段，你的金融资产和我们自己的资产将完全保持一致的成长\n为了达成目标，我们的首选是直接持有一系列多元化的企业，从中获得稳定的现金流和持续的高于市场平均水平的资本回报\n从整体和长期来看，我们希望那些未体现的盈利，通过资本增值的形式体现在我们的内在价值里\n巴菲特以及伯克希尔避免进行预测，因为这是一种糟糕的管理习惯，经常会导致管理人粉饰报表\n但是任何短期的压力都不应以牺牲长期竞争力为代价\n一场大会的毫无建树是由于参与股东们更在意自己在台上的表现，而不是关心公司运营的状况\n在伯克希尔公司，我们通常会换位思考，设想如果我们自己处于股东的位置，应该得到什么样的信息，我们会从这样的角度向股东披露完整的报告\n这种打假活动针对的目标是公司信息披露行为中的“选择性披露”，近些年来，这种选择性披露行为像癌症一样蔓延。的确，信息的选择性披露已经成为大型公司的一种标准化的行为\nCEO们预测公司增长速度，是骗人的和危险的。当然，他们是被分析师和公司自己的投资者关系部门怂恿裹挟着这么做。但他们应该拒绝，因为这样预测多了会招致麻烦。\n厨房里如果有蟑螂，绝不可能只有一只\n在一个由一群和事佬组成的董事会里，不太可能会有人提出更换CEO的提议。同样，也不可能对CEO提议的公司并购活动提出质疑\n毕竟，没有人会喜欢去洗外面租来的车\n除了要维持独立性，董事们也必须具备丰富的商业经验，以股东利益为导向，以及在公司拥有真正的利益\n在收购之前，他们就已是商界的管理明星，已经证明了自己在各自领域中的才华，我们的主要贡献就是让他们自由发挥天分，不给他们添乱\n“如果我们雇用的都是比我们矮的人，我们将成为一家侏儒公司；但如果我们雇用的都是比我们高的人，我们会成为一家巨人公司。”\n我们希望我们的经理人队伍考虑什么是重要的，而不是考虑什么被认为是重要的。\n当投资的时候，我们将自己视为企业分析师——而不是市场分析师，不是宏观经济分析师，甚至不是证券分析师。\n他说你应该将市场报价想象为一个名叫“市场先生”的人\n如果你不懂得你的公司，不能比市场先生更准确地评估你的公司，你就不要参与这场游戏\n就像人们打牌时说的：“如果玩了30分钟，你还不知道谁是倒霉蛋，有可能就是你。\n一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力\n有些人会在不同市场间倒手，意图赚取差价。你不必感到惊讶，从业者为此选了一个法语词汇：套利。\n如果需要同时做很多事情，就像同时将很多烙铁放在火中，人们就必须花大量的时间，既要监控交易的过程，又要监控市场股价的波动。这不是芒格和我所想的生活模式。（如果只是为了赚钱而整天盯着股票行情，这种生活有什么意义可言？\n在完全忽视股价的情况下，一家拥有子公司的母公司，如果子公司长期表现优异，母公司是不可能出售子公司的。“为什么要卖出？”CEO会问，“难道要我卖出皇冠上的宝石吗\n应该评估是否在其预期的持股期间，其投资的税后收益总和（包括他卖出所得）会带给他至少在投资开始之初同等的购买力，加上合理的利率因素\n一个视力平平的人，没有必要在干草堆里寻找绣花针。\n我们的座右铭是：“如果你一开始就取得了成功，那么，不必再做测试。\n很多大名鼎鼎的基金管理人现在关注的是其他基金管理人未来几天干什么，而不是关注企业未来几年干什么。对于他们而言，股票仅仅是游戏中的筹码，就像大富翁游戏中，如同顶针和熨斗一样的道具\n我们的目标是发现那些价格合理的杰出公司，而不是价格便宜的平庸公司\n最值得拥有的公司是，那些在一个一直延伸的时期周期里，可以不断利用增量资本获得很高回报率的公司\n他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误\n二级市场经常周期性地被大量傻瓜所主导，会持续设定一个“清算”价格。无论这个价格多么愚蠢，它是股票或债券持有者需要或希望卖出的价格，总是有这样的机会出现\n无论什么样的天才或努力，有些事情总是需要时间。即便你能让九个女人同时怀孕，也不可能让她们在一个月的时间里生出小宝宝。）\n但我更喜欢一个确定的良好结果，而不是一个期望的伟大结果。\n在企业内部，有一种看不见的力量足以压倒一切，我们可以称其为“惯性驱使”或“机构强迫症”\n如果我们在资产负债表上使用适当的负债，可以在安全的前提下增加一些盈利\n信用就像氧气。此二者，在充足的时候，人们不会注意到它们的存在；当它们消失的时候，人们才会发现它们的重要性\n当年花1美元可以买到的东西，今天要花7美元以上。因此，即便一个不用交税的机构，也必须在同期从债券上获得4.3%的年化利息收入，才能维持其购买力不变。如果这些机构的管理人将任何的利息部分视为“收入”的话，他们一定是在和自己开玩笑\n即使在最混乱的经济环境中，美国国债也是唯一靠得住的流动性良好的投资对象\n大多数人宁愿去死，也不愿意思考。很多人就是这样\n巨大的负债可以让管理层前所未有地专注工作，就像在汽车方向盘上装一把匕首，可以提高司机的注意力一样\n衍生品还可能造成连锁反应式的风险，因为很多保险公司或再保险公司将它们的风险分散给其他保险公司","title":"巴菲特致股东的信"},{"content":"简单分析下xorm 里面 session 和 slave 里面 close 的代码\n1 xorm.EngineGroup.Slave() Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用）） 如果这时候再调用 close 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。 如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 NewSsession 和 Close, 所以不在需要手动调用close 1 xorm.EngineGroup.NewSsession() 会返回一个xorm.Session对象, 对应我们数据库操作中的\u0026quot;会话事务\u0026quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交) 调用 close, 对清除 session 中未提交的事务和一些缓存的 sql 前置处理语句 对于普通 select 语句调不调用是没什么太大影响 (但是还是建议new之后调用close) ","permalink":"https://ynikl.github.io/posts/xorm-slave-newsseion/","summary":"简单分析下xorm 里面 session 和 slave 里面 close 的代码\n1 xorm.EngineGroup.Slave() Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用）） 如果这时候再调用 close 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。 如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 NewSsession 和 Close, 所以不在需要手动调用close 1 xorm.EngineGroup.NewSsession() 会返回一个xorm.Session对象, 对应我们数据库操作中的\u0026quot;会话事务\u0026quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交) 调用 close, 对清除 session 中未提交的事务和一些缓存的 sql 前置处理语句 对于普通 select 语句调不调用是没什么太大影响 (但是还是建议new之后调用close) ","title":"xorm 的 session 和 salve 的区别"},{"content":"想自己整理一篇基本的 make 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.\n阮一峰文章地址\n如果不写 c, 主要理解就几个概念就可以使用了\ntarget 可以用来当作想要执行的命令集的名称 .PHONY: 可以用来声明命令集名称 recipes 实际执行的命令集合 介绍一下我自己的应用场景 我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.\ncase 1: 简化本地编译和测试, 自动做 setup 和 teardown\n当我想要尝试一下整个项目是否编译\n1 2 3 4 .PHONY: build build: go build . rm -rf [PROJECT NAME] 使用上面的 makefile, 我就只需要 make build, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 build 一下\ncase 2: git 提交代码自动化操作\n当我想要把我代码推送到, 测试分支, 进行集成测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .PHONY: dev ProjectName=\u0026#34;Your Project Name\u0026#34; TargetBranch=\u0026#34;Your want to merge branch\u0026#34; CurBranch=$(shell git branch --show-current) dev: go build . rm -f $(ProjectName) git add . git commit -m $(msg) git push git checkout ${DevBranch} git pull --rebase git merge ${CurBranch} -m \u0026#34;Merge branch \u0026#39;${CurBranch}\u0026#39; into ${DevBranch}\u0026#34; go build rm -f $(ProjectName) git push git checkout ${CurBranch} 简化 git 的操作流程, 现在只需要make dev就可以完成, 还可以在合并之前和之后增加测试, 我自己目前知识简单的 build 下而已 QAQ.\n","permalink":"https://ynikl.github.io/posts/makefile-basic-use/","summary":"想自己整理一篇基本的 make 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.\n阮一峰文章地址\n如果不写 c, 主要理解就几个概念就可以使用了\ntarget 可以用来当作想要执行的命令集的名称 .PHONY: 可以用来声明命令集名称 recipes 实际执行的命令集合 介绍一下我自己的应用场景 我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.\ncase 1: 简化本地编译和测试, 自动做 setup 和 teardown\n当我想要尝试一下整个项目是否编译\n1 2 3 4 .PHONY: build build: go build . rm -rf [PROJECT NAME] 使用上面的 makefile, 我就只需要 make build, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 build 一下\ncase 2: git 提交代码自动化操作\n当我想要把我代码推送到, 测试分支, 进行集成测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .","title":"Make 的基本使用"},{"content":"公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.\n介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件\n消息中间件的作用\n解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释\nProducer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型\nfanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:\n生产者连接到 Broker, 开启信道 生产者声明一个交换器 生产者声明一个队列 生产者通过路由键将交换器和队列绑定 生产者发送消息到 Broker 交换器根据接受对路由键匹配队列 投递到对应的消息队列 如果没有匹配的队列, 丢弃或者退回给生产者 消费者接受消息流程:\n建立连接, 开启信道 消费者向 Broker 发起消息请求 Broker 回应并返回消息 消费者发送确认 (ack) 接受到消息 关闭信道 关闭连接 AMQP 位于应用层的通信协议 ( 在 TCP 之上, 将数据填充到 TCP 中)\n几个基础的协议定义的操作\nProtocal Header 0-9-1 指定协议 Connection.Start Channel.Open Basic.Publish 推送消息 Channel.Close Connection.Close 部署 在你的机子上部署一个玩具吧\n采用 docker 部署 docker run -itd --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management\n进入管理页面 访问 http://127.0.0.1:15672/\n登入 用户名: guest 密码: guest\n更多默认配置\n管理 进入交互 shell docker exec -it rabbitmq bash\n增加一个用户 rabbitmqctl add_user ian ian1234\n增加一个 vhost rabbitmqctl add_vhost playground\nvhost是什么? vhost (virtual host), 虚拟主机, 在实例间提供逻辑上的分离 \u0026ndash; 实现数据隔离. RabbitMQ 默认创建一个名为 \u0026ldquo;/\u0026rdquo; 的 vhost\n查看 vhost rabbitmqctl list_vhosts\n设置权限 rabbitmqctl set_permissions --vhost playground ian \u0026quot;.*\u0026quot; \u0026quot;.*\u0026quot; \u0026quot;.*\u0026quot;\namqp uri规则 \u0026quot;amqp://userName:password@ipAddress:portNumber/virtualHost\u0026quot; 根据我们上述的新增在用户和vhost, 可以得到uri: amqp://ian:ian1234@localhost:5672/playground 5672为 rabbitmq的默认终端, 我们的 docker contain 需要把它映射到本机带端口\n实现生产者 go 使用 github.com/rabbitmq/amqp091-go 包\n根据上文的消息投递流程实现\n连接到 broker\n1 2 connectionUrl := \u0026#34;amqp://ian:ian1234@localhost:5672/playground\u0026#34; conn, err := amqp.Dial(connectionUrl) 打开 channel\n1 ch, err := conn.Channel() 声明一个交互器( 该步骤可以省略, 直接使用默认的 direct交换器)\n1 err = ch.ExchangeDeclare(\u0026#34;hello-exchange\u0026#34;, \u0026#34;direct\u0026#34;, true, false, false, false, nil) 声明一个队列\n1 q, err := ch.QueueDeclare(\u0026#34;hello\u0026#34;, true, false, false, false, nil) 将 Exchange 绑定到队列上 (如果声明交换器的步骤省略了, 该步骤也可以省略)\n1 err = ch.QueueBind(q.Name, \u0026#34;hellokey\u0026#34;, \u0026#34;hello-exchange\u0026#34;, false, nil) 发送消息 (如果没有声明交换器, 对应的参数直接传入空字符串\u0026quot;\u0026quot;, 会使用默认的 direct 交换器)\n1 2 3 4 err = ch.Publish(\u0026#34;hello-exchange\u0026#34;, \u0026#34;hellokey\u0026#34;, false, false, amqp.Publishing{ ContentType: \u0026#34;text/plain\u0026#34;, Body: []byte(body), }) 完整代码地址\n登录到本地管理页面可以查看类似于下图, 有消息投递\n实现消费者 消费者相对于生产者就简单多了. 打开信道直接消费就可以了.\n连接, 打开信道\n1 2 3 4 5 6 7 8 connectionUrl := \u0026#34;amqp://ian:ian1234@localhost:5672/playground\u0026#34; conn, err := amqp.Dial(connectionUrl) if err != nil { log.Fatal(err) } defer conn.Close() ch, err := conn.Channel() 开始消费\n1 2 3 4 5 6 7 // msgsCh 是一个消息管道 msgsCh, err := ch.Consume(\u0026#34;hello\u0026#34;, \u0026#34;consumer-name\u0026#34;, true, false, false, false, nil) for msg := range msgsCh { log.Println(\u0026#34;received a message: \u0026#34;, string(msg.Body)) } log.Println(\u0026#34;done, msg channel is closed\u0026#34;) 参考 官网 tutorial RabbitMQ 实战指南 ","permalink":"https://ynikl.github.io/blog/rabbitmq-learning-note/","summary":"公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.\n介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件\n消息中间件的作用\n解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释\nProducer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型\nfanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:","title":"RabbitMQ 基本入门实践"},{"content":" The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.\nlife if not short\n","permalink":"https://ynikl.github.io/posts/life-is-not-short/","summary":"The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.\nlife if not short","title":"Life Is Not Short"},{"content":"微服务是针对公司某一复杂业务程序实现的设计模式, 与巨石架构(Monolith)是相对的.\n微服务对应的应该是公司业务能力层级上的拆分与设计, 为了减少业务之间的耦合而导致相互拖累, 在对外业务能力不变的情况下, 在应用内部将能力拆分成一些微小服务. 也可以理解为是对巨石架构进行\u0026quot;解耦\u0026quot;.\n举个例子: 原先公司做的是一个外卖系统, 这个系统中可能包含了客户下单, 商家接单, 骑手配送等功能. 但是全部都打包在一个程序中. 发版时, 可能客户下单功能修改了功能, 导致商家没办法接单了. 或者商家接单功能实现的有问题, 导致整个应用程序挂掉, 现在用户下不了单, 骑手也没法接单, 整个公司的业务就瘫痪了. 然后, 在客户下单-商家接单-骑手配送这个大业务流程不变的情况下, 我们在外卖系统内部, 分成了多个服务, 各个服务之间使用 API 松耦合通信, 隔离影响. 比如, 客户下单服务, 专门处理客户下单这一业务, 并将生成的订单推送到消息代理 (如:kafka) 或直接推送给其他服务等, 它只要能保证完成它的职责即可. 后者, 就可以称之为 \u0026ldquo;微服务架构\u0026rdquo;. 当然, 这只是一个例子, 实际情况会更加复杂.\n在\u0026laquo;微服务设计模式\u0026raquo; 中对微服务的定义:\n将应用程序构建为松耦合, 可独立部署的一组服务\n书中也对\u0026quot;微\u0026quot;的大小给了定义:\n大小的定义为能够由小团队开发服务\n不用刻意地去追求服务的大小. 微服务的落地, 往往就会伴随着, 组织结构和开发的流程的改变, 由不同的 小团队 独立负某一服务.\n像我们现在如果提到微服务, 就经常也会提到一些微服务框架 go-zero, go-micro 或者基础设施 docker, k8s 或者工具 gRPC, prometheus 之类的.\n像这种框架和组件之类的只是一种技术工具. 他们并不能定义微服务, 他们可能只是为了克服微服务架构设计带来的某一些缺陷, 或者与微服务结合可以发挥出更大的价值.\n举个极端的例子: 在你后端业务完全不划分的情况下, 你甚至可以在 go-zero 的框架基础上, 将你公司所有的业务打包进一个应用程序, 用docker打包, 并部署在k8s环境中, 再通过 gRPC 与前端通信. 你用到了很多著名的名词技术, 但是你实现出来应用的是巨石架构还是微服务架构呢?\n参考 微服务设计模式\n","permalink":"https://ynikl.github.io/books/miscroservices-patterns/","summary":"微服务是针对公司某一复杂业务程序实现的设计模式, 与巨石架构(Monolith)是相对的.\n微服务对应的应该是公司业务能力层级上的拆分与设计, 为了减少业务之间的耦合而导致相互拖累, 在对外业务能力不变的情况下, 在应用内部将能力拆分成一些微小服务. 也可以理解为是对巨石架构进行\u0026quot;解耦\u0026quot;.\n举个例子: 原先公司做的是一个外卖系统, 这个系统中可能包含了客户下单, 商家接单, 骑手配送等功能. 但是全部都打包在一个程序中. 发版时, 可能客户下单功能修改了功能, 导致商家没办法接单了. 或者商家接单功能实现的有问题, 导致整个应用程序挂掉, 现在用户下不了单, 骑手也没法接单, 整个公司的业务就瘫痪了. 然后, 在客户下单-商家接单-骑手配送这个大业务流程不变的情况下, 我们在外卖系统内部, 分成了多个服务, 各个服务之间使用 API 松耦合通信, 隔离影响. 比如, 客户下单服务, 专门处理客户下单这一业务, 并将生成的订单推送到消息代理 (如:kafka) 或直接推送给其他服务等, 它只要能保证完成它的职责即可. 后者, 就可以称之为 \u0026ldquo;微服务架构\u0026rdquo;. 当然, 这只是一个例子, 实际情况会更加复杂.\n在\u0026laquo;微服务设计模式\u0026raquo; 中对微服务的定义:\n将应用程序构建为松耦合, 可独立部署的一组服务\n书中也对\u0026quot;微\u0026quot;的大小给了定义:\n大小的定义为能够由小团队开发服务\n不用刻意地去追求服务的大小. 微服务的落地, 往往就会伴随着, 组织结构和开发的流程的改变, 由不同的 小团队 独立负某一服务.\n像我们现在如果提到微服务, 就经常也会提到一些微服务框架 go-zero, go-micro 或者基础设施 docker, k8s 或者工具 gRPC, prometheus 之类的.\n像这种框架和组件之类的只是一种技术工具. 他们并不能定义微服务, 他们可能只是为了克服微服务架构设计带来的某一些缺陷, 或者与微服务结合可以发挥出更大的价值.","title":"我理解的微服务 -- 读《微服务设计模式》总结"},{"content":"胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 连接 两个 不兼容 的组件, 或是两个不兼容的服务.\n胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.\n参考 Quora 回答 wiki\n","permalink":"https://ynikl.github.io/posts/what-is-glue-code/","summary":"胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 连接 两个 不兼容 的组件, 或是两个不兼容的服务.\n胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.\n参考 Quora 回答 wiki","title":"什么是 \"胶水代码\""},{"content":"今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.\n简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:\n1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:\narray 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址\n简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, \u0026ldquo;左闭右开原则\u0026rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即\u0026quot;cap(a) - low\u0026quot; low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt.Printf(\u0026#34;b: len %d, cap %d, c: len %d, c:cap %d\u0026#34;, len(b), cap(b), len(c), cap(c)) 输出: b: len 5, cap 10, c: len 2, c:cap 8 底层分配情况如下:\n1 2 3 4 5 6 7 底层数组 : [0 0 0 0 0 0 0 0 0 0] 旧切片容量: 10 : [0 0 0 0 0 0 0 0 0 0] 旧切片长度: 5 : [0 0 0 0 0] 新切片容量: 8 : [0 0 0 0 0 0 0 0] 新切片长度: 2 : [0 0] 完整版重切片 a[low:high:max] 完整版是为了补充简单版, 新切片会默认拥有从开始下标后的所有底层数组容量. 即新数组拥有修改全部数据底层能力 (重切片出来的不同切片, 在没有 append 操作触发重新分配底层数组的前提下, 指向的都是同一个数据, 修改数据相互可见)\n增加了 max 参数, 表示新切片可以获取到最大的原切片的容量大小. 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4:6] fmt.Printf(\u0026#34;b: len %d, cap %d, c: len %d, c:cap %d\u0026#34;, len(b), cap(b), len(c), cap(c)) 输出: b: len 5, cap 10, c: len 2, c:cap 4 底层分配情况如下\n1 2 3 4 5 6 7 底层数组 : [0 0 0 0 0 0 0 0 0 0] 旧切片容量:10 : [0 0 0 0 0 0 0 0 0 0] 旧切片长度:5 : [0 0 0 0 0] 新切片容量:4 : [0 0 0 0] 新切片长度:2 : [0 0] 但是, 如果 max 要求获取的容量大于旧数据容量. 可想而知, 那一定会 panic\n1 2 3 4 5 6 7 a := [10]int{} b := a[:4:4] c := b[0:4:5] 输出: panic: runtime error: slice bounds out of range [::5] with capacity 4 所以参数要求: 0 \u0026lt;= low \u0026lt;= high \u0026lt;= max \u0026lt;= cap(a)\n参考 stack overflow 问题1 简单版 stack overflow 问题2 详细版 golang 官方文档 ","permalink":"https://ynikl.github.io/posts/golang-reslicing-slice/","summary":"今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.\n简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:\n1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:\narray 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址\n简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, \u0026ldquo;左闭右开原则\u0026rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即\u0026quot;cap(a) - low\u0026quot; low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt.","title":"Go中slice[i:j:k]第三个参数是做什么的"},{"content":"一个完善的方案的需要考虑的三个方面\n当前需求 理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。\n结果上下文 好处：当前方案的好处，解决了什么 弊端: 什么是它不能解决的 问题：引入什么新的问题 与其他方案的关系 前导：当前方案是怎么演变出来。 后续：当前方案会引入什么新问题，有什么后续的解决方案 替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案 参考《微服务设计模式》的1.6.2\u0026quot;模式和模式语言\u0026quot;, 相对减少了模式关系中的泛化和特化。\n","permalink":"https://ynikl.github.io/posts/thinking-choosing-tech/","summary":"一个完善的方案的需要考虑的三个方面\n当前需求 理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。\n结果上下文 好处：当前方案的好处，解决了什么 弊端: 什么是它不能解决的 问题：引入什么新的问题 与其他方案的关系 前导：当前方案是怎么演变出来。 后续：当前方案会引入什么新问题，有什么后续的解决方案 替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案 参考《微服务设计模式》的1.6.2\u0026quot;模式和模式语言\u0026quot;, 相对减少了模式关系中的泛化和特化。","title":"我们为何选择 XXX 技术方案"},{"content":"场景 在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.\n比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.\n分析 优点:\n将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象 在不同策略之间划清界限 增加单独策略的可测试性 缺点:\n后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动 会带来的问题:\n可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力 总结:\n在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).\n实现流程 主要的思想, 我觉得还是 面向接口编程\n分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(interface) 将算法或策略剥离成独立的策略对象, 并实现上述抽象接口 主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略\u0026quot;插入\u0026quot;(plugin)流程, 调用, 获取结果, ok. 参考 refactoringguru - strategy ","permalink":"https://ynikl.github.io/posts/strategy-pattern/","summary":"场景 在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.\n比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.\n分析 优点:\n将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象 在不同策略之间划清界限 增加单独策略的可测试性 缺点:\n后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动 会带来的问题:\n可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力 总结:\n在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).\n实现流程 主要的思想, 我觉得还是 面向接口编程\n分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(interface) 将算法或策略剥离成独立的策略对象, 并实现上述抽象接口 主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略\u0026quot;插入\u0026quot;(plugin)流程, 调用, 获取结果, ok. 参考 refactoringguru - strategy ","title":"设计模式 -- 策略模式"},{"content":"链表的定义： wiki 百科给出定义:\nIn computer science, a linked list is a linear collection of data elemetns whose order is not given by their physical placement in memory. Instead, each element points to the next.\n翻译一下：\n一个线性表 每个元素会指向下一个元素的位置 链表的优缺点 优点:\n不需要提前分配内存 在查找到元素位置的提前下，插入和删除动作是一个常量，即 O(1) 没有容量上限，可以自由扩容 缺点:\n查询某个元素，需要从头开始遍历，即 O(n) 实现代码\n单向链表 最普通的链表\n双向链表 循环链表 ","permalink":"https://ynikl.github.io/dsa/linked-list/","summary":"链表的定义： wiki 百科给出定义:\nIn computer science, a linked list is a linear collection of data elemetns whose order is not given by their physical placement in memory. Instead, each element points to the next.\n翻译一下：\n一个线性表 每个元素会指向下一个元素的位置 链表的优缺点 优点:\n不需要提前分配内存 在查找到元素位置的提前下，插入和删除动作是一个常量，即 O(1) 没有容量上限，可以自由扩容 缺点:\n查询某个元素，需要从头开始遍历，即 O(n) 实现代码\n单向链表 最普通的链表\n双向链表 循环链表 ","title":"Linked List"},{"content":"github code\n非科班出身的我，有好几次尝试过跟着国外大学的课程重新学习计算机基础， 但是每次都是半途放弃了，这次尝试根据数据结构主题进行学习。\n主流的数据结构类型\nLinked List（链表） List （线性表） 2D Arrays Strings（串） Stack （栈） Queue（队列） Hash Table（哈希表） Heap （堆） Tree （树） Graphs（图） Binary Tree Binary Search Tree ","permalink":"https://ynikl.github.io/dsa/datastructures-list/","summary":"github code\n非科班出身的我，有好几次尝试过跟着国外大学的课程重新学习计算机基础， 但是每次都是半途放弃了，这次尝试根据数据结构主题进行学习。\n主流的数据结构类型\nLinked List（链表） List （线性表） 2D Arrays Strings（串） Stack （栈） Queue（队列） Hash Table（哈希表） Heap （堆） Tree （树） Graphs（图） Binary Tree Binary Search Tree ","title":"基础数据结构列表"},{"content":"大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”\n大端的优势是高位计算，和可读性 小端的优势的低位运算 各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。\n以上是阅读阮一峰的博文-字节序探析：大端与小端的比较的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。\n参考连接 阮一峰的博文-字节序探析：大端与小端的比较 ","permalink":"https://ynikl.github.io/posts/endianness/","summary":"大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”\n大端的优势是高位计算，和可读性 小端的优势的低位运算 各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。\n以上是阅读阮一峰的博文-字节序探析：大端与小端的比较的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。\n参考连接 阮一峰的博文-字节序探析：大端与小端的比较 ","title":"计算机中的：大端和小端"},{"content":"是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。\n在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。\n模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。\ngo.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =\u0026gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思\nmodule 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据\ngo.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。\n1 2 3 \u0026gt; cat go.sum example.com/mod v1.0.0 h1:6Cz1EhbAk54HWaw6fhCpSPxWGjIMLuF9MlO4Ou568sQ= example.com/mod v1.0.0/go.mod h1:mgm3p5SY7FVOgVLVSXIYK9qk0umwLQLOG06xLpFUeTI= 文件中以：模块路径 + 版本号 + hash算法名 + hash值 的组合写入\nexample.com/mod 是模块路径名 v1.0.0 是版本号，在第二行有是以/go.mod结尾，代表该 hash 值是对依赖模块本身的go.mod文件的 hash 值 h1: 代表使用的 hash 算法，代表 SHA-256 哈希值，没什么好说的了 Module cache 本地的目录，用户存放下载下来的的模块文件。\n默认路径是在$GOPAth/pkg/mod\nModule cache 文件夹详细说明\n语义化版本 go 采用语义化版本 v1.18.1\n一个模块的版本是不变的 —— 只要拉过一次模块，该模块就会存在缓存在Go 官方的模块服务中，以后拉取改模块就会从官方的模块服务拉取，且该动作不可逆。\n版本号 = \u0026ldquo;v\u0026rdquo; + 主版本号 + 小版本号 + 补丁号\n主版本号的增加后，小版本号和补丁号要重新置零。主版本号增加，代表该版本出现不向后兼容的改动。比如移除旧的包 小版本号增加后，补丁号重新置零。表示版本改动公共接口但是向后兼容的，比如增加一个函数 补丁号增加，表示该版本对公开接口没有改动。比如修改bug 版本的后面可能还会增加一些提前发布的标识，比如 v1.18.1-beta v1.18.1-pre\n当 go 的 模块没有声明发布版本的时候(比如拉取某分支做为模块)，go 就会自己生成 伪版本, 可以仅作了解。\n如果使用模块的版本号大于等于v2的时候，需要在引入包的后缀加上/v2\n1 import \u0026#34;github.com/urfave/cli/v2\u0026#34; 怎么用 开启模块功能 模块功能的开启, 配置在环境变量GO111MODULE\n=off, 忽略GOPATH路径下的go.mod文件，直接引用GOPATH/src中的包文件 =on，启用模块功能 =auto, 如果项目有go.mod文件启用，没有则是用GOPATH模式 常用命令快览 go mod\n1 go mod init example.com/example/m1 初始化当前文件夹，让其成为一个 module\ngo get\n1 go get -d example.com/example/m1@v1.2.3 主要用法:修改当前项目的go.mod，引入新的依赖项目。\n-d 的标志，表示获取目标包之后，不进行本地编译或安装。Go 1.18 之后的默认行为。\n1 go get -d -u example.com/example/m1 也可以用来升级依赖模块的版本，升级到最新版本。如果目标模块的新版的所依赖的其他模块也可能会一并升级。也可以指定版本-u=patch\n修改制定依赖版本的操作也可以通过制定后缀版本号实现\n1 go get example.com/example/m1@v2.3.1 go mod edit\n通过指令修改go.mod文件，与直接修改go.mod效果一致\n1 go mod edit -replace example.com/a@v1.0.0=./a 将某个模块引用指向本地。可以用来解决引用正在开发中，还没有发布过的模块\ngo mod tidy\n根据项目的源码引用整理go.mod中的引用情况。添加缺少的依赖，或者移除冗余的依赖。\ngo mod vendor\n将依赖一并放在自己项目的中，可以省去自己拉取依赖的很多麻烦，提高可用性。go 项目的根目录中的 vendor 文件夹就是用来干这个事的\n将项目依赖移入vendor文件中，当存在了vendor文件夹，项目会使用vendor中的依赖。大于 1.14 版本需要指定参数-mod=vendor才会启用\n本地修改之后模块版本之后需要，重新使用go mod vendor将新的依赖模块同步入vendor中。\ngo mod verify\n用于检测模块再被下载之后入，模块中的代码是否有被修改过。\n对源码文件的 hash，与当前文件的go.sum中的 hash 对比校验是否有被修改过。 如果go.sum中没有该模块的hash值，就会从checksum database 中获取目标 hash 值。（除非设置了GOPRIVATE或者GONOSUMDB)\n1 2 ❯ go mod verify github.com/ynikl/playmod v1.0.0: dir has been modified (/Users/ian/go/pkg/mod/github.com/ynikl/playmod@v1.0.0) 上述例子，源文件被我手动强制修改过，就会报错\ngo mod why\n1 go mod why example.com/mod 用于解释当前项目为什么会依赖某一个模块，输出项目对目标模块的依赖树图\ngo list -m all\n可以用于输出当前项目依赖的所有模块\nMVS Minimal version selection（MVS), 当引入的不同模块，又存在依赖与相同模块的（相同大版本，不同版本小版本）的时候。\n在使用模块相关命令的时候，会选择所依赖的不同版本的中，构建项目所需要从最小版本。\nA.12 与 B1.2 分别需要 C1.3 和 C1.4 为了是项目能正常进行，需要使用 C1.4 版本\n参考 官网Go Modules参考 Minimal Version Seletion 官方介绍 Modules 博文 提议 ","permalink":"https://ynikl.github.io/blog/go-modules/","summary":"是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。\n在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。\n模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。\ngo.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =\u0026gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思\nmodule 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据\ngo.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。\n1 2 3 \u0026gt; cat go.","title":"小窥 Go 中的 Modules"},{"content":"mysql 在事务中再开启事务，前一个事务会被自动提交\nstackoverflow\n","permalink":"https://ynikl.github.io/posts/mysql-nested-transactions/","summary":"mysql 在事务中再开启事务，前一个事务会被自动提交\nstackoverflow","title":"Mysql 不支持事务嵌套"},{"content":"举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。\n并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构\n并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。\nConcurrency is not Parallelism by Rob Pike\n","permalink":"https://ynikl.github.io/posts/concurrency-and-parallelism/","summary":"举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。\n并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构\n并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。\nConcurrency is not Parallelism by Rob Pike","title":"并发与并行的区别"},{"content":"读Randy\u0026rsquo;s的博客遗憾最小化框架有感\n在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定\n做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾\nJeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。\nBezos的视频地址 Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁\nAsk yourself: in 10 years from now, will you be proud of having done this? \u0026hellip; Do things that your future self will be proud, is my motto for the time being.\n","permalink":"https://ynikl.github.io/posts/how-make-decisions/","summary":"读Randy\u0026rsquo;s的博客遗憾最小化框架有感\n在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定\n做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾\nJeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。\nBezos的视频地址 Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁\nAsk yourself: in 10 years from now, will you be proud of having done this? \u0026hellip; Do things that your future self will be proud, is my motto for the time being.","title":"如何做决定——遗憾最小化"},{"content":"Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法\nLock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。\nMutex 实现了一个 sync.Locker 接口, 该接口只有两个方法\nLock Unlock Mutex 锁有几种状态\nmutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量\nmutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态\n正常模式 normal 饥饿模式 starvation 正常模式下，等待获取的锁的协程遵循先进先出的原则。\n但是，当释放锁的时候如果有新协程进入获取锁代码的时候。因为新入协程本身已经运行在CPU上了，所以有抢占锁的优势。由于阻塞在等待队列上的协程，竞争不过新入协程。当等待时间操作 1ms，就会触发饥饿模式。\n饥饿模式，进行互斥锁解锁的协程直接的将锁的所有权直接已经给等待队列的第一个协程。新进协程被禁止抢占互斥锁。\n在转移所有权的时候，如果满足一下任意条件，则进入正常模式：\n锁的等待者只剩最后一个 等待时间小于1ms 正常模式有利于更好的性能，饥饿模式则避免出现“饿死”情况。\nMutex 的方法详解 Lock 第一步，通过调用 atomic 的 CAS 操作，尝试加锁，如果成功加锁直接返回\n1 atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) 如果第一步失败，则代表该锁已经被加过锁，锁定了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 func (m *Mutex) lockSlow() { // 当前协程的变量, 可以用于表示当前协程的状态 // 用于统计锁的等待时长，是否进入饥饿模式 var waitStartTime int64 starving := false // 当前协程是否处于饥饿 awoke := false // 是否处于唤醒 iter := 0 // 统计自旋次数 old := m.state for { // 进入自旋的状态条件， **已经锁定** 且非饥饿状态。 if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { // 如果锁的状态 woken 字段未被标记， 将自身标记位唤醒，且将 Mutex 的 woken 位标记位1 // 当协程自己进入获取锁的第一候选人 if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() // 控制自旋次数，大于4次之后不进入自旋状态 iter++ // 获取最新的状态 old = m.state continue } // 有可能，自旋自后已经解锁或者只是单纯不能自旋限制了。下面尝试通过 CAS 竞争锁。 // 新值用于设置新的状态 new := old // 非饥饿状态才设置锁定 if old\u0026amp;mutexStarving == 0 { new |= mutexLocked } if old\u0026amp;(mutexLocked|mutexStarving) != 0 { // 等待者加1 new += 1 \u0026lt;\u0026lt; mutexWaiterShift } // 当前协程是饥饿状态，尝试标记锁的新状态位饥饿状态。 if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. if new\u0026amp;mutexWoken == 0 { // Mutex 的唤醒位被抢走，出现不一致。协程变量的唤醒位应该与 Mutex 的唤醒位一致 throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // 标志 锁的唤醒位为0 new \u0026amp;^= mutexWoken } // CAS 尝试, Mutex 状态没有被变更 if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 非饥饿状态下，CAS 成功新的 new 字段中会有 mutexLocked 标记（在new下的第一个if）。当前协程获取到了互斥锁, if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } // queueLifo 表示该协程是否为第一次获取锁。如果中间被唤醒过，这放在等待队列头部 queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 通过信号量，进入阻塞 runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1) // 进入饥饿模式 starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state // 当前是饥饿模式 if old\u0026amp;mutexStarving != 0 { // 如果当前锁的状态位饥饿模式，但是当前协程可以执行的当前行代码，代表当前协程已经被从阻塞中唤醒。 // 饥饿状态 + 被唤醒 =》当前锁已经已经到当前协程上 if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { // 检查状态一致 throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // 由当协程来设置最新的锁定状态 delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) // 判断是否需要退出饥饿模式 if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving } atomic.AddInt32(\u0026amp;m.state, delta) break } // 当前是正常模式，通过CAS自由竞争锁。 awoke = true iter = 0 // 重置计数 } else { // 再来 old = m.state } } } 是否可以进入自旋状态代码解释源码地址\nUnlock 第一步直接减去 mutexLocked 标志位常量，如果 new 等于0结束——简单（锁一次开一次，easy）。\n1 new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) 如果 state 还不等于0（有协程等待，竞争锁）, 进入 unlockSlow\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func (m *Mutex) unlockSlow(new int32) { // 上一步已经减过 locked 位， 在加上应该等于1，否则不是正常解锁（解锁未锁定的锁）。 if (new+mutexLocked)\u0026amp;mutexLocked == 0 { fatal(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } // 正常模式 if new\u0026amp;mutexStarving == 0 { old := new for { // If there are no waiters or a goroutine has already // been woken or grabbed the lock, no need to wake anyone. // In starvation mode ownership is directly handed off from unlocking // goroutine to the next waiter. We are not part of this chain, // since we did not observe mutexStarving when we unlocked the mutex above. // So get off the way. // 没有等待协程无需通过信号量唤醒 // 1. 如果 mutexLocked 位为1，则代表锁已经被新入协程获取。 // 2. mutexWoken 代表协程有协程正在活动，无需再释放信号量 // 3. mutexStarving 锁的状态一直被抢占，才会导致当前位饥饿状态，无需在释放信号量 if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return } // Grab the right to wake someone. new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt3(\u0026amp;m.state, old, new) { // 信号量唤醒，各自竞争 runtime_Semrelease(\u0026amp;m.sema, false, 1) return } old = m.state } } else { // 饥饿模式，通过信号量直接移交当前CPU时间 runtime_Semrelease(\u0026amp;m.sema, true, 1) } }2 如何把锁移交给等待队列的协程？\n使用 Mutex.sema 信号量实现锁转移\n参考 源代码地址sync.mutex.go 包说明文档\n","permalink":"https://ynikl.github.io/blog/go-sync_mutex/","summary":"Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法\nLock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。\nMutex 实现了一个 sync.Locker 接口, 该接口只有两个方法\nLock Unlock Mutex 锁有几种状态\nmutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量\nmutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态","title":"Go-互斥锁的实现"},{"content":"为什么学 高学习产出转化比 助力下一份工作 公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。 后端架构转变的主流方向, 有利于再次找工作。\n怎么学 想要学习好一个技术，就需要有想学习这门技术的动力。\n首先要对它有较全面的理解：\n我们为什么要学习这门技术 技术的使用场景，以及使用的优势和劣势 现在该技术在大环境中的使用情况 再开始学习技术本身。\n针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。\n具体方法：\n我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。 使用 go-zero 框架完成一个练手项目开发。 ","permalink":"https://ynikl.github.io/posts/2022/0526-why-learn-microservices/","summary":"为什么学 高学习产出转化比 助力下一份工作 公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。 后端架构转变的主流方向, 有利于再次找工作。\n怎么学 想要学习好一个技术，就需要有想学习这门技术的动力。\n首先要对它有较全面的理解：\n我们为什么要学习这门技术 技术的使用场景，以及使用的优势和劣势 现在该技术在大环境中的使用情况 再开始学习技术本身。\n针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。\n具体方法：\n我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。 使用 go-zero 框架完成一个练手项目开发。 ","title":"我为什么要学微服务"},{"content":"富兰克林自传\n富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。\n年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。\n摘录富兰克林十三美德：\n节制:食不过饱，饮酒不醉； 寡言:言必于人于己有益，避免无益的聊天； 生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做； 决心:当做必做；决心要做的事应坚持不懈； 俭朴:用钱必须于人或于己有益，换言之，切戒浪费； 勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动； 诚恳:不欺骗人；思想要纯洁公正；说话也要如此； 公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务； 适度:避免极端；人若给你应得的处罚，你当容忍之； 清洁:身体、衣服和住所力求清洁； 镇静:勿因小事或普遍不可避免的事故而惊慌失措； 贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉； 谦虚:仿效耶稣和苏格拉底。\n","permalink":"https://ynikl.github.io/books/autobiography-benjamin_franklin/","summary":"富兰克林自传\n富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。\n年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。\n摘录富兰克林十三美德：\n节制:食不过饱，饮酒不醉； 寡言:言必于人于己有益，避免无益的聊天； 生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做； 决心:当做必做；决心要做的事应坚持不懈； 俭朴:用钱必须于人或于己有益，换言之，切戒浪费； 勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动； 诚恳:不欺骗人；思想要纯洁公正；说话也要如此； 公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务； 适度:避免极端；人若给你应得的处罚，你当容忍之； 清洁:身体、衣服和住所力求清洁； 镇静:勿因小事或普遍不可避免的事故而惊慌失措； 贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉； 谦虚:仿效耶稣和苏格拉底。","title":"富兰克林自传读后感"},{"content":"在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。\n原文章地址 Godoc: documenting Go code\nGo 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。\n所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。\ngodoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。\ngodoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc\u0026quot;相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。\n使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的Fprint函数的注释。\n1 2 3 4 // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered. func Fprint(w io.Writer, a ...interface{}) (n int, err error) { 值得注意的是该注释是以被注释的对象命名开头的一个完整的句子。 这个使用规范可以方便我们生成各种各样的格式文档，从简单的纯文本到 UNIX 是 man 的帮助页，还可以使用其他工具更见简单地获取到信息， 比如提取出第一行或者句子。\n在包的声明处的注释，需要写整个包的概括说明。这些注释可以很简洁，就像 sort 包中的简短描述：\n1 2 3 // Package sort provides primitives for sorting slices and user-defined // collections. package sort 也可以很详细，比如 gob 包。有另一个使用惯例：像这种有这大量注释文档的包，单独一个doc.go文件，放置包的注释。\n不论包的注释文档大小，第一句注释会被展示在 godoc 的呈现包列表中。\n那些没有与最外层声明（可以简单理解为包内全局对象）连接在一块的注释会被 godoc 忽略。但是，有一个例外。那些写在最外层且以“BUG(who)”开头的注释，会被识别为已知的 bug，且会被包含在包文档的“Bugs”分区中。这个“who”部分应该填写可以提供更加详细信息的人名。举个已经在 bytes 包中注释的问题:\n1 // BUG(r): The rule Title uses for word boundaries does not handle Unicode punctuation properly. 某些时候，当一个结构体字段，或者函数，类型，甚至一个整个包变成了冗余或者没有使用必要，但是还是需要与旧代码保持兼容。这时，可以增加一个一段落以“Deprecated:”开头后面跟废弃信息的注释。标识该对象不应该再被使用。\n下面展示一些 godoc 把注释转化成网页的规则：\n不同的段落需要以空行分割。否则将会被识别成同一段。 带有格式的文本，需要要缩进。 URL 会被转化成网页连接，无需特殊处理。 上方的这些规则不需要你做任何的特殊处理。\n事实上，godoc 的极简处理方式使得它非常容易使用。所以，很多 go 项目，包括标准库，都已经开始开始遵循 godoc 的注释文档规范。\n你自己的项目也可以通过编写符合文中规范的注释生成漂亮的文档。任何下载在$GOROOT/src/pkg 或者任何在 GOPATH 空间下的 go 代码包，都可以被 godoc 的命令行或者 HTTP 的接口访问， 你也可以通过在命令后添加-path参数或者直接使用godoc .来指定源码的路径。在godoc 文档 你可以查看到更加详细的内容。\n","permalink":"https://ynikl.github.io/blog/godoc-documenting-go-code/","summary":"在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。\n原文章地址 Godoc: documenting Go code\nGo 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。\n所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。\ngodoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。\ngodoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc\u0026quot;相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。\n使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的Fprint函数的注释。\n1 2 3 4 // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered.","title":"【翻译】使用 Godoc 给 go 代码添加文档"},{"content":"IP 中斜杠表示的是子网掩码的位数\n例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000\n","permalink":"https://ynikl.github.io/posts/cs-the-slash-meaning-of-ip/","summary":"IP 中斜杠表示的是子网掩码的位数\n例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000","title":"IP表示中 / 代表的意思"},{"content":"以前有一段时间, 怀疑过自己\u0026quot;软件工程师\u0026quot;和以前工程意义上的\u0026quot;工程师\u0026quot;有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的见识书中看了一个五级工程师的概念, 算是解惑了我做为一个\u0026quot;码农\u0026quot;和工程师的区别.\n(图片来源于图书截图)\n第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围. 第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程. 第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维. 第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样. 第一级工程师: 开创一个行业的鼻祖. 能够改变世界. 反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.\n所以我自己应该就是 5.0, 五级工程师, 五流程序员.\n","permalink":"https://ynikl.github.io/posts/five-class-engineer/","summary":"以前有一段时间, 怀疑过自己\u0026quot;软件工程师\u0026quot;和以前工程意义上的\u0026quot;工程师\u0026quot;有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的见识书中看了一个五级工程师的概念, 算是解惑了我做为一个\u0026quot;码农\u0026quot;和工程师的区别.\n(图片来源于图书截图)\n第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围. 第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程. 第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维. 第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样. 第一级工程师: 开创一个行业的鼻祖. 能够改变世界. 反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.\n所以我自己应该就是 5.0, 五级工程师, 五流程序员.","title":"Five Class Programer"},{"content":"hugo 的默认内容都是在 content/ 路径下方\n在 markdown 文章中使用 { {\u0026lt; ref \u0026quot;/blog/my-first-post.md\u0026quot; \u0026gt;}}(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带/ 是表示从 content/ 目录下的下一个绝对路径\n1 [我的文章]({ {\u0026lt; ref \u0026#34;/blog/my-first-post.md\u0026#34; }}) 记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错\nhugo官方文档\n","permalink":"https://ynikl.github.io/posts/hugo_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%BF%9E%E6%8E%A5/","summary":"hugo 的默认内容都是在 content/ 路径下方\n在 markdown 文章中使用 { {\u0026lt; ref \u0026quot;/blog/my-first-post.md\u0026quot; \u0026gt;}}(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带/ 是表示从 content/ 目录下的下一个绝对路径\n1 [我的文章]({ {\u0026lt; ref \u0026#34;/blog/my-first-post.md\u0026#34; }}) 记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错\nhugo官方文档","title":"Hugo 如何使用已经发布文章做为相对URL"},{"content":"我的第一篇杂文\n阅读了卡片写作笔记法, 和Show Your Work之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.\n原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.\n","permalink":"https://ynikl.github.io/posts/my-first-post/","summary":"我的第一篇杂文\n阅读了卡片写作笔记法, 和Show Your Work之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.\n原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.","title":"My first Post"},{"content":"见识:豆瓣地址\n个人评分: 8.0 分\n前辈用他的智慧和经验, 告诉我们如何更好地活着.\n为什么读这本书 很多到了中年的人会有这样的体会： 自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。\n为了这一句话, 读这一本书. 自己的作为一个普工程序员, 在技术浪潮的最后端被拖着走. 本根不需要到中年, 今年是我从事程序员工作的第四年, 我已经被感受到了被\u0026quot;命\u0026quot;限制住 的感觉了.\n书中讲了什么 作者分享了他对商业, 技术, 职业, 创业, 金钱, 读书的观点和看法\n用提出了商业的本质是\u0026quot;消费\u0026quot;的观点, 剖析了现在主流的\u0026quot;共享经济\u0026quot;, 带我们用商业的本质眼光, 去看哪些形式的共享经济是真正的\u0026quot;共享经济\u0026quot;, 哪些只是噱头炒概念的而已. 分析了IOT, 和数字跟踪技术, 区块链, 众筹等.\n介绍了新科技公司的创业过程中的一些普世经验. 如何选取赛道, 如何发挥自己小公司的优势, 如何在科技浪潮中存活下来, 以及中如何招聘优秀员工.\n关于在职场如何招聘到优秀的员工, 又可以引申到自己如何成为一个优秀的员工, 作者也给出了答案.\n树立完成的职业思维, 带着发展的目光选择岗位 在职业思维下主动和积极的面对工作 打开自己思维格局, 多去了解行业大局 有了不错的收入之后, 就涉及到了, 如何树立一个正确的金钱观. 要对自己收入有一个正确的认识, 避免过度追求提高收入, 进而牺牲了自己的健康, 家庭等. (现在经常听到我们的工友, 猝死就是这方面没有正确面对)\n下半篇, 作者开始就上升到了人生态度问题. 以一个正确的心态, 面对生活, 面对婚姻, 面对死亡. 分清楚自己生活中的 \u0026ldquo;西瓜和芝麻\u0026rdquo;, 避免习惯于低层次的追求, 会影响我们的心志.\n最后文中讲述对大学生的建议 (我已经错过了), 阐述沟通的重要性, 以及介绍了拉里·佩奇名人, 巴菲特的非凡\u0026quot;见识\u0026quot;.\n我从书中收获了什么 对现在的\u0026quot;共享经济\u0026quot;有了更深的认识, 对科技迭代有了一个基础性的认识, 重视自己职业发展和做文字的积累, 开始努力去全面了解自己的行业, 以及在阅读中莫名地增加了我对生活的信心.\n书中的三句精华句子 很多到了中年的人会有这样的体会：自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。 我们知道今天几乎任何一所三甲医院的主治医师，水平一定比 50 年前所谓的名医高很多。但是，今天没有哪个中医敢讲自己比 500 年前的名医水平高。这就是因为前者有积累效应，而后者没有 我们对死亡的恐惧有点儿莫名其妙，我们站在“有”的世界，试图理解“无”的问题，按照“有”的逻辑，对“无”产生恐惧 三句话总结本书 拓展视野, 打开格局, 重视积累 以发展的眼光看职业生涯, 分清楚工作和职业的区别, 拒绝伪工作. 向死而生 ","permalink":"https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/","summary":"见识:豆瓣地址\n个人评分: 8.0 分\n前辈用他的智慧和经验, 告诉我们如何更好地活着.\n为什么读这本书 很多到了中年的人会有这样的体会： 自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。\n为了这一句话, 读这一本书. 自己的作为一个普工程序员, 在技术浪潮的最后端被拖着走. 本根不需要到中年, 今年是我从事程序员工作的第四年, 我已经被感受到了被\u0026quot;命\u0026quot;限制住 的感觉了.\n书中讲了什么 作者分享了他对商业, 技术, 职业, 创业, 金钱, 读书的观点和看法\n用提出了商业的本质是\u0026quot;消费\u0026quot;的观点, 剖析了现在主流的\u0026quot;共享经济\u0026quot;, 带我们用商业的本质眼光, 去看哪些形式的共享经济是真正的\u0026quot;共享经济\u0026quot;, 哪些只是噱头炒概念的而已. 分析了IOT, 和数字跟踪技术, 区块链, 众筹等.\n介绍了新科技公司的创业过程中的一些普世经验. 如何选取赛道, 如何发挥自己小公司的优势, 如何在科技浪潮中存活下来, 以及中如何招聘优秀员工.\n关于在职场如何招聘到优秀的员工, 又可以引申到自己如何成为一个优秀的员工, 作者也给出了答案.\n树立完成的职业思维, 带着发展的目光选择岗位 在职业思维下主动和积极的面对工作 打开自己思维格局, 多去了解行业大局 有了不错的收入之后, 就涉及到了, 如何树立一个正确的金钱观. 要对自己收入有一个正确的认识, 避免过度追求提高收入, 进而牺牲了自己的健康, 家庭等. (现在经常听到我们的工友, 猝死就是这方面没有正确面对)\n下半篇, 作者开始就上升到了人生态度问题. 以一个正确的心态, 面对生活, 面对婚姻, 面对死亡. 分清楚自己生活中的 \u0026ldquo;西瓜和芝麻\u0026rdquo;, 避免习惯于低层次的追求, 会影响我们的心志.\n最后文中讲述对大学生的建议 (我已经错过了), 阐述沟通的重要性, 以及介绍了拉里·佩奇名人, 巴菲特的非凡\u0026quot;见识\u0026quot;.","title":"见识"},{"content":"Show Your Work 读书总结 概括 我为什么要读这本书\n如何提高自己的影响力\n这本书怎样影响了我\n打算开始分享计划, 学习如何分享, 讲述故事. 计划\u0026quot;学术假\u0026quot;\n书中的三句精华句子\nYou find time the same place you find spare change: in the nooks and crannies On the spectrum of creative work, the difference between the mediocre and the good is vast. Mediocrity is, however, still on the spectrum; you can move from mediocre to good in increments. The real gap is between doing nothing and doing something You can turn your flow into stock 三句话总结本书\n我们需要把自己展示出来, 这样子别人才能知道你是一个什么样子的人. ( 酒香也怕巷子深) 把自己当成一个业务爱好者, 对自己分享负责, 但不用追求到完美, 心态开放, 保持热情 把握自己分享的尺度, 任何事情, 思想, 启发都是值得分享的. 在互联网上保持真诚, 尊重他人, 保护自己. 感悟点 不要觉得你没有什么事情可以分享, 一定会有人对你做的事情感兴趣. 比如一天结束，可以分享自己在做什么，做什么什么决定，收获了什么，受到了什么启发，有什么成果\n互联网上的人们都很烂，如果不包含链接，99.9%的就不会去找目标网页\n如果虚假的分享你的成功，你不仅抢夺了他人的成功，还欺骗了分享成果的人们\n要能解释自己正在做什么\n分享自己的知识，也可以让别人知道你在干嘛，知道你的工作，也是自己的一种再学习过程\n要倾听别人的意见，不要一味地分享自己\n要用内容去吸引读者，不要悲哀地要求别人粉你\n学会在网上保护自己，过滤垃圾评论\n通勤的好处：分离家庭与工作\n适当给自己放假，学术假。每七年让自己重新充电🔋。\n认识你自己\n","permalink":"https://ynikl.github.io/books/showyourwork/","summary":"Show Your Work 读书总结 概括 我为什么要读这本书\n如何提高自己的影响力\n这本书怎样影响了我\n打算开始分享计划, 学习如何分享, 讲述故事. 计划\u0026quot;学术假\u0026quot;\n书中的三句精华句子\nYou find time the same place you find spare change: in the nooks and crannies On the spectrum of creative work, the difference between the mediocre and the good is vast. Mediocrity is, however, still on the spectrum; you can move from mediocre to good in increments. The real gap is between doing nothing and doing something You can turn your flow into stock 三句话总结本书","title":"Show Your Work"},{"content":"启动一个容器 打个样\n1 docker run -itd --rm --name hello image_name \u0026ndash; it 将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式\n\u0026ndash;rm 当容器停止之后, 会自动删除改容器\n外挂文件夹 参数 -v docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash\n与容器交互 进入容器 docker attach\nexec\ndocker -it exec CONTAIN_NAME bash\nexex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯. 加上 -it, 进入交互的终端模式\n查看日志 docker logs CONTAINER 可以查看容器日志\n-f 可以持续输出容器内部的最新日志\n管理容器 启动\n1 docker start CONTAINER 暂停\n1 docker stop CONTAINER 管理镜像 查看所有的镜像列表\n1 docker image ls 删除镜像\n1 docker rmi IMAGE 删除 \u0026lt;none\u0026gt; 名称的镜像\n1 docker rmi $(docker images --filter \u0026#34;dangling=true\u0026#34; -q --no-trunc) ","permalink":"https://ynikl.github.io/blog/docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"启动一个容器 打个样\n1 docker run -itd --rm --name hello image_name \u0026ndash; it 将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式\n\u0026ndash;rm 当容器停止之后, 会自动删除改容器\n外挂文件夹 参数 -v docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash\n与容器交互 进入容器 docker attach\nexec\ndocker -it exec CONTAIN_NAME bash\nexex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯. 加上 -it, 进入交互的终端模式\n查看日志 docker logs CONTAINER 可以查看容器日志\n-f 可以持续输出容器内部的最新日志\n管理容器 启动\n1 docker start CONTAINER 暂停\n1 docker stop CONTAINER 管理镜像 查看所有的镜像列表\n1 docker image ls 删除镜像","title":"Docker 基本使用"},{"content":"Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本\nchannel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)\nDo not communicate by sharing memory; instead, share memory by communicating.\nchannel 保证:\n数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开 channel 的实现 channel 在内部实现的结构体为 runtime.hchan\n有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe.Pointer // 环形数组开始地址 elemsize uint16 // channel 传输的元素大小, 用于计算内存大小 closed uint32 // channel 是否已经关闭 0未关闭, 非0关闭 elemtype *_type // element type # channel 元素的类型 sendx uint // 环形链表中, 发送数据存储的下标 recvx uint // 环形链表中, 接受数据获取数据的下标 recvq waitq // 阻塞在该 channel 等待获取数据的 Groutine 列表 sendq waitq // 阻塞在该 channel 等待写入数据的 Groutine 列表 lock mutex // # 互斥锁 用于保护自身数据变更 } 初始化 channel 传递的元素不能太大 如果是空结构体或者无缓冲队列, 是不需要分配环形队列内存 如果传递数据类型有内含指针, 需要将环形队列分配到堆上 内部实现函数runtime.makechan\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 func makechan(t *chantype, size int) *hchan { // compiler checks this but be safe. // 编译器会校验channel元素的大小, 小于64KB. 若大于64KB, 编译器会报错 if elem.size \u0026gt;= 1\u0026lt;\u0026lt;16 { throw(\u0026#34;makechan: invalid channel element type\u0026#34;) } if hchanSize%maxAlign != 0 || elem.align \u0026gt; maxAlign { throw(\u0026#34;makechan: bad alignment\u0026#34;) } mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u0026gt; maxAlloc-hchanSize || size \u0026lt; 0 { panic(plainError(\u0026#34;makechan: size out of range\u0026#34;)) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. // buf points into the same allocation, elemtype is persistent. // SudoG\u0026#39;s are referenced from their owning thread so they can\u0026#39;t be collected. // TODO(dvyukov,rlh): Rethink when collector can move allocated objects. var c *hchan switch { case mem == 0: // Queue or element size is zero. # 无缓冲队列或者空结构体为传递值, 不需要额外分配队列内存 c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. c.buf = c.raceaddr() case elem.ptrdata == 0: // # channel 元素不存在指针引导数据, 将环形数组分配在 hchan 后面 // Elements do not contain pointers. // Allocate hchan and buf in one call. c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. c = new(hchan) c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026amp;c.lock, lockRankHchan) // # locakRankHchan 锁的等级 return c } 关闭 核心代码runtime.closechan更新自身数据结构中的关闭状态, 并 唤醒阻塞在 channel 上的所有协程. 被唤醒的协程(sudog)的 success 标识会被置为 false.\n被唤醒的 写操作的协程, 也会发生panic. ( \u0026ldquo;send on closed channel\u0026rdquo; )\n自身操作会发生 panic 的情况\n未初始化 channel 重复关闭 channel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 func closechan(c *hchan) { if c == nil { // 未初始化的channel 会发生panic panic(plainError(\u0026#34;close of nil channel\u0026#34;)) } // # 开始关闭, 锁定之后数据都进不来了 lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;close of closed channel\u0026#34;)) } c.closed = 1 var glist gList // release all readers # 唤醒所有因为读取数据阻塞的协程 for { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g // # [channel 唤醒协议总是设置params为sudog](https://github.com/golang/go/commit/30a68bfb806b5217932e280f5a5f521237e69077) gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // release all writers (they will panic) # 唤醒所有因为写入数据阻塞的协程 for { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026amp;c.lock) // Ready all Gs now that we\u0026#39;ve dropped the channel lock. for !glist.empty() { gp := glist.pop() gp.schedlink = 0 // # 唤醒协程, 将协程加入调度 goready(gp, 3) } } 发送数据 向已经关闭的 channel 发送数据会发生 panic\n数据流程:\n检查是否已经初始化 非阻塞写入数据, 检查数据是否已经满, 快速返回 是否已经关闭 检查 channel 中是否已经有等待获取数据而阻塞的协程, 如果有直接将数据发送给等待的协程. channel 的 buffer 是否还有空间, 如果有将数据放置到 buffer 中, 返回 channel 的 buffer 已经满了, 根据是否为 select 操作, 判断是否需要将协程阻塞 当协程阻塞之后, 在被唤醒之后需要再检查一次, channel 是否已经关闭. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 // # block 的参数是由是否在 select 中, 由编译过程决定的; 只有在select语句中block = true func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { if !block { return false } // # 向未初始化的 channel 发送数据会永远阻塞 gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // # 带 select 的 channel 在数据已经满了情况直接返回 if !block \u0026amp;\u0026amp; c.closed == 0 \u0026amp;\u0026amp; full(c) { return false } // 保护数据 lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } // # 先从接受协程队列中获取阻塞的协程, 直接将数据发送给阻塞的协程 if sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } // # channel 的 buffer 中还有剩余空间 if c.qcount \u0026lt; c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. qp := chanbuf(c, c.sendx) if raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) c.sendx++ // # 环形队列, 当索引到最后从头开始 if c.sendx == c.dataqsiz { c.sendx = 0 } // # 增加当前 channel buffer 存储的数据个数 c.qcount++ unlock(\u0026amp;c.lock) return true } if !block { unlock(\u0026amp;c.lock) return false } // # 发送数据的协程阻塞在当前 channel // Block on the channel. Some receiver will complete our operation for us. gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we\u0026#39;re about // to park on a channel. The window between when this G\u0026#39;s status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) // Ensure the value being sent is kept alive until the // receiver copies it out. The sudog has a pointer to the // stack object, but sudogs aren\u0026#39;t considered as roots of the // stack tracer. KeepAlive(ep) // # 协程被唤醒了 // someone woke us up. if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) // # 挂载在协程上的发送协程会 panic if closed { if c.closed == 0 { throw(\u0026#34;chansend: spurious wakeup\u0026#34;) } panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } return true } 接收数据 与发送数据一样, 同样带着是否阻塞的参数. 在编译时,由是否有 select 操作决定. 核心代码runtime.chanrecv\n不带 select 从未初始化的 channel 获取数据, 会永远阻塞 runtime.chanrecv 返回值中, 第一个返回值selected表示在,select 语句中, 该 case 是否会被选中执行 接收数据流程:\n检查是否已经初始化 检查非阻塞获取数据下, 是否可以直接返回 如果已经关闭的 channel 且没有已经没有缓冲数据, 返回数据类型的默认值. 检查有因发送数据阻塞在 channel 的协程, 如果没有 buffer, 直接从阻塞的协程中获取数据, 否则从 buffer 中获取数据数据, 将第一个阻塞的协程的数据放入 buffer 中. 如果缓冲 buffer 有数据, 则从buffer 中获取数据. 非阻塞操作, 直接返回. 否则协程进行阻塞. 注意事项:\n当 select 一个 已经关闭的 channel 的时候, 该 case 会被疯狂输出, 导致cpu使用率上升\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 // chanrecv receives on channel c and writes the received data to ep. // ep may be nil, in which case received data is ignored. // If block == false and no elements are available, returns (false, false). // Otherwise, if c is closed, zeros *ep and returns (true, false). // Otherwise, fills in *ep with an element and returns (true, true). // A non-nil ep must point to the heap or the caller\u0026#39;s stack. func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { if c == nil { if !block { // select 情况下, selected = false, 不执行该 case return } // # 非 select 会永远阻塞 gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // # 不加锁检查, 带 select 接收操作, 如果 channel 未关闭, 且没有可以获取的数据直接返回 // Fast path: check for failed non-blocking operation without acquiring the lock. if !block \u0026amp;\u0026amp; empty(c) { // After observing that the channel is not ready for receiving, we observe whether the // channel is closed. // // Reordering of these checks could lead to incorrect behavior when racing with a close. // For example, if the channel was open and not empty, was closed, and then drained, // reordered reads could incorrectly indicate \u0026#34;open and empty\u0026#34;. To prevent reordering, // we use atomic loads for both checks, and rely on emptying and closing to happen in // separate critical sections under the same lock. This assumption fails when closing // an unbuffered channel with a blocked send, but that is an error condition anyway. if atomic.Load(\u0026amp;c.closed) == 0 { // Because a channel cannot be reopened, the later observation of the channel // being not closed implies that it was also not closed at the moment of the // first observation. We behave as if we observed the channel at that moment // and report that the receive cannot proceed. return } // The channel is irreversibly closed. Re-check whether the channel has any pending data // to receive, which could have arrived between the empty and closed checks above. // Sequential consistency is also required here, when racing with such a send. if empty(c) { // The channel is irreversibly closed and empty. if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { typedmemclr(c.elemtype, ep) } // select 会选择改 case 疯狂输出 return true, false } } lock(\u0026amp;c.lock) if c.closed != 0 { // # 如果 channel 已经关闭, 且buffer 中已经没有数据了, 返回传输数据类型的默认值 if c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } // # 在返回的时候有可能刚好有数据会进来, 所以需要进行加锁操作 unlock(\u0026amp;c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } // The channel has been closed, but the channel\u0026#39;s buffer have data. } else { // # 如果 channel 没有 buffer 会直接从阻塞中的发送数据协程中获取数据 // # 如果 channel 有 buffer. 当可以获取到因为发送数据而阻塞的协程时, 代表缓冲的 buffer 已经满了. 所以, 将从 buffer 中获取数据, 并将获取到的第一个阻塞协程, 的数据放入 buffer 尾端. 保证先入先出 // Just found waiting sender with not closed. if sg := c.sendq.dequeue(); sg != nil { // Found a waiting sender. If buffer is size 0, receive value // directly from sender. Otherwise, receive from head of queue // and add sender\u0026#39;s value to the tail of the queue (both map to // the same buffer slot because the queue is full). recv(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true, true } } // # 从 buffer 中获取数据 if c.qcount \u0026gt; 0 { // Receive directly from queue qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026amp;c.lock) return true, true } // # 非阻塞操作, 返回 if !block { unlock(\u0026amp;c.lock) return false, false } // 将获取数据的协程阻塞 // no sender available: block on this channel. gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil c.recvq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we\u0026#39;re about // to park on a channel. The window between when this G\u0026#39;s status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) // someone woke us up if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false // 如果是因为 channel的关闭 操作唤醒的, success 值为 false success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) return true, success } 用法总结 初始化:\n避免对未初始化 channel 的进行读写操作, 可能会造成阻塞 在 select 语句中, 对已经关闭的 channel 可以赋予 nil 值, 避免 cpu 飙高 关闭协程:\n关闭协程的动作, 应该由数据写入方操作 channel 当参数传递时, 尽可能带上操作方向(读取/写入), 编译器会保证, 单向写入协程不允许关闭 关闭的时候要确保所有的写入协程都已经操作完毕. 避免引起写入协程发生 panic 在 channel 中阻塞的协程, 唤醒条件\n到达协程数据操作的目标, 写入 / 读取数据 channel 关闭 Referrences Go官方源码 Share Memory By Communication ","permalink":"https://ynikl.github.io/blog/go-channel/","summary":"Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本\nchannel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)\nDo not communicate by sharing memory; instead, share memory by communicating.\nchannel 保证:\n数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开 channel 的实现 channel 在内部实现的结构体为 runtime.hchan\n有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe.","title":"Channel"},{"content":"如何提高自己的所编写的文字留存问题? 自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意. 然后就会把已经写下的文字和内容删除掉.\n","permalink":"https://ynikl.github.io/posts/%E6%8F%90%E5%8D%87%E6%96%87%E5%AD%97%E7%95%99%E5%AD%98%E7%8E%87/","summary":"如何提高自己的所编写的文字留存问题? 自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意. 然后就会把已经写下的文字和内容删除掉.","title":"提升文字留存率"},{"content":"2022 年度目标 提升自己的基础技术竞争力, 确保不会找不到工作\n精通 go 编程语言 精通 redis 精通 mysql 5 月份 OKR O:\n加深对 Go 语言的基础知识理解 熟悉 redis 的所有数据类型 KR:\n输出3篇高质量的 go 语言blog\nchannel module tools 数据 redis 所有数据类型总结博文一篇\n所有数据类型总结博文 6 月份 OKR 成为一个 golang 资深开发工程师\nGo GMP 调度总结博文 做一个部门内部的 GMP 调度培训 成为一个优秀的软件工程师\n微服务架构设计模式通读并完成博文输出 Mysql 表结构数据类型总结博文 成为一个独立的 apple 软件开发者\n开发一个 macos 蕃茄钟小程序雏形 总结 6 月份只完成了一项 微服务架构设计模式 书籍的阅读. 完成情况比较差.\n主要原因: 对设定的目标不够上心. 6月份对健身很感兴趣, 一心扑在了健身上了, 对于月初制定的计划也就淡忘了.\n7 月份 OKR O1: 首要目标, 还是要技术总结和输出 go 语言的基础知识, 成为一个 资深的 golang 开发者\ngo gmp 调度总结博文 map channel context 总结博文输出 Mysql 表结构数据类型总结博文 (6月份遗留) O2: 学习计算机基础知识\n学习 RabbitMQ 实战指南 (因为当前公司项目有用到相关的组件, 需要快速学习一下) 总结 docker 的基本使用 学习 unix 网络编程 卷一 O3: 保持健康, 保持阅读\n有 25 天完成, 每天阅读 4 番茄钟的. 每周 至少健身 4次. 总结 执行力不够. 每天制定目标早起, 前天晚上又要早睡. 再加上健身时间, 周一至周五非工作时间都已经排满了.\n周末, 执行力不够, 会比较懒散地趴在床上刷抖音, 刷视频之类的. 没有有效地利用时间, 导致制定的计划都完不成.\n8 月份 OKR O1: 高级 go 语言开发者\ngo gmp 调度总结博文 map, context 总结博文输出 O2: 补充计算机基础知识\nTree 数据结构类型 Mysql 表结构数据类型总结博文 (6月份遗留) Unix 网络编程 卷一 O3: 保持健康, 保持阅读\n有 25 天完成, 每天阅读 4 番茄钟的. 有 25 天完成, 当天的总结和第二天的规划. 每周有4点,8点半之前到公司 每周 至少健身 4次. 9 月份 OKR O1: 可以在自我介绍上写上 精通Go语言\ngo gmp 调度总结博文 map, context 总结博文输出 interface 深入学习 reflect 反射包使用 O2: 拓展知识\nMysql 表结构数据类型总结博文 (6月份遗留) O3: 保持健康, 保持阅读\n有 25 天完成, 每天阅读 4 番茄钟的. 每周有4点,8点半之前到公司 每周 至少健身 4次. ","permalink":"https://ynikl.github.io/okr/okr-2022/","summary":"2022 年度目标 提升自己的基础技术竞争力, 确保不会找不到工作\n精通 go 编程语言 精通 redis 精通 mysql 5 月份 OKR O:\n加深对 Go 语言的基础知识理解 熟悉 redis 的所有数据类型 KR:\n输出3篇高质量的 go 语言blog\nchannel module tools 数据 redis 所有数据类型总结博文一篇\n所有数据类型总结博文 6 月份 OKR 成为一个 golang 资深开发工程师\nGo GMP 调度总结博文 做一个部门内部的 GMP 调度培训 成为一个优秀的软件工程师\n微服务架构设计模式通读并完成博文输出 Mysql 表结构数据类型总结博文 成为一个独立的 apple 软件开发者\n开发一个 macos 蕃茄钟小程序雏形 总结 6 月份只完成了一项 微服务架构设计模式 书籍的阅读. 完成情况比较差.\n主要原因: 对设定的目标不够上心. 6月份对健身很感兴趣, 一心扑在了健身上了, 对于月初制定的计划也就淡忘了.\n7 月份 OKR O1: 首要目标, 还是要技术总结和输出 go 语言的基础知识, 成为一个 资深的 golang 开发者","title":"2022"},{"content":"工具分类 go build 编译源代码文件\n-race 编译出的目标程序，会启用数据竞争检测\ngo doc 查看包的文档(定义于doc.go的注释中), 于包中公开的函数签名\nexample\n1 2 3 go doc go doc encoding/json go env 查看 go 相关的环境变量\n1 2 3 4 5 # -w 设置环境变量 go env -w GOPAHT=\u0026#39;/some/path\u0026#39; # -u 恢复成默认设置 go env -u GOPATH go generate 扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”\n注释的指令格式\n//go:generate command argument...\nps: wire 也是利用命令, 生成依赖注入文件\ngo get 管理当前module依赖\n1 2 3 4 5 6 7 8 # 添加依赖包 go get example.com/pkg # 指定包版本 go get example.com/pkg@1.2.3 # 移除依赖 go get example.com/pkg@none go install 获取包文件，并编译和安装。可执行文件编译到$GOBIN路径下, 包文件编译到$GOPATH/pkg\ngo list 列出包的数据信息\ngo mod 管理 modules\n1 2 3 4 edit\t修改go.mod init\t初始化 tidy\t自动补全依赖包 vendor\t生成一个所有依赖的vendor文件夹 go test 跑单元测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 go test -v . # 指定函数 go test -run 函数名 # 性能测试 go test -v -bench . -benchtime 50s # 单元测试覆盖率 go test -cover # 强制重新跑测试, 不使用缓存的结果 source: https://stackoverflow.com/a/48882892/9992963 go test -count=1 go tool 1 2 # 不带参数，显示工具列表 go tool compile 使用go tool compile -N -l -S main.go生成汇编代码\n","permalink":"https://ynikl.github.io/blog/go-cmd/","summary":"工具分类 go build 编译源代码文件\n-race 编译出的目标程序，会启用数据竞争检测\ngo doc 查看包的文档(定义于doc.go的注释中), 于包中公开的函数签名\nexample\n1 2 3 go doc go doc encoding/json go env 查看 go 相关的环境变量\n1 2 3 4 5 # -w 设置环境变量 go env -w GOPAHT=\u0026#39;/some/path\u0026#39; # -u 恢复成默认设置 go env -u GOPATH go generate 扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”\n注释的指令格式\n//go:generate command argument...\nps: wire 也是利用命令, 生成依赖注入文件\ngo get 管理当前module依赖\n1 2 3 4 5 6 7 8 # 添加依赖包 go get example.","title":"Go 常用的命令汇总"},{"content":" whoami: 潜水员\n五流程序员 文字业余爱好者 目前在学 Go Redis 微服务设计模式 计算机技能 Go Redis Mysql Operating System Algorithm (basic) 想学习的技能 摄影 Bucket List 逃离办公室 去西藏 写一本书 ","permalink":"https://ynikl.github.io/me/","summary":" whoami: 潜水员\n五流程序员 文字业余爱好者 目前在学 Go Redis 微服务设计模式 计算机技能 Go Redis Mysql Operating System Algorithm (basic) 想学习的技能 摄影 Bucket List 逃离办公室 去西藏 写一本书 ","title":""},{"content":"Hugo 文章分类管理 文件夹 内容存放在content/目录下方, content/下方的子目录会形成资源URI,\n例如 content/blog/doc.md 文章访问目录即为 https//XXX.github.io/blog.doc.md\n分类管理 文章内容表述 (Front Matter) 使用进行分类, 默认只有tags\n1 2 3 tags: - Go - fast 可以在config添加自定的分类选项\n1 2 3 taxonomies: series: series category: categories 文章路径 类别 描述 地址 home 网站homepage /index.html page 指定页面 /post/页面/index.html section 分区 /section/index.html taxonomy 分类 /tags/index.html term 分类系列 /tags/go/index.html _index.md 和 index.md 在文件夹下方添加_index.md会识别成section. 在文件夹下方添加index.md会被识别成文章.\n千万不要在默认的content目录下方添加index.md\n","permalink":"https://ynikl.github.io/blog/hugo-%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/","summary":"Hugo 文章分类管理 文件夹 内容存放在content/目录下方, content/下方的子目录会形成资源URI,\n例如 content/blog/doc.md 文章访问目录即为 https//XXX.github.io/blog.doc.md\n分类管理 文章内容表述 (Front Matter) 使用进行分类, 默认只有tags\n1 2 3 tags: - Go - fast 可以在config添加自定的分类选项\n1 2 3 taxonomies: series: series category: categories 文章路径 类别 描述 地址 home 网站homepage /index.html page 指定页面 /post/页面/index.html section 分区 /section/index.html taxonomy 分类 /tags/index.html term 分类系列 /tags/go/index.html _index.md 和 index.md 在文件夹下方添加_index.md会识别成section. 在文件夹下方添加index.md会被识别成文章.\n千万不要在默认的content目录下方添加index.md","title":"Hugo 文章分类管理"}]