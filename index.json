[{"content":"背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致下游的 nginx 的连接数暴涨.\n问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client\n探索 在 StackOverflow 发现的相关答案\nHow to release http.Client in Go?\n给的答案是建议复用 Client\nThe Client\u0026rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.\nhttp.Client 的结构体\n1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time.Duration } 在 RoundTripper 中实现了连接复用的逻辑\n1 2 3 type RoundTripper interface { RoundTrip(*Request) (*Response, error) } 中定义了 RoundTrip 方法, 提供客户端请求的时候调用.\n调用地址\n查看一下 Golang Transport 的基本实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Transport struct { idleMu sync.Mutex closeIdle bool // user has requested to close all idle conns idleConn map[connectMethodKey][]*persistConn // most recently used at end idleConnWait map[connectMethodKey]wantConnQueue // waiting getConns idleLRU connLRU connsPerHostMu sync.Mutex connsPerHost map[connectMethodKey]int connsPerHostWait map[connectMethodKey]wantConnQueue // waiting getConns // 还有其他字段略 } 结构体中间有很多连接存储相关的字段.\n在 http 请求调用 Transport 中间有一个关键方法 getConn 获取一个连接\n方法声明一个想要的连接地址, wantConn 推入到 queueForDial\nQueueForDial 方法会判断时候connsPerHost 中间是否有当前的请求的缓存连接\n如果有直接拿来重复使用 如果没有, 就需要重新进行拨号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 w.beforeDial() if t.MaxConnsPerHost \u0026lt;= 0 { go t.dialConnFor(w) return } t.connsPerHostMu.Lock() defer t.connsPerHostMu.Unlock() if n := t.connsPerHost[w.key]; n \u0026lt; t.MaxConnsPerHost { if t.connsPerHost == nil { t.connsPerHost = make(map[connectMethodKey]int) } t.connsPerHost[w.key] = n + 1 go t.dialConnFor(w) return } if t.connsPerHostWait == nil { t.connsPerHostWait = make(map[connectMethodKey]wantConnQueue) } q := t.connsPerHostWait[w.key] q.cleanFront() q.pushBack(w) t.connsPerHostWait[w.key] = q 结论 重复使用 http.Client 可以达到 TCP 连接复用的效果\n","permalink":"https://ynikl.github.io/blog/golang-client-reuse/","summary":"背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致下游的 nginx 的连接数暴涨.\n问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client\n探索 在 StackOverflow 发现的相关答案\nHow to release http.Client in Go?\n给的答案是建议复用 Client\nThe Client\u0026rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.\nhttp.Client 的结构体\n1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time.","title":"Golang 是否需要为每个请求 New 一个 Client"},{"content":"查看负载 系统平均负载\n1 uptime 那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。 如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。\n查看内存信息 1 free -h 查看 cpu 型号\n1 cat /proc/cpuinfo | grep \u0026#39;physical id\u0026#39; | sort | uniq | wc -l 核数\n1 cat /proc/cpuinfo |grep \u0026#34;cores\u0026#34;|uniq|awk \u0026#39;{print $4}\u0026#39; 参考文章 https://www.eet-china.com/mp/a87720.html https://colobu.com/2019/02/22/how-to-find-cpu-cores-in-linux/ https://wangchujiang.com/linux-command/c/uptime.html ","permalink":"https://ynikl.github.io/blog/linux-server-device-info/","summary":"查看负载 系统平均负载\n1 uptime 那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。 如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。\n查看内存信息 1 free -h 查看 cpu 型号\n1 cat /proc/cpuinfo | grep \u0026#39;physical id\u0026#39; | sort | uniq | wc -l 核数\n1 cat /proc/cpuinfo |grep \u0026#34;cores\u0026#34;|uniq|awk \u0026#39;{print $4}\u0026#39; 参考文章 https://www.eet-china.com/mp/a87720.html https://colobu.com/2019/02/22/how-to-find-cpu-cores-in-linux/ https://wangchujiang.com/linux-command/c/uptime.html ","title":"查看 Linux 的负载情况"},{"content":"查看一个文件指定范围内的所有修改记录\n1 git log -p -2 -L1081,+5:\u0026#39;hello/world.go\u0026#39; -p -2 或者 --patch -2\n往前展示两个 commit 的 diff . 在 git 中 commit 和 patch 是同一个意思参考下文.\ngit commands patching\nA few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches.\n-L 语法 -L\u0026lt;start\u0026gt;,\u0026lt;end\u0026gt;:\u0026lt;file\u0026gt;, -L:\u0026lt;funcname\u0026gt;:\u0026lt;file\u0026gt;\n限制指定查看范围.\n","permalink":"https://ynikl.github.io/posts/git-view-change-log-in-specifie-line/","summary":"查看一个文件指定范围内的所有修改记录\n1 git log -p -2 -L1081,+5:\u0026#39;hello/world.go\u0026#39; -p -2 或者 --patch -2\n往前展示两个 commit 的 diff . 在 git 中 commit 和 patch 是同一个意思参考下文.\ngit commands patching\nA few commands in Git are centered around the concept of thinking of commits in terms of the changes they introduce, as though the commit series is a series of patches.\n-L 语法 -L\u0026lt;start\u0026gt;,\u0026lt;end\u0026gt;:\u0026lt;file\u0026gt;, -L:\u0026lt;funcname\u0026gt;:\u0026lt;file\u0026gt;\n限制指定查看范围.","title":"Git 查看文件指定范围的修改记录"},{"content":"代码整洁架构\n核心思想 最重要的是依赖顺序需要内收 \u0026ndash; 业务逻辑不能依赖框架\n分层 简单分层四层\nEntities Use Cases Interface Adapters Framework and Drivers Entity 实体抽象层 我的理解应该是在公司业务, 或者项目领域上对于业务模型的抽象. 不容易改变 (除非公司 业务, 或者项目方向改变). 应该是与 领域驱动设计 不谋而合\nUse Cases 使用场景层 业务使用场景, 应该是存放相关不同业务场景的具体实现流程\nInterface Adapters 接口转化器层 负责 Use Cases 数据 与外部使用数据转换器实现.\n比较特别的例子, 将 Use Cases 产生的数据与外部的 UI 表现层所需要的数据格式做转化.\nFramework and Divers 数据库和框架层, 外部工具包接口依赖之类的.\n依赖倒置 当遇到跨层依赖的时候, 内层需要引用到外层逻辑时: 比如, Use Case 要呈现 UI 数据结构 (Interface Adapters 层) 时, 不能直接引用 UI 层的数据模型.\n而是, 通过依赖倒置. 将 UI 层的处理逻辑, 注入 Use Case 层进行处理, 实现目标.\ngolang 整洁模板 引用自 golang clean template\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 ├─cmd 应用入口 │ └─app ├─config ├─docs // 存放文档 ├─internal │ ├─app │ ├─controller // 控制器 │ │ ├─amqp_rpc │ │ └─http │ │ └─v1 │ ├─entity // 实体层 │ ├─middleware // 中间件 │ └─usecase │ ├─repo // 数据库操作 │ └─webapi // RESTful API ├─migrations ├─pkg //以被外部程序安全导入的包 │ ├─crypto │ ├─httpresponse │ ├─httpserver │ ├─logger │ ├─mysql │ ├─postgres │ ├─rabbitmq │ └─redis 参考文章 结构架构介绍 the clean architecture goang clean template ","permalink":"https://ynikl.github.io/blog/clean-architectrue/","summary":"代码整洁架构\n核心思想 最重要的是依赖顺序需要内收 \u0026ndash; 业务逻辑不能依赖框架\n分层 简单分层四层\nEntities Use Cases Interface Adapters Framework and Drivers Entity 实体抽象层 我的理解应该是在公司业务, 或者项目领域上对于业务模型的抽象. 不容易改变 (除非公司 业务, 或者项目方向改变). 应该是与 领域驱动设计 不谋而合\nUse Cases 使用场景层 业务使用场景, 应该是存放相关不同业务场景的具体实现流程\nInterface Adapters 接口转化器层 负责 Use Cases 数据 与外部使用数据转换器实现.\n比较特别的例子, 将 Use Cases 产生的数据与外部的 UI 表现层所需要的数据格式做转化.\nFramework and Divers 数据库和框架层, 外部工具包接口依赖之类的.\n依赖倒置 当遇到跨层依赖的时候, 内层需要引用到外层逻辑时: 比如, Use Case 要呈现 UI 数据结构 (Interface Adapters 层) 时, 不能直接引用 UI 层的数据模型.\n而是, 通过依赖倒置. 将 UI 层的处理逻辑, 注入 Use Case 层进行处理, 实现目标.","title":"代码整洁架构"},{"content":"我为什么要读这本书? 检讨自己, 学习理财的相关知识\n曾经读完了 穷爸爸富爸爸 在那一段时间内有开始理财的想法, 后续又随的物欲的上涨, 开始过度超前消费, 让自己陷入了债务危机\n这本书怎样影响了我? 开始编写梦想日记和成功日记 理解了\u0026quot;鹅\u0026quot;的故事, 开始做储蓄, 划分支出 作为一个陷入\u0026quot;债务危机\u0026quot;的人的自救 72 小时定律: 决定做一件事情要在72个小时内完成 72 公式: 投资 / 年利率 = 本金翻一倍需要的年数; 通货膨胀价值减半需要的年数 书中的三句精华句子? “：“吉娅，你真的认真找过工作了吗？我是说，你有没有用一整个下午的时间来考虑如何挣到钱的问题呢？” \u0026ndash; 很多时候你觉得你思考过了, 但是你真的花费了足够的时间思考了吗? “他用一种恳切的目光望着我，说：“我生命中出现了最美好的东西，是因为我做了原本不敢做的事。” \u0026ndash; 确实如此, 要去尝试自己所不敢做的事情 总结本书 通俗易懂, 醍醐灌顶 陷入债务危机的人的自救方法\n销毁信用支付: 信用支付会比现金消费花的钱更多 尽可能少偿还贷款: 避免再次借贷, 弥补空缺 偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费. 书摘 “可是，这正是许多没有钱的人爱犯的错误。他们总是有那么多紧急的事情要做，以至于没有时间来关注重要的事情。”\n“钱钱对我点了点头，说：“困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟”\n理解重要不紧急的事情\n“很简单。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。” ”\n陷入债务危机的人的自救方法\n销毁信用支付: 信用支付会比现金消费花的钱更多 尽可能少偿还贷款: 避免再次借贷, 弥补空缺 偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费. “鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。”\n“我叹道：“要在‘鹅’和愿望之间作取舍真难！” “你根本不用放弃任何一个。两件事可以同时进行。”金先生微笑着说，“比如你挣了10马克，那么你可以分配一下这笔钱，把其中的大部分存入银行，然后把一部分放入你的梦想储蓄罐，剩下的当作零花钱。”\n“所有人都希望自己变得富有一些，只是有些人的这一愿望更为强烈，而有些人却假装自己满足于现在的生活。事实上，大多数人都希望自己更幸福、更成功，也想拥有更多的钱”\n“可是假如我们缺钱的话，钱就会变得格外重要。你回想一下那次我们差点淹死在河里的情形，当时我们想的只是必须从河里爬上来，其他的一切都变得无关紧要了”\n“中国的智者老子说过：‘天下难事，必作于易；天下大事，必作于细”\n“第一，我建议你拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。”\n“没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西”\n“但如果你的零花钱是现在的10倍的话，你的问题只会变得更加严重。因为我们的支出永远是随着我们的收入而增长的。”\n“第一，为别人解决一个难题，那么你就能赚到许多钱；第二，把精力集中在你知道的、能做的和拥有的东西上。”\n“：“吉娅，你真的认真找过工作了吗？我是说，你有没有用一整个下午的时间来考虑如何挣到钱的问题呢？”\n“情况顺利的时候，人人都能挣到钱。只有在逆境中，一切才能见分晓。”\n“可是有的时候，疯狂的念头确实比普通的小目标更容易实现。当你定下大目标的时候，就意味着你必须付出比别人多得多的努力。”\n“假如我总是花光我的钱，那我就永远也得不到我的‘鹅’，所以我就总得为了赚钱而工作。而一旦我有了一只‘鹅’，我的钱就会自动为我工作了。”\n“没有人能强迫你做你不愿意做的事情。只有你自己才能强迫自己去做。”\n“他用一种恳切的目光望着我，说：“我生命中出现了最美好的东西，是因为我做了原本不敢做的事。”\n“你就永远不会知道，给自己一些压力之后，你能够做到些什么。一个人觉得最引以为自豪的事情，往往是那些做起来最艰难的事情。这一点你千万不要忘记”\n挑选基金\n1．基金应该至少有10年历史。假如它在这么长时间内一直有丰厚的利润，那我们可以认为，未来它也会运作良好。 2．应该选择大型的跨国股票基金。这种基金在世界各地购买股票，以此分散风险，所以十分安全。 3．对基金的走势图进行比较。我们应该观察在过去10年间哪些基金的年终利润最好。\n“它的名字叫72公式。”老太太讲解说，“你们直接用72除以你们投资的年利润百分比，得出的数字就是这笔钱翻一倍所要的年数”\n“银行存折肯定不是保存钱的最合适的地方，金先生总是把银行存折叫作“吞钱机器”。”\n","permalink":"https://ynikl.github.io/books/ein-hund-namens-money/","summary":"我为什么要读这本书? 检讨自己, 学习理财的相关知识\n曾经读完了 穷爸爸富爸爸 在那一段时间内有开始理财的想法, 后续又随的物欲的上涨, 开始过度超前消费, 让自己陷入了债务危机\n这本书怎样影响了我? 开始编写梦想日记和成功日记 理解了\u0026quot;鹅\u0026quot;的故事, 开始做储蓄, 划分支出 作为一个陷入\u0026quot;债务危机\u0026quot;的人的自救 72 小时定律: 决定做一件事情要在72个小时内完成 72 公式: 投资 / 年利率 = 本金翻一倍需要的年数; 通货膨胀价值减半需要的年数 书中的三句精华句子? “：“吉娅，你真的认真找过工作了吗？我是说，你有没有用一整个下午的时间来考虑如何挣到钱的问题呢？” \u0026ndash; 很多时候你觉得你思考过了, 但是你真的花费了足够的时间思考了吗? “他用一种恳切的目光望着我，说：“我生命中出现了最美好的东西，是因为我做了原本不敢做的事。” \u0026ndash; 确实如此, 要去尝试自己所不敢做的事情 总结本书 通俗易懂, 醍醐灌顶 陷入债务危机的人的自救方法\n销毁信用支付: 信用支付会比现金消费花的钱更多 尽可能少偿还贷款: 避免再次借贷, 弥补空缺 偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费. 书摘 “可是，这正是许多没有钱的人爱犯的错误。他们总是有那么多紧急的事情要做，以至于没有时间来关注重要的事情。”\n“钱钱对我点了点头，说：“困难总是在不断地出现。尽管如此，你每天还是要不间断地去做对你的未来意义重大的事情。你为此花费的时间不会超过10分钟，但是就是这10分钟会让一切变得不同。大多数人总是在现有的水平上停滞不前，就是因为他们没有拿出这10分钟”\n理解重要不紧急的事情\n“很简单。当你决定做一件事情的时候，你必须在72小时之内完成，否则你很可能永远不会再做了。” ”\n陷入债务危机的人的自救方法\n销毁信用支付: 信用支付会比现金消费花的钱更多 尽可能少偿还贷款: 避免再次借贷, 弥补空缺 偿还消费贷款时: 也要保持着存款, 剩余可支配一半用于储蓄,一半用于消费. “鹅代表你的钱。如果你存钱，你就会得到利息。利息就相当于金蛋。”\n“我叹道：“要在‘鹅’和愿望之间作取舍真难！” “你根本不用放弃任何一个。两件事可以同时进行。”金先生微笑着说，“比如你挣了10马克，那么你可以分配一下这笔钱，把其中的大部分存入银行，然后把一部分放入你的梦想储蓄罐，剩下的当作零花钱。”\n“所有人都希望自己变得富有一些，只是有些人的这一愿望更为强烈，而有些人却假装自己满足于现在的生活。事实上，大多数人都希望自己更幸福、更成功，也想拥有更多的钱”\n“可是假如我们缺钱的话，钱就会变得格外重要。你回想一下那次我们差点淹死在河里的情形，当时我们想的只是必须从河里爬上来，其他的一切都变得无关紧要了”\n“中国的智者老子说过：‘天下难事，必作于易；天下大事，必作于细”\n“第一，我建议你拿一本相册作为你的梦想相册。收集一些与自己的愿望有关的照片，把它们贴在相册里。我们要通过图片来思考。”\n“没有想象力的人是很难成就大事的。我们对一件事投入的精力越多，成功的可能性也越大。可是大多数人把精力放在自己并不喜欢的事情上，而不去想象自己希望得到的东西”","title":"小狗钱钱"},{"content":"使用场景 写个demo, 想查看一下程序内部的内存占用情况.\n使用方法 主角 runtime 包\n对象 MemStats 方法 ReadMemStats demo 展示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(\u0026amp;m) // For info on each, see: https://golang.org/pkg/runtime/#MemStats fmt.Printf(\u0026#34;Alloc = %v MiB\u0026#34;, bToMb(m.Alloc)) fmt.Printf(\u0026#34;\\tTotalAlloc = %v MiB\u0026#34;, bToMb(m.TotalAlloc)) fmt.Printf(\u0026#34;\\tSys = %v MiB\u0026#34;, bToMb(m.Sys)) fmt.Printf(\u0026#34;\\tNumGC = %v\\n\u0026#34;, m.NumGC) } 代码出处\n解释 ReadMemStats runtime.ReadMemStats 方法会读取到内存分配器的当前时刻最新的内存分配数据, 并将 其填充到传入参数的MemStats 的变量中.\n可以充当一个内存快照, 用于进行对比.\nMemStats 字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 type MemStats struct { // 当前堆上对象的内存分配大小, 同HeapAlloc字段, 单位 bytes Alloc uint64 // 历史总的累计分配内存大小 TotalAlloc uint64 // 从操作系统分配的内存大小 Sys uint64 // 记录指针索引性能, go 语言内部使用 Lookups uint64 // 堆上分配的对象数量 Mallocs uint64 // 堆上剩余的内存大小 Frees uint64 HeapAlloc uint64 // 从操作系统分配的 堆 内存大小 HeapSys uint64 // 未使用的空闲内存分片大小 spans HeapIdle uint64 // 使用中的内存分片大小 HeapInuse uint64 // 回退的内存大小 HeapReleased uint64 // 堆上分配的对象数量 HeapObjects uint64 // 栈上使用的内存片大小 StackInuse uint64 // 从操作系统分配的栈的内存大小 StackSys uint64 // MSpanInuse is bytes of allocated mspan structures. MSpanInuse uint64 // MSpanSys is bytes of memory obtained from the OS for mspan // structures. MSpanSys uint64 // MCacheInuse is bytes of allocated mcache structures. MCacheInuse uint64 // MCacheSys is bytes of memory obtained from the OS for // mcache structures. MCacheSys uint64 // BuckHashSys is bytes of memory in profiling bucket hash tables. BuckHashSys uint64 // GCSys is bytes of memory in garbage collection metadata. GCSys uint64 // OtherSys is bytes of memory in miscellaneous off-heap // runtime allocations. OtherSys uint64 // 在多大的堆内存时, 触发GC NextGC uint64 // 上次GC 时间 LastGC uint64 // PauseTotalNs is the cumulative nanoseconds in GC // stop-the-world pauses since the program started. // // During a stop-the-world pause, all goroutines are paused // and only the garbage collector can run. PauseTotalNs uint64 // PauseNs is a circular buffer of recent GC stop-the-world // pause times in nanoseconds. // // The most recent pause is at PauseNs[(NumGC+255)%256]. In // general, PauseNs[N%256] records the time paused in the most // recent N%256th GC cycle. There may be multiple pauses per // GC cycle; this is the sum of all pauses during a cycle. PauseNs [256]uint64 // PauseEnd is a circular buffer of recent GC pause end times, // as nanoseconds since 1970 (the UNIX epoch). // // This buffer is filled the same way as PauseNs. There may be // multiple pauses per GC cycle; this records the end of the // last pause in a cycle. PauseEnd [256]uint64 // GC 次数 NumGC uint32 // 手动调用 GC 的次数 NumForcedGC uint32 // GC 使用的 CPU 时间 GCCPUFraction float64 // 可以GC,一直是true EnableGC bool // BySize reports per-size class allocation statistics. // // BySize[N] gives statistics for allocations of size S where // BySize[N-1].Size \u0026lt; S ≤ BySize[N].Size. // // This does not report allocations larger than BySize[60].Size. BySize [61]struct { // Size is the maximum byte size of an object in this // size class. Size uint32 // Mallocs is the cumulative count of heap objects // allocated in this size class. The cumulative bytes // of allocation is Size*Mallocs. The number of live // objects in this size class is Mallocs - Frees. Mallocs uint64 // Frees is the cumulative count of heap objects freed // in this size class. Frees uint64 } } 源码出处\n我用于分析 map 的 delete 操作占用内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import ( \u0026#34;fmt\u0026#34; \u0026#34;runtime\u0026#34; ) func main() { m := make(map[string][]int) m[\u0026#34;a\u0026#34;] = make([]int, 1*1024*1024*1024) PrintMemUsage() delete(m, \u0026#34;a\u0026#34;) runtime.GC() PrintMemUsage() fmt.Println(\u0026#34;make storage value\u0026#34;) mint := make(map[int]int, 1\u0026lt;\u0026lt;30) for i := 0; i \u0026lt; 1*1024*2; i++ { mint[i] = 1024 } PrintMemUsage() runtime.GC() PrintMemUsage() // 注意: 需要引用, 避免被提前回收 fmt.Println(len(m), len(mint)) // go run main.go // Outpu: // // Alloc = 8192 MiB\tTotalAlloc = 8192 MiB\tSys = 8464 MiB\tNumGC = 0 // Alloc = 0 MiB\tTotalAlloc = 8192 MiB\tSys = 8465 MiB\tNumGC = 2 // make storage value // Alloc = 39168 MiB\tTotalAlloc = 47360 MiB\tSys = 48898 MiB\tNumGC = 3 // Alloc = 39168 MiB\tTotalAlloc = 47360 MiB\tSys = 48898 MiB\tNumGC = 4 // 0 2048 } func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(\u0026amp;m) // For info on each, see: https://golang.org/pkg/runtime/#MemStats fmt.Printf(\u0026#34;Alloc = %v MiB\u0026#34;, bToMb(m.Alloc)) fmt.Printf(\u0026#34;\\tTotalAlloc = %v MiB\u0026#34;, bToMb(m.TotalAlloc)) fmt.Printf(\u0026#34;\\tSys = %v MiB\u0026#34;, bToMb(m.Sys)) fmt.Printf(\u0026#34;\\tNumGC = %v\\n\u0026#34;, m.NumGC) } 分析结果得出, 如果在 map 中存储的 value, 如果是引用值的话, 占用的内存是被 GC 回收 的. 但是, 如果是值类型如简单的int是不会被回收的.\n","permalink":"https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/","summary":"使用场景 写个demo, 想查看一下程序内部的内存占用情况.\n使用方法 主角 runtime 包\n对象 MemStats 方法 ReadMemStats demo 展示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(\u0026amp;m) // For info on each, see: https://golang.","title":"go 使用 runtime 包进行内存占用分析"},{"content":"概括 我为什么要读这本书? 养成一个批判性的看待问题方式.\n这本书怎样影响了我? 了解了一些常见的经典辩证错误, 比如: 人身攻击, 虚假两难, 完美解决方案 看待一个问题之前, 要想想这个问题, 关我什么事. 对于一些问题的论述会更加注意和小心 书中的三句精华句子? 一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？” 结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。 常见的谬论\n人身攻击谬误（ad hominem fallacy）: 人身攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。 滑坡谬误: 指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件发生。 追求完美解决方案谬误: 指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种解决方案根本就不应该采用。 偷换概念谬误:一旦你看到一个关键词或短语在论证中不止一次出现，检查一下看看其意思有没有发生改变，如果意思发生改变，就要警惕偷换概念谬误。 权威谬误: 除非我们知道这些权威对这一论题拥有特别的专门知识，否则我们就要将这个理由视为谬误。这种类型的谬误叫做诉诸可疑权威谬误（appeal to questionable authority fallacy）。 虚假的两难选择: 世界上只有两种人——一种人表演，另一种人观看。” 要让这样的陈述成立，我们必须假设只有这两种选择，是不是这样呢？当然不是！作者创造了一种虚假的两难选择（false dilemma）。 乱扣帽子谬误: 当有人宣称他们发现了导致某个行为的原因，而实际上他们所做的不过是为这种行为起了个名字而已，我们要对这种乱扣帽子谬误[7]（explaining by naming fallacy）保持警惕。 循环论证谬误[1]（begging the question fauacy）。 错误类比谬误指有人提出一个类比，其中却存在重要而又相关的不同点。 过度简化因果关系谬误: 如果持论者不能考虑到各种原因的复杂性，他们就犯了过度简化因果关系谬误[1]（causal oversimplication fallacy）。 事后归因谬误[1]（全称为\u0026quot;post hoc, ergo propter hoc fallacy\u0026quot;，拉丁文的意思是“在这之后，所以是因为这个的谬误”。） 三句话总结本书 书摘 一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？”\n小贴士：价值观指的是人们认为较有价值而没有明说出来的观点。它们树立了一定的行为准则，据此我们来衡量人类行为的品质高下。\n一厢情愿的思维之所以常常挥之不去，是因为我们否认一切的思维方式常常出现。\n描述性论题是指对过去、现在或将来的各种描述的精确与否提出的问题。\n我们将这些问题称为规定性论题（prescriptive issues）。社会论争通常都属于规定性论题。\n问一问“作者是在对什么事件进行回应”常常能帮你找出一篇文章的中心论题。\n但是，当论题并没有直截了当地说出来时，最有效的方法就是先找准结论。很多情况下，在你能确认论题之前都得先找出结论来。\n结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。\n结论是作者或演说者希望你选择的目的地和终点站。接下来你所关心的是：基于支撑这一论断的所有材料，我该不该接受这个结论？\n有没有一个清楚明确的论题，通常是区别作家成熟不成熟的一个重要标志。\n如果你写作或者演说的目的是为了传达某个特定的结论，你的读者或听众就会尽力去寻找这一结论。老老实实地把结论说出来，而且说得清楚明白，其实也就是在帮助你的读者或听众。\n请记住：只有当你找到支撑结论的理由时你才能判定一个结论的价值。\n·论证必有其目的。\n最后一点需要进一步加以强调和说明。心急火燎地去推进批判性思维并没有什么意义。\n在规定性论证中，理由常常不是一般性的规定性陈述就是描述性的看法或原则。\n相反，一个关心批判性思维的作者会考虑到可能存在的种种理由并掂量它们的分量，然后才会做出结论。\n如果你的论题是利用当前时事来探究政治或社会问题，比如公立教育改革或反恐战争，那就应当从主要的新闻出版物着手。\n我们在读书或听讲的时候，一定要强迫自己去寻找那些意思不明确的词或短语，否则你就会抓不住要领。\n事实上，很多文献，如美国宪法，都是有意要显得模棱两可，这样这份文献才能与时俱进，其中的关键词如“自由”、“携带武器”的不同含义才能适应不断发展的现实需求。诚然，\n因为有人要你接受他的结论，所以你只需要去寻找那些影响你接受其结论的词或短语。这样说来，你应该在理由和结论中寻找这些词或短语。\n一个词或短语越抽象，人们越有可能对其做出多重解读。\n第一个障碍是你自认为和作者表达的是同一个意思。\n意义通常表现为下列三种方式：同义替换、举例说明以及我们通称的“具体标准定义”（\n还有一种方法可以帮你发现这个词可能存在的其他含义，那就是尽量在脑海中想象这个词所代表的具体景象，如果你想象不出来，那你很可能就找到了一处重要的歧义。\n那些激发强烈情感反应的术语被称为附加感情色彩的术语（loaded terms）。它们感动我们的能力大大超越了它们本身的描述性含义。\n作为一个积极主动的学生，你有责任提出各种问题来消除歧义。但你的责任到此为止。作者和演说者才是努力要说服你接受某些观点的人。身为说客，他有责任回答你对可能存在的歧义的各种关心。 你没有义务来评价那些不明确的想法或选择。\n我们把这些没有明说出来的想法称为假设（assumptions）。\n人的价值观会影响他列举出的种种理由，因而也影响到他的结论。实际上，只有把这些价值观假设添加到推理中，他们的理由才能从逻辑上证实其结论。\n当作者对于社会论争采取了一种立场，他们通常都会选择一种价值观而排斥另一种价值观，他们有价值优先或者价值倾向。\n找到价值观假设一个比较好的起点就是检查一下作者的背景。\n因此，要判断一个人的价值观假设，一个重要手段就是要注意他用来证实结论的各种理由，然后判断哪些价值取向会导致作者认为这些理由比其他理由更可取，\n遇到有争议的主题，以这种方式说明价值观假设可以不断提醒自己作者放弃了什么，又得到了什么。\n遇到有争议的主题，以这种方式说明价值观假设可以不断提醒自己作者放弃了什么，又得到了什么。尽量抵制住诱惑，不要一找到作者或演说者的价值观就过早地停止分析的过程。\n任何一个想要进行论证的人都有必要提供一些解释，说明为什么你应该接受那个论证中暗含的特定的价值观假设。\n价值取向需要有一定的正当理由，这样批判性思考的人才能加以考虑。一个价值取向需要有证实它的理由，正如任何一个结论都需要理由一样。\n描述性假设（descriptive assumption）就是对这个世界过去、现在或未来是什么样的想法，而你应该记得，规定性的或者说价值观假设是关于这个世界应该是什么样的那些想法。\n不断思考结论和理由之间存在的鸿沟。你为什么一开始就要寻找这些假设呢？因为你想让自己能判断理由在多大程度上证实结论。\n批判性阅读和聆听的主要目标就在于判定结论的可接受程度或者价值大小。\n所谓谬误，就是推理中的欺骗手段，作者有可能利用这个欺骗手段来说服你采纳其结论。\n人身攻击谬误（ad hominem fallacy）: 人身攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。 滑坡谬误: 指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件发生。 追求完美解决方案谬误: 指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种解决方案根本就不应该采用。 偷换概念谬误:一旦你看到一个关键词或短语在论证中不止一次出现，检查一下看看其意思有没有发生改变，如果意思发生改变，就要警惕偷换概念谬误。 权威谬误: 除非我们知道这些权威对这一论题拥有特别的专门知识，否则我们就要将这个理由视为谬误。这种类型的谬误叫做诉诸可疑权威谬误（appeal to questionable authority fallacy）。 虚假的两难选择: 世界上只有两种人——一种人表演，另一种人观看。” 要让这样的陈述成立，我们必须假设只有这两种选择，是不是这样呢？当然不是！作者创造了一种虚假的两难选择（false dilemma）。 乱扣帽子谬误: 当有人宣称他们发现了导致某个行为的原因，而实际上他们所做的不过是为这种行为起了个名字而已，我们要对这种乱扣帽子谬误[7]（explaining by naming fallacy）保持警惕。 循环论证谬误[1]（begging the question fauacy）。 错误类比谬误指有人提出一个类比，其中却存在重要而又相关的不同点。 过度简化因果关系谬误: 如果持论者不能考虑到各种原因的复杂性，他们就犯了过度简化因果关系谬误[1]（causal oversimplication fallacy）。 事后归因谬误[1]（全称为\u0026quot;post hoc, ergo propter hoc fallacy\u0026quot;，拉丁文的意思是“在这之后，所以是因为这个的谬误”。） 当我们被要求解释为什么特定的行为会发生时，我们常常受到诱惑，想要隐藏我们对很多复杂因果关系的无知，干脆给那种行为贴上个标签或者套上个名字，然后我们错误地假设因为我们知道那个标签或名字，我们就知道事情的起因。\n如果需要证据，但又没有看到证据，那么这个断言就是孤立论断（mere assertion），意思是它是一个没有用任何方式来加以证实的断言。\n与其问一问它们是不是真的，我们宁愿问问它们是不是可靠。其实，我们想问的是：“我们可以依靠这样的看法吗？”\n因为单一的个人经历，甚至是个人经历的总和，根本不足以构成一个有代表性的经历样本，个人经历常常会导致我们犯下以偏概全谬误[1]（hasty generalization fallacy）。\n典型案例常常很有说服力，因为它们是那样具体生动而又细致感人，很容易就在我们的脑海里浮现出来。\n引用具体当事人的这些说法都被称为当事人证词（personal testimonials）。\n我们常常说眼见为实，这里则倒过来，相信什么就看得见什么！\n引用另一家通讯社（如美联社）。这些引证给人一种支撑证据的幻象但是却绕过了一个最基本的问题：那个原始专家的断言到底有多大可信度？\n观察者，不像特定的镜子，并不能给我们提供“纯粹”的观察。我们所“见”所说的都是经过一系列的价值观、偏见、态度和期望值过滤后剩下来的东西。\n最后，调查本身所包含的很多偏见让它们变得更加可疑。其中两个最重要的偏见是措辞偏见（biased wording）和语境偏见（biased context）。\n当我们因为朋友的极力推荐而选择买下一张CD，我们也是在以相同的方式进行推理。我们这样推理是因为我们彼此之间非常相像，喜欢或不喜欢的东西有很多都是相同的，\n当类比用于设定谈话的语气时，识别它们就变得尤其重要。\n过度情绪化的类比遮蔽了论证中的真正论题，而且阻碍了实质性的对话。尽量识别包含了重要的情感内涵意义的那些比较，这样做才能避免受这些类比的欺骗。\n在寻找替代原因时，我们必须要记住，我们找出的任何一个单独的原因都极有可能是引起事件发生的其中一个原因，而不是其唯一的原因。\n将因果关系和相关关系二者混淆起来，既可以理解，同时又异常危险。虽然原因确实先于结果出现，但先于结果出现的还有很多种其他因素，而其中很多不是引发结果的原因。\n有一种常见的偏见就是基本归因错误（fundamental attribution error），在这种错误里，我们在解释他人的行为时普遍高估了个人倾向的重要性而低估了环境因素的作用。也就是说，我们喜欢把别人行为的动因看成是来自其内部因素的作用（他们个人的性格特点），而不是来自外部因素的作用（环境的力量）。\n你应该时时刻刻向读者证明你并没有忽略其他可选的解释。也许随着你的研究的展开，你发现貌似言之成理的解释实际上并不能被证据所证明。\n第一个策略就是尽量找到足够多的关于这些数据是如何采集的信息。\n作者谈论的是平均数、中位数还是众数，将会产生很大的区别。\n另一个重要的有可能缺失掉的信息类型是相对比较（relevant comparisons）。\n因此，真正的自主思考需要我们坚持不懈地寻找作者到底隐瞒了什么信息，不论其是无心省略还是有意隐瞒。\n我们从理由当中得出不同的结论是因为我们的背景各不相同，目标千差万别，这样我们在决定将理由和结论连起来的时候必然会被不同的假设所吸引。\n","permalink":"https://ynikl.github.io/books/asking-the-right-questions/","summary":"概括 我为什么要读这本书? 养成一个批判性的看待问题方式.\n这本书怎样影响了我? 了解了一些常见的经典辩证错误, 比如: 人身攻击, 虚假两难, 完美解决方案 看待一个问题之前, 要想想这个问题, 关我什么事. 对于一些问题的论述会更加注意和小心 书中的三句精华句子? 一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？” 结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。 常见的谬论\n人身攻击谬误（ad hominem fallacy）: 人身攻击谬误指针对个人的人身攻击或侮辱，而不是直接反驳其提供的理由。 滑坡谬误: 指假设采取提议的行动会引发一系列不可控的不利事件，而事实上却有现成的程序来防止这类连锁事件发生。 追求完美解决方案谬误: 指假设因为尝试某种解决方案后还有遗留问题未解决，那么这种解决方案根本就不应该采用。 偷换概念谬误:一旦你看到一个关键词或短语在论证中不止一次出现，检查一下看看其意思有没有发生改变，如果意思发生改变，就要警惕偷换概念谬误。 权威谬误: 除非我们知道这些权威对这一论题拥有特别的专门知识，否则我们就要将这个理由视为谬误。这种类型的谬误叫做诉诸可疑权威谬误（appeal to questionable authority fallacy）。 虚假的两难选择: 世界上只有两种人——一种人表演，另一种人观看。” 要让这样的陈述成立，我们必须假设只有这两种选择，是不是这样呢？当然不是！作者创造了一种虚假的两难选择（false dilemma）。 乱扣帽子谬误: 当有人宣称他们发现了导致某个行为的原因，而实际上他们所做的不过是为这种行为起了个名字而已，我们要对这种乱扣帽子谬误[7]（explaining by naming fallacy）保持警惕。 循环论证谬误[1]（begging the question fauacy）。 错误类比谬误指有人提出一个类比，其中却存在重要而又相关的不同点。 过度简化因果关系谬误: 如果持论者不能考虑到各种原因的复杂性，他们就犯了过度简化因果关系谬误[1]（causal oversimplication fallacy）。 事后归因谬误[1]（全称为\u0026quot;post hoc, ergo propter hoc fallacy\u0026quot;，拉丁文的意思是“在这之后，所以是因为这个的谬误”。） 三句话总结本书 书摘 一寸光阴一寸金，在决定花大把光阴去客观评估一个问题之前，最好先问一下自己：“这个问题关我什么事？”\n小贴士：价值观指的是人们认为较有价值而没有明说出来的观点。它们树立了一定的行为准则，据此我们来衡量人类行为的品质高下。\n一厢情愿的思维之所以常常挥之不去，是因为我们否认一切的思维方式常常出现。\n描述性论题是指对过去、现在或将来的各种描述的精确与否提出的问题。\n我们将这些问题称为规定性论题（prescriptive issues）。社会论争通常都属于规定性论题。\n问一问“作者是在对什么事件进行回应”常常能帮你找出一篇文章的中心论题。\n但是，当论题并没有直截了当地说出来时，最有效的方法就是先找准结论。很多情况下，在你能确认论题之前都得先找出结论来。\n结论是一个个观点，需要其他观点来进行支撑。因此，如果有人断言某件事是正确的，或者某件事应该去做，却没有提供相应陈述来支撑他的这一断言，这一断言就不能称为结论，因为提出此断言的人并没有提供这个看法得以建立的任何基础。相应地，我们把没有证据支撑的断言称为纯观点（mere opinion）。\n结论是作者或演说者希望你选择的目的地和终点站。接下来你所关心的是：基于支撑这一论断的所有材料，我该不该接受这个结论？","title":"Asking the Right Questions"},{"content":" 吾本乘兴而行，兴尽而返，何必见戴\n\u0026ndash; 世说新语·任诞\n我本来是乘着一时高兴而来，现在兴尽就返回家，为什么非得见到戴逵呢？\n","permalink":"https://ynikl.github.io/notes/20221109/","summary":"吾本乘兴而行，兴尽而返，何必见戴\n\u0026ndash; 世说新语·任诞\n我本来是乘着一时高兴而来，现在兴尽就返回家，为什么非得见到戴逵呢？","title":"20221109"},{"content":"5 代码整洁结构 内部不应该依赖外部, 业务逻辑的实现, 不应该依赖于框架\n","permalink":"https://ynikl.github.io/notes/202212/","summary":"5 代码整洁结构 内部不应该依赖外部, 业务逻辑的实现, 不应该依赖于框架","title":"20221109"},{"content":"文件系统原理 BIOS：启动主动运行的韧体，会认识第一个可启动的装置 MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序； 启动管理程序(boot loader)：一支可读取核心文件来运行的软件； 相关命令 查看磁盘信息 1 fdisk -l macOS\n1 diskutil list 查看磁盘用量\n1 df -h 查看文件大小\n1 du -h 新磁盘的安装流程 对磁盘进行分割，以创建可用的 partition ； 对该 partition 进行格式化( format )，以创建系统可用的 filesystem； 在 Linux 系统上，需要创建挂载点 ( 亦即是目录 )，并将他挂载上来； 操作磁盘分区, fdisk 后面跟具体的物理磁盘\n1 fdisk /dev/hdc 创建一个ext4文件系统\n1 mkfs -t ext4 /dev/vdb1 挂载磁盘分区\n1 2 mkdir /mnt/hdc6 mount /dev/hdc6 /mnt/hdc6 参考 Linux 磁盘与文件系统管理\n","permalink":"https://ynikl.github.io/posts/linux-filesystem/","summary":"文件系统原理 BIOS：启动主动运行的韧体，会认识第一个可启动的装置 MBR：第一个可启动装置的第一个磁区内的主要启动记录区块，内含启动管理程序； 启动管理程序(boot loader)：一支可读取核心文件来运行的软件； 相关命令 查看磁盘信息 1 fdisk -l macOS\n1 diskutil list 查看磁盘用量\n1 df -h 查看文件大小\n1 du -h 新磁盘的安装流程 对磁盘进行分割，以创建可用的 partition ； 对该 partition 进行格式化( format )，以创建系统可用的 filesystem； 在 Linux 系统上，需要创建挂载点 ( 亦即是目录 )，并将他挂载上来； 操作磁盘分区, fdisk 后面跟具体的物理磁盘\n1 fdisk /dev/hdc 创建一个ext4文件系统\n1 mkfs -t ext4 /dev/vdb1 挂载磁盘分区\n1 2 mkdir /mnt/hdc6 mount /dev/hdc6 /mnt/hdc6 参考 Linux 磁盘与文件系统管理","title":"Linux 文件系统简单操作流程"},{"content":"原文: Minimal Version Selection\n意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.\n翻译: Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list). 为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持 编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.\n版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:\n构建当前的编译列表 升级所有模块到各自对应的最新版本 升级一个模块到对应的版本 降级一个模块到对应的版本 最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进 行升级, 降级, 添加或者移除模块.\n这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易 理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖 是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只 用了几行 go 的代码就是实现了.\n最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵 守语义化版本: 向前兼容的版本使用小版本号, 不向前兼容的版本使用大版本号.\n对应的四种列表操作:\n构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份. 升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表 升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入 时如果如果已经存在, 就是仅保存最新的版本 降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标 模块版本之下 这些操作简单, 高效, 且容易实现\n剩余内容 略\n","permalink":"https://ynikl.github.io/blog/golang-minimal-version-selection/","summary":"原文: Minimal Version Selection\n意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.\n翻译: Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list). 为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持 编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.\n版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:\n构建当前的编译列表 升级所有模块到各自对应的最新版本 升级一个模块到对应的版本 降级一个模块到对应的版本 最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进 行升级, 降级, 添加或者移除模块.\n这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易 理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖 是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只 用了几行 go 的代码就是实现了.\n最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵 守语义化版本: 向前兼容的版本使用小版本号, 不向前兼容的版本使用大版本号.\n对应的四种列表操作:\n构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份. 升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表 升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入 时如果如果已经存在, 就是仅保存最新的版本 降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标 模块版本之下 这些操作简单, 高效, 且容易实现","title":"Golang Minimal Version Selection 意识流翻译(仅开头)"},{"content":"遇到了 grpc 不遵循语义版本, 导致不同版本包之间的冲突.\n更新了目标的版本模块之后, 编译一下就发现原先项目引用的 gozero 框架报错了. 搜索一下 相关的关键词,就可以定位到问题是 grpc 搞的鬼.\n再找到对应的兼容版本, 升级到对应的版本就可以了.\ngo 依赖版本选择 [golang 的最小版本选择]https://ynikl.github.io/blog/golang-minimal-version-selection/\n大体意思:\n会选择当前编译需要依赖包的最高版本(使用语义化版本)\n寻找依赖的原因 go mod why\n寻找自己项目引用某个包的 最短引用路径, 导致会引用目标包的\n1 go mod why google.golang.org/grpc 输出目标包的引用依赖层级\n1 2 3 4 5 6 ❯ go mod why google.golang.org/grpc # google.golang.org/grpc hello/world/test git.test.cn/company-open/rpc-pkgs google.golang.org/grpc go mod graph\n可以打印出, 模块的依赖图\n1 2 3 4 5 6 example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example.com/b@v1.2.0 example.com/c@v1.2.0 ","permalink":"https://ynikl.github.io/blog/golang-find-module-conflict/","summary":"遇到了 grpc 不遵循语义版本, 导致不同版本包之间的冲突.\n更新了目标的版本模块之后, 编译一下就发现原先项目引用的 gozero 框架报错了. 搜索一下 相关的关键词,就可以定位到问题是 grpc 搞的鬼.\n再找到对应的兼容版本, 升级到对应的版本就可以了.\ngo 依赖版本选择 [golang 的最小版本选择]https://ynikl.github.io/blog/golang-minimal-version-selection/\n大体意思:\n会选择当前编译需要依赖包的最高版本(使用语义化版本)\n寻找依赖的原因 go mod why\n寻找自己项目引用某个包的 最短引用路径, 导致会引用目标包的\n1 go mod why google.golang.org/grpc 输出目标包的引用依赖层级\n1 2 3 4 5 6 ❯ go mod why google.golang.org/grpc # google.golang.org/grpc hello/world/test git.test.cn/company-open/rpc-pkgs google.golang.org/grpc go mod graph\n可以打印出, 模块的依赖图\n1 2 3 4 5 6 example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example.","title":"Golang 解决依赖包版本冲突"},{"content":"学习路径 数据结构 流程控制 代码组织 工程化 数据结构 strings int list tuple dictionary 如何查看一个基本的类型对象拥有的方法\n1 2 3 name = \u0026#34;ada\u0026#34; dir(name) dir 获取对象的属性\n字符串 1 name = \u0026#34;ada lovelace\u0026#34; 拼接, 用+\n1 2 3 first_name = \u0026#34;ada\u0026#34; last_name = \u0026#34;lovelace\u0026#34; full_name = first_name + \u0026#34; \u0026#34; + last_name 声明字符串中 '单引号和\u0026quot; 双引号没有区别, 可以用来相互替换 多行字串使用'''连续三个单引号或双引号声明 字符串格式化\nformat\n1 2 3 \u0026gt;\u0026gt;\u0026gt; \u0026#39;Hey {name}, there is a 0x{errno:x} error!\u0026#39;.format( ... name=name, errno=errno) \u0026#39;Hey Bob, there is a 0xbadc0ffee error!\u0026#39; \u0026lsquo;f\u0026rsquo;string 模版\n1 2 \u0026gt;\u0026gt;\u0026gt; f\u0026#39;Hello, {name}!\u0026#39; \u0026#39;Hello, Bob!\u0026#39; 数字 整数 : 不带小数点 浮点数 : 带小数点, 存在精度问题 操作符\n+ - * \\ % 与字符串的转换:\nstr() 数字转化成字符串 int() 字符串转化成整数 float() 字符串转化成浮点数 逻辑 布尔值\nTrue False 与或非\nand or not 比较\n== != \u0026lt;= =\n\u0026lt; 转化\nbool(1) // True bool(\u0026quot;\u0026quot;) // False 列表 创建 声明\n1 people = [\u0026#39;alice\u0026#39;, \u0026#39;fred\u0026#39;, \u0026#39;ian\u0026#39;] range\n1 2 3 4 5 for i in range(1, 5): print(i) // 直接创建一个数组 intList = list(range(1, 5) 列表解析\n1 squares = [ value * 2 for value in range(1, 11)] 切片\n1 newPeoples = people[:3] 操作 遍历\n1 2 for person in people: print(person) 元组 创建\n使用小括号创建, 创建之后内部值无法修改\n1 aTuple = (1, 3, 5) 遍历\n1 2 for a in aTuple: print(a) 字典 声明\n1 peopleCity = { \u0026#34;ian\u0026#34;:\u0026#34;xiamen\u0026#34;, \u0026#34;jinx\u0026#34;:\u0026#34;beijing\u0026#34;} 取值\n1 print(peopleCity[\u0026#34;ian\u0026#34;]) 存在修改, 不存在添加\n1 peopleCity[\u0026#34;newguy\u0026#34;] = \u0026#34;newcity\u0026#34; 删除\n1 del peopleCity[\u0026#34;ian\u0026#34;] 遍历\n1 2 3 for person, city in peopleCity.items(): print(person) print(city) 流程控制 if if\u0026hellip;else\u0026hellip;\n1 2 3 4 5 6 if True : print(\u0026#34;\u0026#34;) elif True: print(\u0026#34;if if \u0026#34;) else: print(\u0026#34;\u0026#34;) 判断是否在列表\n1 if person in people: 判断列表是否为空\n1 2 if people : print(\u0026#34;not empty\u0026#34;) 以下略:\nwhile break continue 代码组织 函数 定义 1 2 def func_name(): print(\u0026#34;function bdoy\u0026#34;) 普通形参 1 2 def greating(name, words): ... 关键字参数 1 greating(naem=\u0026#39;ian\u0026#39;, words=\u0026#39;hello\u0026#39;) 默认值 1 2 def greating(name, words=\u0026#39;hello\u0026#39;): ... 返回值 1 2 def getMeFive(): return 5 可变参数 1 2 def make_pizza(*toppings): ... 使用*表示可变参数, 内部生成一个元组传递到函数内部\n模块 模块为文件, 使用import导入模块, 假设有hello.py文件, 里有greating函数\n导入模块 1 2 3 import hello hello.greating() 不用写前缀\n1 from hello import * 导入函数 1 2 3 from hello import greating greating() 别名 函数\n1 from hello import greating as gt 模块\n1 import hello as ho 类 面向对象\n声明 1 2 3 4 5 6 7 8 9 10 class Dog(): def __init__(self, name, age): \u0026#34;\u0026#34;\u0026#34;初始化属性name和age\u0026#34;\u0026#34;\u0026#34; self.name = name self.age = age 6 def sit(self): \u0026#34;\u0026#34;\u0026#34;模拟小狗被命令时蹲下\u0026#34;\u0026#34;\u0026#34; print(self.name.title() + \u0026#34; is now sitting.\u0026#34;) 初始化函数 __init___\n指向自身引用 self\n实例化 1 2 3 4 5 my_dog = Dog(\u0026#34;kiki\u0026#34;, 3) my_dog.site() // 访问属性 print(my_dog.name) 访问不存在的属性, 会出错\n继承 1 2 3 class Car(): def __init__(self): 继承\n1 2 3 4 class ElectricCar(Car): def __init__(self): super().init() 从模块导入 与导入方法一致\n1 from dog import Dog 工程化 文件 1 wiht open(filename) as file_obj: json 转存和加载\njson.dump json.load 异常 捕获异常\n1 2 3 4 5 6 try: print(5/0) except ZeroDivisionError: pass else: ... 单元测试 继承 unittest\n1 2 3 4 5 6 7 8 9 ipmort unittest calss NameTestCase(unittest.TestCase): def test_func_name(self): // self.assertEqual() ... unittest.main() ","permalink":"https://ynikl.github.io/blog/python-basic-quick/","summary":"学习路径 数据结构 流程控制 代码组织 工程化 数据结构 strings int list tuple dictionary 如何查看一个基本的类型对象拥有的方法\n1 2 3 name = \u0026#34;ada\u0026#34; dir(name) dir 获取对象的属性\n字符串 1 name = \u0026#34;ada lovelace\u0026#34; 拼接, 用+\n1 2 3 first_name = \u0026#34;ada\u0026#34; last_name = \u0026#34;lovelace\u0026#34; full_name = first_name + \u0026#34; \u0026#34; + last_name 声明字符串中 '单引号和\u0026quot; 双引号没有区别, 可以用来相互替换 多行字串使用'''连续三个单引号或双引号声明 字符串格式化\nformat\n1 2 3 \u0026gt;\u0026gt;\u0026gt; \u0026#39;Hey {name}, there is a 0x{errno:x} error!\u0026#39;.format( ... name=name, errno=errno) \u0026#39;Hey Bob, there is a 0xbadc0ffee error!","title":"Python 基本语法快速学习"},{"content":"乐观锁和悲观锁 首先, 乐观锁和悲观锁和本身并不是一种具体锁.\n而是一种编程的并发控制思想. 原名应该叫做乐观并发控制(Optimistic concurrency control) 简称 OCC 和 悲观并发控制(Pessimistic Concurrency Control) 简称 PCC\n什么是锁 维基百科对锁的定义\nIn computer science, a lock or mutex (from mutual exclusion) is a synchronization primitive: a mechanism that enforces limits on access to a resource when there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy, and with a variety of possible methods there exists multiple unique implementations for different applications.\n简单表述一下: 锁是一个同步原语, 是一种控制访问资源的线程的手段\n乐观锁 乐观锁是对于要锁定的的访问资源或变量, 持有乐观的态度 \u0026ndash; 即在自己访问该变量的时候, 不会有其他线程来访问该变量.\n主要思想是在写入数据的时候, 对比一下, 当前变量的值是不是与自己取出来的时候是一致, 如果一致即表示着 数据没有被其他线程修改过\n有两种具体的策略\n版本号 CAS 版本号 在每一次对加锁数据进行修改时候的, 对版本号进行增加操作. 当回写的数据时候判断版本号 是否一致.\n如果保持一致, 才会继续进行操作.\nCAS 利用CPU硬件层面支持 \u0026ndash; 比较和写入两步为原子性. 直接对当前值进行判断, 是与取出的数 据一致. 一致才继续进行操作.\n利用CAS, 自增完成数字自增的伪代码\n1 2 3 4 5 6 7 8 function add(p: pointer to int, a: int) returns int done ← false while not done value ← *p // Even this operation doesn\u0026#39;t need to be atomic. done ← cas(p, value, value + a) return value + a 如果一直失败的话, cpu就会保持自旋 \u0026ndash; 对cpu算力消耗较大, 直至成功.\nABA 问题 在乐观锁中, 如果值没有变化, 它的背后含义代表该值没有对其他线程修改过.\n但是存在着这种情况.\n线程1, 取值 A 线程2, 取值 A 线程2, 修改 B 值 \u0026ndash; 成功 线程2, 取值 B, 再修改成 A \u0026ndash; 成功 线程1, 对比 A值, 一致 修改的对象值已经被其他对象修改过, 但又被修改成旧的值. 对于 ABA 问题有没有危害,要 看具体的业务场景\n如果使用版本号, 每一次修改值, 都增加版本号, 就可以避免该问题.\n悲观锁 悲观锁, 认为自己取值之后, 一定会有其他线程过来修改自己取值的对象. 采取保守策略 \u0026ndash; 直接对该数据进行锁定.\n按对数据的锁定类型, 可以分成两种锁:\n互斥锁 读写锁 互斥锁 对数据锁定期间, 不允许其他线程的访问 \u0026ndash; 读取也不允许. 其他线程只能等待当前的线程 执行完毕\n常见的即是各种语言自带的互斥锁.\n读写锁 数据锁定期间, 其他线程可以读取数据, 但是不能写入数据.\n常见的也是各种语言的读写锁.\n参考 乐观锁、悲观锁，这一篇就够了！ ABA问题 锁的定义 ","permalink":"https://ynikl.github.io/blog/cs-optimitic-concurrency-control/","summary":"乐观锁和悲观锁 首先, 乐观锁和悲观锁和本身并不是一种具体锁.\n而是一种编程的并发控制思想. 原名应该叫做乐观并发控制(Optimistic concurrency control) 简称 OCC 和 悲观并发控制(Pessimistic Concurrency Control) 简称 PCC\n什么是锁 维基百科对锁的定义\nIn computer science, a lock or mutex (from mutual exclusion) is a synchronization primitive: a mechanism that enforces limits on access to a resource when there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy, and with a variety of possible methods there exists multiple unique implementations for different applications.","title":"乐观锁和悲观锁"},{"content":"我的总结 对于功能, 业务, 代码逻辑, 不要只停留在表面, 要进一步地去思考为什么 保持开放的心态, 尊重他人的意见, 勇于承认自己的\u0026quot;不知道\u0026quot;. 去思考他人为什么这么想 保持学习, 拥抱变化 有时间观念, 把控项目进度. 控制有规律的开发节奏, 不要让自己经常加班. 每天下班都能完成一天的任务. 让真正的软件用户做决策, 保持定期沟通, 让用户一直确认自己想要的东西 让工具替代人力, 实现自动化 控制代码质量, 简单, 清晰, 内聚 团队内部保持沟通 \u0026ndash; 站会, 及时反映变化. 遇到问题及时求救, 保持向上反馈. 不要辜负人家的预期 深入思考, 保持开发, 拥抱变化, 保持沟通, 注重质量, 保持学习, 自动化.\n书本原文 深度思考问题\n“拙劣的代码工人会这样不假思索地改完代码，然后快速转向下一个问题。 优秀的程序员会挖掘更深一层，尽力去理解为什么这里必须要加1，更重要的是，他会想明白会产生什么其他影响。”\n“在一本流行的管理图书《第五项修炼》中，作者建议，在理解一个问题的时候，需要渐次地问5个以上的“为什么”。这听起来就像退回到了4岁，那时对一切都充满着好奇。它是很好的方式，进一步挖掘简单直白的答案，通过这个路线，设想就会更加接近事实真相。”\n当你问“为什么”的时候，也许你会被反问：“为什么你问这个问题？”在提问之前，想好你提问的理由，这会有助于你问出恰当的问题。\n保持开发, 承认自己的不知道\n“这个，我不知道”是一个好的起点，应该由此进行更进一步的调查，而不应在此戛然结束。”\n“如果你对答案不满意，那么看看你是否可以改变问题。”\n“作为第1步的理解代码，往往是最难的。如果别人给你的代码很容易理解，接下来的工作就省心多了”\n尊重他人的意见\n“孤立非常危险，不要让开发人员完全孤立地编写代码（见第155页，习惯40）。如果团队成员花些时间阅读其他同事写的代码，他们就能确保代码是可读和可理解的，并且不会随意加入这些“+1或-1”的代码。阅读代码的频率越高越好。实行代码复审 ，不仅有助于代码更好理解，而且是发现bug最有效的方法之一。”\n“用Les Brown的一句话说就是：“你不需要很出色才能起步，但是你必须起步才能变得很出色。”\n“如果你是一个有远见的人，就一定要特别尊重别人的意见。你是一个掌舵者，一定要把握方向，深思熟虑，吸取各方的意见。”\n保持学习\n“谁会帮助你保持步伐前进呢？在一个企业化的社会中，只有一个人会为你负责——你自己。是否能跟上变化，完全取决于你自己”\n“跟踪技术变化 。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯”\n拥抱变化, 交付用户想要的软件\n“敏捷的根本之一就是拥抱变化。既然变化是永恒的，你有可能一直使用相同的技术和工具吗？”\n“真正的敌人是变化。软件开发如战争，形势的变化快速而又剧烈。固守昨天的计划而无视环境的变化会带来灾难。”\n“不要在前期做大量的设计”并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事”\n时间观念\n“许多的敏捷技巧来源于时间盒——设定一个短时的期限，为任务设定不能延长的最终期限。你可以选择放弃其他方面的任务，但是最终期限是不变的。你可能不知道完成所有的任务需要多少个时间盒，但每个时间盒必须是短期的、有限的，并且要完成具体的目标”\n“如果在你工作的时候没有一个固定的最终期限（例如一天的结束），就应该好好想想了。它会让你的工作有一个节奏，在每天下班的时候，提交所有的工作，开心地收工。这样，明天就能开始新的内容，解决下一系列难题”\n“有人说，上帝发明了时间，就是为了防止所有事情同时发生。因此我们需要更具远见，保持不同的开发节奏，这样敏捷项目的所有事情就不会突然同时发生，也不会随机发生，时间也不会不可预知。”\n让真正的用户做决策\n“记录客户做出的决定，并注明原因。好记性不如烂笔头”\n“不要随意假设低级别的问题不会影响他们的业务。如果能影响他们的业务，就是有价值的问题。”\n“因而，你只有一个选择：要么现在就让用户做决定，要么现在就开始开发，迟些让用户决定，不过要付出较高的成本。如果你在开发阶段回避这些问题，就增加了风险，但是你要能越早解决这些问题，就越有可能避免繁重的重新设计和编码。甚至在接近项目最终期限的时候，也能避免与日俱增的时间压力。”\n“开发者（及项目经理）能做的一个最重要的决定就是：判断哪些是自己决定不了的，应该让企业主做决定。你不需要自己给业务上的关键问题做决定。毕竟，那不是你的事情。如果遇到了一个问题，会影响到系统的行为或者如何使用系统，把这个问题告诉业务负责人”\n“没有人的思想和观点可以及时冻结，特别是项目的客户。就算是他们已经告诉你想要的东西了，他们的期望和想法还是在不停地进化——特别是当他们在使用新系统的部分功能时，他们才开始意识到它的影响和可能发生的问题。这就是人的本性。”\n“你生产出了他们曾经要求过的软件，但却不是他们现在真正想要的。那最后的结果就是：惊讶、震惊和失望，而不是满意。 ”\n分析技术的利弊\n“每一门技术都会有优点和缺点，无论它是开源的还是商业产品、框架、工具或者语言，一定要清楚它的利弊。”\n控制迭代\n“迭代开发是，在小且重复的周期里，你完成各种开发任务：分析、设计、实现、测试和获得反馈，所以叫作迭代”\n“每个工作日，每个团队成员会重新评估完成一个任务还需要多少小时。不管怎么样，只要所有任务的评估总和超过了一个迭代剩余的时间，那么任务就必须移到下一个迭代中开发”\n单元测试, 控制代码质量\n“单元测试能及时提供反馈 。你的代码会重复得到锻炼。但若修改或者重写了代码，测试用例就会检查你是否破坏了已有的功能。你可以快速得到反馈，并很容易地修复它们。\n单元测试让你的代码更加健壮 。测试帮助你全面思考代码的行为，帮你练习正面、反面以及异常情况。\n单元测试是有用的设计工具 。正如我们在实践20中谈论到的，单元测试有助于实现简单的、注重实效的设计。\n单元测试是让你自信的后台 。你测试代码，了解它在各种不同条件下的行为。这会让你在面对新的任务、时间紧迫的巨大压力之下，找到自信。\n单元测试是解决问题时的探测器 。单元测试就像是测试印制电路板的示波镜。当问题出现的时候，你可以快速地给代码发送一个脉冲信号。这为你提供[…]”\n“如果不是真正需要它的时候，你就不应该实现这个功能。基于这一点，现在还没有足够的理由表示你需要Player 这个类”\n“开发人员在完成任务时，可能会难以抵挡诱惑为节省时间而走“捷径”。然而，这些“捷径”往往只会推迟问题的爆发时间，而不是把它彻底解决掉”\n“项目是以增量式方式进行开发的，写程序时也应该进行增量式编程\n“源代码可以被读懂，不是因为其中的注释，而应该是由于它本身优雅而清晰——变量名运用正确、空格使用得当、逻辑分离清晰，以及表达式非常简洁。”\n“这时要扪心自问，是不是真的需要用它，以及它将如何帮你解决眼前的问题。问问自己，是不是特定的问题强迫你使用这个解决方案。不要让自己被迫进行过分设计，也不要将代码过分复杂化。”\n“内聚性用来评估一个组件（包、模块或配件）中成员的功能相关性。内聚程度高，表明各个成员共同完成了一个功能特性或是一组功能特性”\n成为自己产品的用户\n“很多成功的公司都是靠着“吃自己的狗食”活着。也就是说，如果要让你的产品尽可能地好，自己先要积极地使用它。”\n度量项目进度\n“所以，我们不应该去计算工作量完成的百分比，而应该测定还剩下多少工作量没有完成。如果你最初估计这个任务需要40个小时，在开发了35个小时之后，你认为还需要另外30个小时的工作。那就得到了很重要的度量结果（这里诚实非常重要，隐瞒真相毫无意义）。”\n“奇怪的是，它花费的时间很可能要比最初估计时间长。没有关系，我们希望这能作为下一次的参考。在为下一个任务估计工作量时，可以根据这次经验调整评估。如果你低估了一个任务，评估是2天，它最后花费了6天，那么系数就是3。除非是异常情况，否则你应该对下次估计乘以系数3。你的评估会波动一段时间，有时候过低估计，有时候过高估计。但随着时间的推移，你的评估会与事实接近，你也会对任务所花费的时间有更清楚的认识。”\n团队合作\n“既然整个团队都是项目工作的一部分，我们希望实行代码集体所有制 （见第155页），以保证任何团队成员的缺席不会对项目造成影响”\n“对于初学者来说，准备好后再共享代码才是有礼貌的做法（见第162页），这样才不会用未完成的工作来给团队成员造成麻烦。当准备好之后，我们应该与其他团队成员一起做代码复查\n“坐着开的会议通常会持续更久，大部分人不喜欢站着进行长时间的谈话。”\n“通常，立会都是在每个工作日的早些时候，且大家都在上班时举行。但是不要把它安排为上班后的第一件事。要让大家有机会从刚才混乱的交通状况中恢复状态，喝点咖啡，删除一些垃圾邮件什么的。要保证会议结束后有足够的时间，让大家在午餐之前做不少工作，同时也不要开始得过早，让每个人都巴不得赶紧结束会议，去喝点东西。一般来说，在大家到公司之后的半个小时到一个小时之内举行，是个不错的选择。”\n“如果觉得立会是在浪费时间，那可能是大家还没有形成真正的团队意识。这并不是坏事，有利于针对问题进行改进。”\n“当多人同时开发时，代码会被频繁地检查、重构以及维护。如果需要修复bug，任何一名开发人员都可以完成这项工作。同时有两个或两个以上的人，可以处理应用中不同部分的代码，可以让项目的日程安排也变得更为容易。”\n“另一方面，知道别人将会接过自己的代码，就意味着自己要更守规矩。当知道别人在注意时，一定会更加小心。”\n费曼学习法\n“通过详细解释自己知道的东西，可以使自己的理解更深入。当别人提出问题时，也可以发现不同的角度。也许可以发现一些新技巧——听到一个声音这样告诉自己：“我以前还没有这样思考过这个问题”\n“为团队成员在寻求帮助之前陷入某个问题的时间设定一个时限，一个小时应该是不错的选择”\n“如果有人还是没有任何线索，那就给更多提示吧（或者甚至是答案）。如果有人提出来某些想法，不妨帮他们分析每种想法的优劣之处。如果有人给出的答案或解决方法更好，那就从中汲取经验，然后分享你的体会吧。这对双方来说都是极佳的学习经验。”\n“用问题来回答问题，可以引导提问的人走上正确的道路。\n如果有人真的陷入胶着状态，就不要折磨他们了。告诉他们答案，再解释为什么是这样。”\n“同样的功能，不同开发人员的代码实现可能不同。差异并不意味着不好。除非你可以让某段代码明确变得更好，否则不要随意批评别人的代码。”\n及时向上反馈\n“及时通报进展与问题，有情况发生时，就不会让别人感到突然，而且他们也很愿意了解目前的进展状况。他们会知道何时应提供帮助，而且你也获得了他们的信任”\n“接受一个任务，也就意味着做出了要准时交付的承诺”\n慢慢来\n“有句老话说得好：“你可以把马带到水边……但是你不能强迫它使用你最钟爱的代码编辑器。” You can lead a horse to water, but you can make him drink.\n","permalink":"https://ynikl.github.io/books/practices_of_an_agile_developer/","summary":"我的总结 对于功能, 业务, 代码逻辑, 不要只停留在表面, 要进一步地去思考为什么 保持开放的心态, 尊重他人的意见, 勇于承认自己的\u0026quot;不知道\u0026quot;. 去思考他人为什么这么想 保持学习, 拥抱变化 有时间观念, 把控项目进度. 控制有规律的开发节奏, 不要让自己经常加班. 每天下班都能完成一天的任务. 让真正的软件用户做决策, 保持定期沟通, 让用户一直确认自己想要的东西 让工具替代人力, 实现自动化 控制代码质量, 简单, 清晰, 内聚 团队内部保持沟通 \u0026ndash; 站会, 及时反映变化. 遇到问题及时求救, 保持向上反馈. 不要辜负人家的预期 深入思考, 保持开发, 拥抱变化, 保持沟通, 注重质量, 保持学习, 自动化.\n书本原文 深度思考问题\n“拙劣的代码工人会这样不假思索地改完代码，然后快速转向下一个问题。 优秀的程序员会挖掘更深一层，尽力去理解为什么这里必须要加1，更重要的是，他会想明白会产生什么其他影响。”\n“在一本流行的管理图书《第五项修炼》中，作者建议，在理解一个问题的时候，需要渐次地问5个以上的“为什么”。这听起来就像退回到了4岁，那时对一切都充满着好奇。它是很好的方式，进一步挖掘简单直白的答案，通过这个路线，设想就会更加接近事实真相。”\n当你问“为什么”的时候，也许你会被反问：“为什么你问这个问题？”在提问之前，想好你提问的理由，这会有助于你问出恰当的问题。\n保持开发, 承认自己的不知道\n“这个，我不知道”是一个好的起点，应该由此进行更进一步的调查，而不应在此戛然结束。”\n“如果你对答案不满意，那么看看你是否可以改变问题。”\n“作为第1步的理解代码，往往是最难的。如果别人给你的代码很容易理解，接下来的工作就省心多了”\n尊重他人的意见\n“孤立非常危险，不要让开发人员完全孤立地编写代码（见第155页，习惯40）。如果团队成员花些时间阅读其他同事写的代码，他们就能确保代码是可读和可理解的，并且不会随意加入这些“+1或-1”的代码。阅读代码的频率越高越好。实行代码复审 ，不仅有助于代码更好理解，而且是发现bug最有效的方法之一。”\n“用Les Brown的一句话说就是：“你不需要很出色才能起步，但是你必须起步才能变得很出色。”\n“如果你是一个有远见的人，就一定要特别尊重别人的意见。你是一个掌舵者，一定要把握方向，深思熟虑，吸取各方的意见。”\n保持学习\n“谁会帮助你保持步伐前进呢？在一个企业化的社会中，只有一个人会为你负责——你自己。是否能跟上变化，完全取决于你自己”\n“跟踪技术变化 。你不需要精通所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯”\n拥抱变化, 交付用户想要的软件\n“敏捷的根本之一就是拥抱变化。既然变化是永恒的，你有可能一直使用相同的技术和工具吗？”\n“真正的敌人是变化。软件开发如战争，形势的变化快速而又剧烈。固守昨天的计划而无视环境的变化会带来灾难。”\n“不要在前期做大量的设计”并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事”\n时间观念\n“许多的敏捷技巧来源于时间盒——设定一个短时的期限，为任务设定不能延长的最终期限。你可以选择放弃其他方面的任务，但是最终期限是不变的。你可能不知道完成所有的任务需要多少个时间盒，但每个时间盒必须是短期的、有限的，并且要完成具体的目标”\n“如果在你工作的时候没有一个固定的最终期限（例如一天的结束），就应该好好想想了。它会让你的工作有一个节奏，在每天下班的时候，提交所有的工作，开心地收工。这样，明天就能开始新的内容，解决下一系列难题”\n“有人说，上帝发明了时间，就是为了防止所有事情同时发生。因此我们需要更具远见，保持不同的开发节奏，这样敏捷项目的所有事情就不会突然同时发生，也不会随机发生，时间也不会不可预知。”","title":"高效程序员的45个习惯"},{"content":"实现并发控制 在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 channel 进行传入和传出.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { concurrencyNum := 10 limitCh := make(chan bool, concurrencyNum) wg := new(sync.WaitGroup) for i := 0; i \u0026lt; 100; i++ { limitCh \u0026lt;- true wg.Add(1) go func() { defer func() { \u0026lt;-limitCh wg.Done() }() time.Sleep(1 * time.Second) fmt.Println(\u0026#34;do some things...\u0026#34;) }() } wg.Wait() fmt.Println(\u0026#34;ok\u0026#34;) } 如果如果中间运行代码有可能存在错误, 捕获错误. 有两种方法:\n声明一个 err channel 用于承接错误 声明一个外部 err 变量, 并通过互斥锁进行保护 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 func main() { concurrencyNum := 10 limitCh := make(chan bool, concurrencyNum) errCh := make(chan error, concurrencyNum) var externalErr error wg := new(sync.WaitGroup) func() { for i := 0; i \u0026lt; 100; i++ { select { case err := \u0026lt;-errCh: externalErr = err return default: } wg.Add(1) limitCh \u0026lt;- true go func() { defer func() { \u0026lt;-limitCh wg.Done() }() time.Sleep(1 * time.Second) fmt.Println(\u0026#34;do some things...\u0026#34;) if rand.Intn(5) == 1 { err := errors.New(\u0026#34;this is a error\u0026#34;) errCh \u0026lt;- err } }() } }() wg.Wait() fmt.Println(\u0026#34;ok\u0026#34;) fmt.Println(externalErr) } 每个地放都写这么多代码, 就有了重复的感觉. 本质上就两点:\n通过 channel 控制并发数 通过 waitgroup 保证所有的协程都执行完毕 通过另一个 errchannel 接受中间执行的错误 errgroup 可以通过使用, 官方的拓展包 errgroup 更快实现\n声明 errgroup\n普通声明 new(errgroup.Group) 使用 context errgroup.WithContext 限制开启的协程数据\neg.SetLimit(goroutineNum)\n开启协程\neg.Go eg.TryGo 整体代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 eg := new(errgroup.Group) eg.SetLimit(10) for i := 0; i \u0026lt; 100; i++ { eg.Go(func() error { time.Sleep(1 * time.Second) fmt.Println(\u0026#34;hello go\u0026#34;) return nil }) } err := eg.Wait() fmt.Println(\u0026#34;done\u0026#34;, err) 目前有个使用场景没办法满足:\n就是没办法在开启协程之前, 知道原先已经执行的协程是否有发生错误. 如果有发生错误的. 就停止再继续开启协程.\n可以通过添加一个 外部的 errChannel , 覆盖到上面的需求.\n","permalink":"https://ynikl.github.io/blog/golang-errgroup/","summary":"实现并发控制 在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 channel 进行传入和传出.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { concurrencyNum := 10 limitCh := make(chan bool, concurrencyNum) wg := new(sync.WaitGroup) for i := 0; i \u0026lt; 100; i++ { limitCh \u0026lt;- true wg.Add(1) go func() { defer func() { \u0026lt;-limitCh wg.Done() }() time.Sleep(1 * time.Second) fmt.","title":"Go  errgroup 的基本用法"},{"content":"在 golang 中查看源码是比较方便的. 可以直接到 官方包文档中直接查看文档和跳转到源码\n但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成 什么底层方法了.\n比如, 我知道一些make(map[int]bool)是怎么实现的.\n这时候就需要一些方法了. 引用一下鸟窝大佬的文章 总结一下三种方法:\ngo tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile 产生的汇编代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 0x001c 00028 (main.go:5)\tFUNCDATA\t$1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB) 0x001c 00028 (main.go:5)\tFUNCDATA\t$2, main.main.stkobj(SB) 0x001c 00028 (main.go:6)\tSTP\t(ZR, ZR), main..autotmp_4-48(SP) 0x0020 00032 (main.go:6)\tSTP\t(ZR, ZR), main..autotmp_4-32(SP) 0x0024 00036 (main.go:6)\tSTP\t(ZR, ZR), main..autotmp_4-16(SP) 0x0028 00040 (main.go:6)\tMOVD\t$type.map[int]bool(SB), R0 0x0030 00048 (main.go:6)\tMOVD\t$100, R1 0x0034 00052 (main.go:6)\tMOVD\t$main..autotmp_4-48(SP), R2 0x0038 00056 (main.go:6)\tPCDATA\t$1, ZR 0x0038 00056 (main.go:6)\tCALL\truntime.makemap(SB) 0x003c 00060 (main.go:6)\tMOVD\tR0, main.mp-112(SP) 0x0040 00064 (main.go:7)\tMOVD\tR0, R1 0x0044 00068 (main.go:7)\tMOVD\tZR, R2 0x0048 00072 (main.go:7)\tMOVD\t$type.map[int]bool(SB), R0 go tool objdump产生的汇编代码\n1 2 3 4 5 6 7 main.go:6\t0x10008a734\ta907ffff\tSTP (ZR, ZR), 120(RSP)\tmain.go:6\t0x10008a738\t90000160\tADRP 180224(PC), R0\tmain.go:6\t0x10008a73c\t91100000\tADD $1024, R0, R0\tmain.go:6\t0x10008a740\td2800c81\tMOVD $100, R1\tmain.go:6\t0x10008a744\t910163e2\tADD $88, RSP, R2\tmain.go:6\t0x10008a748\t97fe0522\tCALL runtime.makemap(SB)\tmain.go:6\t0x10008a74c\tf90023e0\tMOVD R0, 64(RSP)\tgo build -gcflags -S 产生的汇编代码\n1 2 3 4 5 6 7 8 mp_10-32(SP) 0x0024 00036 (/Users/ian/play/map/main.go:6) STP (ZR, ZR), main..autotmp_10-16(SP) 0x0028 00040 (/Users/ian/play/map/main.go:6) MOVD $type.map[int]bool(SB), R0 0x0030 00048 (/Users/ian/play/map/main.go:6) MOVD $100, R1 0x0034 00052 (/Users/ian/play/map/main.go:6) MOVD $main..autotmp_10-48(SP), R2 0x0038 00056 (/Users/ian/play/map/main.go:6) PCDATA $1, ZR 0x0038 00056 (/Users/ian/play/map/main.go:6) CALL runtime.makemap(SB) 0x003c 00060 (/Users/ian/play/map/main.go:6) MOVD R0, main.mp-72(SP) 大同小异, 根据源代码的行号(mian.go:6) 都可以从代码中看到, 调用call 了makemap 这个方法\n我们在到源码中, 找到makemap方法, 就可以查看对应的源码了\n参考 得到Go程序的汇编代码的方法\n","permalink":"https://ynikl.github.io/blog/golang-get-assembly-fn/","summary":"在 golang 中查看源码是比较方便的. 可以直接到 官方包文档中直接查看文档和跳转到源码\n但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成 什么底层方法了.\n比如, 我知道一些make(map[int]bool)是怎么实现的.\n这时候就需要一些方法了. 引用一下鸟窝大佬的文章 总结一下三种方法:\ngo tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile 产生的汇编代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 0x001c 00028 (main.go:5)\tFUNCDATA\t$1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB) 0x001c 00028 (main.go:5)\tFUNCDATA\t$2, main.main.stkobj(SB) 0x001c 00028 (main.go:6)\tSTP\t(ZR, ZR), main.","title":"如何查看 golang 编译之后调用的源码方法"},{"content":"开这个目录的目的:\n是为了记录一些, 我日常读到的一些文章收获和心得.\n","permalink":"https://ynikl.github.io/journal/","summary":"开这个目录的目的:\n是为了记录一些, 我日常读到的一些文章收获和心得.","title":"Journal"},{"content":"Content-Disposition 常见是用在 http 请求的 Response 的 Header 头部.\n告诉请求客户端(浏览器) 如何处理内容;\nContent-Disposition是在 MIME 标准定义的. http 中的用法只是其中的一小部分.\n语法参数 inline 会在浏览器内部显示\n1 Content-Disposition: inline attachment 会被保存成文件\n1 Content-Disposition: attachment 后面可以跟 filename, 值为预设文件名称, 中间使用;分号隔开.\n1 Content-Disposition: attachment; filename=\u0026#34;filename.jpg\u0026#34; 拓展参数, 有两个文件名称参数可选\nfilename* filename filename* 采用了 RFC 5987 中规定的编码方式, 假如两个参数都使用 filename* 的优先级更高\nRFC 5987 该提议最终还是引用 RFC 2231 中的编码方式. 下面简单介绍一下语法\n*星号用于标记该同名参数是支持该编码语法的, 就如( filename* 之于 filename) '单个逗号用于分割 字符集名称 , 语言, 文件名称 %百分号用于标记编码方式, 参考RFC 2047, 所以文件名中不能有% 1 filename*=us-ascii\u0026#39;en-us\u0026#39;This%20is%20%2A%2A%2Afun%2A%2A%2A 使用us-ascii编码, en-us英语\n问题: 下载文件名称乱码 根据上面的知识, 就可以解决有的浏览器下载文件时中文名称乱码.\nHttp 返回设置Content-Disposition值 使用 RFC 2231 的文件名称方式, 制定编码utf-8 将文件名称移除% 1 disposition := fmt.Sprintf(\u0026#34;attachment;filename*=utf-8\u0026#39;\u0026#39;%s\u0026#34;, url.QueryEscape(name)) 参考 MDN RFC 2231\n","permalink":"https://ynikl.github.io/posts/http-content-disposition/","summary":"Content-Disposition 常见是用在 http 请求的 Response 的 Header 头部.\n告诉请求客户端(浏览器) 如何处理内容;\nContent-Disposition是在 MIME 标准定义的. http 中的用法只是其中的一小部分.\n语法参数 inline 会在浏览器内部显示\n1 Content-Disposition: inline attachment 会被保存成文件\n1 Content-Disposition: attachment 后面可以跟 filename, 值为预设文件名称, 中间使用;分号隔开.\n1 Content-Disposition: attachment; filename=\u0026#34;filename.jpg\u0026#34; 拓展参数, 有两个文件名称参数可选\nfilename* filename filename* 采用了 RFC 5987 中规定的编码方式, 假如两个参数都使用 filename* 的优先级更高\nRFC 5987 该提议最终还是引用 RFC 2231 中的编码方式. 下面简单介绍一下语法\n*星号用于标记该同名参数是支持该编码语法的, 就如( filename* 之于 filename) '单个逗号用于分割 字符集名称 , 语言, 文件名称 %百分号用于标记编码方式, 参考RFC 2047, 所以文件名中不能有% 1 filename*=us-ascii\u0026#39;en-us\u0026#39;This%20is%20%2A%2A%2Afun%2A%2A%2A 使用us-ascii编码, en-us英语","title":"Content Disposition"},{"content":"豆瓣因为涉及敏感词不让写, 干脆就写到这里来 (我也没写啥不好的呀 QAQ).\n真正的现实，都是充满着矛盾。对万事万物保持一颗敬畏的心.\n一方面是平民老百姓承受着流离失所的痛苦，一方面他们又可以从老破房子住到新的高楼“不破不立”，改善环境。 既要看到痛苦，也要看到改善。看外该电影， 更加让我懂得，看待事情要怀着敬畏之心，事情都是有双面性的。\n总得来说，还是觉得耿属于“好市长”，在中国经济飞速发展的过程中，为人民干实事，坚定自己的立场，倾听民声（市民赌在司令部门口申诉问题的场景给我印象极深）。\n","permalink":"https://ynikl.github.io/posts/the-chinese-mayor/","summary":"豆瓣因为涉及敏感词不让写, 干脆就写到这里来 (我也没写啥不好的呀 QAQ).\n真正的现实，都是充满着矛盾。对万事万物保持一颗敬畏的心.\n一方面是平民老百姓承受着流离失所的痛苦，一方面他们又可以从老破房子住到新的高楼“不破不立”，改善环境。 既要看到痛苦，也要看到改善。看外该电影， 更加让我懂得，看待事情要怀着敬畏之心，事情都是有双面性的。\n总得来说，还是觉得耿属于“好市长”，在中国经济飞速发展的过程中，为人民干实事，坚定自己的立场，倾听民声（市民赌在司令部门口申诉问题的场景给我印象极深）。","title":"The Chinese Mayor"},{"content":"概括 我为什么要读这本书? 我觉得生活挺无聊, 人生活着没有什么意义. 听说在这本书中会有人生的意义\n这本书怎样影响了我? 看清楚自己之所以活着, 就如史铁生所说, 就是还想得到什么. 并不是如我嘴上所说的: \u0026ldquo;人生活着没什么意义\u0026rdquo; 打算更加大胆地去追求自己想要\u0026quot;得到\u0026quot;的东西 看清楚做某一件事情的意义 \u0026ndash; 不只是看重结果, 也要去看重过程 书中的三句精华句子? 可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望 只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。 世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。 上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。 此岸永远是残缺的，否则彼岸就要坍塌。 三句话总结本书 尊重不完美, 不要抱怨, 不断地去追求完美 看清楚自己想要得到什么 人生不能只看重目的, 要去享受这个过程. 书摘 在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。\n树干上留着一只蝉蜕，寂寞如一间空屋；露水在草叶上滚动，聚集，压弯了草叶轰然坠地摔开万道金光。”“\n上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。\n剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。\n看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。\n就命运而言，休论公道。\n其实总共只有三个问题交替着来骚扰我，来陪伴我。第一个是要不要去死，第二个是为什么活，第三个，我干吗要写作。\n人为什么活着？因为人想活着，说到底是这么回事，人真正的名字叫做：欲望。\n可我为什么还想活呢？因为你还想得到点儿什么，你觉得你还是可以得到点儿什么的，比如说爱情，比如说价值感之类，人真正的名字叫欲望。\n结果你又发表了几篇，并且出了一点儿小名，可这时你越来越感到恐慌。我忽然觉得自己活得像个人质，刚刚有点儿像个人了却又过了头，\n人都忍不住要为生存找一些牢靠的理由。你不担心你会枯竭了？我不知道，不过我想，活着的问题在死前是完不了的。\n就算是三个月！我平白地相信这样一个期限。\n多年以后才听一位无名的哲人说过：危卧病榻，难有无神论者。\n但在命运的混沌之点，人自然会忽略着科学，向虚暝之中寄托一份虔敬的祈盼。\n机会不在外面在心里，结婚的机会有可能在外边，可爱情的机会只能在心里\n那位台湾作家三毛说得对：爱如禅，不能说不能说，一说就错。\n别人告诉我，她昏迷前的最后一句话是：“我那个有病的儿子和我那个还未成年的女儿……”\n砌墙盖房，不单为避风雨，因为大家都有些秘密，其次当然还有一些钱财。秘密，不信你去慢慢推想，它是趣味的爹娘。\n千万别把运动和能量，以及和时空分割开来理解。我随即得了启发：也千万别把人和意义分割开来理解。不是人有欲望，而是人即欲望。\n如今想来，分明就是为了一个“轻”字：珍宝转眼被处理成垃圾，一段生命轻得飘散了，没有了，以为是什么原来什么也不是，轻易、简单、灰飞烟灭。一段生命之轻，威胁了生命全面之重，惶茫往灵魂里渗透：是不是生命的所有段落都会落此下场啊？人的根本恐惧就在这个“轻”字上，比如歧视和漠视，比如嘲笑，比如穷人手里作废的股票，比如失恋和死亡。轻，最是可怕。\n艰苦的生活需要希望，鲜活的生命需要爱情，数不完的日子和数不完的心事，都要诉说。\n也许是因为人缺了什么就更喜欢什么吧，我的两条腿一动不能动，却是个体育迷。\n上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。\n我希望既有一个健美的躯体又有一个了悟人生意义的灵魂，我希望二者兼得。\n难道我们不该对灵魂有了残疾的人，比对肢体有了残疾的人，给予更多的同情和爱吗？\n既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？\n有知识不能只是有对物的知识，而是得有对人的了悟。\n我们也完全可以把你以后的生活设计得无比顺利，但这样下去我们是不是绕了一圈又回到那不祥的阴影中去了？你将再没有企盼了吗？再没有新的追求了吗？那么你的心路是不是又在荒芜，于是你的幸福感又要老化、萎缩、枯竭了呢？\n只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。\n一个只想（只想！）使过程精彩的人是无法被剥夺的，因为死神也无法将一个精彩的过程变成不精彩的过程，因为坏运也无法阻挡你去创造一个精彩的过程，相反你可以把死亡也变成一个精彩的过程，相反坏运更利于你去创造精彩的过程。\n过程！对，生命的意义就在于你能创造这过程的美好与精彩，生命的价值就在于你能够镇静而又激动地欣赏这过程的美丽与悲壮。\n有位大物理学家说过：“物理学不告诉我们世界是什么，而是告诉我们关于世界我们能够谈论什么。”\n历史难免是一部御制经典，文学要弥补它，所以看重的是那些沉默的心魂。\n佛嘛，心中无佛什么事都敢干。\n丑弱的人和圆满的神之间，是信者永远的路。\n此岸永远是残缺的，否则彼岸就要坍塌。\n历史，这两个字，可能包含着任何你想得到和想不到的危险，可能给你带来任何想得到和想不到的灾难。\n那个年代的人都懂得，话说到这儿最好止步；历史，这两个字，可能包含着任何你想得到和想不到的危险，可能给你带来任何想得到和想不到的灾难。\n家长们把“耐克”一类颠来倒去地看，说：“啥东西，值得这么贵？”他们不懂，春天是不能这样计算的。\n大人们其实忘了，春天莫不如此，各位年轻时也是一样。\n世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。\n我想，那就不必再去地坛寻找安静，莫如在安静中寻找地坛。\n","permalink":"https://ynikl.github.io/books/%E6%88%91%E4%B8%8E%E5%9C%B0%E5%9D%9B/","summary":"概括 我为什么要读这本书? 我觉得生活挺无聊, 人生活着没有什么意义. 听说在这本书中会有人生的意义\n这本书怎样影响了我? 看清楚自己之所以活着, 就如史铁生所说, 就是还想得到什么. 并不是如我嘴上所说的: \u0026ldquo;人生活着没什么意义\u0026rdquo; 打算更加大胆地去追求自己想要\u0026quot;得到\u0026quot;的东西 看清楚做某一件事情的意义 \u0026ndash; 不只是看重结果, 也要去看重过程 书中的三句精华句子? 可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望 只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。 世上有一种东西，其价值远远超过它的价格。这儿的价值，并不止于“物化劳动”，还物化着春天整整一个季节的能量。 上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。 此岸永远是残缺的，否则彼岸就要坍塌。 三句话总结本书 尊重不完美, 不要抱怨, 不断地去追求完美 看清楚自己想要得到什么 人生不能只看重目的, 要去享受这个过程. 书摘 在满园弥漫的沉静光芒中，一个人更容易看到时间，并看见自己的身影。\n树干上留着一只蝉蜕，寂寞如一间空屋；露水在草叶上滚动，聚集，压弯了草叶轰然坠地摔开万道金光。”“\n上帝在交给我们这件事实的时候，已经顺便保证了它的结果，所以死是一件不必急于求成的事，死是一个必然会降临的节日。\n剩下的就是怎样活的问题了。这却不是在某一个瞬间就能完全想透的，不是能够一次性解决的事，怕是活多久就要想它多久了，就像是伴你终生的魔鬼或恋人。\n看来差别永远是要有的。看来就只好接受苦难——人类的全部剧目需要它，存在的本身需要它。看来上帝又一次对了。\n就命运而言，休论公道。\n其实总共只有三个问题交替着来骚扰我，来陪伴我。第一个是要不要去死，第二个是为什么活，第三个，我干吗要写作。\n人为什么活着？因为人想活着，说到底是这么回事，人真正的名字叫做：欲望。\n可我为什么还想活呢？因为你还想得到点儿什么，你觉得你还是可以得到点儿什么的，比如说爱情，比如说价值感之类，人真正的名字叫欲望。\n结果你又发表了几篇，并且出了一点儿小名，可这时你越来越感到恐慌。我忽然觉得自己活得像个人质，刚刚有点儿像个人了却又过了头，\n人都忍不住要为生存找一些牢靠的理由。你不担心你会枯竭了？我不知道，不过我想，活着的问题在死前是完不了的。\n就算是三个月！我平白地相信这样一个期限。\n多年以后才听一位无名的哲人说过：危卧病榻，难有无神论者。\n但在命运的混沌之点，人自然会忽略着科学，向虚暝之中寄托一份虔敬的祈盼。\n机会不在外面在心里，结婚的机会有可能在外边，可爱情的机会只能在心里\n那位台湾作家三毛说得对：爱如禅，不能说不能说，一说就错。\n别人告诉我，她昏迷前的最后一句话是：“我那个有病的儿子和我那个还未成年的女儿……”\n砌墙盖房，不单为避风雨，因为大家都有些秘密，其次当然还有一些钱财。秘密，不信你去慢慢推想，它是趣味的爹娘。\n千万别把运动和能量，以及和时空分割开来理解。我随即得了启发：也千万别把人和意义分割开来理解。不是人有欲望，而是人即欲望。\n如今想来，分明就是为了一个“轻”字：珍宝转眼被处理成垃圾，一段生命轻得飘散了，没有了，以为是什么原来什么也不是，轻易、简单、灰飞烟灭。一段生命之轻，威胁了生命全面之重，惶茫往灵魂里渗透：是不是生命的所有段落都会落此下场啊？人的根本恐惧就在这个“轻”字上，比如歧视和漠视，比如嘲笑，比如穷人手里作废的股票，比如失恋和死亡。轻，最是可怕。\n艰苦的生活需要希望，鲜活的生命需要爱情，数不完的日子和数不完的心事，都要诉说。\n也许是因为人缺了什么就更喜欢什么吧，我的两条腿一动不能动，却是个体育迷。\n上帝从来不对任何人施舍“最幸福”这三个字，他在所有人的欲望前面设下永恒的距离，公平地给每一个人以局限。\n我希望既有一个健美的躯体又有一个了悟人生意义的灵魂，我希望二者兼得。\n难道我们不该对灵魂有了残疾的人，比对肢体有了残疾的人，给予更多的同情和爱吗？\n既然是梦想不妨就让它完美些罢。何必连梦想也那么拘谨那么谦虚呢？\n有知识不能只是有对物的知识，而是得有对人的了悟。\n我们也完全可以把你以后的生活设计得无比顺利，但这样下去我们是不是绕了一圈又回到那不祥的阴影中去了？你将再没有企盼了吗？再没有新的追求了吗？那么你的心路是不是又在荒芜，于是你的幸福感又要老化、萎缩、枯竭了呢？\n只要你最最关心的是目的而不是过程你无论怎样都得落入绝境，只要你仍然不从目的转向过程你就别想走出绝境。\n一个只想（只想！）使过程精彩的人是无法被剥夺的，因为死神也无法将一个精彩的过程变成不精彩的过程，因为坏运也无法阻挡你去创造一个精彩的过程，相反你可以把死亡也变成一个精彩的过程，相反坏运更利于你去创造精彩的过程。\n过程！对，生命的意义就在于你能创造这过程的美好与精彩，生命的价值就在于你能够镇静而又激动地欣赏这过程的美丽与悲壮。\n有位大物理学家说过：“物理学不告诉我们世界是什么，而是告诉我们关于世界我们能够谈论什么。”\n历史难免是一部御制经典，文学要弥补它，所以看重的是那些沉默的心魂。\n佛嘛，心中无佛什么事都敢干。\n丑弱的人和圆满的神之间，是信者永远的路。","title":"我与地坛"},{"content":"最近接手公司一个视频相关项目, 也是使用ffmpeg工具. 需要快速了解下.\n概念 码率, 帧率, 文件大小 帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.\ninterlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i progressive: 现代整页整页呈现, 描述单位p: 60p 码率(bit rate) :视频一秒中有多少位, 决定视频的质量\nABR: 平均码率 CBR: 常量码率 VBR: 动态码率 文件大小 = 视频文件 + 音频文件\n视频文件 = 码率 * 时间(s) / 8 音频文件 = 码率 * 时间(s) / 8\n文件格式 不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers) 可以存储声音或者视频数据.\n相关缩写 encoding (E) decoding (D) video (V) audio (A) subtitles (S) 文件元数据 metadata 描述媒体文件自身的信息, 比如:\n1 2 3 4 5 6 7 8 9 10 Metadata: publisher : Ninja Tune track : 1 album : Ninja Tuna artist : Mr. Scruff album_artist : Mr. Scruff title : Kalimba genre : Electronic composer : A. Carthy and A. Kingslow date : 2008 声音 数字音频是通过对声音的模拟信息, 抽样且用数据信号表示.\n音频使用 bit depths 来表示声音的解析度:\n8bit, 12bit, 14bit \u0026hellip;\n声音的样本频率用 Hz 表示\n8000Hz, 11025Hz, 16000Hz \u0026hellip;\nFFmpeg 其他套件 ffplay 播放器 ffprobe 查看媒体文件的信息 ffserver 流服务器 使用 通用参数 -i 输入源, 可以是文件也可以是 url\n-vf option for video filters -af option for audio filters.\n-filter_complex 当多个输入源的时候使用\n-y 输出文件会强制覆盖已经存在的文件\n帮助 1 2 3 4 5 \u0026#34; 查看支持格式 ffmpeg -formats \u0026#34; 编解码器 ffmpeg -codecs 调整帧率 1 ffmpeg -i input.avi -r 30 output.mp4 调整码率 1 ffmpeg -i input.avi -b:v 1500k output.mp4 缩放视频大小 s : w x h 参数 宽乘以高 1 2 3 4 5 \u0026#34; 缩小分辨率 ffmpeg -i input.avi -s 640x480 output.avi \u0026#34; 扩大分辨率 ffmpeg -i input.mpg -vf scale=iw/PHI:ih/PHI output.mp4 旋转, 翻转 旋转\n1 ffmpeg -i CMYK.avi -vf transpose=2 CMYK_transposed.avi 竖直翻转\n1 ffmpeg -i meta.mp4 -vf vflip output_flip.mp4 裁切 裁切视频的画中画, 裁切视频的中心 1/2 的视频\n1 ffmpeg -i input.avi -vf crop=iw/2:ih/2 output.avi 模糊化 模糊化\n1 ffmpeg -i input.mpg -vf boxblur=1.5:1 output.mp4 锐化\n1 ffmpeg -i input -vf unsharp output.mp4 叠加 1 ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output 裁剪 获取一个时间段内的音频 -t 参数为秒\n1 ffmpeg -i input.mp4 -t 180 output_3_min.mp4 --ss 设置开始时间点 ( seek from start, 从视频开始过多少秒开始操作)\n1 2 \u0026#34; 直接截断开头3分钟 ffmpeg -i input.mp4 -ss 180 output_without_start_3.mp4 截取某一段时间视频\n1 2 \u0026#34; 截取第4分钟, 一分钟视频 ffmpeg -i input.mp4 -ss 180 -t 60 clip_4th_min.mp4 图片操作 从视频中截取某一帧\n1 ffmpeg -i videoclip.avi -ss 01:23:45 image.jpg 翻转图片\n1 2 3 4 5 ffmpeg -i orange.jpg -vf hflip orange_hflip.jpg ffmpeg -i orange.jpg -vf vflip orange_vflip.jpg \u0026#34; transpose [0, 1, 2, 3] ffmpeg -i image.png -vf transpose=1 image_rotated.png 转换图片格式\n1 ffmpeg -i illustration.png illustration.jpg 格式转化 格式转化流程:\nDemuxer (分解复用) : 将合成信号恢复成原本独立的信号数据 Decoder (解码器) : 解码 Encoder (编码器) : 编码 Muxer ( _ ): 将多个信号数据合并\n1 2 3 4 ffmpeg -y -i input.avi output.mp4 \u0026#34; 改变格式, 但不更改编解码方式 ffmpeg -i input.avi -q 1 -c copy output.mov 混音 将两个声合成一个文件\n1 ffmpeg -i demo.mp3 -i louder_sound.aac -filter_complex amix=inputs=2 sounds.wav 加强耳机的立体声效果\n1 ffmpeg -i music.mp3 -af earwax -q 1 music_headphones.mp3 参考 FFmpeg Basics 2012 by Frantisek Korbel ","permalink":"https://ynikl.github.io/blog/ffmpeg-basics/","summary":"最近接手公司一个视频相关项目, 也是使用ffmpeg工具. 需要快速了解下.\n概念 码率, 帧率, 文件大小 帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.\ninterlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i progressive: 现代整页整页呈现, 描述单位p: 60p 码率(bit rate) :视频一秒中有多少位, 决定视频的质量\nABR: 平均码率 CBR: 常量码率 VBR: 动态码率 文件大小 = 视频文件 + 音频文件\n视频文件 = 码率 * 时间(s) / 8 音频文件 = 码率 * 时间(s) / 8\n文件格式 不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers) 可以存储声音或者视频数据.\n相关缩写 encoding (E) decoding (D) video (V) audio (A) subtitles (S) 文件元数据 metadata 描述媒体文件自身的信息, 比如:","title":"FFmpeg 基本使用"},{"content":"操作 演进 加锁后进程挂掉了 加锁成功之后, 进程挂掉了没有进行解锁操作. 导致进入死锁状态.\n引入 expire 设置超时时长, 自动释放 key\n1 2 3 4 5 6 7 8 \u0026gt; setnx lock:key true \u0026gt; OK \u0026gt; expire lock:key 5 \u0026#34; ... do something critical ... \u0026gt; del lock:codehole 加锁动作 到 expire 之间挂掉了 redis 2.8 之后支持 set 拓展指令\n1 \u0026gt; set lock:key true ex 5 nx 加锁互斥锁, 并同时设置超时时长\n执行超时, 被其他进程获取到了锁 加锁之后, 本身进程执行时间超过了预先设置的 expire 的时间. 就会导致锁被提前释放.\n解决方案:\n尽量不要用与锁住时间教长的任务, 尝试缩小锁定的\u0026quot;关键区域\u0026quot; 续锁 (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间 执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁 Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。 \u0026ndash; Redis深度历险\n解决方案: 给加锁的 key 设置随机数的value, 删除之前先匹配是否一致再删除\n匹配和删除动作之间的原子性可以用 Lua 脚本保证\n1 2 3 4 5 6 # delifequals if redis.call(\u0026#34;get\u0026#34;,KEYS[1]) == ARGV[1] then return redis.call(\u0026#34;del\u0026#34;,KEYS[1]) else return 0 end 可重入锁 利用线程的本地变量(Threadloacl), 维护锁的持有计数, 实现支持多次加锁, 多次解锁\n参考 Redis 深度历险 阿里二面：Redis分布式锁过期了但业务还没有执行完，怎么办 ","permalink":"https://ynikl.github.io/blog/redis-do-distributed-lock/","summary":"操作 演进 加锁后进程挂掉了 加锁成功之后, 进程挂掉了没有进行解锁操作. 导致进入死锁状态.\n引入 expire 设置超时时长, 自动释放 key\n1 2 3 4 5 6 7 8 \u0026gt; setnx lock:key true \u0026gt; OK \u0026gt; expire lock:key 5 \u0026#34; ... do something critical ... \u0026gt; del lock:codehole 加锁动作 到 expire 之间挂掉了 redis 2.8 之后支持 set 拓展指令\n1 \u0026gt; set lock:key true ex 5 nx 加锁互斥锁, 并同时设置超时时长\n执行超时, 被其他进程获取到了锁 加锁之后, 本身进程执行时间超过了预先设置的 expire 的时间. 就会导致锁被提前释放.\n解决方案:\n尽量不要用与锁住时间教长的任务, 尝试缩小锁定的\u0026quot;关键区域\u0026quot; 续锁 (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间 执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁 Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。 \u0026ndash; Redis深度历险","title":"Redis 用于做分布式锁"},{"content":"CI 自动化发布流程 可重复 可快速回滚 发布流程快速 在合并的时候可以对代码进行快速验证 CD 部署流程平台化 一键部署 总结 所谓的 CI/CD 就是通过自动化操作, 比如自动化测试, 自动化部署. 使用项目拥有快速上线的能力 \u0026ndash; 可以快速验证, 快速回滚, 快速发布.\n","permalink":"https://ynikl.github.io/posts/ci-cd/","summary":"CI 自动化发布流程 可重复 可快速回滚 发布流程快速 在合并的时候可以对代码进行快速验证 CD 部署流程平台化 一键部署 总结 所谓的 CI/CD 就是通过自动化操作, 比如自动化测试, 自动化部署. 使用项目拥有快速上线的能力 \u0026ndash; 可以快速验证, 快速回滚, 快速发布.","title":"CI/CD"},{"content":"本想写一篇关于 golang 中 map 底层的文章， 但是发现已经了相当不错的文章 \u0026ndash; 字节跳动技术团队 - Golang 中 map 探究 这里只补充一下，缺少的 map 的删除操作\n内部数据结构 初始化 map 是一个有\u0026quot;包含内容\u0026quot;的数据结构, 使用之前需要提前初始化, 即调用make\n真正是调用源码是 runtime.makemap\n获取数据 删除 源码地址\n删除的关键代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Only clear key if there are pointers in it. // # 当 Key 是指针类型的时候会去清空指针 if t.key.ptrdata != 0 { if goarch.PtrSize == 8 { *(*unsafe.Pointer)(k) = nil } else { // There are three ways to squeeze at one ore more 32 bit pointers into 64 bits. // Just call memclrHasPointers instead of trying to handle all cases here. memclrHasPointers(k, 8) } } e := add(unsafe.Pointer(b), dataOffset+bucketCnt*8+i*uintptr(t.elemsize)) // # 当 Value 为指针类型的时候, 指针为空, 解除引用 -\u0026gt; GC if t.elem.ptrdata != 0 { memclrHasPointers(e, t.elem.size) } else { memclrNoHeapPointers(e, t.elem.size) } // # 讲 hash 值标记为空 b.tophash[i] = emptyOne 上述删除代码操作现象\n当map的value类型中包含引用类型, 删除对应的key之后, 经过GC就会释放占用的内存 当map的value 类型不包含引用类型, 删除对应的key之后, GC无法释放类型 可以查看我自己的实验结果 {{}}\nhttps://ynikl.github.io/blog/golang-memory-analyze-with-runtime/ 扩容 参考 Golang 中 map 探究\n","permalink":"https://ynikl.github.io/blog/golang-map/","summary":"本想写一篇关于 golang 中 map 底层的文章， 但是发现已经了相当不错的文章 \u0026ndash; 字节跳动技术团队 - Golang 中 map 探究 这里只补充一下，缺少的 map 的删除操作\n内部数据结构 初始化 map 是一个有\u0026quot;包含内容\u0026quot;的数据结构, 使用之前需要提前初始化, 即调用make\n真正是调用源码是 runtime.makemap\n获取数据 删除 源码地址\n删除的关键代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Only clear key if there are pointers in it. // # 当 Key 是指针类型的时候会去清空指针 if t.key.ptrdata != 0 { if goarch.","title":"Golang Map 介绍"},{"content":"我觉得人生活着没有意义，但是我又为什么还活着呢？今天， 刚好看到了史铁生的《我与地坛》里面给了我答案\n可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望\n","permalink":"https://ynikl.github.io/posts/the-meaning-of-living/","summary":"我觉得人生活着没有意义，但是我又为什么还活着呢？今天， 刚好看到了史铁生的《我与地坛》里面给了我答案\n可我为什么还想活呢? 因为你还想得到点儿什么, 你觉得你还是可以得到点儿什么的, 比如说爱情, 比如说价值感之类的, 人真正的名字叫欲望","title":"活着的意义"},{"content":"概括 我为什么要读这本书? Youtuber 推荐, 好奇金融相关的知识\n这本书怎样影响了我? 不要轻易地去触碰股市, 直到我真正的理解它.\n书中的三句精华句子? 一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力 他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误 活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。 三句话总结本书 投资的时候要看重的公司的内在价值而不是市场先生的报价 减少交易次数 努力地去看透事情的本质 书摘 笔记摘自\n巴菲特致股东的信：投资者和公司高管教程（原书第4版）\n【美】沃伦E.巴菲特\n关于巴菲特一生的成功秘诀，已经有无数人做出了评价，我个人认为可以归结为八个字：与时俱进，良性循环\n“与坏人打交道，做成一笔好生意，这样的事情，我从来没有遇见过。”巴菲特的这句名言令人深思\n从别人的故事里，找到自己的人生启发，这就是读书的意义所在\n广受尊重的投资家兼作家菲尔·费雪（即菲利普·费雪，Phil Fisher）曾经将公司吸引股东的策略比喻为餐馆吸引顾客的策略。 一家餐馆可以定位于特定的食客阶层——喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困惑，最终离开。\n应该可以直接与公司CEO进行沟通，得到他现在和未来如何对企业进行估值的看法\n如果我们对一只股票有良好的长期预期，那么短期的价格波动对我们来说毫无意义，除非有人报给我们一个非常有吸引力的价格。\n芒格和我无法向你承诺结果。但我们可以保证，只要你是我们的合伙人，在任何时段，你的金融资产和我们自己的资产将完全保持一致的成长\n为了达成目标，我们的首选是直接持有一系列多元化的企业，从中获得稳定的现金流和持续的高于市场平均水平的资本回报\n从整体和长期来看，我们希望那些未体现的盈利，通过资本增值的形式体现在我们的内在价值里\n巴菲特以及伯克希尔避免进行预测，因为这是一种糟糕的管理习惯，经常会导致管理人粉饰报表\n但是任何短期的压力都不应以牺牲长期竞争力为代价\n一场大会的毫无建树是由于参与股东们更在意自己在台上的表现，而不是关心公司运营的状况\n在伯克希尔公司，我们通常会换位思考，设想如果我们自己处于股东的位置，应该得到什么样的信息，我们会从这样的角度向股东披露完整的报告\n这种打假活动针对的目标是公司信息披露行为中的“选择性披露”，近些年来，这种选择性披露行为像癌症一样蔓延。的确，信息的选择性披露已经成为大型公司的一种标准化的行为\nCEO们预测公司增长速度，是骗人的和危险的。当然，他们是被分析师和公司自己的投资者关系部门怂恿裹挟着这么做。但他们应该拒绝，因为这样预测多了会招致麻烦。\n厨房里如果有蟑螂，绝不可能只有一只\n在一个由一群和事佬组成的董事会里，不太可能会有人提出更换CEO的提议。同样，也不可能对CEO提议的公司并购活动提出质疑\n毕竟，没有人会喜欢去洗外面租来的车\n除了要维持独立性，董事们也必须具备丰富的商业经验，以股东利益为导向，以及在公司拥有真正的利益\n在收购之前，他们就已是商界的管理明星，已经证明了自己在各自领域中的才华，我们的主要贡献就是让他们自由发挥天分，不给他们添乱\n“如果我们雇用的都是比我们矮的人，我们将成为一家侏儒公司；但如果我们雇用的都是比我们高的人，我们会成为一家巨人公司。”\n我们希望我们的经理人队伍考虑什么是重要的，而不是考虑什么被认为是重要的。\n当投资的时候，我们将自己视为企业分析师——而不是市场分析师，不是宏观经济分析师，甚至不是证券分析师。\n他说你应该将市场报价想象为一个名叫“市场先生”的人\n如果你不懂得你的公司，不能比市场先生更准确地评估你的公司，你就不要参与这场游戏\n就像人们打牌时说的：“如果玩了30分钟，你还不知道谁是倒霉蛋，有可能就是你。\n一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力\n有些人会在不同市场间倒手，意图赚取差价。你不必感到惊讶，从业者为此选了一个法语词汇：套利。\n如果需要同时做很多事情，就像同时将很多烙铁放在火中，人们就必须花大量的时间，既要监控交易的过程，又要监控市场股价的波动。这不是芒格和我所想的生活模式。（如果只是为了赚钱而整天盯着股票行情，这种生活有什么意义可言？\n在完全忽视股价的情况下，一家拥有子公司的母公司，如果子公司长期表现优异，母公司是不可能出售子公司的。“为什么要卖出？”CEO会问，“难道要我卖出皇冠上的宝石吗\n应该评估是否在其预期的持股期间，其投资的税后收益总和（包括他卖出所得）会带给他至少在投资开始之初同等的购买力，加上合理的利率因素\n一个视力平平的人，没有必要在干草堆里寻找绣花针。\n我们的座右铭是：“如果你一开始就取得了成功，那么，不必再做测试。\n很多大名鼎鼎的基金管理人现在关注的是其他基金管理人未来几天干什么，而不是关注企业未来几年干什么。对于他们而言，股票仅仅是游戏中的筹码，就像大富翁游戏中，如同顶针和熨斗一样的道具\n我们的目标是发现那些价格合理的杰出公司，而不是价格便宜的平庸公司\n最值得拥有的公司是，那些在一个一直延伸的时期周期里，可以不断利用增量资本获得很高回报率的公司\n他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误\n二级市场经常周期性地被大量傻瓜所主导，会持续设定一个“清算”价格。无论这个价格多么愚蠢，它是股票或债券持有者需要或希望卖出的价格，总是有这样的机会出现\n无论什么样的天才或努力，有些事情总是需要时间。即便你能让九个女人同时怀孕，也不可能让她们在一个月的时间里生出小宝宝。）\n但我更喜欢一个确定的良好结果，而不是一个期望的伟大结果。\n在企业内部，有一种看不见的力量足以压倒一切，我们可以称其为“惯性驱使”或“机构强迫症”\n如果我们在资产负债表上使用适当的负债，可以在安全的前提下增加一些盈利\n信用就像氧气。此二者，在充足的时候，人们不会注意到它们的存在；当它们消失的时候，人们才会发现它们的重要性\n当年花1美元可以买到的东西，今天要花7美元以上。因此，即便一个不用交税的机构，也必须在同期从债券上获得4.3%的年化利息收入，才能维持其购买力不变。如果这些机构的管理人将任何的利息部分视为“收入”的话，他们一定是在和自己开玩笑\n即使在最混乱的经济环境中，美国国债也是唯一靠得住的流动性良好的投资对象\n大多数人宁愿去死，也不愿意思考。很多人就是这样\n巨大的负债可以让管理层前所未有地专注工作，就像在汽车方向盘上装一把匕首，可以提高司机的注意力一样\n衍生品还可能造成连锁反应式的风险，因为很多保险公司或再保险公司将它们的风险分散给其他保险公司\n“世俗的智慧告诉我们，循规蹈矩的失败，可能比标新立异的成功，更有利于保全名声\n这场愚蠢游戏的核心是，人们通常都认为房屋的价格肯定会随着时间而上升，任何的下降都是可以忽略不计的。这个前提几乎贯穿于任何房屋的交易行为和交易价格中\n借贷者将钱借给那些以他们的收入根本还不起钱的人，借款者很愉快地签署这些合同。借贷双方都寄希望于“房价的上升”，以弥补这项“不可能完成的任务”所带来的缺口。\n.\u0026gt; 但是，居住和使用应作为买房时的首要动机，而不应该将购房视作升值盈利或再融资的手段。同时，购房时应该考虑与收入相匹配，量力而行。\n投资者的整体回报，随着交易频率的上升而减少。\n道琼斯在20世纪的100年中，从65.73点上升到11497.12点，相当于年化复合回报率5.3%（当然，投资者在此期间还能收到分红。）在接下来21世纪的100年中，为了达到同样的回报率，道琼斯指数必须——你需要深呼一口气——达到2011011.23点。也就是说，到21世纪末，道琼斯将以200万点收盘，但看看本世纪初的前六年，道琼斯指数几乎原地没动。\n活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。这实际上是对股东们征收的重税，虽然只是一个人决定“换个位子”，虽然支付的对象是金融机构，而不是华盛顿\n并不是所有的收益都是在同等的情况下创造的。在很多公司，尤其是那些具有高资产/利润比特征的公司里，通货膨胀会侵蚀财报中显示的部分甚至全部收益。这个会被通胀侵蚀的收益部分，我们称之为“受限定收益”，不能被用于派发红利，以利于公司保持其经济竞争地位。\n如果再投资能获得高回报，就应该保留收益进行再投资；如果回报低下，就应该分红\n除非它们经历了极其巨大的惊人的单位成长，杰出的公司一定会产生大量的富余现金。如果公司将这些收益投在那些回报低下的业务，公司的整体留存资本的表现可能依然会很卓越，因为，核心业务部分的回报非凡。这就像高尔夫比赛中，职业选手和业余选手的混合赛，即便队伍中的业余选手都是没有希望的笨蛋，但整个球队的表现还是不错，因为得分主要来源于其中的职业选手\n如果一家公司的股票价格远低于其内在价值，通常在这个时候，回购最有意义\n首先，一家公司有充足的现金以备运营和流动性之需；其次，股价远低于保守计算的内在价值\n以及那些冲着分拆预期而来的买家，毫无疑问将会稀释现有股东群体的质量\n过度活跃的股市是企业的扒手。\n我们采取的方式就像一个人寻找合适的另一半一样：保持积极、兴趣、开放的心态，但不能着急\n桑塔亚娜（Santayana）曾说：“当你忘却了目标，狂热会让你付出很多倍的努力\n我们试图避免一些小动作——“如果一些事情不值得做，也就不值得做好。\n诺亚法则：重要的是建造方舟，而不是预测大雨\n我们喜欢与那些热爱自家公司的人做生意，而不仅仅是因为喜欢钱（虽然，我们也可以理解他为何喜欢）。当这种附加的情感存在时，它是一个信号，让人可以发现企业所具有的重要品质：不做假账，以产品为荣，尊重客户，以及一群忠诚的、有强烈方向感的人。与此相反的情况，也是真的。当\n","permalink":"https://ynikl.github.io/books/%E5%B7%B4%E8%8F%B2%E7%89%B9%E8%87%B4%E8%82%A1%E4%B8%9C%E7%9A%84%E4%BF%A1/","summary":"概括 我为什么要读这本书? Youtuber 推荐, 好奇金融相关的知识\n这本书怎样影响了我? 不要轻易地去触碰股市, 直到我真正的理解它.\n书中的三句精华句子? 一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力 他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误 活跃股票的交易成本非常高，经常能达到一家上市公司净利润的10%或更多。 三句话总结本书 投资的时候要看重的公司的内在价值而不是市场先生的报价 减少交易次数 努力地去看透事情的本质 书摘 笔记摘自\n巴菲特致股东的信：投资者和公司高管教程（原书第4版）\n【美】沃伦E.巴菲特\n关于巴菲特一生的成功秘诀，已经有无数人做出了评价，我个人认为可以归结为八个字：与时俱进，良性循环\n“与坏人打交道，做成一笔好生意，这样的事情，我从来没有遇见过。”巴菲特的这句名言令人深思\n从别人的故事里，找到自己的人生启发，这就是读书的意义所在\n广受尊重的投资家兼作家菲尔·费雪（即菲利普·费雪，Phil Fisher）曾经将公司吸引股东的策略比喻为餐馆吸引顾客的策略。 一家餐馆可以定位于特定的食客阶层——喜欢快餐的，喜欢优雅的，喜欢东方食品的等。通过风格的定位，最终获得一批志同道合的拥趸。如果餐馆的服务、菜单、价格水平策略得当，那么这批客户会成为固定的回头客。但如果餐馆经常转换风格，那么这批快乐而稳定的客户就会消失。如果餐馆的定位在法式美食和外卖鸡之间摇摆不定，那么一定会令回头客感到困惑，最终离开。\n应该可以直接与公司CEO进行沟通，得到他现在和未来如何对企业进行估值的看法\n如果我们对一只股票有良好的长期预期，那么短期的价格波动对我们来说毫无意义，除非有人报给我们一个非常有吸引力的价格。\n芒格和我无法向你承诺结果。但我们可以保证，只要你是我们的合伙人，在任何时段，你的金融资产和我们自己的资产将完全保持一致的成长\n为了达成目标，我们的首选是直接持有一系列多元化的企业，从中获得稳定的现金流和持续的高于市场平均水平的资本回报\n从整体和长期来看，我们希望那些未体现的盈利，通过资本增值的形式体现在我们的内在价值里\n巴菲特以及伯克希尔避免进行预测，因为这是一种糟糕的管理习惯，经常会导致管理人粉饰报表\n但是任何短期的压力都不应以牺牲长期竞争力为代价\n一场大会的毫无建树是由于参与股东们更在意自己在台上的表现，而不是关心公司运营的状况\n在伯克希尔公司，我们通常会换位思考，设想如果我们自己处于股东的位置，应该得到什么样的信息，我们会从这样的角度向股东披露完整的报告\n这种打假活动针对的目标是公司信息披露行为中的“选择性披露”，近些年来，这种选择性披露行为像癌症一样蔓延。的确，信息的选择性披露已经成为大型公司的一种标准化的行为\nCEO们预测公司增长速度，是骗人的和危险的。当然，他们是被分析师和公司自己的投资者关系部门怂恿裹挟着这么做。但他们应该拒绝，因为这样预测多了会招致麻烦。\n厨房里如果有蟑螂，绝不可能只有一只\n在一个由一群和事佬组成的董事会里，不太可能会有人提出更换CEO的提议。同样，也不可能对CEO提议的公司并购活动提出质疑\n毕竟，没有人会喜欢去洗外面租来的车\n除了要维持独立性，董事们也必须具备丰富的商业经验，以股东利益为导向，以及在公司拥有真正的利益\n在收购之前，他们就已是商界的管理明星，已经证明了自己在各自领域中的才华，我们的主要贡献就是让他们自由发挥天分，不给他们添乱\n“如果我们雇用的都是比我们矮的人，我们将成为一家侏儒公司；但如果我们雇用的都是比我们高的人，我们会成为一家巨人公司。”\n我们希望我们的经理人队伍考虑什么是重要的，而不是考虑什么被认为是重要的。\n当投资的时候，我们将自己视为企业分析师——而不是市场分析师，不是宏观经济分析师，甚至不是证券分析师。\n他说你应该将市场报价想象为一个名叫“市场先生”的人\n如果你不懂得你的公司，不能比市场先生更准确地评估你的公司，你就不要参与这场游戏\n就像人们打牌时说的：“如果玩了30分钟，你还不知道谁是倒霉蛋，有可能就是你。\n一个投资者如果想成功，必须将两种能力结合在一起，一是判断优秀企业的能力，一是将自己的思维和行为与市场中弥漫的极易传染的情绪隔离开来的能力\n有些人会在不同市场间倒手，意图赚取差价。你不必感到惊讶，从业者为此选了一个法语词汇：套利。\n如果需要同时做很多事情，就像同时将很多烙铁放在火中，人们就必须花大量的时间，既要监控交易的过程，又要监控市场股价的波动。这不是芒格和我所想的生活模式。（如果只是为了赚钱而整天盯着股票行情，这种生活有什么意义可言？\n在完全忽视股价的情况下，一家拥有子公司的母公司，如果子公司长期表现优异，母公司是不可能出售子公司的。“为什么要卖出？”CEO会问，“难道要我卖出皇冠上的宝石吗\n应该评估是否在其预期的持股期间，其投资的税后收益总和（包括他卖出所得）会带给他至少在投资开始之初同等的购买力，加上合理的利率因素\n一个视力平平的人，没有必要在干草堆里寻找绣花针。\n我们的座右铭是：“如果你一开始就取得了成功，那么，不必再做测试。\n很多大名鼎鼎的基金管理人现在关注的是其他基金管理人未来几天干什么，而不是关注企业未来几年干什么。对于他们而言，股票仅仅是游戏中的筹码，就像大富翁游戏中，如同顶针和熨斗一样的道具\n我们的目标是发现那些价格合理的杰出公司，而不是价格便宜的平庸公司\n最值得拥有的公司是，那些在一个一直延伸的时期周期里，可以不断利用增量资本获得很高回报率的公司\n他们懂什么并不重要，更重要的是，他们知道自己不懂什么。一个投资者只要做出为数有限的正确的事，就可以避免犯重大错误\n二级市场经常周期性地被大量傻瓜所主导，会持续设定一个“清算”价格。无论这个价格多么愚蠢，它是股票或债券持有者需要或希望卖出的价格，总是有这样的机会出现\n无论什么样的天才或努力，有些事情总是需要时间。即便你能让九个女人同时怀孕，也不可能让她们在一个月的时间里生出小宝宝。）\n但我更喜欢一个确定的良好结果，而不是一个期望的伟大结果。\n在企业内部，有一种看不见的力量足以压倒一切，我们可以称其为“惯性驱使”或“机构强迫症”\n如果我们在资产负债表上使用适当的负债，可以在安全的前提下增加一些盈利\n信用就像氧气。此二者，在充足的时候，人们不会注意到它们的存在；当它们消失的时候，人们才会发现它们的重要性\n当年花1美元可以买到的东西，今天要花7美元以上。因此，即便一个不用交税的机构，也必须在同期从债券上获得4.3%的年化利息收入，才能维持其购买力不变。如果这些机构的管理人将任何的利息部分视为“收入”的话，他们一定是在和自己开玩笑\n即使在最混乱的经济环境中，美国国债也是唯一靠得住的流动性良好的投资对象\n大多数人宁愿去死，也不愿意思考。很多人就是这样\n巨大的负债可以让管理层前所未有地专注工作，就像在汽车方向盘上装一把匕首，可以提高司机的注意力一样\n衍生品还可能造成连锁反应式的风险，因为很多保险公司或再保险公司将它们的风险分散给其他保险公司","title":"巴菲特致股东的信"},{"content":"概览 Mysql 支持以下数据类型\n数字类型 串类型(字符和字节) 日期和时间 空间 JSON 数字类型 整数类型 Interger 类型 存储大小 bytes 其他别名 TinyInt 1 bool, boolean = tinyint(1) SmallInt 2 MediumInt 3 Int 4 BigInt 8 int(M) 表示显示宽度, 最大显示宽度为(255), M 与存储空间的大小无关. 空间大小由具体类型决定.\n如果具体数值达不到宽度, 左边就会用0值补齐至 M 位.\n浮点 ( Floating-Point ) 类型 存储 补充 范围 Float 4 bytes 单精度 Double 8 bytes 双精度 Float(p) p 表示小数点后的精度位数\nFloat(M, D) Mysql 语法: M表示总显示位数, D表示小数点后个数 \u0026ndash; 由Mysql自己做约分处理. Mysql 8.0 后废弃该语法.\n定点 ( Fixed-Point ) 用于需要准备保存字段数据, 如金钱相关字段.\nDecimal(M, D) 其中, M 表示字段中有效数据个数, D 表示小数点后个数\nDecimal(5,2) 的精度为 -999.99 - 999.99\n位 ( Bit-Value ) BIT(M) 用于存储位值, M范围(1-64), 当存储的数值小于 M, 会进行左边补0\nexample\n1 2 3 4 mysql\u0026gt; CREATE TABLE t (b BIT(8)); mysql\u0026gt; INSERT INTO t SET b = b\u0026#39;11111111\u0026#39;; mysql\u0026gt; INSERT INTO t SET b = b\u0026#39;1010\u0026#39;; mysql\u0026gt; INSERT INTO t SET b = b\u0026#39;0101\u0026#39;; 1 2 3 4 5 6 7 8 mysql\u0026gt; SELECT b+0, BIN(b), OCT(b), HEX(b) FROM t; +------+----------+--------+--------+ | b+0 | BIN(b) | OCT(b) | HEX(b) | +------+----------+--------+--------+ | 255 | 11111111 | 377 | FF | | 10 | 1010 | 12 | A | | 5 | 101 | 5 | 5 | +------+----------+--------+--------+ 参考 Mysql 8.0 官方文档\n","permalink":"https://ynikl.github.io/blog/mysql-data-type-numbers/","summary":"概览 Mysql 支持以下数据类型\n数字类型 串类型(字符和字节) 日期和时间 空间 JSON 数字类型 整数类型 Interger 类型 存储大小 bytes 其他别名 TinyInt 1 bool, boolean = tinyint(1) SmallInt 2 MediumInt 3 Int 4 BigInt 8 int(M) 表示显示宽度, 最大显示宽度为(255), M 与存储空间的大小无关. 空间大小由具体类型决定.\n如果具体数值达不到宽度, 左边就会用0值补齐至 M 位.\n浮点 ( Floating-Point ) 类型 存储 补充 范围 Float 4 bytes 单精度 Double 8 bytes 双精度 Float(p) p 表示小数点后的精度位数\nFloat(M, D) Mysql 语法: M表示总显示位数, D表示小数点后个数 \u0026ndash; 由Mysql自己做约分处理. Mysql 8.0 后废弃该语法.\n定点 ( Fixed-Point ) 用于需要准备保存字段数据, 如金钱相关字段.","title":"Mysql- 数据类型 - 数字"},{"content":"概览 Mysql 支持以下数据类型\n数字类型 串类型(字符和字节) 日期类型 空间 JSON 日期类型 Mysql 支持的数据类型\nDATE TIME DATETIME TIMESTAMP YEAR Date 只存储日期数据, 不包含时间. YYYY-MM-DD, 范围是从 \u0026lsquo;1000-01-01\u0026rsquo; to \u0026lsquo;9999-12-31\u0026rsquo;\nDateTime 存储日期, 也存储时间 'YYYY-MM-DD hh:mm:ss'\n范围是从'1000-01-01 00:00:00\u0026rsquo; to \u0026lsquo;9999-12-31 23:59:59\u0026rsquo;\nTIMESTAMP 存储Unix时间戳数据 会受到服务器时区影响\u0026ndash; 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之 时区环境变量设置 范围 \u0026lsquo;1970-01-01 00:00:01\u0026rsquo; UTC to \u0026lsquo;2038-01-19 03:14:07\u0026rsquo; UTC.\n相关函数:\nFROM_UNIXTIME 把 Unix 时间戳转化成日期 UNIX_TIMESTAMP 把日期转化成 Unix 时间戳 YEAR 显示形式 YYYY, 可选显示位数YYYY(M)\n默认4位显示 \u0026lsquo;1991\u0026rsquo; TIME 只有时间部分,没有日期部分 hh:mm:ss, 范围从 \u0026lsquo;-838:59:59\u0026rsquo; 到 \u0026lsquo;838:59:59\u0026rsquo;\n自动更新 DateTime 和 Timestamp 在 Mysql 8.0, 支持自动初始化和当数据更新时自动更新.\n1 2 3 4 CREATE TABLE t1 ( ts TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, dt DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP ); 存储毫秒级别的时间 支持存储毫秒级别的时间类型有:\nTIME DATETIME TIMESTAMP 声明模式为 type_name(fsp), fsp 为0-6, 表示小数点后个数\n1 2 3 4 CREATE TABLE fractest( c1 TIME(2), c2 DATETIME(2), c3 TIMESTAMP(2) ); INSERT INTO t1 VALUES (\u0026#39;17:51:04.777\u0026#39;, \u0026#39;2018-09-08 17:51:04.777\u0026#39;, \u0026#39;2018-09-08 17:51:04.777\u0026#39;); 存储空间 | 类型 | 大小 | 其他 | | Year | 1 bytes | | | DATE | 3 bytes | | | Time | 3 bytes | 5.6.4 之后支持小数点 | | Timestamp | 4 bytes | 同上 | | DateTime | 8 bytes | 同上 |\n小数点精度的位数\n| 0 | 0 bytes | | 1,2 | 1 bytes | | 3,4 | 2 bytes | | 4,5 | 3 bytes |\n使用推荐 高性能 Mysql 里面总结 DateTime 和 Timestamp 的使用选择:\n非特殊情况, 尽量使用 timestamp, 因为空间效率更高. Timestamp 不会存储时区, 而 Datetime 会存储时区 Timestamp 做为索引的话会更加轻量 Timestamp 和 Int 的使用选择\n没有必要用 INT 存储, 保存时间戳. 因为没有任何收益. Timestamp 可以支持数据变更时自动更新. 相关的一些函数 FROM_UNIXTIME 可以将 Unix 时间戳转化成日期 参考 Mysql 8.0 官方文档 Mysql date 内部数据结构 [高性能 Mysql]\n","permalink":"https://ynikl.github.io/blog/mysql-data-type-date/","summary":"概览 Mysql 支持以下数据类型\n数字类型 串类型(字符和字节) 日期类型 空间 JSON 日期类型 Mysql 支持的数据类型\nDATE TIME DATETIME TIMESTAMP YEAR Date 只存储日期数据, 不包含时间. YYYY-MM-DD, 范围是从 \u0026lsquo;1000-01-01\u0026rsquo; to \u0026lsquo;9999-12-31\u0026rsquo;\nDateTime 存储日期, 也存储时间 'YYYY-MM-DD hh:mm:ss'\n范围是从'1000-01-01 00:00:00\u0026rsquo; to \u0026lsquo;9999-12-31 23:59:59\u0026rsquo;\nTIMESTAMP 存储Unix时间戳数据 会受到服务器时区影响\u0026ndash; 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之 时区环境变量设置 范围 \u0026lsquo;1970-01-01 00:00:01\u0026rsquo; UTC to \u0026lsquo;2038-01-19 03:14:07\u0026rsquo; UTC.\n相关函数:\nFROM_UNIXTIME 把 Unix 时间戳转化成日期 UNIX_TIMESTAMP 把日期转化成 Unix 时间戳 YEAR 显示形式 YYYY, 可选显示位数YYYY(M)\n默认4位显示 \u0026lsquo;1991\u0026rsquo; TIME 只有时间部分,没有日期部分 hh:mm:ss, 范围从 \u0026lsquo;-838:59:59\u0026rsquo; 到 \u0026lsquo;838:59:59\u0026rsquo;","title":"Mysql- 数据类型 - 日期"},{"content":"简单分析下xorm 里面 session 和 slave 里面 close 的代码\n1 xorm.EngineGroup.Slave() Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用）） 如果这时候再调用 close 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。 如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 NewSsession 和 Close, 所以不在需要手动调用close 1 xorm.EngineGroup.NewSsession() 会返回一个xorm.Session对象, 对应我们数据库操作中的\u0026quot;会话事务\u0026quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交) 调用 close, 对清除 session 中未提交的事务和一些缓存的 sql 前置处理语句 对于普通 select 语句调不调用是没什么太大影响 (但是还是建议new之后调用close) ","permalink":"https://ynikl.github.io/posts/xorm-slave-newsseion/","summary":"简单分析下xorm 里面 session 和 slave 里面 close 的代码\n1 xorm.EngineGroup.Slave() Slave () 会直接返回 xorm.Engine对象（指代我们项目到数据库的逻辑连接（里面有tcp复用）） 如果这时候再调用 close 的会，会直接把 xorm.Engine 关闭（即数据库连接关闭）。 如果用这个 engine， 执行查询动作如 find， get时. 内部会有自动执行 NewSsession 和 Close, 所以不在需要手动调用close 1 xorm.EngineGroup.NewSsession() 会返回一个xorm.Session对象, 对应我们数据库操作中的\u0026quot;会话事务\u0026quot;, 是否自动提交之类选项.(未手动开始事务时,都是自动提交) 调用 close, 对清除 session 中未提交的事务和一些缓存的 sql 前置处理语句 对于普通 select 语句调不调用是没什么太大影响 (但是还是建议new之后调用close) ","title":"xorm 的 session 和 salve 的区别"},{"content":"想自己整理一篇基本的 make 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.\n阮一峰文章地址\n如果不写 c, 主要理解就几个概念就可以使用了\ntarget 可以用来当作想要执行的命令集的名称 .PHONY: 可以用来声明命令集名称 recipes 实际执行的命令集合 介绍一下我自己的应用场景 我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.\ncase 1: 简化本地编译和测试, 自动做 setup 和 teardown\n当我想要尝试一下整个项目是否编译\n1 2 3 4 .PHONY: build build: go build . rm -rf [PROJECT NAME] 使用上面的 makefile, 我就只需要 make build, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 build 一下\ncase 2: git 提交代码自动化操作\n当我想要把我代码推送到, 测试分支, 进行集成测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .PHONY: dev ProjectName=\u0026#34;Your Project Name\u0026#34; TargetBranch=\u0026#34;Your want to merge branch\u0026#34; CurBranch=$(shell git branch --show-current) dev: go build . rm -f $(ProjectName) git add . git commit -m $(msg) git push git checkout ${DevBranch} git pull --rebase git merge ${CurBranch} -m \u0026#34;Merge branch \u0026#39;${CurBranch}\u0026#39; into ${DevBranch}\u0026#34; go build rm -f $(ProjectName) git push git checkout ${CurBranch} 简化 git 的操作流程, 现在只需要make dev就可以完成, 还可以在合并之前和之后增加测试, 我自己目前知识简单的 build 下而已 QAQ.\n","permalink":"https://ynikl.github.io/posts/makefile-basic-use/","summary":"想自己整理一篇基本的 make 指令用法, 突然发现 阮一峰大佬已经整理了一篇很完整的博客, 遂放弃.\n阮一峰文章地址\n如果不写 c, 主要理解就几个概念就可以使用了\ntarget 可以用来当作想要执行的命令集的名称 .PHONY: 可以用来声明命令集名称 recipes 实际执行的命令集合 介绍一下我自己的应用场景 我目前主力编程语言是 go, 我用的编辑器是 vim, 所以我基本就在 shell 里面完成编码任务.\ncase 1: 简化本地编译和测试, 自动做 setup 和 teardown\n当我想要尝试一下整个项目是否编译\n1 2 3 4 .PHONY: build build: go build . rm -rf [PROJECT NAME] 使用上面的 makefile, 我就只需要 make build, 就不用再删除编译出来文件. QAQ, 可以再加一些单元测试命令, 检测测试是否通过. 因为公司的项目, 在单测这方面做的不是很好, 我自己就是简单 build 一下\ncase 2: git 提交代码自动化操作\n当我想要把我代码推送到, 测试分支, 进行集成测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 .","title":"Make 的基本使用"},{"content":"公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.\n介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件\n消息中间件的作用\n解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释\nProducer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型\nfanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:\n生产者连接到 Broker, 开启信道 生产者声明一个交换器 生产者声明一个队列 生产者通过路由键将交换器和队列绑定 生产者发送消息到 Broker 交换器根据接受对路由键匹配队列 投递到对应的消息队列 如果没有匹配的队列, 丢弃或者退回给生产者 消费者接受消息流程:\n建立连接, 开启信道 消费者向 Broker 发起消息请求 Broker 回应并返回消息 消费者发送确认 (ack) 接受到消息 关闭信道 关闭连接 AMQP 位于应用层的通信协议 ( 在 TCP 之上, 将数据填充到 TCP 中)\n几个基础的协议定义的操作\nProtocal Header 0-9-1 指定协议 Connection.Start Channel.Open Basic.Publish 推送消息 Channel.Close Connection.Close 部署 在你的机子上部署一个玩具吧\n采用 docker 部署 docker run -itd --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management\n进入管理页面 访问 http://127.0.0.1:15672/\n登入 用户名: guest 密码: guest\n更多默认配置\n管理 进入交互 shell docker exec -it rabbitmq bash\n增加一个用户 rabbitmqctl add_user ian ian1234\n增加一个 vhost rabbitmqctl add_vhost playground\nvhost是什么? vhost (virtual host), 虚拟主机, 在实例间提供逻辑上的分离 \u0026ndash; 实现数据隔离. RabbitMQ 默认创建一个名为 \u0026ldquo;/\u0026rdquo; 的 vhost\n查看 vhost rabbitmqctl list_vhosts\n设置权限 rabbitmqctl set_permissions --vhost playground ian \u0026quot;.*\u0026quot; \u0026quot;.*\u0026quot; \u0026quot;.*\u0026quot;\namqp uri规则 \u0026quot;amqp://userName:password@ipAddress:portNumber/virtualHost\u0026quot; 根据我们上述的新增在用户和vhost, 可以得到uri: amqp://ian:ian1234@localhost:5672/playground 5672为 rabbitmq的默认终端, 我们的 docker contain 需要把它映射到本机带端口\n实现生产者 go 使用 github.com/rabbitmq/amqp091-go 包\n根据上文的消息投递流程实现\n连接到 broker\n1 2 connectionUrl := \u0026#34;amqp://ian:ian1234@localhost:5672/playground\u0026#34; conn, err := amqp.Dial(connectionUrl) 打开 channel\n1 ch, err := conn.Channel() 声明一个交互器( 该步骤可以省略, 直接使用默认的 direct交换器)\n1 err = ch.ExchangeDeclare(\u0026#34;hello-exchange\u0026#34;, \u0026#34;direct\u0026#34;, true, false, false, false, nil) 声明一个队列\n1 q, err := ch.QueueDeclare(\u0026#34;hello\u0026#34;, true, false, false, false, nil) 将 Exchange 绑定到队列上 (如果声明交换器的步骤省略了, 该步骤也可以省略)\n1 err = ch.QueueBind(q.Name, \u0026#34;hellokey\u0026#34;, \u0026#34;hello-exchange\u0026#34;, false, nil) 发送消息 (如果没有声明交换器, 对应的参数直接传入空字符串\u0026quot;\u0026quot;, 会使用默认的 direct 交换器)\n1 2 3 4 err = ch.Publish(\u0026#34;hello-exchange\u0026#34;, \u0026#34;hellokey\u0026#34;, false, false, amqp.Publishing{ ContentType: \u0026#34;text/plain\u0026#34;, Body: []byte(body), }) 完整代码地址\n登录到本地管理页面可以查看类似于下图, 有消息投递\n实现消费者 消费者相对于生产者就简单多了. 打开信道直接消费就可以了.\n连接, 打开信道\n1 2 3 4 5 6 7 8 connectionUrl := \u0026#34;amqp://ian:ian1234@localhost:5672/playground\u0026#34; conn, err := amqp.Dial(connectionUrl) if err != nil { log.Fatal(err) } defer conn.Close() ch, err := conn.Channel() 开始消费\n1 2 3 4 5 6 7 // msgsCh 是一个消息管道 msgsCh, err := ch.Consume(\u0026#34;hello\u0026#34;, \u0026#34;consumer-name\u0026#34;, true, false, false, false, nil) for msg := range msgsCh { log.Println(\u0026#34;received a message: \u0026#34;, string(msg.Body)) } log.Println(\u0026#34;done, msg channel is closed\u0026#34;) 参考 官网 tutorial RabbitMQ 实战指南 ","permalink":"https://ynikl.github.io/blog/rabbitmq-learning-note/","summary":"公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.\n介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件\n消息中间件的作用\n解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释\nProducer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型\nfanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:","title":"RabbitMQ 基本入门实践"},{"content":" The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.\nlife if not short\n","permalink":"https://ynikl.github.io/posts/life-is-not-short/","summary":"The most surprising thing is that you wouldn’t let anyone steal your property, but you consistently let people steal your time, which is infinitely more valuable.\nlife if not short","title":"Life Is Not Short"},{"content":"微服务是针对公司某一复杂业务程序实现的设计模式, 与巨石架构(Monolith)是相对的.\n微服务对应的应该是公司业务能力层级上的拆分与设计, 为了减少业务之间的耦合而导致相互拖累, 在对外业务能力不变的情况下, 在应用内部将能力拆分成一些微小服务. 也可以理解为是对巨石架构进行\u0026quot;解耦\u0026quot;.\n举个例子: 原先公司做的是一个外卖系统, 这个系统中可能包含了客户下单, 商家接单, 骑手配送等功能. 但是全部都打包在一个程序中. 发版时, 可能客户下单功能修改了功能, 导致商家没办法接单了. 或者商家接单功能实现的有问题, 导致整个应用程序挂掉, 现在用户下不了单, 骑手也没法接单, 整个公司的业务就瘫痪了. 然后, 在客户下单-商家接单-骑手配送这个大业务流程不变的情况下, 我们在外卖系统内部, 分成了多个服务, 各个服务之间使用 API 松耦合通信, 隔离影响. 比如, 客户下单服务, 专门处理客户下单这一业务, 并将生成的订单推送到消息代理 (如:kafka) 或直接推送给其他服务等, 它只要能保证完成它的职责即可. 后者, 就可以称之为 \u0026ldquo;微服务架构\u0026rdquo;. 当然, 这只是一个例子, 实际情况会更加复杂.\n在\u0026laquo;微服务设计模式\u0026raquo; 中对微服务的定义:\n将应用程序构建为松耦合, 可独立部署的一组服务\n书中也对\u0026quot;微\u0026quot;的大小给了定义:\n大小的定义为能够由小团队开发服务\n不用刻意地去追求服务的大小. 微服务的落地, 往往就会伴随着, 组织结构和开发的流程的改变, 由不同的 小团队 独立负某一服务.\n像我们现在如果提到微服务, 就经常也会提到一些微服务框架 go-zero, go-micro 或者基础设施 docker, k8s 或者工具 gRPC, prometheus 之类的.\n像这种框架和组件之类的只是一种技术工具. 他们并不能定义微服务, 他们可能只是为了克服微服务架构设计带来的某一些缺陷, 或者与微服务结合可以发挥出更大的价值.\n举个极端的例子: 在你后端业务完全不划分的情况下, 你甚至可以在 go-zero 的框架基础上, 将你公司所有的业务打包进一个应用程序, 用docker打包, 并部署在k8s环境中, 再通过 gRPC 与前端通信. 你用到了很多著名的名词技术, 但是你实现出来应用的是巨石架构还是微服务架构呢?\n参考 微服务设计模式\n","permalink":"https://ynikl.github.io/books/miscroservices-patterns/","summary":"微服务是针对公司某一复杂业务程序实现的设计模式, 与巨石架构(Monolith)是相对的.\n微服务对应的应该是公司业务能力层级上的拆分与设计, 为了减少业务之间的耦合而导致相互拖累, 在对外业务能力不变的情况下, 在应用内部将能力拆分成一些微小服务. 也可以理解为是对巨石架构进行\u0026quot;解耦\u0026quot;.\n举个例子: 原先公司做的是一个外卖系统, 这个系统中可能包含了客户下单, 商家接单, 骑手配送等功能. 但是全部都打包在一个程序中. 发版时, 可能客户下单功能修改了功能, 导致商家没办法接单了. 或者商家接单功能实现的有问题, 导致整个应用程序挂掉, 现在用户下不了单, 骑手也没法接单, 整个公司的业务就瘫痪了. 然后, 在客户下单-商家接单-骑手配送这个大业务流程不变的情况下, 我们在外卖系统内部, 分成了多个服务, 各个服务之间使用 API 松耦合通信, 隔离影响. 比如, 客户下单服务, 专门处理客户下单这一业务, 并将生成的订单推送到消息代理 (如:kafka) 或直接推送给其他服务等, 它只要能保证完成它的职责即可. 后者, 就可以称之为 \u0026ldquo;微服务架构\u0026rdquo;. 当然, 这只是一个例子, 实际情况会更加复杂.\n在\u0026laquo;微服务设计模式\u0026raquo; 中对微服务的定义:\n将应用程序构建为松耦合, 可独立部署的一组服务\n书中也对\u0026quot;微\u0026quot;的大小给了定义:\n大小的定义为能够由小团队开发服务\n不用刻意地去追求服务的大小. 微服务的落地, 往往就会伴随着, 组织结构和开发的流程的改变, 由不同的 小团队 独立负某一服务.\n像我们现在如果提到微服务, 就经常也会提到一些微服务框架 go-zero, go-micro 或者基础设施 docker, k8s 或者工具 gRPC, prometheus 之类的.\n像这种框架和组件之类的只是一种技术工具. 他们并不能定义微服务, 他们可能只是为了克服微服务架构设计带来的某一些缺陷, 或者与微服务结合可以发挥出更大的价值.","title":"我理解的微服务 -- 读《微服务设计模式》总结"},{"content":"胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 连接 两个 不兼容 的组件, 或是两个不兼容的服务.\n胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.\n参考 Quora 回答 wiki\n","permalink":"https://ynikl.github.io/posts/what-is-glue-code/","summary":"胶水代码(glue code), 可以了解为是大号的适配器, 没有业务意义, 主要的目的是用于 连接 两个 不兼容 的组件, 或是两个不兼容的服务.\n胶水代码可以是一段代码, 也可以是一个脚本文件, 甚至可以是新的组件.\n参考 Quora 回答 wiki","title":"什么是 \"胶水代码\""},{"content":"今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.\n简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:\n1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:\narray 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址\n简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, \u0026ldquo;左闭右开原则\u0026rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即\u0026quot;cap(a) - low\u0026quot; low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt.Printf(\u0026#34;b: len %d, cap %d, c: len %d, c:cap %d\u0026#34;, len(b), cap(b), len(c), cap(c)) 输出: b: len 5, cap 10, c: len 2, c:cap 8 底层分配情况如下:\n1 2 3 4 5 6 7 底层数组 : [0 0 0 0 0 0 0 0 0 0] 旧切片容量: 10 : [0 0 0 0 0 0 0 0 0 0] 旧切片长度: 5 : [0 0 0 0 0] 新切片容量: 8 : [0 0 0 0 0 0 0 0] 新切片长度: 2 : [0 0] 完整版重切片 a[low:high:max] 完整版是为了补充简单版, 新切片会默认拥有从开始下标后的所有底层数组容量. 即新数组拥有修改全部数据底层能力 (重切片出来的不同切片, 在没有 append 操作触发重新分配底层数组的前提下, 指向的都是同一个数据, 修改数据相互可见)\n增加了 max 参数, 表示新切片可以获取到最大的原切片的容量大小. 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4:6] fmt.Printf(\u0026#34;b: len %d, cap %d, c: len %d, c:cap %d\u0026#34;, len(b), cap(b), len(c), cap(c)) 输出: b: len 5, cap 10, c: len 2, c:cap 4 底层分配情况如下\n1 2 3 4 5 6 7 底层数组 : [0 0 0 0 0 0 0 0 0 0] 旧切片容量:10 : [0 0 0 0 0 0 0 0 0 0] 旧切片长度:5 : [0 0 0 0 0] 新切片容量:4 : [0 0 0 0] 新切片长度:2 : [0 0] 但是, 如果 max 要求获取的容量大于旧数据容量. 可想而知, 那一定会 panic\n1 2 3 4 5 6 7 a := [10]int{} b := a[:4:4] c := b[0:4:5] 输出: panic: runtime error: slice bounds out of range [::5] with capacity 4 所以参数要求: 0 \u0026lt;= low \u0026lt;= high \u0026lt;= max \u0026lt;= cap(a)\n参考 stack overflow 问题1 简单版 stack overflow 问题2 详细版 golang 官方文档 ","permalink":"https://ynikl.github.io/blog/golang-reslicing-slice/","summary":"今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.\n简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:\n1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:\narray 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址\n简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, \u0026ldquo;左闭右开原则\u0026rdquo; 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即\u0026quot;cap(a) - low\u0026quot; low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt.","title":"Go中slice[i:j:k]第三个参数是做什么的"},{"content":"一个完善的方案的需要考虑的三个方面\n当前需求 理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。\n结果上下文 好处：当前方案的好处，解决了什么 弊端: 什么是它不能解决的 问题：引入什么新的问题 与其他方案的关系 前导：当前方案是怎么演变出来。 后续：当前方案会引入什么新问题，有什么后续的解决方案 替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案 参考《微服务设计模式》的1.6.2\u0026quot;模式和模式语言\u0026quot;, 相对减少了模式关系中的泛化和特化。\n","permalink":"https://ynikl.github.io/posts/thinking-choosing-tech/","summary":"一个完善的方案的需要考虑的三个方面\n当前需求 理清楚初心，当前方案要解决的问题。聚焦到主要解决的问题。\n结果上下文 好处：当前方案的好处，解决了什么 弊端: 什么是它不能解决的 问题：引入什么新的问题 与其他方案的关系 前导：当前方案是怎么演变出来。 后续：当前方案会引入什么新问题，有什么后续的解决方案 替换：可以解决同样需求的情况下，还没什么备选方案。为什么选择了当前方案 参考《微服务设计模式》的1.6.2\u0026quot;模式和模式语言\u0026quot;, 相对减少了模式关系中的泛化和特化。","title":"我们为何选择 XXX 技术方案"},{"content":"场景 在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.\n比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.\n分析 优点:\n将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象 在不同策略之间划清界限 增加单独策略的可测试性 缺点:\n后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动 会带来的问题:\n可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力 总结:\n在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).\n实现流程 主要的思想, 我觉得还是 面向接口编程\n分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(interface) 将算法或策略剥离成独立的策略对象, 并实现上述抽象接口 主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略\u0026quot;插入\u0026quot;(plugin)流程, 调用, 获取结果, ok. 参考 refactoringguru - strategy ","permalink":"https://ynikl.github.io/posts/strategy-pattern/","summary":"场景 在有多种算法, 计算策略, 甚至业务流程以一种可相互替换的场景出现时. 就可以考虑该设计模式.\n比如: 地图导航的出行路线计算, 商品购买的捆绑促销方式等.\n分析 优点:\n将具体的策略与调用策略的流程代码解耦, 修改策略代码时候可以仅修改策略对象 在不同策略之间划清界限 增加单独策略的可测试性 缺点:\n后续变更有一定束缚性 ( 限制在抽象接口中 ) . 若需要打破策略的抽象接口, 就会造成较大的改动 会带来的问题:\n可能将原先一个流程代码, 拆分成了多分. 如果代码结构没有组织好, 想要大局把握可能比较费力 总结:\n在流程算法策略有多个 ( 如果只有一个就没有必要抽象了, 一梭子写完就行 ), 且各个策略都有一定复杂性 ( 只是简单几个 if 的也略了吧 ) 的场景下. 就可以使用 ( 接口的签名可以写的比较松一点, 传递和返回较高层级的数据对象 ).\n实现流程 主要的思想, 我觉得还是 面向接口编程\n分析要拆分的算法或者策略, 将主流程和策略部分, 提取抽象成一个通用接口(interface) 将算法或策略剥离成独立的策略对象, 并实现上述抽象接口 主流程代码根据业务逻辑, 初始化策略对象, 将需要的策略\u0026quot;插入\u0026quot;(plugin)流程, 调用, 获取结果, ok. 参考 refactoringguru - strategy ","title":"设计模式 -- 策略模式"},{"content":"链表的定义： wiki 百科给出定义:\nIn computer science, a linked list is a linear collection of data elemetns whose order is not given by their physical placement in memory. Instead, each element points to the next.\n翻译一下：\n一个线性表 每个元素会指向下一个元素的位置 链表的优缺点 优点:\n不需要提前分配内存 在查找到元素位置的提前下，插入和删除动作是一个常量，即 O(1) 没有容量上限，可以自由扩容 缺点:\n查询某个元素，需要从头开始遍历，即 O(n) 实现代码\n单向链表 最普通的链表\n双向链表 循环链表 ","permalink":"https://ynikl.github.io/dsa/linked-list/","summary":"链表的定义： wiki 百科给出定义:\nIn computer science, a linked list is a linear collection of data elemetns whose order is not given by their physical placement in memory. Instead, each element points to the next.\n翻译一下：\n一个线性表 每个元素会指向下一个元素的位置 链表的优缺点 优点:\n不需要提前分配内存 在查找到元素位置的提前下，插入和删除动作是一个常量，即 O(1) 没有容量上限，可以自由扩容 缺点:\n查询某个元素，需要从头开始遍历，即 O(n) 实现代码\n单向链表 最普通的链表\n双向链表 循环链表 ","title":"Linked List"},{"content":"github code\n非科班出身的我，有好几次尝试过跟着国外大学的课程重新学习计算机基础， 但是每次都是半途放弃了，这次尝试根据数据结构主题进行学习。\n主流的数据结构类型\nLinked List（链表） List （线性表） 2D Arrays Strings（串） Stack （栈） Queue（队列） Hash Table（哈希表） Heap （堆） Tree （树） Graphs（图） Binary Tree Binary Search Tree ","permalink":"https://ynikl.github.io/dsa/datastructures-list/","summary":"github code\n非科班出身的我，有好几次尝试过跟着国外大学的课程重新学习计算机基础， 但是每次都是半途放弃了，这次尝试根据数据结构主题进行学习。\n主流的数据结构类型\nLinked List（链表） List （线性表） 2D Arrays Strings（串） Stack （栈） Queue（队列） Hash Table（哈希表） Heap （堆） Tree （树） Graphs（图） Binary Tree Binary Search Tree ","title":"基础数据结构列表"},{"content":"大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”\n大端的优势是高位计算，和可读性 小端的优势的低位运算 各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。\n以上是阅读阮一峰的博文-字节序探析：大端与小端的比较的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。\n参考连接 阮一峰的博文-字节序探析：大端与小端的比较 ","permalink":"https://ynikl.github.io/posts/endianness/","summary":"大端和小端的命名出处是来自于《格列佛游记》中吃鸡蛋分成从大端开始吃的“大端派”和从小端开始吃的“小端派”\n大端的优势是高位计算，和可读性 小端的优势的低位运算 各自的优劣分析本质上还是因为内存的连续性，需要修改和读取的位数越少越有优势。\n以上是阅读阮一峰的博文-字节序探析：大端与小端的比较的简单总结。本来自己也是想要整理一篇关于大小端分析的文章。刚好阮老师发文了，收获甚多，就不在自己整理了。\n参考连接 阮一峰的博文-字节序探析：大端与小端的比较 ","title":"计算机中的：大端和小端"},{"content":"是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。\n在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。\n模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。\ngo.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =\u0026gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思\nmodule 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据\ngo.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。\n1 2 3 \u0026gt; cat go.sum example.com/mod v1.0.0 h1:6Cz1EhbAk54HWaw6fhCpSPxWGjIMLuF9MlO4Ou568sQ= example.com/mod v1.0.0/go.mod h1:mgm3p5SY7FVOgVLVSXIYK9qk0umwLQLOG06xLpFUeTI= 文件中以：模块路径 + 版本号 + hash算法名 + hash值 的组合写入\nexample.com/mod 是模块路径名 v1.0.0 是版本号，在第二行有是以/go.mod结尾，代表该 hash 值是对依赖模块本身的go.mod文件的 hash 值 h1: 代表使用的 hash 算法，代表 SHA-256 哈希值，没什么好说的了 Module cache 本地的目录，用户存放下载下来的的模块文件。\n默认路径是在$GOPAth/pkg/mod\nModule cache 文件夹详细说明\n语义化版本 go 采用语义化版本 v1.18.1\n一个模块的版本是不变的 —— 只要拉过一次模块，该模块就会存在缓存在Go 官方的模块服务中，以后拉取改模块就会从官方的模块服务拉取，且该动作不可逆。\n版本号 = \u0026ldquo;v\u0026rdquo; + 主版本号 + 小版本号 + 补丁号\n主版本号的增加后，小版本号和补丁号要重新置零。主版本号增加，代表该版本出现不向后兼容的改动。比如移除旧的包 小版本号增加后，补丁号重新置零。表示版本改动公共接口但是向后兼容的，比如增加一个函数 补丁号增加，表示该版本对公开接口没有改动。比如修改bug 版本的后面可能还会增加一些提前发布的标识，比如 v1.18.1-beta v1.18.1-pre\n当 go 的 模块没有声明发布版本的时候(比如拉取某分支做为模块)，go 就会自己生成 伪版本, 可以仅作了解。\n如果使用模块的版本号大于等于v2的时候，需要在引入包的后缀加上/v2\n1 import \u0026#34;github.com/urfave/cli/v2\u0026#34; 怎么用 开启模块功能 模块功能的开启, 配置在环境变量GO111MODULE\n=off, 忽略GOPATH路径下的go.mod文件，直接引用GOPATH/src中的包文件 =on，启用模块功能 =auto, 如果项目有go.mod文件启用，没有则是用GOPATH模式 常用命令快览 go mod\n1 go mod init example.com/example/m1 初始化当前文件夹，让其成为一个 module\ngo get\n1 go get -d example.com/example/m1@v1.2.3 主要用法:修改当前项目的go.mod，引入新的依赖项目。\n-d 的标志，表示获取目标包之后，不进行本地编译或安装。Go 1.18 之后的默认行为。\n1 go get -d -u example.com/example/m1 也可以用来升级依赖模块的版本，升级到最新版本。如果目标模块的新版的所依赖的其他模块也可能会一并升级。也可以指定版本-u=patch\n修改制定依赖版本的操作也可以通过制定后缀版本号实现\n1 go get example.com/example/m1@v2.3.1 go mod edit\n通过指令修改go.mod文件，与直接修改go.mod效果一致\n1 go mod edit -replace example.com/a@v1.0.0=./a 将某个模块引用指向本地。可以用来解决引用正在开发中，还没有发布过的模块\ngo mod tidy\n根据项目的源码引用整理go.mod中的引用情况。添加缺少的依赖，或者移除冗余的依赖。\ngo mod vendor\n将依赖一并放在自己项目的中，可以省去自己拉取依赖的很多麻烦，提高可用性。go 项目的根目录中的 vendor 文件夹就是用来干这个事的\n将项目依赖移入vendor文件中，当存在了vendor文件夹，项目会使用vendor中的依赖。大于 1.14 版本需要指定参数-mod=vendor才会启用\n本地修改之后模块版本之后需要，重新使用go mod vendor将新的依赖模块同步入vendor中。\ngo mod verify\n用于检测模块再被下载之后入，模块中的代码是否有被修改过。\n对源码文件的 hash，与当前文件的go.sum中的 hash 对比校验是否有被修改过。 如果go.sum中没有该模块的hash值，就会从checksum database 中获取目标 hash 值。（除非设置了GOPRIVATE或者GONOSUMDB)\n1 2 ❯ go mod verify github.com/ynikl/playmod v1.0.0: dir has been modified (/Users/ian/go/pkg/mod/github.com/ynikl/playmod@v1.0.0) 上述例子，源文件被我手动强制修改过，就会报错\ngo mod why\n1 go mod why example.com/mod 用于解释当前项目为什么会依赖某一个模块，输出项目对目标模块的依赖树图\ngo list -m all\n可以用于输出当前项目依赖的所有模块\nMVS Minimal version selection（MVS), 当引入的不同模块，又存在依赖与相同模块的（相同大版本，不同版本小版本）的时候。\n在使用模块相关命令的时候，会选择所依赖的不同版本的中，构建项目所需要从最小版本。\nA.12 与 B1.2 分别需要 C1.3 和 C1.4 为了是项目能正常进行，需要使用 C1.4 版本\n参考 官网Go Modules参考 Minimal Version Seletion 官方介绍 Modules 博文 提议 ","permalink":"https://ynikl.github.io/blog/go-modules/","summary":"是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。\n在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。\n模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。\ngo.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =\u0026gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思\nmodule 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据\ngo.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。\n1 2 3 \u0026gt; cat go.","title":"小窥 Go 中的 Modules"},{"content":"mysql 在事务中再开启事务，前一个事务会被自动提交\nstackoverflow\n","permalink":"https://ynikl.github.io/posts/mysql-nested-transactions/","summary":"mysql 在事务中再开启事务，前一个事务会被自动提交\nstackoverflow","title":"Mysql 不支持事务嵌套"},{"content":"举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。\n并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构\n并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。\nConcurrency is not Parallelism by Rob Pike\n","permalink":"https://ynikl.github.io/posts/concurrency-and-parallelism/","summary":"举个例子，电脑的鼠标，键盘或者其他设备的驱动程序，他们是并发的，但不是并行的。他们也不需要并行去运行。\n并发是很多程序（形容运行任务，不是广义上的程序）的独立运行，并发是一种程序设计结构\n并行是一次性运行很多程序，并行是一种程序的运行现象，当成程序设计成并发的，他很容易就变成了并行， 但并行不一定是并发的目的。\nConcurrency is not Parallelism by Rob Pike","title":"并发与并行的区别"},{"content":"读Randy\u0026rsquo;s的博客遗憾最小化框架有感\n在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定\n做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾\nJeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。\nBezos的视频地址 Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁\nAsk yourself: in 10 years from now, will you be proud of having done this? \u0026hellip; Do things that your future self will be proud, is my motto for the time being.\n","permalink":"https://ynikl.github.io/posts/how-make-decisions/","summary":"读Randy\u0026rsquo;s的博客遗憾最小化框架有感\n在面对人生岔路口的时候，很多时候就需要对不同决定做取舍，是否勇于打破自己的人生的桎梏。怎么样要做出让自己十年之后的自己不会后悔的决定\n做决定之前，问问自己的内心，如果我不这么做，几年之后，年老之后会不会后悔，会不会遗憾\nJeff Bezos 曾经谈到了自己是如何做决定的，他称之为 Regret Minimization Framwork (遗憾最小化框架) —— 他会想象自己到了 80 岁的时候，是否会认为不做这件事情会让自己遗憾。尽量让人生的遗憾数量最小化。即使当时的选择后来看来是错误的，但也不会后悔尝试过。\nBezos的视频地址 Cycle.js 作者 staltz 回答是否会对自己做的库没有像 React / Vue 那样火起来而感到气馁\nAsk yourself: in 10 years from now, will you be proud of having done this? \u0026hellip; Do things that your future self will be proud, is my motto for the time being.","title":"如何做决定——遗憾最小化"},{"content":"Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法\nLock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。\nMutex 实现了一个 sync.Locker 接口, 该接口只有两个方法\nLock Unlock Mutex 锁有几种状态\nmutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量\nmutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态\n正常模式 normal 饥饿模式 starvation 正常模式下，等待获取的锁的协程遵循先进先出的原则。\n但是，当释放锁的时候如果有新协程进入获取锁代码的时候。因为新入协程本身已经运行在CPU上了，所以有抢占锁的优势。由于阻塞在等待队列上的协程，竞争不过新入协程。当等待时间操作 1ms，就会触发饥饿模式。\n饥饿模式，进行互斥锁解锁的协程直接的将锁的所有权直接已经给等待队列的第一个协程。新进协程被禁止抢占互斥锁。\n在转移所有权的时候，如果满足一下任意条件，则进入正常模式：\n锁的等待者只剩最后一个 等待时间小于1ms 正常模式有利于更好的性能，饥饿模式则避免出现“饿死”情况。\nMutex 的方法详解 Lock 第一步，通过调用 atomic 的 CAS 操作，尝试加锁，如果成功加锁直接返回\n1 atomic.CompareAndSwapInt32(\u0026amp;m.state, 0, mutexLocked) 如果第一步失败，则代表该锁已经被加过锁，锁定了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 func (m *Mutex) lockSlow() { // 当前协程的变量, 可以用于表示当前协程的状态 // 用于统计锁的等待时长，是否进入饥饿模式 var waitStartTime int64 starving := false // 当前协程是否处于饥饿 awoke := false // 是否处于唤醒 iter := 0 // 统计自旋次数 old := m.state for { // 进入自旋的状态条件， **已经锁定** 且非饥饿状态。 if old\u0026amp;(mutexLocked|mutexStarving) == mutexLocked \u0026amp;\u0026amp; runtime_canSpin(iter) { // 如果锁的状态 woken 字段未被标记， 将自身标记位唤醒，且将 Mutex 的 woken 位标记位1 // 当协程自己进入获取锁的第一候选人 if !awoke \u0026amp;\u0026amp; old\u0026amp;mutexWoken == 0 \u0026amp;\u0026amp; old\u0026gt;\u0026gt;mutexWaiterShift != 0 \u0026amp;\u0026amp; atomic.CompareAndSwapInt32(\u0026amp;m.state, old, old|mutexWoken) { awoke = true } runtime_doSpin() // 控制自旋次数，大于4次之后不进入自旋状态 iter++ // 获取最新的状态 old = m.state continue } // 有可能，自旋自后已经解锁或者只是单纯不能自旋限制了。下面尝试通过 CAS 竞争锁。 // 新值用于设置新的状态 new := old // 非饥饿状态才设置锁定 if old\u0026amp;mutexStarving == 0 { new |= mutexLocked } if old\u0026amp;(mutexLocked|mutexStarving) != 0 { // 等待者加1 new += 1 \u0026lt;\u0026lt; mutexWaiterShift } // 当前协程是饥饿状态，尝试标记锁的新状态位饥饿状态。 if starving \u0026amp;\u0026amp; old\u0026amp;mutexLocked != 0 { new |= mutexStarving } if awoke { // The goroutine has been woken from sleep, // so we need to reset the flag in either case. if new\u0026amp;mutexWoken == 0 { // Mutex 的唤醒位被抢走，出现不一致。协程变量的唤醒位应该与 Mutex 的唤醒位一致 throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // 标志 锁的唤醒位为0 new \u0026amp;^= mutexWoken } // CAS 尝试, Mutex 状态没有被变更 if atomic.CompareAndSwapInt32(\u0026amp;m.state, old, new) { // 非饥饿状态下，CAS 成功新的 new 字段中会有 mutexLocked 标记（在new下的第一个if）。当前协程获取到了互斥锁, if old\u0026amp;(mutexLocked|mutexStarving) == 0 { break // locked the mutex with CAS } // queueLifo 表示该协程是否为第一次获取锁。如果中间被唤醒过，这放在等待队列头部 queueLifo := waitStartTime != 0 if waitStartTime == 0 { waitStartTime = runtime_nanotime() } // 通过信号量，进入阻塞 runtime_SemacquireMutex(\u0026amp;m.sema, queueLifo, 1) // 进入饥饿模式 starving = starving || runtime_nanotime()-waitStartTime \u0026gt; starvationThresholdNs old = m.state // 当前是饥饿模式 if old\u0026amp;mutexStarving != 0 { // 如果当前锁的状态位饥饿模式，但是当前协程可以执行的当前行代码，代表当前协程已经被从阻塞中唤醒。 // 饥饿状态 + 被唤醒 =》当前锁已经已经到当前协程上 if old\u0026amp;(mutexLocked|mutexWoken) != 0 || old\u0026gt;\u0026gt;mutexWaiterShift == 0 { // 检查状态一致 throw(\u0026#34;sync: inconsistent mutex state\u0026#34;) } // 由当协程来设置最新的锁定状态 delta := int32(mutexLocked - 1\u0026lt;\u0026lt;mutexWaiterShift) // 判断是否需要退出饥饿模式 if !starving || old\u0026gt;\u0026gt;mutexWaiterShift == 1 { delta -= mutexStarving } atomic.AddInt32(\u0026amp;m.state, delta) break } // 当前是正常模式，通过CAS自由竞争锁。 awoke = true iter = 0 // 重置计数 } else { // 再来 old = m.state } } } 是否可以进入自旋状态代码解释源码地址\nUnlock 第一步直接减去 mutexLocked 标志位常量，如果 new 等于0结束——简单（锁一次开一次，easy）。\n1 new := atomic.AddInt32(\u0026amp;m.state, -mutexLocked) 如果 state 还不等于0（有协程等待，竞争锁）, 进入 unlockSlow\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func (m *Mutex) unlockSlow(new int32) { // 上一步已经减过 locked 位， 在加上应该等于1，否则不是正常解锁（解锁未锁定的锁）。 if (new+mutexLocked)\u0026amp;mutexLocked == 0 { fatal(\u0026#34;sync: unlock of unlocked mutex\u0026#34;) } // 正常模式 if new\u0026amp;mutexStarving == 0 { old := new for { // If there are no waiters or a goroutine has already // been woken or grabbed the lock, no need to wake anyone. // In starvation mode ownership is directly handed off from unlocking // goroutine to the next waiter. We are not part of this chain, // since we did not observe mutexStarving when we unlocked the mutex above. // So get off the way. // 没有等待协程无需通过信号量唤醒 // 1. 如果 mutexLocked 位为1，则代表锁已经被新入协程获取。 // 2. mutexWoken 代表协程有协程正在活动，无需再释放信号量 // 3. mutexStarving 锁的状态一直被抢占，才会导致当前位饥饿状态，无需在释放信号量 if old\u0026gt;\u0026gt;mutexWaiterShift == 0 || old\u0026amp;(mutexLocked|mutexWoken|mutexStarving) != 0 { return } // Grab the right to wake someone. new = (old - 1\u0026lt;\u0026lt;mutexWaiterShift) | mutexWoken if atomic.CompareAndSwapInt3(\u0026amp;m.state, old, new) { // 信号量唤醒，各自竞争 runtime_Semrelease(\u0026amp;m.sema, false, 1) return } old = m.state } } else { // 饥饿模式，通过信号量直接移交当前CPU时间 runtime_Semrelease(\u0026amp;m.sema, true, 1) } }2 如何把锁移交给等待队列的协程？\n使用 Mutex.sema 信号量实现锁转移\n参考 源代码地址sync.mutex.go 包说明文档\n","permalink":"https://ynikl.github.io/blog/golang-sync_mutex/","summary":"Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法\nLock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。\nMutex 实现了一个 sync.Locker 接口, 该接口只有两个方法\nLock Unlock Mutex 锁有几种状态\nmutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量\nmutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态","title":"Go-互斥锁的实现"},{"content":"为什么学 高学习产出转化比 助力下一份工作 公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。 后端架构转变的主流方向, 有利于再次找工作。\n怎么学 想要学习好一个技术，就需要有想学习这门技术的动力。\n首先要对它有较全面的理解：\n我们为什么要学习这门技术 技术的使用场景，以及使用的优势和劣势 现在该技术在大环境中的使用情况 再开始学习技术本身。\n针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。\n具体方法：\n我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。 使用 go-zero 框架完成一个练手项目开发。 ","permalink":"https://ynikl.github.io/posts/2022/0526-why-learn-microservices/","summary":"为什么学 高学习产出转化比 助力下一份工作 公司现在正在初步尝试开始引入微服务，现在学习微服务具有较高的学习工作转化比。 后端架构转变的主流方向, 有利于再次找工作。\n怎么学 想要学习好一个技术，就需要有想学习这门技术的动力。\n首先要对它有较全面的理解：\n我们为什么要学习这门技术 技术的使用场景，以及使用的优势和劣势 现在该技术在大环境中的使用情况 再开始学习技术本身。\n针对于“微服务”这种概念性技术。就需要具体落实到某一个框架，进行一个实战项目。过程中掌握框架使用方法，对过程中所涉及到的相关技术有粗略的了解。\n具体方法：\n我想先通过快速通过《微服务设计模式》了解微服务的使用场景，以及如何设计。 使用 go-zero 框架完成一个练手项目开发。 ","title":"我为什么要学微服务"},{"content":"富兰克林自传\n富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。\n年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。\n摘录富兰克林十三美德：\n节制:食不过饱，饮酒不醉； 寡言:言必于人于己有益，避免无益的聊天； 生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做； 决心:当做必做；决心要做的事应坚持不懈； 俭朴:用钱必须于人或于己有益，换言之，切戒浪费； 勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动； 诚恳:不欺骗人；思想要纯洁公正；说话也要如此； 公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务； 适度:避免极端；人若给你应得的处罚，你当容忍之； 清洁:身体、衣服和住所力求清洁； 镇静:勿因小事或普遍不可避免的事故而惊慌失措； 贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉； 谦虚:仿效耶稣和苏格拉底。\n","permalink":"https://ynikl.github.io/books/autobiography-benjamin_franklin/","summary":"富兰克林自传\n富兰克林, 美国独立宣言的签署者之一，白手起家致富，发明了避雷针路灯，组织了社区消防队，写下了《富兰克林自传》，一个丰富多产的人生。\n年少时勤奋读书，诚信独立，中年时勤勉奋斗，注重自身美德修养。又积极参与社会活动。\n摘录富兰克林十三美德：\n节制:食不过饱，饮酒不醉； 寡言:言必于人于己有益，避免无益的聊天； 生活:每一样东西应有一定的安放地方；每件日常事物当有一定的时间去做； 决心:当做必做；决心要做的事应坚持不懈； 俭朴:用钱必须于人或于己有益，换言之，切戒浪费； 勤勉:不浪费时间；每时每刻做些有用的事，戒掉一切不必要的行动； 诚恳:不欺骗人；思想要纯洁公正；说话也要如此； 公正:不做损人利己的事；不要忘记履行对人有益而又是你应尽的义务； 适度:避免极端；人若给你应得的处罚，你当容忍之； 清洁:身体、衣服和住所力求清洁； 镇静:勿因小事或普遍不可避免的事故而惊慌失措； 贞节:除了为了健康或生育后代起见，不常进行房事，切戒房事过度，伤害身体或损害你自己及他人的安宁或名誉； 谦虚:仿效耶稣和苏格拉底。","title":"富兰克林自传读后感"},{"content":"在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。\n原文章地址 Godoc: documenting Go code\nGo 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。\n所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。\ngodoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。\ngodoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc\u0026quot;相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。\n使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的Fprint函数的注释。\n1 2 3 4 // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered. func Fprint(w io.Writer, a ...interface{}) (n int, err error) { 值得注意的是该注释是以被注释的对象命名开头的一个完整的句子。 这个使用规范可以方便我们生成各种各样的格式文档，从简单的纯文本到 UNIX 是 man 的帮助页，还可以使用其他工具更见简单地获取到信息， 比如提取出第一行或者句子。\n在包的声明处的注释，需要写整个包的概括说明。这些注释可以很简洁，就像 sort 包中的简短描述：\n1 2 3 // Package sort provides primitives for sorting slices and user-defined // collections. package sort 也可以很详细，比如 gob 包。有另一个使用惯例：像这种有这大量注释文档的包，单独一个doc.go文件，放置包的注释。\n不论包的注释文档大小，第一句注释会被展示在 godoc 的呈现包列表中。\n那些没有与最外层声明（可以简单理解为包内全局对象）连接在一块的注释会被 godoc 忽略。但是，有一个例外。那些写在最外层且以“BUG(who)”开头的注释，会被识别为已知的 bug，且会被包含在包文档的“Bugs”分区中。这个“who”部分应该填写可以提供更加详细信息的人名。举个已经在 bytes 包中注释的问题:\n1 // BUG(r): The rule Title uses for word boundaries does not handle Unicode punctuation properly. 某些时候，当一个结构体字段，或者函数，类型，甚至一个整个包变成了冗余或者没有使用必要，但是还是需要与旧代码保持兼容。这时，可以增加一个一段落以“Deprecated:”开头后面跟废弃信息的注释。标识该对象不应该再被使用。\n下面展示一些 godoc 把注释转化成网页的规则：\n不同的段落需要以空行分割。否则将会被识别成同一段。 带有格式的文本，需要要缩进。 URL 会被转化成网页连接，无需特殊处理。 上方的这些规则不需要你做任何的特殊处理。\n事实上，godoc 的极简处理方式使得它非常容易使用。所以，很多 go 项目，包括标准库，都已经开始开始遵循 godoc 的注释文档规范。\n你自己的项目也可以通过编写符合文中规范的注释生成漂亮的文档。任何下载在$GOROOT/src/pkg 或者任何在 GOPATH 空间下的 go 代码包，都可以被 godoc 的命令行或者 HTTP 的接口访问， 你也可以通过在命令后添加-path参数或者直接使用godoc .来指定源码的路径。在godoc 文档 你可以查看到更加详细的内容。\n","permalink":"https://ynikl.github.io/blog/golang-godoc-documenting-go-code/","summary":"在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。\n原文章地址 Godoc: documenting Go code\nGo 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。\n所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。\ngodoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。\ngodoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc\u0026quot;相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。\n使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的Fprint函数的注释。\n1 2 3 4 // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered.","title":"【翻译】使用 Godoc 给 go 代码添加文档"},{"content":"IP 中斜杠表示的是子网掩码的位数\n例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000\n","permalink":"https://ynikl.github.io/posts/cs-the-slash-meaning-of-ip/","summary":"IP 中斜杠表示的是子网掩码的位数\n例如 202.118.130.0/24 表示 子网页码的位数有24位，即 1111.1111.1111.0000","title":"IP表示中 / 代表的意思"},{"content":"以前有一段时间, 怀疑过自己\u0026quot;软件工程师\u0026quot;和以前工程意义上的\u0026quot;工程师\u0026quot;有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的见识书中看了一个五级工程师的概念, 算是解惑了我做为一个\u0026quot;码农\u0026quot;和工程师的区别.\n(图片来源于图书截图)\n第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围. 第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程. 第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维. 第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样. 第一级工程师: 开创一个行业的鼻祖. 能够改变世界. 反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.\n所以我自己应该就是 5.0, 五级工程师, 五流程序员.\n","permalink":"https://ynikl.github.io/posts/five-class-engineer/","summary":"以前有一段时间, 怀疑过自己\u0026quot;软件工程师\u0026quot;和以前工程意义上的\u0026quot;工程师\u0026quot;有什么区别, 自己只是将需求文档换成了代码, 这种活动并没有什么太大的突破. 然后我在吴军的见识书中看了一个五级工程师的概念, 算是解惑了我做为一个\u0026quot;码农\u0026quot;和工程师的区别.\n(图片来源于图书截图)\n第五级工程师: 有能够独自解决问题的能力, 但是问题规模较小, 属于个人能力可以解决的范围. 第四级工程师: 有沟通和领导能力, 可以带领一个团队, 完成一个规模化的工程. 第三级工程师: 能设计和完成一款产品, 取得市场成功. 对行业的商业环境有较深理解, 且有产品思维. 第二级工程师: 能够在行业做出有创造性, 有突破性的产品. 世界因为能够因为他们有一点点不一样. 第一级工程师: 开创一个行业的鼻祖. 能够改变世界. 反思自己的工程能力, 目前的所有项目技术上的问题都可以独立解决, 也能够针对某一棘手问题独立设计出可行的解决方案. 但是没有带领过团队解决过规模化问题, 亦没有技术创新.\n所以我自己应该就是 5.0, 五级工程师, 五流程序员.","title":"Five Class Programer"},{"content":"hugo 的默认内容都是在 content/ 路径下方\n在 markdown 文章中使用 { {\u0026lt; ref \u0026quot;/blog/my-first-post.md\u0026quot; \u0026gt;}}(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带/ 是表示从 content/ 目录下的下一个绝对路径\n1 [我的文章]({ {\u0026lt; ref \u0026#34;/blog/my-first-post.md\u0026#34; }}) 记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错\nhugo官方文档\n","permalink":"https://ynikl.github.io/posts/hugo_%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%AF%B9%E8%BF%9E%E6%8E%A5/","summary":"hugo 的默认内容都是在 content/ 路径下方\n在 markdown 文章中使用 { {\u0026lt; ref \u0026quot;/blog/my-first-post.md\u0026quot; \u0026gt;}}(两个左花括号中间是没有空格的), 会在编译时发生地址替换, 带/ 是表示从 content/ 目录下的下一个绝对路径\n1 [我的文章]({ {\u0026lt; ref \u0026#34;/blog/my-first-post.md\u0026#34; }}) 记得是已经发布的文章, 如果使用不存在, 或者是不参加发布的草稿文章就会发生报错\nhugo官方文档","title":"Hugo 如何使用已经发布文章做为相对URL"},{"content":"我的第一篇杂文\n阅读了卡片写作笔记法, 和Show Your Work之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.\n原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.\n","permalink":"https://ynikl.github.io/posts/my-first-post/","summary":"我的第一篇杂文\n阅读了卡片写作笔记法, 和Show Your Work之后, 打算重新开始写自己的博客. 用文字记录下自己的想法和收获.\n原先有断断续续写过几次博客, 但是每次都是半途而废的放弃. 希望这次可以坚持的久一点, 目标至少要有一年.","title":"My first Post"},{"content":"见识:豆瓣地址\n个人评分: 8.0 分\n前辈用他的智慧和经验, 告诉我们如何更好地活着.\n为什么读这本书 很多到了中年的人会有这样的体会： 自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。\n为了这一句话, 读这一本书. 自己的作为一个普工程序员, 在技术浪潮的最后端被拖着走. 本根不需要到中年, 今年是我从事程序员工作的第四年, 我已经被感受到了被\u0026quot;命\u0026quot;限制住 的感觉了.\n书中讲了什么 作者分享了他对商业, 技术, 职业, 创业, 金钱, 读书的观点和看法\n用提出了商业的本质是\u0026quot;消费\u0026quot;的观点, 剖析了现在主流的\u0026quot;共享经济\u0026quot;, 带我们用商业的本质眼光, 去看哪些形式的共享经济是真正的\u0026quot;共享经济\u0026quot;, 哪些只是噱头炒概念的而已. 分析了IOT, 和数字跟踪技术, 区块链, 众筹等.\n介绍了新科技公司的创业过程中的一些普世经验. 如何选取赛道, 如何发挥自己小公司的优势, 如何在科技浪潮中存活下来, 以及中如何招聘优秀员工.\n关于在职场如何招聘到优秀的员工, 又可以引申到自己如何成为一个优秀的员工, 作者也给出了答案.\n树立完成的职业思维, 带着发展的目光选择岗位 在职业思维下主动和积极的面对工作 打开自己思维格局, 多去了解行业大局 有了不错的收入之后, 就涉及到了, 如何树立一个正确的金钱观. 要对自己收入有一个正确的认识, 避免过度追求提高收入, 进而牺牲了自己的健康, 家庭等. (现在经常听到我们的工友, 猝死就是这方面没有正确面对)\n下半篇, 作者开始就上升到了人生态度问题. 以一个正确的心态, 面对生活, 面对婚姻, 面对死亡. 分清楚自己生活中的 \u0026ldquo;西瓜和芝麻\u0026rdquo;, 避免习惯于低层次的追求, 会影响我们的心志.\n最后文中讲述对大学生的建议 (我已经错过了), 阐述沟通的重要性, 以及介绍了拉里·佩奇名人, 巴菲特的非凡\u0026quot;见识\u0026quot;.\n我从书中收获了什么 对现在的\u0026quot;共享经济\u0026quot;有了更深的认识, 对科技迭代有了一个基础性的认识, 重视自己职业发展和做文字的积累, 开始努力去全面了解自己的行业, 以及在阅读中莫名地增加了我对生活的信心.\n书中的三句精华句子 很多到了中年的人会有这样的体会：自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。 我们知道今天几乎任何一所三甲医院的主治医师，水平一定比 50 年前所谓的名医高很多。但是，今天没有哪个中医敢讲自己比 500 年前的名医水平高。这就是因为前者有积累效应，而后者没有 我们对死亡的恐惧有点儿莫名其妙，我们站在“有”的世界，试图理解“无”的问题，按照“有”的逻辑，对“无”产生恐惧 三句话总结本书 拓展视野, 打开格局, 重视积累 以发展的眼光看职业生涯, 分清楚工作和职业的区别, 拒绝伪工作. 向死而生 ","permalink":"https://ynikl.github.io/books/%E8%A7%81%E8%AF%86/","summary":"见识:豆瓣地址\n个人评分: 8.0 分\n前辈用他的智慧和经验, 告诉我们如何更好地活着.\n为什么读这本书 很多到了中年的人会有这样的体会： 自己无论多么努力，似乎都得不到社会的进一步认可；相反，如果按部就班地做事情，好像也坏不到哪里去。冥冥之中似乎被这两条线给框死，其实这就是命。\n为了这一句话, 读这一本书. 自己的作为一个普工程序员, 在技术浪潮的最后端被拖着走. 本根不需要到中年, 今年是我从事程序员工作的第四年, 我已经被感受到了被\u0026quot;命\u0026quot;限制住 的感觉了.\n书中讲了什么 作者分享了他对商业, 技术, 职业, 创业, 金钱, 读书的观点和看法\n用提出了商业的本质是\u0026quot;消费\u0026quot;的观点, 剖析了现在主流的\u0026quot;共享经济\u0026quot;, 带我们用商业的本质眼光, 去看哪些形式的共享经济是真正的\u0026quot;共享经济\u0026quot;, 哪些只是噱头炒概念的而已. 分析了IOT, 和数字跟踪技术, 区块链, 众筹等.\n介绍了新科技公司的创业过程中的一些普世经验. 如何选取赛道, 如何发挥自己小公司的优势, 如何在科技浪潮中存活下来, 以及中如何招聘优秀员工.\n关于在职场如何招聘到优秀的员工, 又可以引申到自己如何成为一个优秀的员工, 作者也给出了答案.\n树立完成的职业思维, 带着发展的目光选择岗位 在职业思维下主动和积极的面对工作 打开自己思维格局, 多去了解行业大局 有了不错的收入之后, 就涉及到了, 如何树立一个正确的金钱观. 要对自己收入有一个正确的认识, 避免过度追求提高收入, 进而牺牲了自己的健康, 家庭等. (现在经常听到我们的工友, 猝死就是这方面没有正确面对)\n下半篇, 作者开始就上升到了人生态度问题. 以一个正确的心态, 面对生活, 面对婚姻, 面对死亡. 分清楚自己生活中的 \u0026ldquo;西瓜和芝麻\u0026rdquo;, 避免习惯于低层次的追求, 会影响我们的心志.\n最后文中讲述对大学生的建议 (我已经错过了), 阐述沟通的重要性, 以及介绍了拉里·佩奇名人, 巴菲特的非凡\u0026quot;见识\u0026quot;.","title":"见识"},{"content":"Show Your Work 读书总结 概括 我为什么要读这本书\n如何提高自己的影响力\n这本书怎样影响了我\n打算开始分享计划, 学习如何分享, 讲述故事. 计划\u0026quot;学术假\u0026quot;\n书中的三句精华句子\nYou find time the same place you find spare change: in the nooks and crannies On the spectrum of creative work, the difference between the mediocre and the good is vast. Mediocrity is, however, still on the spectrum; you can move from mediocre to good in increments. The real gap is between doing nothing and doing something You can turn your flow into stock 三句话总结本书\n我们需要把自己展示出来, 这样子别人才能知道你是一个什么样子的人. ( 酒香也怕巷子深) 把自己当成一个业务爱好者, 对自己分享负责, 但不用追求到完美, 心态开放, 保持热情 把握自己分享的尺度, 任何事情, 思想, 启发都是值得分享的. 在互联网上保持真诚, 尊重他人, 保护自己. 感悟点 不要觉得你没有什么事情可以分享, 一定会有人对你做的事情感兴趣. 比如一天结束，可以分享自己在做什么，做什么什么决定，收获了什么，受到了什么启发，有什么成果\n互联网上的人们都很烂，如果不包含链接，99.9%的就不会去找目标网页\n如果虚假的分享你的成功，你不仅抢夺了他人的成功，还欺骗了分享成果的人们\n要能解释自己正在做什么\n分享自己的知识，也可以让别人知道你在干嘛，知道你的工作，也是自己的一种再学习过程\n要倾听别人的意见，不要一味地分享自己\n要用内容去吸引读者，不要悲哀地要求别人粉你\n学会在网上保护自己，过滤垃圾评论\n通勤的好处：分离家庭与工作\n适当给自己放假，学术假。每七年让自己重新充电🔋。\n认识你自己\n","permalink":"https://ynikl.github.io/books/showyourwork/","summary":"Show Your Work 读书总结 概括 我为什么要读这本书\n如何提高自己的影响力\n这本书怎样影响了我\n打算开始分享计划, 学习如何分享, 讲述故事. 计划\u0026quot;学术假\u0026quot;\n书中的三句精华句子\nYou find time the same place you find spare change: in the nooks and crannies On the spectrum of creative work, the difference between the mediocre and the good is vast. Mediocrity is, however, still on the spectrum; you can move from mediocre to good in increments. The real gap is between doing nothing and doing something You can turn your flow into stock 三句话总结本书","title":"Show Your Work"},{"content":"启动一个容器 打个样\n1 docker run -itd --rm --name hello image_name \u0026ndash; it 将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式\n\u0026ndash;rm 当容器停止之后, 会自动删除改容器\n外挂文件夹 参数 -v docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash\n与容器交互 进入容器 docker attach\nexec\ndocker -it exec CONTAIN_NAME bash\nexex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯. 加上 -it, 进入交互的终端模式\n查看日志 docker logs CONTAINER 可以查看容器日志\n-f 可以持续输出容器内部的最新日志\n管理容器 启动\n1 docker start CONTAINER 暂停\n1 docker stop CONTAINER 提交\n1 docker commit --author=\u0026#34;ian\u0026#34; CONTAINER NEW-IMAGENAME:TAG 管理镜像 查看所有的镜像列表\n1 docker image ls 删除镜像\n1 docker rmi IMAGE 删除 \u0026lt;none\u0026gt; 名称的镜像\n1 docker rmi $(docker images --filter \u0026#34;dangling=true\u0026#34; -q --no-trunc) ","permalink":"https://ynikl.github.io/blog/docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"启动一个容器 打个样\n1 docker run -itd --rm --name hello image_name \u0026ndash; it 将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式\n\u0026ndash;rm 当容器停止之后, 会自动删除改容器\n外挂文件夹 参数 -v docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash\n与容器交互 进入容器 docker attach\nexec\ndocker -it exec CONTAIN_NAME bash\nexex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯. 加上 -it, 进入交互的终端模式\n查看日志 docker logs CONTAINER 可以查看容器日志\n-f 可以持续输出容器内部的最新日志\n管理容器 启动\n1 docker start CONTAINER 暂停\n1 docker stop CONTAINER 提交\n1 docker commit --author=\u0026#34;ian\u0026#34; CONTAINER NEW-IMAGENAME:TAG 管理镜像 查看所有的镜像列表","title":"Docker 基本使用"},{"content":"Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本\nchannel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)\nDo not communicate by sharing memory; instead, share memory by communicating.\nchannel 保证:\n数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开 channel 的实现 channel 在内部实现的结构体为 runtime.hchan\n有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe.Pointer // 环形数组开始地址 elemsize uint16 // channel 传输的元素大小, 用于计算内存大小 closed uint32 // channel 是否已经关闭 0未关闭, 非0关闭 elemtype *_type // element type # channel 元素的类型 sendx uint // 环形链表中, 发送数据存储的下标 recvx uint // 环形链表中, 接受数据获取数据的下标 recvq waitq // 阻塞在该 channel 等待获取数据的 Groutine 列表 sendq waitq // 阻塞在该 channel 等待写入数据的 Groutine 列表 lock mutex // # 互斥锁 用于保护自身数据变更 } 初始化 channel 传递的元素不能太大 如果是空结构体或者无缓冲队列, 是不需要分配环形队列内存 如果传递数据类型有内含指针, 需要将环形队列分配到堆上 内部实现函数runtime.makechan\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 func makechan(t *chantype, size int) *hchan { // compiler checks this but be safe. // 编译器会校验channel元素的大小, 小于64KB. 若大于64KB, 编译器会报错 if elem.size \u0026gt;= 1\u0026lt;\u0026lt;16 { throw(\u0026#34;makechan: invalid channel element type\u0026#34;) } if hchanSize%maxAlign != 0 || elem.align \u0026gt; maxAlign { throw(\u0026#34;makechan: bad alignment\u0026#34;) } mem, overflow := math.MulUintptr(elem.size, uintptr(size)) if overflow || mem \u0026gt; maxAlloc-hchanSize || size \u0026lt; 0 { panic(plainError(\u0026#34;makechan: size out of range\u0026#34;)) } // Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers. // buf points into the same allocation, elemtype is persistent. // SudoG\u0026#39;s are referenced from their owning thread so they can\u0026#39;t be collected. // TODO(dvyukov,rlh): Rethink when collector can move allocated objects. var c *hchan switch { case mem == 0: // Queue or element size is zero. # 无缓冲队列或者空结构体为传递值, 不需要额外分配队列内存 c = (*hchan)(mallocgc(hchanSize, nil, true)) // Race detector uses this location for synchronization. c.buf = c.raceaddr() case elem.ptrdata == 0: // # channel 元素不存在指针引导数据, 将环形数组分配在 hchan 后面 // Elements do not contain pointers. // Allocate hchan and buf in one call. c = (*hchan)(mallocgc(hchanSize+mem, nil, true)) c.buf = add(unsafe.Pointer(c), hchanSize) default: // Elements contain pointers. c = new(hchan) c.buf = mallocgc(mem, elem, true) } c.elemsize = uint16(elem.size) c.elemtype = elem c.dataqsiz = uint(size) lockInit(\u0026amp;c.lock, lockRankHchan) // # locakRankHchan 锁的等级 return c } 关闭 核心代码runtime.closechan更新自身数据结构中的关闭状态, 并 唤醒阻塞在 channel 上的所有协程. 被唤醒的协程(sudog)的 success 标识会被置为 false.\n被唤醒的 写操作的协程, 也会发生panic. ( \u0026ldquo;send on closed channel\u0026rdquo; )\n自身操作会发生 panic 的情况\n未初始化 channel 重复关闭 channel 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 func closechan(c *hchan) { if c == nil { // 未初始化的channel 会发生panic panic(plainError(\u0026#34;close of nil channel\u0026#34;)) } // # 开始关闭, 锁定之后数据都进不来了 lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;close of closed channel\u0026#34;)) } c.closed = 1 var glist gList // release all readers # 唤醒所有因为读取数据阻塞的协程 for { sg := c.recvq.dequeue() if sg == nil { break } if sg.elem != nil { typedmemclr(c.elemtype, sg.elem) sg.elem = nil } if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g // # [channel 唤醒协议总是设置params为sudog](https://github.com/golang/go/commit/30a68bfb806b5217932e280f5a5f521237e69077) gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } // release all writers (they will panic) # 唤醒所有因为写入数据阻塞的协程 for { sg := c.sendq.dequeue() if sg == nil { break } sg.elem = nil if sg.releasetime != 0 { sg.releasetime = cputicks() } gp := sg.g gp.param = unsafe.Pointer(sg) sg.success = false if raceenabled { raceacquireg(gp, c.raceaddr()) } glist.push(gp) } unlock(\u0026amp;c.lock) // Ready all Gs now that we\u0026#39;ve dropped the channel lock. for !glist.empty() { gp := glist.pop() gp.schedlink = 0 // # 唤醒协程, 将协程加入调度 goready(gp, 3) } } 发送数据 向已经关闭的 channel 发送数据会发生 panic\n数据流程:\n检查是否已经初始化 非阻塞写入数据, 检查数据是否已经满, 快速返回 是否已经关闭 检查 channel 中是否已经有等待获取数据而阻塞的协程, 如果有直接将数据发送给等待的协程. channel 的 buffer 是否还有空间, 如果有将数据放置到 buffer 中, 返回 channel 的 buffer 已经满了, 根据是否为 select 操作, 判断是否需要将协程阻塞 当协程阻塞之后, 在被唤醒之后需要再检查一次, channel 是否已经关闭. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 // # block 的参数是由是否在 select 中, 由编译过程决定的; 只有在select语句中block = true func chansend(c *hchan, ep unsafe.Pointer, block bool, callerpc uintptr) bool { if c == nil { if !block { return false } // # 向未初始化的 channel 发送数据会永远阻塞 gopark(nil, nil, waitReasonChanSendNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // # 带 select 的 channel 在数据已经满了情况直接返回 if !block \u0026amp;\u0026amp; c.closed == 0 \u0026amp;\u0026amp; full(c) { return false } // 保护数据 lock(\u0026amp;c.lock) if c.closed != 0 { unlock(\u0026amp;c.lock) panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } // # 先从接受协程队列中获取阻塞的协程, 直接将数据发送给阻塞的协程 if sg := c.recvq.dequeue(); sg != nil { // Found a waiting receiver. We pass the value we want to send // directly to the receiver, bypassing the channel buffer (if any). send(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true } // # channel 的 buffer 中还有剩余空间 if c.qcount \u0026lt; c.dataqsiz { // Space is available in the channel buffer. Enqueue the element to send. qp := chanbuf(c, c.sendx) if raceenabled { racenotify(c, c.sendx, nil) } typedmemmove(c.elemtype, qp, ep) c.sendx++ // # 环形队列, 当索引到最后从头开始 if c.sendx == c.dataqsiz { c.sendx = 0 } // # 增加当前 channel buffer 存储的数据个数 c.qcount++ unlock(\u0026amp;c.lock) return true } if !block { unlock(\u0026amp;c.lock) return false } // # 发送数据的协程阻塞在当前 channel // Block on the channel. Some receiver will complete our operation for us. gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil mysg.g = gp mysg.isSelect = false mysg.c = c gp.waiting = mysg gp.param = nil c.sendq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we\u0026#39;re about // to park on a channel. The window between when this G\u0026#39;s status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, 2) // Ensure the value being sent is kept alive until the // receiver copies it out. The sudog has a pointer to the // stack object, but sudogs aren\u0026#39;t considered as roots of the // stack tracer. KeepAlive(ep) // # 协程被唤醒了 // someone woke us up. if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false closed := !mysg.success gp.param = nil if mysg.releasetime \u0026gt; 0 { blockevent(mysg.releasetime-t0, 2) } mysg.c = nil releaseSudog(mysg) // # 挂载在协程上的发送协程会 panic if closed { if c.closed == 0 { throw(\u0026#34;chansend: spurious wakeup\u0026#34;) } panic(plainError(\u0026#34;send on closed channel\u0026#34;)) } return true } 接收数据 与发送数据一样, 同样带着是否阻塞的参数. 在编译时,由是否有 select 操作决定. 核心代码runtime.chanrecv\n不带 select 从未初始化的 channel 获取数据, 会永远阻塞 runtime.chanrecv 返回值中, 第一个返回值selected表示在,select 语句中, 该 case 是否会被选中执行 接收数据流程:\n检查是否已经初始化 检查非阻塞获取数据下, 是否可以直接返回 如果已经关闭的 channel 且没有已经没有缓冲数据, 返回数据类型的默认值. 检查有因发送数据阻塞在 channel 的协程, 如果没有 buffer, 直接从阻塞的协程中获取数据, 否则从 buffer 中获取数据数据, 将第一个阻塞的协程的数据放入 buffer 中. 如果缓冲 buffer 有数据, 则从buffer 中获取数据. 非阻塞操作, 直接返回. 否则协程进行阻塞. 注意事项:\n当 select 一个 已经关闭的 channel 的时候, 该 case 会被疯狂输出, 导致cpu使用率上升\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 // chanrecv receives on channel c and writes the received data to ep. // ep may be nil, in which case received data is ignored. // If block == false and no elements are available, returns (false, false). // Otherwise, if c is closed, zeros *ep and returns (true, false). // Otherwise, fills in *ep with an element and returns (true, true). // A non-nil ep must point to the heap or the caller\u0026#39;s stack. func chanrecv(c *hchan, ep unsafe.Pointer, block bool) (selected, received bool) { if c == nil { if !block { // select 情况下, selected = false, 不执行该 case return } // # 非 select 会永远阻塞 gopark(nil, nil, waitReasonChanReceiveNilChan, traceEvGoStop, 2) throw(\u0026#34;unreachable\u0026#34;) } // # 不加锁检查, 带 select 接收操作, 如果 channel 未关闭, 且没有可以获取的数据直接返回 // Fast path: check for failed non-blocking operation without acquiring the lock. if !block \u0026amp;\u0026amp; empty(c) { // After observing that the channel is not ready for receiving, we observe whether the // channel is closed. // // Reordering of these checks could lead to incorrect behavior when racing with a close. // For example, if the channel was open and not empty, was closed, and then drained, // reordered reads could incorrectly indicate \u0026#34;open and empty\u0026#34;. To prevent reordering, // we use atomic loads for both checks, and rely on emptying and closing to happen in // separate critical sections under the same lock. This assumption fails when closing // an unbuffered channel with a blocked send, but that is an error condition anyway. if atomic.Load(\u0026amp;c.closed) == 0 { // Because a channel cannot be reopened, the later observation of the channel // being not closed implies that it was also not closed at the moment of the // first observation. We behave as if we observed the channel at that moment // and report that the receive cannot proceed. return } // The channel is irreversibly closed. Re-check whether the channel has any pending data // to receive, which could have arrived between the empty and closed checks above. // Sequential consistency is also required here, when racing with such a send. if empty(c) { // The channel is irreversibly closed and empty. if raceenabled { raceacquire(c.raceaddr()) } if ep != nil { typedmemclr(c.elemtype, ep) } // select 会选择改 case 疯狂输出 return true, false } } lock(\u0026amp;c.lock) if c.closed != 0 { // # 如果 channel 已经关闭, 且buffer 中已经没有数据了, 返回传输数据类型的默认值 if c.qcount == 0 { if raceenabled { raceacquire(c.raceaddr()) } // # 在返回的时候有可能刚好有数据会进来, 所以需要进行加锁操作 unlock(\u0026amp;c.lock) if ep != nil { typedmemclr(c.elemtype, ep) } return true, false } // The channel has been closed, but the channel\u0026#39;s buffer have data. } else { // # 如果 channel 没有 buffer 会直接从阻塞中的发送数据协程中获取数据 // # 如果 channel 有 buffer. 当可以获取到因为发送数据而阻塞的协程时, 代表缓冲的 buffer 已经满了. 所以, 将从 buffer 中获取数据, 并将获取到的第一个阻塞协程, 的数据放入 buffer 尾端. 保证先入先出 // Just found waiting sender with not closed. if sg := c.sendq.dequeue(); sg != nil { // Found a waiting sender. If buffer is size 0, receive value // directly from sender. Otherwise, receive from head of queue // and add sender\u0026#39;s value to the tail of the queue (both map to // the same buffer slot because the queue is full). recv(c, sg, ep, func() { unlock(\u0026amp;c.lock) }, 3) return true, true } } // # 从 buffer 中获取数据 if c.qcount \u0026gt; 0 { // Receive directly from queue qp := chanbuf(c, c.recvx) if raceenabled { racenotify(c, c.recvx, nil) } if ep != nil { typedmemmove(c.elemtype, ep, qp) } typedmemclr(c.elemtype, qp) c.recvx++ if c.recvx == c.dataqsiz { c.recvx = 0 } c.qcount-- unlock(\u0026amp;c.lock) return true, true } // # 非阻塞操作, 返回 if !block { unlock(\u0026amp;c.lock) return false, false } // 将获取数据的协程阻塞 // no sender available: block on this channel. gp := getg() mysg := acquireSudog() mysg.releasetime = 0 if t0 != 0 { mysg.releasetime = -1 } // No stack splits between assigning elem and enqueuing mysg // on gp.waiting where copystack can find it. mysg.elem = ep mysg.waitlink = nil gp.waiting = mysg mysg.g = gp mysg.isSelect = false mysg.c = c gp.param = nil c.recvq.enqueue(mysg) // Signal to anyone trying to shrink our stack that we\u0026#39;re about // to park on a channel. The window between when this G\u0026#39;s status // changes and when we set gp.activeStackChans is not safe for // stack shrinking. atomic.Store8(\u0026amp;gp.parkingOnChan, 1) gopark(chanparkcommit, unsafe.Pointer(\u0026amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, 2) // someone woke us up if mysg != gp.waiting { throw(\u0026#34;G waiting list is corrupted\u0026#34;) } gp.waiting = nil gp.activeStackChans = false // 如果是因为 channel的关闭 操作唤醒的, success 值为 false success := mysg.success gp.param = nil mysg.c = nil releaseSudog(mysg) return true, success } 用法总结 初始化:\n避免对未初始化 channel 的进行读写操作, 可能会造成阻塞 在 select 语句中, 对已经关闭的 channel 可以赋予 nil 值, 避免 cpu 飙高 关闭协程:\n关闭协程的动作, 应该由数据写入方操作 channel 当参数传递时, 尽可能带上操作方向(读取/写入), 编译器会保证, 单向写入协程不允许关闭 关闭的时候要确保所有的写入协程都已经操作完毕. 避免引起写入协程发生 panic 在 channel 中阻塞的协程, 唤醒条件\n到达协程数据操作的目标, 写入 / 读取数据 channel 关闭 Referrences Go官方源码 Share Memory By Communication ","permalink":"https://ynikl.github.io/blog/golang-channel/","summary":"Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本\nchannel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)\nDo not communicate by sharing memory; instead, share memory by communicating.\nchannel 保证:\n数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开 channel 的实现 channel 在内部实现的结构体为 runtime.hchan\n有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe.","title":"Channel"},{"content":"如何提高自己的所编写的文字留存问题? 自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意. 然后就会把已经写下的文字和内容删除掉.\n","permalink":"https://ynikl.github.io/posts/%E6%8F%90%E5%8D%87%E6%96%87%E5%AD%97%E7%95%99%E5%AD%98%E7%8E%87/","summary":"如何提高自己的所编写的文字留存问题? 自己经常写了很多文字, 但是每当自己回顾的时候都不是很满意. 然后就会把已经写下的文字和内容删除掉.","title":"提升文字留存率"},{"content":"2022 年度目标 提升自己的基础技术竞争力, 确保不会找不到工作\n精通 go 编程语言 精通 redis 精通 mysql 5 月份 OKR O:\n加深对 Go 语言的基础知识理解 熟悉 redis 的所有数据类型 KR:\n输出3篇高质量的 go 语言blog\nchannel module tools 数据 redis 所有数据类型总结博文一篇\n所有数据类型总结博文 6 月份 OKR 成为一个 golang 资深开发工程师\nGo GMP 调度总结博文 做一个部门内部的 GMP 调度培训 成为一个优秀的软件工程师\n微服务架构设计模式通读并完成博文输出 Mysql 表结构数据类型总结博文 成为一个独立的 apple 软件开发者\n开发一个 macos 蕃茄钟小程序雏形 总结 6 月份只完成了一项 微服务架构设计模式 书籍的阅读. 完成情况比较差.\n主要原因: 对设定的目标不够上心. 6月份对健身很感兴趣, 一心扑在了健身上了, 对于月初制定的计划也就淡忘了.\n7 月份 OKR O1: 首要目标, 还是要技术总结和输出 go 语言的基础知识, 成为一个 资深的 golang 开发者\ngo gmp 调度总结博文 map channel context 总结博文输出 Mysql 表结构数据类型总结博文 (6月份遗留) O2: 学习计算机基础知识\n学习 RabbitMQ 实战指南 (因为当前公司项目有用到相关的组件, 需要快速学习一下) 总结 docker 的基本使用 学习 unix 网络编程 卷一 O3: 保持健康, 保持阅读\n有 25 天完成, 每天阅读 4 番茄钟的. 每周 至少健身 4次. 总结 执行力不够. 每天制定目标早起, 前天晚上又要早睡. 再加上健身时间, 周一至周五非工作时间都已经排满了.\n周末, 执行力不够, 会比较懒散地趴在床上刷抖音, 刷视频之类的. 没有有效地利用时间, 导致制定的计划都完不成.\n8 月份 OKR O1: 高级 go 语言开发者\ngo gmp 调度总结博文 map, context 总结博文输出 O2: 补充计算机基础知识\nTree 数据结构类型 Mysql 表结构数据类型总结博文 (6月份遗留) Unix 网络编程 卷一 O3: 保持健康, 保持阅读\n有 25 天完成, 每天阅读 4 番茄钟的. 有 25 天完成, 当天的总结和第二天的规划. 每周有4点,8点半之前到公司 每周 至少健身 4次. 8月份总结 过度娱乐，沉溺于抖音，每一天可以刷1-2个小时 健身花费的时间占比居高不下， 过度重视健身。 9月份安排 在写自我技术能力的时候，依旧没有能力把 精通 这两个字放在 Go语言前面 \u0026ndash; 9月份最主要目标 下调健身花费的时间占比， 采用5分化训练。 每次尽量把时间控制在一个小时之内。 每天保持一个小时的时间用于提高技术能力。 9 月份 OKR O1: 可以在自我介绍上写上 精通Go语言\ngo gmp 调度总结博文 map, context 总结博文输出 interface 深入学习 reflect 反射包使用 O2: 拓展知识\nMysql 表结构数据类型总结博文 (6月份遗留) O3: 保持健康, 保持阅读\n有 25 天完成, 每天阅读 4 番茄钟的. 每周有4点,8点半之前到公司 每周 至少健身 4次. 10 月份 OKR 无\n11 月份 OKR 技术\nO1: 精通Go语言\ngo map 总结博文输出 go context 总结博文输出 go gmp 调度总结博文 O2: 拓展技术边界\n前端技术入门 Python 入门 生活\nO1: 文字沉淀,\n摩托车给我带来了什么文章总结 摩托车骑行录像整理 ","permalink":"https://ynikl.github.io/okr/okr-2022/","summary":"2022 年度目标 提升自己的基础技术竞争力, 确保不会找不到工作\n精通 go 编程语言 精通 redis 精通 mysql 5 月份 OKR O:\n加深对 Go 语言的基础知识理解 熟悉 redis 的所有数据类型 KR:\n输出3篇高质量的 go 语言blog\nchannel module tools 数据 redis 所有数据类型总结博文一篇\n所有数据类型总结博文 6 月份 OKR 成为一个 golang 资深开发工程师\nGo GMP 调度总结博文 做一个部门内部的 GMP 调度培训 成为一个优秀的软件工程师\n微服务架构设计模式通读并完成博文输出 Mysql 表结构数据类型总结博文 成为一个独立的 apple 软件开发者\n开发一个 macos 蕃茄钟小程序雏形 总结 6 月份只完成了一项 微服务架构设计模式 书籍的阅读. 完成情况比较差.\n主要原因: 对设定的目标不够上心. 6月份对健身很感兴趣, 一心扑在了健身上了, 对于月初制定的计划也就淡忘了.\n7 月份 OKR O1: 首要目标, 还是要技术总结和输出 go 语言的基础知识, 成为一个 资深的 golang 开发者","title":"2022"},{"content":"技术 Go interface 深入学习 reflect 反射包使用 1.17 版本 1.18 版本 架构 架构整洁之道 ","permalink":"https://ynikl.github.io/okr/backlog/","summary":"技术 Go interface 深入学习 reflect 反射包使用 1.17 版本 1.18 版本 架构 架构整洁之道 ","title":"BackLog"},{"content":"工具分类 go build 编译源代码文件\n-race 编译出的目标程序，会启用数据竞争检测\ngo doc 查看包的文档(定义于doc.go的注释中), 于包中公开的函数签名\nexample\n1 2 3 go doc go doc encoding/json go env 查看 go 相关的环境变量\n1 2 3 4 5 # -w 设置环境变量 go env -w GOPAHT=\u0026#39;/some/path\u0026#39; # -u 恢复成默认设置 go env -u GOPATH go generate 扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”\n注释的指令格式\n//go:generate command argument...\nps: wire 也是利用命令, 生成依赖注入文件\ngo get 管理当前module依赖\n1 2 3 4 5 6 7 8 # 添加依赖包 go get example.com/pkg # 指定包版本 go get example.com/pkg@1.2.3 # 移除依赖 go get example.com/pkg@none go install 获取包文件，并编译和安装。可执行文件编译到$GOBIN路径下, 包文件编译到$GOPATH/pkg\ngo list 列出包的数据信息\ngo mod 管理 modules\n1 2 3 4 edit\t修改go.mod init\t初始化 tidy\t自动补全依赖包 vendor\t生成一个所有依赖的vendor文件夹 go test 跑单元测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 go test -v . # 指定函数 go test -run 函数名 # 性能测试 go test -v -bench . -benchtime 50s # 单元测试覆盖率 go test -cover # 强制重新跑测试, 不使用缓存的结果 source: https://stackoverflow.com/a/48882892/9992963 go test -count=1 go tool 1 2 # 不带参数，显示工具列表 go tool compile 使用go tool compile -N -l -S main.go生成汇编代码\n","permalink":"https://ynikl.github.io/blog/golang-cmd/","summary":"工具分类 go build 编译源代码文件\n-race 编译出的目标程序，会启用数据竞争检测\ngo doc 查看包的文档(定义于doc.go的注释中), 于包中公开的函数签名\nexample\n1 2 3 go doc go doc encoding/json go env 查看 go 相关的环境变量\n1 2 3 4 5 # -w 设置环境变量 go env -w GOPAHT=\u0026#39;/some/path\u0026#39; # -u 恢复成默认设置 go env -u GOPATH go generate 扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”\n注释的指令格式\n//go:generate command argument...\nps: wire 也是利用命令, 生成依赖注入文件\ngo get 管理当前module依赖\n1 2 3 4 5 6 7 8 # 添加依赖包 go get example.","title":"Go 常用的命令汇总"},{"content":" 我: 昵称: 潜水员\n五流程序员 文字业余爱好者 摩托车爱好者 为什么写 在互联网中留下尘埃 把想法外显成文字才会有意义 促进自我思考 目前在学 Go Redis 微服务设计模式 计算机技能 Go Vim Live in Shell Redis Mysql Operating System Algorithm (basic) 想从生活中得到 摄影 游泳 Bucket List 逃离办公室 去西藏 出版一本小说 潜水 跳伞 目录分类说明 blog 一些技术上的杂文 posts 自己的一些感悟和发牢骚 notes 平时遇到的一些有感悟的文字 books 自己读的书籍的一些简单记录 ","permalink":"https://ynikl.github.io/me/","summary":" 我: 昵称: 潜水员\n五流程序员 文字业余爱好者 摩托车爱好者 为什么写 在互联网中留下尘埃 把想法外显成文字才会有意义 促进自我思考 目前在学 Go Redis 微服务设计模式 计算机技能 Go Vim Live in Shell Redis Mysql Operating System Algorithm (basic) 想从生活中得到 摄影 游泳 Bucket List 逃离办公室 去西藏 出版一本小说 潜水 跳伞 目录分类说明 blog 一些技术上的杂文 posts 自己的一些感悟和发牢骚 notes 平时遇到的一些有感悟的文字 books 自己读的书籍的一些简单记录 ","title":"我"},{"content":"Hugo 文章分类管理 文件夹 内容存放在content/目录下方, content/下方的子目录会形成资源URI,\n例如 content/blog/doc.md 文章访问目录即为 https//XXX.github.io/blog.doc.md\n分类管理 文章内容表述 (Front Matter) 使用进行分类, 默认只有tags\n1 2 3 tags: - Go - fast 可以在config添加自定的分类选项\n1 2 3 taxonomies: series: series category: categories 文章路径 类别 描述 地址 home 网站homepage /index.html page 指定页面 /post/页面/index.html section 分区 /section/index.html taxonomy 分类 /tags/index.html term 分类系列 /tags/go/index.html _index.md 和 index.md 在文件夹下方添加_index.md会识别成section. 在文件夹下方添加index.md会被识别成文章.\n千万不要在默认的content目录下方添加index.md\n","permalink":"https://ynikl.github.io/blog/hugo-%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/","summary":"Hugo 文章分类管理 文件夹 内容存放在content/目录下方, content/下方的子目录会形成资源URI,\n例如 content/blog/doc.md 文章访问目录即为 https//XXX.github.io/blog.doc.md\n分类管理 文章内容表述 (Front Matter) 使用进行分类, 默认只有tags\n1 2 3 tags: - Go - fast 可以在config添加自定的分类选项\n1 2 3 taxonomies: series: series category: categories 文章路径 类别 描述 地址 home 网站homepage /index.html page 指定页面 /post/页面/index.html section 分区 /section/index.html taxonomy 分类 /tags/index.html term 分类系列 /tags/go/index.html _index.md 和 index.md 在文件夹下方添加_index.md会识别成section. 在文件夹下方添加index.md会被识别成文章.\n千万不要在默认的content目录下方添加index.md","title":"Hugo 文章分类管理"}]