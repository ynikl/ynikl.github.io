<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Blogs | 潜水员的咖啡小屋</title><meta name=keywords content><meta name=description content="Blogs - 潜水员的咖啡小屋"><meta name=author content="潜水员"><link rel=canonical href=https://ynikl.github.io/blog/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><link rel=icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate type=application/rss+xml href=https://ynikl.github.io/blog/index.xml><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-35FCVN7C8X"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-35FCVN7C8X",{anonymize_ip:!1})}</script><meta property="og:title" content="Blogs"><meta property="og:description" content="发发牢骚"><meta property="og:type" content="website"><meta property="og:url" content="https://ynikl.github.io/blog/"><meta property="og:image" content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="og:site_name" content="潜水员的咖啡小屋"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Blogs"><meta name=twitter:description content="发发牢骚"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://ynikl.github.io/blog/"}]}</script></head><body class=list id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ynikl.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ynikl.github.io/apple-touch-icon_hu580d61a4745e72e64f2a76fb3eea3190_18715_0x35_resize_box_3.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ynikl.github.io/blog/ title=blog><span class=active>blog</span></a></li><li><a href=https://ynikl.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://ynikl.github.io/books/ title=books><span>books</span></a></li><li><a href=https://ynikl.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://ynikl.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ynikl.github.io/me/ title=me?><span>me?</span></a></li></ul></nav></header><main class=main><header class=page-header><div class=breadcrumbs><a href=https://ynikl.github.io/>Home</a></div><h1>Blogs</h1></header><article class=post-entry><header class=entry-header><h2>Golang Gin</h2></header><div class=entry-content><p>Golang Gin 框架的使用和理解 中间的几个关键对象 Engine gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过New()或者Default()创建
New 不带任何中间件 Default 会带 logger 和 recover 通过 Engine.Use() 添加中间件到Engine的RouterGroup
Engine.Run 启动, 并绑定到参数的地址
RouterGroup 1 2 3 4 5 6 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 用于存储中间件的处理方法 – 存储再 HandlersChain 里面, 即[]HandlerFunc
真正的路由地址存储在engine.trees – 路由树, 检索请求地址和对应处理方法.
Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址. 目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树. 也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.
1 2 3 4 5 6 func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { absolutePath := group....</p></div><footer class=entry-footer><span title='2023-01-01 22:08:25 +0800 +0800'>January 1, 2023</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Golang Gin" href=https://ynikl.github.io/blog/golang-gin/></a></article><article class=post-entry><header class=entry-header><h2>Mysql 快速备份数据</h2></header><div class=entry-content><p>1 2 CREATE TABLE dbto.table_name like dbfrom.table_name; insert into dbto.table_name select * from dbfrom.table_name; 原文</p></div><footer class=entry-footer><span title='2022-12-20 10:55:10 +0800 +0800'>December 20, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Mysql 快速备份数据" href=https://ynikl.github.io/blog/mysql-quick-backup-data/></a></article><article class=post-entry><header class=entry-header><h2>Golang 是否需要为每个请求 New 一个 Client</h2></header><div class=entry-content><p>背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致下游的 nginx 的连接数暴涨.
问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client
探索 在 StackOverflow 发现的相关答案
How to release http.Client in Go?
给的答案是建议复用 Client
The Client’s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
http.Client 的结构体
1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time....</p></div><footer class=entry-footer><span title='2022-12-19 15:35:53 +0800 +0800'>December 19, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Golang 是否需要为每个请求 New 一个 Client" href=https://ynikl.github.io/blog/golang-client-reuse/></a></article><article class=post-entry><header class=entry-header><h2>查看 Linux 的负载情况</h2></header><div class=entry-content><p>查看负载 系统平均负载
1 uptime 那么什么是系统平均负载呢？ 系统平均负载是指在特定时间间隔内运行队列中的平均进程数。 如果每个CPU内核的当前活动进程数不大于3的话，那么系统的性能是良好的。如果每个CPU内核的任务数大于5，那么这台机器的性能有严重问题。
查看内存信息 1 free -h 查看 cpu 型号
1 cat /proc/cpuinfo | grep 'physical id' | sort | uniq | wc -l 核数
1 cat /proc/cpuinfo |grep "cores"|uniq|awk '{print $4}' 参考文章 https://www.eet-china.com/mp/a87720.html https://colobu.com/2019/02/22/how-to-find-cpu-cores-in-linux/ https://wangchujiang.com/linux-command/c/uptime.html</p></div><footer class=entry-footer><span title='2022-12-16 14:31:33 +0800 +0800'>December 16, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 查看 Linux 的负载情况" href=https://ynikl.github.io/blog/linux-server-device-info/></a></article><article class=post-entry><header class=entry-header><h2>代码整洁架构</h2></header><div class=entry-content><p>代码整洁架构
核心思想 最重要的是依赖顺序需要内收 – 业务逻辑不能依赖框架
分层 简单分层四层
Entities Use Cases Interface Adapters Framework and Drivers Entity 实体抽象层 我的理解应该是在公司业务, 或者项目领域上对于业务模型的抽象. 不容易改变 (除非公司 业务, 或者项目方向改变). 应该是与 领域驱动设计 不谋而合
Use Cases 使用场景层 业务使用场景, 应该是存放相关不同业务场景的具体实现流程
Interface Adapters 接口转化器层 负责 Use Cases 数据 与外部使用数据转换器实现.
比较特别的例子, 将 Use Cases 产生的数据与外部的 UI 表现层所需要的数据格式做转化.
Framework and Divers 数据库和框架层, 外部工具包接口依赖之类的.
依赖倒置 当遇到跨层依赖的时候, 内层需要引用到外层逻辑时: 比如, Use Case 要呈现 UI 数据结构 (Interface Adapters 层) 时, 不能直接引用 UI 层的数据模型.
而是, 通过依赖倒置. 将 UI 层的处理逻辑, 注入 Use Case 层进行处理, 实现目标....</p></div><footer class=entry-footer><span title='2022-12-05 09:21:02 +0800 +0800'>December 5, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 代码整洁架构" href=https://ynikl.github.io/blog/clean-architectrue/></a></article><article class=post-entry><header class=entry-header><h2>go 使用 runtime 包进行内存占用分析</h2></header><div class=entry-content><p>使用场景 写个demo, 想查看一下程序内部的内存占用情况.
使用方法 主角 runtime 包
对象 MemStats 方法 ReadMemStats demo 展示
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(&m) // For info on each, see: https://golang....</p></div><footer class=entry-footer><span title='2022-11-18 19:27:35 +0800 +0800'>November 18, 2022</span>&nbsp;·&nbsp;5 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to go 使用 runtime 包进行内存占用分析" href=https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/></a></article><article class=post-entry><header class=entry-header><h2>Golang Minimal Version Selection 意识流翻译(仅开头)</h2></header><div class=entry-content><p>原文: Minimal Version Selection
意识流翻译, 只是简单的把自己的理解转化成中文. 仅供参考.
翻译: Go 构建相关的命令需要决定模块版本. 把这些模块和版本号称之为编译列表(build list). 为了稳定的开发, 今天的编译列表必须和明天的编译列表是一致的. 但是开发者也必须支持 编译列表的改变: 升级所有的模块, 升级单个模块, 降级单个模块.
版本选择的问题定位为: 给定一个算法支持对编译列表进行下面四种操作:
构建当前的编译列表 升级所有模块到各自对应的最新版本 升级一个模块到对应的版本 降级一个模块到对应的版本 最后两种操作是在一个具体的模块进行升级和降级. 在满足依赖需求的前提下, 尽量少的进 行升级, 降级, 添加或者移除模块.
这篇博文展示了最小版本选择算法, 一个新的, 简单的版本选择方案. 最小版本选择是容易 理解和能简单推测出他的运行行为的. 而且还能高稳定构建的, 表名一个用户所使用的依赖 是非常接近开发者所使用的依赖. 能够高效实现, 没有使用什么复杂的递归图算法. 仅仅只 用了几行 go 的代码就是实现了.
最小选择算法假设所有的模块都声明了它自己对于其他模块的依赖清单. 且所有的模块都遵 守语义化版本: 向前兼容的版本使用小版本号, 不向前兼容的版本使用大版本号.
对应的四种列表操作:
构建当前模块的编译列表: 将当前模块引用的依赖列表加在一起, 重复的仅保持一份. 升级所有模块版本: 所有最新引用的依赖, 重新构建一份列表 升级某一具体模块版本: 构建没有升级的列表, 再将升级的模块新的引用列表加入, 加入 时如果如果已经存在, 就是仅保存最新的版本 降级一个模块到对应的版本: 反解开所有依赖降级的模块, 每一个依赖都需降级到目标 模块版本之下 这些操作简单, 高效, 且容易实现...</p></div><footer class=entry-footer><span title='2022-11-01 00:15:50 +0800 +0800'>November 1, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Golang Minimal Version Selection 意识流翻译(仅开头)" href=https://ynikl.github.io/blog/golang-minimal-version-selection/></a></article><article class=post-entry><header class=entry-header><h2>Golang 解决依赖包版本冲突</h2></header><div class=entry-content><p>遇到了 grpc 不遵循语义版本, 导致不同版本包之间的冲突.
更新了目标的版本模块之后, 编译一下就发现原先项目引用的 gozero 框架报错了. 搜索一下 相关的关键词,就可以定位到问题是 grpc 搞的鬼.
再找到对应的兼容版本, 升级到对应的版本就可以了.
go 依赖版本选择 [golang 的最小版本选择]https://ynikl.github.io/blog/golang-minimal-version-selection/
大体意思:
会选择当前编译需要依赖包的最高版本(使用语义化版本)
寻找依赖的原因 go mod why
寻找自己项目引用某个包的 最短引用路径, 导致会引用目标包的
1 go mod why google.golang.org/grpc 输出目标包的引用依赖层级
1 2 3 4 5 6 ❯ go mod why google.golang.org/grpc # google.golang.org/grpc hello/world/test git.test.cn/company-open/rpc-pkgs google.golang.org/grpc go mod graph
可以打印出, 模块的依赖图
1 2 3 4 5 6 example.com/main example.com/a@v1.1.0 example.com/main example.com/b@v1.2.0 example.com/a@v1.1.0 example.com/b@v1.1.1 example.com/a@v1.1.0 example.com/c@v1.3.0 example.com/b@v1.1.0 example.com/c@v1.1.0 example....</p></div><footer class=entry-footer><span title='2022-10-31 08:26:33 +0800 +0800'>October 31, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Golang 解决依赖包版本冲突" href=https://ynikl.github.io/blog/golang-find-module-conflict/></a></article><article class=post-entry><header class=entry-header><h2>Python 基本语法快速学习</h2></header><div class=entry-content><p>学习路径 数据结构 流程控制 代码组织 工程化 数据结构 strings int list tuple dictionary 如何查看一个基本的类型对象拥有的方法
1 2 3 name = "ada" dir(name) dir 获取对象的属性
字符串 1 name = "ada lovelace" 拼接, 用+
1 2 3 first_name = "ada" last_name = "lovelace" full_name = first_name + " " + last_name 声明字符串中 '单引号和" 双引号没有区别, 可以用来相互替换 多行字串使用'''连续三个单引号或双引号声明 字符串格式化
format
1 2 3 >>> 'Hey {name}, there is a 0x{errno:x} error!'.format( ... name=name, errno=errno) 'Hey Bob, there is a 0xbadc0ffee error!...</p></div><footer class=entry-footer><span title='2022-10-09 17:34:39 +0800 +0800'>October 9, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Python 基本语法快速学习" href=https://ynikl.github.io/blog/python-basic-quick/></a></article><article class=post-entry><header class=entry-header><h2>乐观锁和悲观锁</h2></header><div class=entry-content><p>乐观锁和悲观锁 首先, 乐观锁和悲观锁和本身并不是一种具体锁.
而是一种编程的并发控制思想. 原名应该叫做乐观并发控制(Optimistic concurrency control) 简称 OCC 和 悲观并发控制(Pessimistic Concurrency Control) 简称 PCC
什么是锁 维基百科对锁的定义
In computer science, a lock or mutex (from mutual exclusion) is a synchronization primitive: a mechanism that enforces limits on access to a resource when there are many threads of execution. A lock is designed to enforce a mutual exclusion concurrency control policy, and with a variety of possible methods there exists multiple unique implementations for different applications....</p></div><footer class=entry-footer><span title='2022-10-02 14:05:43 +0800 +0800'>October 2, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 乐观锁和悲观锁" href=https://ynikl.github.io/blog/cs-optimitic-concurrency-control/></a></article><article class=post-entry><header class=entry-header><h2>Go errgroup 的基本用法</h2></header><div class=entry-content><p>实现并发控制 在 golang 代码中如果要对一段代码进行并发限制. 通常的做法都是在写一个 channel 进行传入和传出.
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 func main() { concurrencyNum := 10 limitCh := make(chan bool, concurrencyNum) wg := new(sync.WaitGroup) for i := 0; i &lt; 100; i++ { limitCh &lt;- true wg.Add(1) go func() { defer func() { &lt;-limitCh wg.Done() }() time.Sleep(1 * time.Second) fmt....</p></div><footer class=entry-footer><span title='2022-09-19 09:19:31 +0800 +0800'>September 19, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Go  errgroup 的基本用法" href=https://ynikl.github.io/blog/golang-errgroup/></a></article><article class=post-entry><header class=entry-header><h2>如何查看 golang 编译之后调用的源码方法</h2></header><div class=entry-content><p>在 golang 中查看源码是比较方便的. 可以直接到 官方包文档中直接查看文档和跳转到源码
但是, 当我们想看一些更加底层的实现方法时, 就需要知道编译器将对应的方法编译成 什么底层方法了.
比如, 我知道一些make(map[int]bool)是怎么实现的.
这时候就需要一些方法了. 引用一下鸟窝大佬的文章 总结一下三种方法:
go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile -N -l -S makemap.go go tool compile 产生的汇编代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 0x001c 00028 (main.go:5) FUNCDATA $1, gclocals·PdpXzE88ETLbqQ9okAZ04w==(SB) 0x001c 00028 (main.go:5) FUNCDATA $2, main.main.stkobj(SB) 0x001c 00028 (main.go:6) STP (ZR, ZR), main....</p></div><footer class=entry-footer><span title='2022-09-18 21:37:55 +0800 +0800'>September 18, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 如何查看 golang 编译之后调用的源码方法" href=https://ynikl.github.io/blog/golang-get-assembly-fn/></a></article><article class=post-entry><header class=entry-header><h2>FFmpeg 基本使用</h2></header><div class=entry-content><p>最近接手公司一个视频相关项目, 也是使用ffmpeg工具. 需要快速了解下.
概念 码率, 帧率, 文件大小 帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.
interlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i progressive: 现代整页整页呈现, 描述单位p: 60p 码率(bit rate) :视频一秒中有多少位, 决定视频的质量
ABR: 平均码率 CBR: 常量码率 VBR: 动态码率 文件大小 = 视频文件 + 音频文件
视频文件 = 码率 * 时间(s) / 8 音频文件 = 码率 * 时间(s) / 8
文件格式 不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers) 可以存储声音或者视频数据.
相关缩写 encoding (E) decoding (D) video (V) audio (A) subtitles (S) 文件元数据 metadata 描述媒体文件自身的信息, 比如:...</p></div><footer class=entry-footer><span title='2022-08-19 00:14:54 +0800 +0800'>August 19, 2022</span>&nbsp;·&nbsp;3 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to FFmpeg 基本使用" href=https://ynikl.github.io/blog/ffmpeg-basics/></a></article><article class=post-entry><header class=entry-header><h2>Redis 用于做分布式锁</h2></header><div class=entry-content><p>操作 演进 加锁后进程挂掉了 加锁成功之后, 进程挂掉了没有进行解锁操作. 导致进入死锁状态.
引入 expire 设置超时时长, 自动释放 key
1 2 3 4 5 6 7 8 > setnx lock:key true > OK > expire lock:key 5 " ... do something critical ... > del lock:codehole 加锁动作 到 expire 之间挂掉了 redis 2.8 之后支持 set 拓展指令
1 > set lock:key true ex 5 nx 加锁互斥锁, 并同时设置超时时长
执行超时, 被其他进程获取到了锁 加锁之后, 本身进程执行时间超过了预先设置的 expire 的时间. 就会导致锁被提前释放.
解决方案:
尽量不要用与锁住时间教长的任务, 尝试缩小锁定的"关键区域" 续锁 (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间 执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁 Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。 – Redis深度历险...</p></div><footer class=entry-footer><span title='2022-08-18 12:18:53 +0800 +0800'>August 18, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Redis 用于做分布式锁" href=https://ynikl.github.io/blog/redis-do-distributed-lock/></a></article><article class=post-entry><header class=entry-header><h2>Golang Map 介绍</h2></header><div class=entry-content><p>本想写一篇关于 golang 中 map 底层的文章， 但是发现已经了相当不错的文章 – 字节跳动技术团队 - Golang 中 map 探究 这里只补充一下，缺少的 map 的删除操作
内部数据结构 初始化 map 是一个有"包含内容"的数据结构, 使用之前需要提前初始化, 即调用make
真正是调用源码是 runtime.makemap
获取数据 删除 源码地址
删除的关键代码
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // Only clear key if there are pointers in it. // # 当 Key 是指针类型的时候会去清空指针 if t.key.ptrdata != 0 { if goarch....</p></div><footer class=entry-footer><span title='2022-08-13 14:14:30 +0800 +0800'>August 13, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Golang Map 介绍" href=https://ynikl.github.io/blog/golang-map/></a></article><article class=post-entry><header class=entry-header><h2>Mysql- 数据类型 - 数字</h2></header><div class=entry-content><p>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期和时间 空间 JSON 数字类型 整数类型 Interger 类型 存储大小 bytes 其他别名 TinyInt 1 bool, boolean = tinyint(1) SmallInt 2 MediumInt 3 Int 4 BigInt 8 int(M) 表示显示宽度, 最大显示宽度为(255), M 与存储空间的大小无关. 空间大小由具体类型决定.
如果具体数值达不到宽度, 左边就会用0值补齐至 M 位.
浮点 ( Floating-Point ) 类型 存储 补充 范围 Float 4 bytes 单精度 Double 8 bytes 双精度 Float(p) p 表示小数点后的精度位数
Float(M, D) Mysql 语法: M表示总显示位数, D表示小数点后个数 – 由Mysql自己做约分处理. Mysql 8.0 后废弃该语法.
定点 ( Fixed-Point ) 用于需要准备保存字段数据, 如金钱相关字段....</p></div><footer class=entry-footer><span title='2022-07-31 17:49:46 +0800 +0800'>July 31, 2022</span>&nbsp;·&nbsp;1 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Mysql- 数据类型 - 数字" href=https://ynikl.github.io/blog/mysql-data-type-numbers/></a></article><article class=post-entry><header class=entry-header><h2>Mysql- 数据类型 - 日期</h2></header><div class=entry-content><p>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期类型 空间 JSON 日期类型 Mysql 支持的数据类型
DATE TIME DATETIME TIMESTAMP YEAR Date 只存储日期数据, 不包含时间. YYYY-MM-DD, 范围是从 ‘1000-01-01’ to ‘9999-12-31’
DateTime 存储日期, 也存储时间 'YYYY-MM-DD hh:mm:ss'
范围是从'1000-01-01 00:00:00’ to ‘9999-12-31 23:59:59’
TIMESTAMP 存储Unix时间戳数据 会受到服务器时区影响– 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之 时区环境变量设置 范围 ‘1970-01-01 00:00:01’ UTC to ‘2038-01-19 03:14:07’ UTC.
相关函数:
FROM_UNIXTIME 把 Unix 时间戳转化成日期 UNIX_TIMESTAMP 把日期转化成 Unix 时间戳 YEAR 显示形式 YYYY, 可选显示位数YYYY(M)
默认4位显示 ‘1991’ TIME 只有时间部分,没有日期部分 hh:mm:ss, 范围从 ‘-838:59:59’ 到 ‘838:59:59’...</p></div><footer class=entry-footer><span title='2022-07-31 17:49:46 +0800 +0800'>July 31, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Mysql- 数据类型 - 日期" href=https://ynikl.github.io/blog/mysql-data-type-date/></a></article><article class=post-entry><header class=entry-header><h2>RabbitMQ 基本入门实践</h2></header><div class=entry-content><p>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.
介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件
消息中间件的作用
解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释
Producer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型
fanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:...</p></div><footer class=entry-footer><span title='2022-07-09 16:43:26 +0800 +0800'>July 9, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to RabbitMQ 基本入门实践" href=https://ynikl.github.io/blog/rabbitmq-learning-note/></a></article><article class=post-entry><header class=entry-header><h2>Go中slice[i:j:k]第三个参数是做什么的</h2></header><div class=entry-content><p>今天, 突然被同事卷到了, 被问到 golang 中 slice 的三个参数是干嘛的? 我突然一时间忘记了, golang 的重切片居然是可以接受第三个参数的, 枉费我已经了写了快两年的 go 了. 赶紧 google 一下, 并总结备忘.
简单介绍 slice 的数据结构 首先, 介绍一下 golang 中切片的结构体:
1 2 3 4 5 type slice struct { array unsafe.Pointer len int cap int } 有三个字段:
array 是切片所指向的底层数组数据 len 就是切片的长度 cap 即容量, 很明显 源码地址
简单版重切片 a[low:high] 接受切片中的开始下标和结束下标, “左闭右开原则” 即重的切片数据会包含 low 下标的值, 但没有 high 下标的值 新切片的 容量(cap) 即为开始下标到原 slice 数据容量结束, 即"cap(a) - low" low 参数可以省略, 默认从 0 下标开始 high 参数也可以省略, 默认就是 slice 的长度, 即 len 的 value 1 2 3 4 5 6 7 8 a := [10]int{} oldSlice := a[:5] newSlice := a[2:4] fmt....</p></div><footer class=entry-footer><span title='2022-06-09 23:52:30 +0800 +0800'>June 9, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to Go中slice[i:j:k]第三个参数是做什么的" href=https://ynikl.github.io/blog/golang-reslicing-slice/></a></article><article class=post-entry><header class=entry-header><h2>小窥 Go 中的 Modules</h2></header><div class=entry-content><p>是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 > cat go....</p></div><footer class=entry-footer><span title='2022-06-03 18:16:55 +0800 +0800'>June 3, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员</footer><a class=entry-link aria-label="post link to 小窥 Go 中的 Modules" href=https://ynikl.github.io/blog/go-modules/></a></article><footer class=page-footer><nav class=pagination><a class=next href=https://ynikl.github.io/blog/page/2/>Next Page »</a></nav></footer></main><footer class=footer><span>2022 Ian Lin All rights reserved</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>