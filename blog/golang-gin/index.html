<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang Gin | 潜水员的咖啡小屋</title>
<meta name=keywords content="golang"><meta name=description content="Golang Gin 框架的使用和理解 框架代码地址
中间的几个关键对象 Engine RouterGroup HandlerFunc Context Engine gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过New()或者Default()创建
New 不带任何中间件 Default 会带 logger 和 recover 通过 Engine.Use() 添加中间件到Engine的RouterGroup
Engine.Run 启动, 并绑定到参数的地址
RouterGroup 1 2 3 4 5 6 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 用于存储中间件的处理方法 &ndash; 存储再 HandlersChain 里面, 即[]HandlerFunc
真正的路由地址存储在engine.trees &ndash; 路由树, 检索请求地址和对应处理方法.
Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址. 目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树. 也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件."><meta name=author content="潜水员"><link rel=canonical href=https://ynikl.github.io/blog/golang-gin/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.2eadbb982468c11a433a3e291f01326f2ba43f065e256bf792dbd79640a92316.js integrity="sha256-Lq27mCRowRpDOj4pHwEybyukPwZeJWv3ktvXlkCpIxY=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://ynikl.github.io/blog/golang-gin/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-35FCVN7C8X"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-35FCVN7C8X",{anonymize_ip:!1})}</script><meta property="og:title" content="Golang Gin"><meta property="og:description" content="Golang Gin 框架的使用和理解 框架代码地址
中间的几个关键对象 Engine RouterGroup HandlerFunc Context Engine gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过New()或者Default()创建
New 不带任何中间件 Default 会带 logger 和 recover 通过 Engine.Use() 添加中间件到Engine的RouterGroup
Engine.Run 启动, 并绑定到参数的地址
RouterGroup 1 2 3 4 5 6 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 用于存储中间件的处理方法 &ndash; 存储再 HandlersChain 里面, 即[]HandlerFunc
真正的路由地址存储在engine.trees &ndash; 路由树, 检索请求地址和对应处理方法.
Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址. 目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树. 也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件."><meta property="og:type" content="article"><meta property="og:url" content="https://ynikl.github.io/blog/golang-gin/"><meta property="og:image" content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2023-01-01T22:08:25+08:00"><meta property="article:modified_time" content="2023-01-01T22:08:25+08:00"><meta property="og:site_name" content="潜水员的咖啡小屋"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang Gin"><meta name=twitter:description content="Golang Gin 框架的使用和理解 框架代码地址
中间的几个关键对象 Engine RouterGroup HandlerFunc Context Engine gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过New()或者Default()创建
New 不带任何中间件 Default 会带 logger 和 recover 通过 Engine.Use() 添加中间件到Engine的RouterGroup
Engine.Run 启动, 并绑定到参数的地址
RouterGroup 1 2 3 4 5 6 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 用于存储中间件的处理方法 &ndash; 存储再 HandlersChain 里面, 即[]HandlerFunc
真正的路由地址存储在engine.trees &ndash; 路由树, 检索请求地址和对应处理方法.
Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址. 目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树. 也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://ynikl.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Golang Gin","item":"https://ynikl.github.io/blog/golang-gin/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang Gin","name":"Golang Gin","description":"Golang Gin 框架的使用和理解 框架代码地址\n中间的几个关键对象 Engine RouterGroup HandlerFunc Context Engine gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过New()或者Default()创建\nNew 不带任何中间件 Default 会带 logger 和 recover 通过 Engine.Use() 添加中间件到Engine的RouterGroup\nEngine.Run 启动, 并绑定到参数的地址\nRouterGroup 1 2 3 4 5 6 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 用于存储中间件的处理方法 \u0026ndash; 存储再 HandlersChain 里面, 即[]HandlerFunc\n真正的路由地址存储在engine.trees \u0026ndash; 路由树, 检索请求地址和对应处理方法.\nEngine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址. 目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树. 也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.","keywords":["golang"],"articleBody":"Golang Gin 框架的使用和理解 框架代码地址\n中间的几个关键对象 Engine RouterGroup HandlerFunc Context Engine gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过New()或者Default()创建\nNew 不带任何中间件 Default 会带 logger 和 recover 通过 Engine.Use() 添加中间件到Engine的RouterGroup\nEngine.Run 启动, 并绑定到参数的地址\nRouterGroup 1 2 3 4 5 6 type RouterGroup struct { Handlers HandlersChain basePath string engine *Engine root bool } 用于存储中间件的处理方法 – 存储再 HandlersChain 里面, 即[]HandlerFunc\n真正的路由地址存储在engine.trees – 路由树, 检索请求地址和对应处理方法.\nEngine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址. 目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树. 也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.\n1 2 3 4 5 6 func (group *RouterGroup) handle(httpMethod, relativePath string, handlers HandlersChain) IRoutes { absolutePath := group.calculateAbsolutePath(relativePath) handlers = group.combineHandlers(handlers) group.engine.addRoute(httpMethod, absolutePath, handlers) return group.returnObj() } 注册路由之前, 先将当前的 http 处理方法, 与当前中间件配置合并, 再添加到engine.\nRouterGroup RouterGroup.Group\t创建一个新的 RouterGroup\n1 2 3 4 5 6 7 func (group *RouterGroup) Group(relativePath string, handlers ...HandlerFunc) *RouterGroup { return \u0026RouterGroup{ Handlers: group.combineHandlers(handlers), basePath: group.calculateAbsolutePath(relativePath), engine: group.engine, } } 创建新的 Group 时候,也会继承旧的 Group, 原先已经设置的 middleware. gin 框架不支持移除中间件的操作，所以在上层设置的中间件的时候一定要确保是公共 common 的\n相似的路由捆绑在一块, 路由组写法, 可以做绑定相同中间件处理.\n1 2 3 4 5 6 7 // Simple group: v1 v1 := router.Group(\"/v1\") { v1.POST(\"/login\", loginEndpoint) v1.POST(\"/submit\", submitEndpoint) v1.POST(\"/read\", readEndpoint) } 中间的花括号只起美化代码作用, 非必需\nHandlerFunc 中间件和请求处理方法的函数签名\n1 type HandlerFunc func(*Context) 处理请求的时候, HandlerFunc 执行完毕 – 代表该请求处理结束\nContext gin 自己实现的 Context 结构\n在中间件中传递参数 控制调用流程 获取参数 返回结果 Context 结构的重要组成部分介绍\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 type Context struct { // 存储URL 参数 Params Params // 写入请求的结果 Writer ResponseWriter // 请求的所有处理方法集合 handlers HandlersChain // 当前执行到第几个方法 index int8 // 存储流转于中间件的参数式 Keys map[string]any } 在中间件中传递参数 context.Get context.Set 两个方法在中间件中传递参数 流程控制 context.Next() 1 2 3 4 5 6 7 func (c *Context) Next() { c.index++ for c.index \u003c int8(len(c.handlers)) { c.handlers[c.index](c) c.index++ } } 将当前代码执行点移交到下一个 HandlerFunc 具体流程看, Middleware\n获取参数 context.Param() 获取 Query Param 的字符串参数 context.Query() context.QueryMap() 或者 context.PostFormMap 获取 map 的参数 context.Bind 将参数包含query参数和body参数解析之后, 反序列化到传入的结构体. tag binding:\"required\" 如果没有对应参数会报错 调用结束 conetxt.JSON 以json的形式, 返回结果 举个例子: 如果是json的的化就是 jsonBinding 进行反序列化 报错 500 context.AbortWithStatus() Cookie 操作 context.Cookie() context.SetCookie() Middleware 符合 HandlerFunc 签名的函数. 就可以Engine.Use注册层路由. 路由设置 的处理函数, 在本质上可以称为中间件.\ngin 会按照 routegroup Use 中间件的先后顺序存储到路由表中 接收请求, 依次执行注册时设置的所有中间件函数. Next 调用流程图:\n1 2 3 4 5 6 7 8 9 10 11 12 13 middleware 1 | - doing m1 work | - call Context.Next() | - call middleware 2 | - doing m2 work | - call Context.Next() | - call middleware 3 | - - done m3 | - continue m2 work | - - done m2 work | - coninue m1 work | - done finish 当调研 Context.Next() 时会调用下一个中间函数, 当下一个函数执行完成之后, 执行 代码会返回到原先调用 Context.Next()的地方 – 递归\nAbort 中间处理时可以调用 Context.Abort()\n1 2 3 func (c *Context) Abort() { c.index = abortIndex } 会将函数调用链的index指向一个超大整数 – 放弃后面所有的处理函数, 但是 调用Abort后, 同一个函数接下的代码还会继续执行\n小demo demo\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 func main() { eg := gin.New() eg.Use(m1, m2) eg.GET(\"/greet\", m3, greet) eg.GET(\"/abort\", abort, m3, greet) eg.Run(\":8080\") } func m1(c *gin.Context) { fmt.Println(\"before m1 next\") c.Next() fmt.Println(\"after m1 next\") } func m2(c *gin.Context) { fmt.Println(\"\\tbefore m2 next\") c.Next() fmt.Println(\"\\tafter m2 next\") } func m3(c *gin.Context) { fmt.Println(\"\\t\\tbefore m3 next\") c.Next() fmt.Println(\"\\t\\tafter m3 next\") } func abort(c *gin.Context) { fmt.Println(\"\\t\\t\\tbefore abort\") c.Abort() fmt.Println(\"\\t\\t\\tafter abort\") } func greet(c *gin.Context) { fmt.Println(\"\\t\\t\\t\\thow are you doing?\") c.JSON(200, \"great\") } 接口 /greet 的输出\n1 2 3 4 5 6 7 before m1 next before m2 next before m3 next how are you doing? after m3 next after m2 next after m1 next 接口 /abort 的数据\n1 2 3 4 5 6 before m1 next before m2 next before abort after abort after m2 next after m1 next 其他 gin.H\n1 2 type gin.H map[string]interface{} // 常用于 engine.JSON() 时返回 json 数据 几个问题 Gin 的 context 有什么作用和怎么用? context 是 Gin 代码请求流转的核心, 存储处理请求的所有必须参数\n基本的使用方法:\n需要知道如何获取参数 – Bind 或者 Param 方法 控制处理函数流程 – Next 或者 Abort 方法 返回结果 – JSON Gin 的整体框架流程是怎么样的? 从接受到一个请求再到返回请求中间的流程? 请求的注册入口, Engine.ServeHTTP\n整体流程\n存储路由路径和注册的处理函数到\"路由树\" – nodetree 接收请求 根据接收到的请求地址, 从路由树中取出注册的函数, 组成HandlerChain 函数处理链 把函数处理链赋值到gin.Context中 由gin.Context开始依次调用注册处理函数, 所以函数遍历完成, 处理结束 通过gin.Context.Writer写入http请求结果 请求结束 ","wordCount":"648","inLanguage":"en","datePublished":"2023-01-01T22:08:25+08:00","dateModified":"2023-01-01T22:08:25+08:00","author":{"@type":"Person","name":"潜水员"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ynikl.github.io/blog/golang-gin/"},"publisher":{"@type":"Organization","name":"潜水员的咖啡小屋","logo":{"@type":"ImageObject","url":"https://ynikl.github.io/apple-touch-icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ynikl.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ynikl.github.io/apple-touch-icon_hu580d61a4745e72e64f2a76fb3eea3190_18715_0x35_resize_box_3.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li></ul></span></div><ul id=menu><li><a href=https://ynikl.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://ynikl.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://ynikl.github.io/books/ title=books><span>books</span></a></li><li><a href=https://ynikl.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://ynikl.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ynikl.github.io/me/ title=me?><span>me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ynikl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ynikl.github.io/blog/>Blogs</a></div><h1 class=post-title>Golang Gin</h1><div class=post-meta>&lt;span title='2023-01-01 22:08:25 +0800 +0800'>January 1, 2023&lt;/span>&amp;nbsp;·&amp;nbsp;4 min&amp;nbsp;·&amp;nbsp;潜水员&nbsp;|&nbsp;<a href=https://github.com/ynikl/ynikl.github.io/tree/main/content/blog/golang-gin.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h1 id=golang-gin-框架的使用和理解>Golang Gin 框架的使用和理解<a hidden class=anchor aria-hidden=true href=#golang-gin-框架的使用和理解>#</a></h1><p><a href=https://github.com/gin-gonic/gin>框架代码地址</a></p><h2 id=中间的几个关键对象>中间的几个关键对象<a hidden class=anchor aria-hidden=true href=#中间的几个关键对象>#</a></h2><ul><li>Engine</li><li>RouterGroup</li><li>HandlerFunc</li><li>Context</li></ul><h3 id=engine>Engine<a hidden class=anchor aria-hidden=true href=#engine>#</a></h3><p>gin 的框架实例, 包含路由地址, 中间件, 框架配置. 通过<code>New()</code>或者<code>Default()</code>创建</p><ul><li><code>New</code> 不带任何中间件</li><li><code>Default</code> 会带 <code>logger</code> 和 <code>recover</code></li></ul><p>通过 <code>Engine.Use()</code> 添加中间件到Engine的<code>RouterGroup</code></p><p><code>Engine.Run</code> 启动, 并绑定到参数的地址</p><h3 id=routergroup>RouterGroup<a hidden class=anchor aria-hidden=true href=#routergroup>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type RouterGroup struct {
</span></span><span class=line><span class=cl>	Handlers HandlersChain
</span></span><span class=line><span class=cl>	basePath string
</span></span><span class=line><span class=cl>	engine   *Engine
</span></span><span class=line><span class=cl>	root     bool
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>用于存储中间件的处理方法 &ndash; 存储再 <code>HandlersChain</code> 里面, 即<code>[]HandlerFunc</code></p><p>真正的路由地址存储在<code>engine.trees</code> &ndash; 路由树, 检索请求地址和对应处理方法.</p><p>Engine 包含 RouterGroup, RouterGroup 也会存储 Engine 的地址.
目的是为了, 加点api地址时, 根据当前具体配置的中间件, 再添加engine的路由树.
也就是说, 过程中修改了中间件, 不会影响到已经配置的路由的中间件.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=cl><span class=k>func</span> <span class=p>(</span><span class=n>group</span> <span class=o>*</span><span class=n>RouterGroup</span><span class=p>)</span> <span class=n>handle</span><span class=p>(</span><span class=n>httpMethod</span><span class=p>,</span> <span class=n>relativePath</span> <span class=n>string</span><span class=p>,</span> <span class=n>handlers</span> <span class=n>HandlersChain</span><span class=p>)</span> <span class=n>IRoutes</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=n>absolutePath</span> <span class=p>:</span><span class=o>=</span> <span class=n>group</span><span class=o>.</span><span class=n>calculateAbsolutePath</span><span class=p>(</span><span class=n>relativePath</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>handlers</span> <span class=o>=</span> <span class=n>group</span><span class=o>.</span><span class=n>combineHandlers</span><span class=p>(</span><span class=n>handlers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=n>group</span><span class=o>.</span><span class=n>engine</span><span class=o>.</span><span class=n>addRoute</span><span class=p>(</span><span class=n>httpMethod</span><span class=p>,</span> <span class=n>absolutePath</span><span class=p>,</span> <span class=n>handlers</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=n>group</span><span class=o>.</span><span class=n>returnObj</span><span class=p>()</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>注册路由之前, 先将当前的 http 处理方法, 与当前中间件配置合并, 再添加到engine.</p><h4 id=routergroup-1>RouterGroup<a hidden class=anchor aria-hidden=true href=#routergroup-1>#</a></h4><p><code>RouterGroup.Group</code> 创建一个新的 <code>RouterGroup</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>group</span> <span class=o>*</span><span class=nx>RouterGroup</span><span class=p>)</span> <span class=nf>Group</span><span class=p>(</span><span class=nx>relativePath</span> <span class=kt>string</span><span class=p>,</span> <span class=nx>handlers</span> <span class=o>...</span><span class=nx>HandlerFunc</span><span class=p>)</span> <span class=o>*</span><span class=nx>RouterGroup</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=k>return</span> <span class=o>&amp;</span><span class=nx>RouterGroup</span><span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>Handlers</span><span class=p>:</span> <span class=nx>group</span><span class=p>.</span><span class=nf>combineHandlers</span><span class=p>(</span><span class=nx>handlers</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>basePath</span><span class=p>:</span> <span class=nx>group</span><span class=p>.</span><span class=nf>calculateAbsolutePath</span><span class=p>(</span><span class=nx>relativePath</span><span class=p>),</span>
</span></span><span class=line><span class=cl>		<span class=nx>engine</span><span class=p>:</span>   <span class=nx>group</span><span class=p>.</span><span class=nx>engine</span><span class=p>,</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>创建新的 Group 时候,也会继承旧的 Group, 原先已经设置的 middleware. gin 框架不支持移除中间件的操作，所以在上层设置的中间件的时候一定要确保是公共 common 的</p><p>相似的路由捆绑在一块, 路由组写法, 可以做绑定相同中间件处理.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// Simple group: v1
</span></span><span class=line><span class=cl>v1 := router.Group(&#34;/v1&#34;)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  v1.POST(&#34;/login&#34;, loginEndpoint)
</span></span><span class=line><span class=cl>  v1.POST(&#34;/submit&#34;, submitEndpoint)
</span></span><span class=line><span class=cl>  v1.POST(&#34;/read&#34;, readEndpoint)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>中间的花括号只起美化代码作用, 非必需</p><h3 id=handlerfunc>HandlerFunc<a hidden class=anchor aria-hidden=true href=#handlerfunc>#</a></h3><p>中间件和请求处理方法的函数签名</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>HandlerFunc</span> <span class=kd>func</span><span class=p>(</span><span class=o>*</span><span class=nx>Context</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>处理请求的时候, HandlerFunc 执行完毕 &ndash; 代表该请求处理结束</p><h3 id=context>Context<a hidden class=anchor aria-hidden=true href=#context>#</a></h3><p>gin 自己实现的 Context 结构</p><ul><li>在中间件中传递参数</li><li>控制调用流程</li><li>获取参数</li><li>返回结果</li></ul><p>Context 结构的重要组成部分介绍</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>Context</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=c1>// 存储URL 参数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Params</span>   <span class=nx>Params</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1>// 写入请求的结果
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Writer</span>    <span class=nx>ResponseWriter</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1>// 请求的所有处理方法集合
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>handlers</span> <span class=nx>HandlersChain</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1>// 当前执行到第几个方法
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>index</span>    <span class=kt>int8</span>
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	<span class=c1>// 存储流转于中间件的参数式
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Keys</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=nx>any</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h4 id=在中间件中传递参数>在中间件中传递参数<a hidden class=anchor aria-hidden=true href=#在中间件中传递参数>#</a></h4><ul><li><code>context.Get</code></li><li><code>context.Set</code> 两个方法在中间件中传递参数</li></ul><h4 id=流程控制>流程控制<a hidden class=anchor aria-hidden=true href=#流程控制>#</a></h4><ul><li><code>context.Next()</code></li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Context</span><span class=p>)</span> <span class=nf>Next</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>index</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>c</span><span class=p>.</span><span class=nx>index</span> <span class=p>&lt;</span> <span class=nb>int8</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>c</span><span class=p>.</span><span class=nx>handlers</span><span class=p>))</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>handlers</span><span class=p>[</span><span class=nx>c</span><span class=p>.</span><span class=nx>index</span><span class=p>](</span><span class=nx>c</span><span class=p>)</span>
</span></span><span class=line><span class=cl>		<span class=nx>c</span><span class=p>.</span><span class=nx>index</span><span class=o>++</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>将当前代码执行点移交到下一个 <code>HandlerFunc</code> 具体流程看, <a href=#Middleware>Middleware</a></p><h4 id=获取参数>获取参数<a hidden class=anchor aria-hidden=true href=#获取参数>#</a></h4><ul><li><code>context.Param()</code> 获取 Query Param 的字符串参数</li><li><code>context.Query()</code></li><li><code>context.QueryMap()</code> 或者 <code>context.PostFormMap</code> 获取 map 的参数</li><li><code>context.Bind</code> 将参数包含query参数和body参数解析之后, 反序列化到传入的结构体.
tag <code>binding:"required"</code> 如果没有对应参数会报错</li></ul><h4 id=调用结束>调用结束<a hidden class=anchor aria-hidden=true href=#调用结束>#</a></h4><ul><li><code>conetxt.JSON</code> 以json的形式, 返回结果
举个例子: 如果是json的的化就是 <code>jsonBinding</code> 进行反序列化</li><li>报错 500 <code>context.AbortWithStatus()</code></li></ul><h4 id=cookie-操作>Cookie 操作<a hidden class=anchor aria-hidden=true href=#cookie-操作>#</a></h4><ul><li><code>context.Cookie()</code></li><li><code>context.SetCookie()</code></li></ul><h3 id=middleware>Middleware<a hidden class=anchor aria-hidden=true href=#middleware>#</a></h3><p>符合 <a href=#HandlerFunc>HandlerFunc</a> 签名的函数. 就可以<code>Engine.Use</code>注册层路由. 路由设置
的处理函数, 在本质上可以称为中间件.</p><ol><li>gin 会按照 routegroup <code>Use</code> 中间件的先后顺序存储到路由表中</li><li>接收请求, 依次执行注册时设置的所有中间件函数.</li></ol><h4 id=next>Next<a hidden class=anchor aria-hidden=true href=#next>#</a></h4><p>调用流程图:</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>middleware 1
</span></span><span class=line><span class=cl>| - doing m1 work
</span></span><span class=line><span class=cl>| - call Context.Next()
</span></span><span class=line><span class=cl>|     - call middleware 2
</span></span><span class=line><span class=cl>|       - doing m2 work
</span></span><span class=line><span class=cl>|       - call Context.Next()
</span></span><span class=line><span class=cl>|         - call middleware 3
</span></span><span class=line><span class=cl>|         - - done m3
</span></span><span class=line><span class=cl>|       - continue m2 work
</span></span><span class=line><span class=cl>|     - - done m2 work
</span></span><span class=line><span class=cl>| - coninue m1 work
</span></span><span class=line><span class=cl>| - done 
</span></span><span class=line><span class=cl>finish
</span></span></code></pre></td></tr></table></div></div><p>当调研 <code>Context.Next()</code> 时会调用下一个中间函数, 当下一个函数执行完成之后, 执行
代码会返回到原先调用 <code>Context.Next()</code>的地方 &ndash; 递归</p><h4 id=abort>Abort<a hidden class=anchor aria-hidden=true href=#abort>#</a></h4><p>中间处理时可以调用 <code>Context.Abort()</code></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>Context</span><span class=p>)</span> <span class=nf>Abort</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nx>index</span> <span class=p>=</span> <span class=nx>abortIndex</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>会将函数调用链的index指向一个超大整数 &ndash; 放弃后面所有的处理函数, 但是 <strong>调用Abort后, 同一个函数接下的代码还会继续执行</strong></p><h4 id=小demo>小demo<a hidden class=anchor aria-hidden=true href=#小demo>#</a></h4><p><a href=https://gist.github.com/ynikl/20b603bfd743d2540d482939ac87d133>demo</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>eg</span> <span class=o>:=</span> <span class=nx>gin</span><span class=p>.</span><span class=nf>New</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>eg</span><span class=p>.</span><span class=nf>Use</span><span class=p>(</span><span class=nx>m1</span><span class=p>,</span> <span class=nx>m2</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>eg</span><span class=p>.</span><span class=nf>GET</span><span class=p>(</span><span class=s>&#34;/greet&#34;</span><span class=p>,</span> <span class=nx>m3</span><span class=p>,</span> <span class=nx>greet</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>eg</span><span class=p>.</span><span class=nf>GET</span><span class=p>(</span><span class=s>&#34;/abort&#34;</span><span class=p>,</span> <span class=nx>abort</span><span class=p>,</span> <span class=nx>m3</span><span class=p>,</span> <span class=nx>greet</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>eg</span><span class=p>.</span><span class=nf>Run</span><span class=p>(</span><span class=s>&#34;:8080&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>m1</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;before m1 next&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>Next</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;after m1 next&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>m2</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;\tbefore m2 next&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>Next</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;\tafter m2 next&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>m3</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;\t\tbefore m3 next&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>Next</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;\t\tafter m3 next&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>abort</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;\t\t\tbefore abort&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>Abort</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;\t\t\tafter abort&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>greet</span><span class=p>(</span><span class=nx>c</span> <span class=o>*</span><span class=nx>gin</span><span class=p>.</span><span class=nx>Context</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;\t\t\t\thow are you doing?&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>c</span><span class=p>.</span><span class=nf>JSON</span><span class=p>(</span><span class=mi>200</span><span class=p>,</span> <span class=s>&#34;great&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>接口 <code>/greet</code> 的输出</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>before m1 next
</span></span><span class=line><span class=cl>        before m2 next
</span></span><span class=line><span class=cl>                before m3 next
</span></span><span class=line><span class=cl>                                how are you doing?
</span></span><span class=line><span class=cl>                after m3 next
</span></span><span class=line><span class=cl>        after m2 next
</span></span><span class=line><span class=cl>after m1 next
</span></span></code></pre></td></tr></table></div></div><p>接口 <code>/abort</code> 的数据</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-sh data-lang=sh><span class=line><span class=cl>before m1 next
</span></span><span class=line><span class=cl>        before m2 next
</span></span><span class=line><span class=cl>                        before abort
</span></span><span class=line><span class=cl>                        after abort
</span></span><span class=line><span class=cl>        after m2 next
</span></span><span class=line><span class=cl>after m1 next
</span></span></code></pre></td></tr></table></div></div><h3 id=其他>其他<a hidden class=anchor aria-hidden=true href=#其他>#</a></h3><p>gin.H</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>gin</span><span class=p>.</span><span class=nx>H</span> <span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>]</span><span class=kd>interface</span><span class=p>{}</span> 
</span></span><span class=line><span class=cl><span class=c1>// 常用于 engine.JSON() 时返回 json 数据
</span></span></span></code></pre></td></tr></table></div></div><h2 id=几个问题>几个问题<a hidden class=anchor aria-hidden=true href=#几个问题>#</a></h2><h3 id=gin-的-context-有什么作用和怎么用>Gin 的 context 有什么作用和怎么用?<a hidden class=anchor aria-hidden=true href=#gin-的-context-有什么作用和怎么用>#</a></h3><p>context 是 Gin 代码请求流转的核心, 存储处理请求的所有必须参数</p><p>基本的使用方法:</p><ol><li>需要知道如何获取参数 &ndash; <code>Bind</code> 或者 <code>Param</code> 方法</li><li>控制处理函数流程 &ndash; <code>Next</code> 或者 <code>Abort</code> 方法</li><li>返回结果 &ndash; <code>JSON</code></li></ol><h3 id=gin-的整体框架流程是怎么样的-从接受到一个请求再到返回请求中间的流程>Gin 的整体框架流程是怎么样的? 从接受到一个请求再到返回请求中间的流程?<a hidden class=anchor aria-hidden=true href=#gin-的整体框架流程是怎么样的-从接受到一个请求再到返回请求中间的流程>#</a></h3><p>请求的注册入口, <code>Engine.ServeHTTP</code></p><p>整体流程</p><ol><li>存储路由路径和注册的处理函数到"路由树" &ndash; <code>nodetree</code></li><li>接收请求</li><li>根据接收到的请求地址, 从路由树中取出注册的函数, 组成<code>HandlerChain</code> 函数处理链</li><li>把函数处理链赋值到<code>gin.Context</code>中</li><li>由<code>gin.Context</code>开始依次调用注册处理函数, 所以函数遍历完成, 处理结束</li><li>通过<code>gin.Context.Writer</code>写入http请求结果</li><li>请求结束</li></ol></div><footer class=post-footer><ul class=post-tags><li><a href=https://ynikl.github.io/tags/golang/>Golang</a></li></ul><nav class=paginav><a class=prev href=https://ynikl.github.io/books/the-power-of-habit/><span class=title>« Prev Page</span><br><span>The Power of Habit</span>
</a><a class=next href=https://ynikl.github.io/blog/mysql-quick-backup-data/><span class=title>Next Page »</span><br><span>Mysql 快速备份数据</span></a></nav></footer><script src=https://utteranc.es/client.js repo=ynikl/ynikl.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>2022 Ian Lin All rights reserved</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>