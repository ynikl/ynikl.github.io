<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>go 使用 runtime 包进行内存占用分析 | 潜水员的咖啡小屋</title>
<meta name=keywords content="golang"><meta name=description content="使用场景 写个demo, 想查看一下程序内部的内存占用情况.
使用方法 主角 runtime 包
对象 MemStats 方法 ReadMemStats demo 展示
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(&amp;m) // For info on each, see: https://golang."><meta name=author content="潜水员"><link rel=canonical href=https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.5b9ae0304f93db6cc493f51846f012428af399c614b4f2fbdb7fa59dd4d5ef5b.js integrity="sha256-W5rgME+T22zEk/UYRvASQorzmcYUtPL723+lndTV71s=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-35FCVN7C8X"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-35FCVN7C8X",{anonymize_ip:!1})}</script><meta property="og:title" content="go 使用 runtime 包进行内存占用分析"><meta property="og:description" content="使用场景 写个demo, 想查看一下程序内部的内存占用情况.
使用方法 主角 runtime 包
对象 MemStats 方法 ReadMemStats demo 展示
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(&amp;m) // For info on each, see: https://golang."><meta property="og:type" content="article"><meta property="og:url" content="https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/"><meta property="og:image" content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-11-18T19:27:35+08:00"><meta property="article:modified_time" content="2022-11-18T19:27:35+08:00"><meta property="og:site_name" content="潜水员的咖啡小屋"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="go 使用 runtime 包进行内存占用分析"><meta name=twitter:description content="使用场景 写个demo, 想查看一下程序内部的内存占用情况.
使用方法 主角 runtime 包
对象 MemStats 方法 ReadMemStats demo 展示
1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(&amp;m) // For info on each, see: https://golang."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://ynikl.github.io/blog/"},{"@type":"ListItem","position":2,"name":"go 使用 runtime 包进行内存占用分析","item":"https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"go 使用 runtime 包进行内存占用分析","name":"go 使用 runtime 包进行内存占用分析","description":"使用场景 写个demo, 想查看一下程序内部的内存占用情况.\n使用方法 主角 runtime 包\n对象 MemStats 方法 ReadMemStats demo 展示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(\u0026amp;m) // For info on each, see: https://golang.","keywords":["golang"],"articleBody":"使用场景 写个demo, 想查看一下程序内部的内存占用情况.\n使用方法 主角 runtime 包\n对象 MemStats 方法 ReadMemStats demo 展示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 // PrintMemUsage outputs the current, total and OS memory being used. As well as the number // of garage collection cycles completed. func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(\u0026m) // For info on each, see: https://golang.org/pkg/runtime/#MemStats fmt.Printf(\"Alloc = %v MiB\", bToMb(m.Alloc)) fmt.Printf(\"\\tTotalAlloc = %v MiB\", bToMb(m.TotalAlloc)) fmt.Printf(\"\\tSys = %v MiB\", bToMb(m.Sys)) fmt.Printf(\"\\tNumGC = %v\\n\", m.NumGC) } 代码出处\n解释 ReadMemStats runtime.ReadMemStats 方法会读取到内存分配器的当前时刻最新的内存分配数据, 并将 其填充到传入参数的MemStats 的变量中.\n可以充当一个内存快照, 用于进行对比.\nMemStats 字段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 type MemStats struct { // 当前堆上对象的内存分配大小, 同HeapAlloc字段, 单位 bytes Alloc uint64 // 历史总的累计分配内存大小 TotalAlloc uint64 // 从操作系统分配的内存大小 Sys uint64 // 记录指针索引性能, go 语言内部使用 Lookups uint64 // 堆上分配的对象数量 Mallocs uint64 // 堆上剩余的内存大小 Frees uint64 HeapAlloc uint64 // 从操作系统分配的 堆 内存大小 HeapSys uint64 // 未使用的空闲内存分片大小 spans HeapIdle uint64 // 使用中的内存分片大小 HeapInuse uint64 // 回退的内存大小 HeapReleased uint64 // 堆上分配的对象数量 HeapObjects uint64 // 栈上使用的内存片大小 StackInuse uint64 // 从操作系统分配的栈的内存大小 StackSys uint64 // MSpanInuse is bytes of allocated mspan structures. MSpanInuse uint64 // MSpanSys is bytes of memory obtained from the OS for mspan // structures. MSpanSys uint64 // MCacheInuse is bytes of allocated mcache structures. MCacheInuse uint64 // MCacheSys is bytes of memory obtained from the OS for // mcache structures. MCacheSys uint64 // BuckHashSys is bytes of memory in profiling bucket hash tables. BuckHashSys uint64 // GCSys is bytes of memory in garbage collection metadata. GCSys uint64 // OtherSys is bytes of memory in miscellaneous off-heap // runtime allocations. OtherSys uint64 // 在多大的堆内存时, 触发GC NextGC uint64 // 上次GC 时间 LastGC uint64 // PauseTotalNs is the cumulative nanoseconds in GC // stop-the-world pauses since the program started. // // During a stop-the-world pause, all goroutines are paused // and only the garbage collector can run. PauseTotalNs uint64 // PauseNs is a circular buffer of recent GC stop-the-world // pause times in nanoseconds. // // The most recent pause is at PauseNs[(NumGC+255)%256]. In // general, PauseNs[N%256] records the time paused in the most // recent N%256th GC cycle. There may be multiple pauses per // GC cycle; this is the sum of all pauses during a cycle. PauseNs [256]uint64 // PauseEnd is a circular buffer of recent GC pause end times, // as nanoseconds since 1970 (the UNIX epoch). // // This buffer is filled the same way as PauseNs. There may be // multiple pauses per GC cycle; this records the end of the // last pause in a cycle. PauseEnd [256]uint64 // GC 次数 NumGC uint32 // 手动调用 GC 的次数 NumForcedGC uint32 // GC 使用的 CPU 时间 GCCPUFraction float64 // 可以GC,一直是true EnableGC bool // BySize reports per-size class allocation statistics. // // BySize[N] gives statistics for allocations of size S where // BySize[N-1].Size \u003c S ≤ BySize[N].Size. // // This does not report allocations larger than BySize[60].Size. BySize [61]struct { // Size is the maximum byte size of an object in this // size class. Size uint32 // Mallocs is the cumulative count of heap objects // allocated in this size class. The cumulative bytes // of allocation is Size*Mallocs. The number of live // objects in this size class is Mallocs - Frees. Mallocs uint64 // Frees is the cumulative count of heap objects freed // in this size class. Frees uint64 } } 源码出处\n我用于分析 map 的 delete 操作占用内存 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 package main import ( \"fmt\" \"runtime\" ) func main() { m := make(map[string][]int) m[\"a\"] = make([]int, 1*1024*1024*1024) PrintMemUsage() delete(m, \"a\") runtime.GC() PrintMemUsage() fmt.Println(\"make storage value\") mint := make(map[int]int, 1\u003c\u003c30) for i := 0; i \u003c 1*1024*2; i++ { mint[i] = 1024 } PrintMemUsage() runtime.GC() PrintMemUsage() // 注意: 需要引用, 避免被提前回收 fmt.Println(len(m), len(mint)) // go run main.go // Outpu: // // Alloc = 8192 MiB\tTotalAlloc = 8192 MiB\tSys = 8464 MiB\tNumGC = 0 // Alloc = 0 MiB\tTotalAlloc = 8192 MiB\tSys = 8465 MiB\tNumGC = 2 // make storage value // Alloc = 39168 MiB\tTotalAlloc = 47360 MiB\tSys = 48898 MiB\tNumGC = 3 // Alloc = 39168 MiB\tTotalAlloc = 47360 MiB\tSys = 48898 MiB\tNumGC = 4 // 0 2048 } func PrintMemUsage() { bToMb := func(b uint64) uint64 { return b / 1024 / 1024 } var m runtime.MemStats runtime.ReadMemStats(\u0026m) // For info on each, see: https://golang.org/pkg/runtime/#MemStats fmt.Printf(\"Alloc = %v MiB\", bToMb(m.Alloc)) fmt.Printf(\"\\tTotalAlloc = %v MiB\", bToMb(m.TotalAlloc)) fmt.Printf(\"\\tSys = %v MiB\", bToMb(m.Sys)) fmt.Printf(\"\\tNumGC = %v\\n\", m.NumGC) } 分析结果得出, 如果在 map 中存储的 value, 如果是引用值的话, 占用的内存是被 GC 回收 的. 但是, 如果是值类型如简单的int是不会被回收的.\n","wordCount":"937","inLanguage":"en","datePublished":"2022-11-18T19:27:35+08:00","dateModified":"2022-11-18T19:27:35+08:00","author":{"@type":"Person","name":"潜水员"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ynikl.github.io/blog/golang-memory-analyze-with-runtime/"},"publisher":{"@type":"Organization","name":"潜水员的咖啡小屋","logo":{"@type":"ImageObject","url":"https://ynikl.github.io/apple-touch-icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ynikl.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ynikl.github.io/apple-touch-icon_hu580d61a4745e72e64f2a76fb3eea3190_18715_0x35_resize_box_3.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ynikl.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://ynikl.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://ynikl.github.io/books/ title=books><span>books</span></a></li><li><a href=https://ynikl.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://ynikl.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ynikl.github.io/me/ title=me?><span>me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ynikl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ynikl.github.io/blog/>Blogs</a></div><h1 class=post-title>go 使用 runtime 包进行内存占用分析</h1><div class=post-meta>&lt;span title='2022-11-18 19:27:35 +0800 +0800'>November 18, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;5 min&amp;nbsp;·&amp;nbsp;潜水员&nbsp;|&nbsp;<a href=https://github.com/ynikl/ynikl.github.io/tree/main/content/blog/golang-memory-analyze-with-runtime.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h3 id=使用场景>使用场景<a hidden class=anchor aria-hidden=true href=#使用场景>#</a></h3><p>写个demo, 想查看一下程序内部的内存占用情况.</p><h3 id=使用方法>使用方法<a hidden class=anchor aria-hidden=true href=#使用方法>#</a></h3><p>主角 runtime 包</p><ul><li>对象 <code>MemStats</code></li><li>方法 <code>ReadMemStats</code></li></ul><p>demo 展示</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=c1>// PrintMemUsage outputs the current, total and OS memory being used. As well as the number 
</span></span></span><span class=line><span class=cl><span class=c1>// of garage collection cycles completed.
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kd>func</span> <span class=nf>PrintMemUsage</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>bToMb</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>b</span> <span class=kt>uint64</span><span class=p>)</span> <span class=kt>uint64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>b</span> <span class=o>/</span> <span class=mi>1024</span> <span class=o>/</span> <span class=mi>1024</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>m</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>MemStats</span>
</span></span><span class=line><span class=cl>	<span class=nx>runtime</span><span class=p>.</span><span class=nf>ReadMemStats</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// For info on each, see: https://golang.org/pkg/runtime/#MemStats
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Alloc = %v MiB&#34;</span><span class=p>,</span> <span class=nf>bToMb</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>Alloc</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;\tTotalAlloc = %v MiB&#34;</span><span class=p>,</span> <span class=nf>bToMb</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>TotalAlloc</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;\tSys = %v MiB&#34;</span><span class=p>,</span> <span class=nf>bToMb</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>Sys</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;\tNumGC = %v\n&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>NumGC</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><a href=https://gist.github.com/j33ty/79e8b736141be19687f565ea4c6f4226>代码出处</a></p><h3 id=解释>解释<a hidden class=anchor aria-hidden=true href=#解释>#</a></h3><h4 id=readmemstats>ReadMemStats<a hidden class=anchor aria-hidden=true href=#readmemstats>#</a></h4><p><code>runtime.ReadMemStats</code> 方法会读取到内存分配器的当前时刻最新的内存分配数据, 并将
其填充到传入参数的<code>MemStats</code> 的变量中.</p><p>可以充当一个内存快照, 用于进行对比.</p><h4 id=memstats-字段>MemStats 字段<a hidden class=anchor aria-hidden=true href=#memstats-字段>#</a></h4><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>  1
</span><span class=lnt>  2
</span><span class=lnt>  3
</span><span class=lnt>  4
</span><span class=lnt>  5
</span><span class=lnt>  6
</span><span class=lnt>  7
</span><span class=lnt>  8
</span><span class=lnt>  9
</span><span class=lnt> 10
</span><span class=lnt> 11
</span><span class=lnt> 12
</span><span class=lnt> 13
</span><span class=lnt> 14
</span><span class=lnt> 15
</span><span class=lnt> 16
</span><span class=lnt> 17
</span><span class=lnt> 18
</span><span class=lnt> 19
</span><span class=lnt> 20
</span><span class=lnt> 21
</span><span class=lnt> 22
</span><span class=lnt> 23
</span><span class=lnt> 24
</span><span class=lnt> 25
</span><span class=lnt> 26
</span><span class=lnt> 27
</span><span class=lnt> 28
</span><span class=lnt> 29
</span><span class=lnt> 30
</span><span class=lnt> 31
</span><span class=lnt> 32
</span><span class=lnt> 33
</span><span class=lnt> 34
</span><span class=lnt> 35
</span><span class=lnt> 36
</span><span class=lnt> 37
</span><span class=lnt> 38
</span><span class=lnt> 39
</span><span class=lnt> 40
</span><span class=lnt> 41
</span><span class=lnt> 42
</span><span class=lnt> 43
</span><span class=lnt> 44
</span><span class=lnt> 45
</span><span class=lnt> 46
</span><span class=lnt> 47
</span><span class=lnt> 48
</span><span class=lnt> 49
</span><span class=lnt> 50
</span><span class=lnt> 51
</span><span class=lnt> 52
</span><span class=lnt> 53
</span><span class=lnt> 54
</span><span class=lnt> 55
</span><span class=lnt> 56
</span><span class=lnt> 57
</span><span class=lnt> 58
</span><span class=lnt> 59
</span><span class=lnt> 60
</span><span class=lnt> 61
</span><span class=lnt> 62
</span><span class=lnt> 63
</span><span class=lnt> 64
</span><span class=lnt> 65
</span><span class=lnt> 66
</span><span class=lnt> 67
</span><span class=lnt> 68
</span><span class=lnt> 69
</span><span class=lnt> 70
</span><span class=lnt> 71
</span><span class=lnt> 72
</span><span class=lnt> 73
</span><span class=lnt> 74
</span><span class=lnt> 75
</span><span class=lnt> 76
</span><span class=lnt> 77
</span><span class=lnt> 78
</span><span class=lnt> 79
</span><span class=lnt> 80
</span><span class=lnt> 81
</span><span class=lnt> 82
</span><span class=lnt> 83
</span><span class=lnt> 84
</span><span class=lnt> 85
</span><span class=lnt> 86
</span><span class=lnt> 87
</span><span class=lnt> 88
</span><span class=lnt> 89
</span><span class=lnt> 90
</span><span class=lnt> 91
</span><span class=lnt> 92
</span><span class=lnt> 93
</span><span class=lnt> 94
</span><span class=lnt> 95
</span><span class=lnt> 96
</span><span class=lnt> 97
</span><span class=lnt> 98
</span><span class=lnt> 99
</span><span class=lnt>100
</span><span class=lnt>101
</span><span class=lnt>102
</span><span class=lnt>103
</span><span class=lnt>104
</span><span class=lnt>105
</span><span class=lnt>106
</span><span class=lnt>107
</span><span class=lnt>108
</span><span class=lnt>109
</span><span class=lnt>110
</span><span class=lnt>111
</span><span class=lnt>112
</span><span class=lnt>113
</span><span class=lnt>114
</span><span class=lnt>115
</span><span class=lnt>116
</span><span class=lnt>117
</span><span class=lnt>118
</span><span class=lnt>119
</span><span class=lnt>120
</span><span class=lnt>121
</span><span class=lnt>122
</span><span class=lnt>123
</span><span class=lnt>124
</span><span class=lnt>125
</span><span class=lnt>126
</span><span class=lnt>127
</span><span class=lnt>128
</span><span class=lnt>129
</span><span class=lnt>130
</span><span class=lnt>131
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>type</span> <span class=nx>MemStats</span> <span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 当前堆上对象的内存分配大小, 同HeapAlloc字段, 单位 bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Alloc</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 历史总的累计分配内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>TotalAlloc</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 从操作系统分配的内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Sys</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 记录指针索引性能, go 语言内部使用
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Lookups</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 堆上分配的对象数量
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Mallocs</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 堆上剩余的内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>Frees</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>HeapAlloc</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 从操作系统分配的 堆 内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>HeapSys</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 未使用的空闲内存分片大小 spans
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>HeapIdle</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 使用中的内存分片大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>HeapInuse</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 回退的内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>HeapReleased</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 堆上分配的对象数量
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>HeapObjects</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 栈上使用的内存片大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>StackInuse</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 从操作系统分配的栈的内存大小
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>StackSys</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// MSpanInuse is bytes of allocated mspan structures.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MSpanInuse</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// MSpanSys is bytes of memory obtained from the OS for mspan
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// structures.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MSpanSys</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// MCacheInuse is bytes of allocated mcache structures.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MCacheInuse</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// MCacheSys is bytes of memory obtained from the OS for
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// mcache structures.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>MCacheSys</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// BuckHashSys is bytes of memory in profiling bucket hash tables.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>BuckHashSys</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// GCSys is bytes of memory in garbage collection metadata.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>GCSys</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// OtherSys is bytes of memory in miscellaneous off-heap
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// runtime allocations.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>OtherSys</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 在多大的堆内存时, 触发GC
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>NextGC</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 上次GC 时间
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>LastGC</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// PauseTotalNs is the cumulative nanoseconds in GC
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// stop-the-world pauses since the program started.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// During a stop-the-world pause, all goroutines are paused
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// and only the garbage collector can run.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>PauseTotalNs</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// PauseNs is a circular buffer of recent GC stop-the-world
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// pause times in nanoseconds.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// The most recent pause is at PauseNs[(NumGC+255)%256]. In
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// general, PauseNs[N%256] records the time paused in the most
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// recent N%256th GC cycle. There may be multiple pauses per
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// GC cycle; this is the sum of all pauses during a cycle.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>PauseNs</span> <span class=p>[</span><span class=mi>256</span><span class=p>]</span><span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// PauseEnd is a circular buffer of recent GC pause end times,
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// as nanoseconds since 1970 (the UNIX epoch).
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// This buffer is filled the same way as PauseNs. There may be
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// multiple pauses per GC cycle; this records the end of the
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// last pause in a cycle.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>PauseEnd</span> <span class=p>[</span><span class=mi>256</span><span class=p>]</span><span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// GC 次数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>NumGC</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 手动调用 GC 的次数
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>NumForcedGC</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// GC 使用的 CPU 时间
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>GCCPUFraction</span> <span class=kt>float64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 可以GC,一直是true
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>EnableGC</span> <span class=kt>bool</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// BySize reports per-size class allocation statistics.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// BySize[N] gives statistics for allocations of size S where
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// BySize[N-1].Size &lt; S ≤ BySize[N].Size.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// This does not report allocations larger than BySize[60].Size.
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>BySize</span> <span class=p>[</span><span class=mi>61</span><span class=p>]</span><span class=kd>struct</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=c1>// Size is the maximum byte size of an object in this
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// size class.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>Size</span> <span class=kt>uint32</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Mallocs is the cumulative count of heap objects
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// allocated in this size class. The cumulative bytes
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// of allocation is Size*Mallocs. The number of live
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// objects in this size class is Mallocs - Frees.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>Mallocs</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>		<span class=c1>// Frees is the cumulative count of heap objects freed
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=c1>// in this size class.
</span></span></span><span class=line><span class=cl><span class=c1></span>		<span class=nx>Frees</span> <span class=kt>uint64</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><a href=https://pkg.go.dev/runtime#MemStats>源码出处</a></p><h3 id=我用于分析-map-的-delete-操作占用内存>我用于分析 map 的 delete 操作占用内存<a hidden class=anchor aria-hidden=true href=#我用于分析-map-的-delete-操作占用内存>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span><span class=lnt>35
</span><span class=lnt>36
</span><span class=lnt>37
</span><span class=lnt>38
</span><span class=lnt>39
</span><span class=lnt>40
</span><span class=lnt>41
</span><span class=lnt>42
</span><span class=lnt>43
</span><span class=lnt>44
</span><span class=lnt>45
</span><span class=lnt>46
</span><span class=lnt>47
</span><span class=lnt>48
</span><span class=lnt>49
</span><span class=lnt>50
</span><span class=lnt>51
</span><span class=lnt>52
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kn>package</span> <span class=nx>main</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kn>import</span> <span class=p>(</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;fmt&#34;</span>
</span></span><span class=line><span class=cl>	<span class=s>&#34;runtime&#34;</span>
</span></span><span class=line><span class=cl><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>m</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>string</span><span class=p>][]</span><span class=kt>int</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>m</span><span class=p>[</span><span class=s>&#34;a&#34;</span><span class=p>]</span> <span class=p>=</span> <span class=nb>make</span><span class=p>([]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=o>*</span><span class=mi>1024</span><span class=o>*</span><span class=mi>1024</span><span class=o>*</span><span class=mi>1024</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nf>PrintMemUsage</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nb>delete</span><span class=p>(</span><span class=nx>m</span><span class=p>,</span> <span class=s>&#34;a&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>runtime</span><span class=p>.</span><span class=nf>GC</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>PrintMemUsage</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=s>&#34;make storage value&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=nx>mint</span> <span class=o>:=</span> <span class=nb>make</span><span class=p>(</span><span class=kd>map</span><span class=p>[</span><span class=kt>int</span><span class=p>]</span><span class=kt>int</span><span class=p>,</span> <span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>30</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>for</span> <span class=nx>i</span> <span class=o>:=</span> <span class=mi>0</span><span class=p>;</span> <span class=nx>i</span> <span class=p>&lt;</span> <span class=mi>1</span><span class=o>*</span><span class=mi>1024</span><span class=o>*</span><span class=mi>2</span><span class=p>;</span> <span class=nx>i</span><span class=o>++</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=nx>mint</span><span class=p>[</span><span class=nx>i</span><span class=p>]</span> <span class=p>=</span> <span class=mi>1024</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=nf>PrintMemUsage</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>runtime</span><span class=p>.</span><span class=nf>GC</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nf>PrintMemUsage</span><span class=p>()</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// 注意: 需要引用, 避免被提前回收
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Println</span><span class=p>(</span><span class=nb>len</span><span class=p>(</span><span class=nx>m</span><span class=p>),</span> <span class=nb>len</span><span class=p>(</span><span class=nx>mint</span><span class=p>))</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	<span class=c1>// go run main.go
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Outpu:
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>//
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Alloc = 8192 MiB	TotalAlloc = 8192 MiB	Sys = 8464 MiB	NumGC = 0
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Alloc = 0 MiB	TotalAlloc = 8192 MiB	Sys = 8465 MiB	NumGC = 2
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// make storage value
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Alloc = 39168 MiB	TotalAlloc = 47360 MiB	Sys = 48898 MiB	NumGC = 3
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// Alloc = 39168 MiB	TotalAlloc = 47360 MiB	Sys = 48898 MiB	NumGC = 4
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=c1>// 0 2048
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=p>}</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>func</span> <span class=nf>PrintMemUsage</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>bToMb</span> <span class=o>:=</span> <span class=kd>func</span><span class=p>(</span><span class=nx>b</span> <span class=kt>uint64</span><span class=p>)</span> <span class=kt>uint64</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>		<span class=k>return</span> <span class=nx>b</span> <span class=o>/</span> <span class=mi>1024</span> <span class=o>/</span> <span class=mi>1024</span>
</span></span><span class=line><span class=cl>	<span class=p>}</span>
</span></span><span class=line><span class=cl>	<span class=kd>var</span> <span class=nx>m</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>MemStats</span>
</span></span><span class=line><span class=cl>	<span class=nx>runtime</span><span class=p>.</span><span class=nf>ReadMemStats</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>m</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=c1>// For info on each, see: https://golang.org/pkg/runtime/#MemStats
</span></span></span><span class=line><span class=cl><span class=c1></span>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;Alloc = %v MiB&#34;</span><span class=p>,</span> <span class=nf>bToMb</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>Alloc</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;\tTotalAlloc = %v MiB&#34;</span><span class=p>,</span> <span class=nf>bToMb</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>TotalAlloc</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;\tSys = %v MiB&#34;</span><span class=p>,</span> <span class=nf>bToMb</span><span class=p>(</span><span class=nx>m</span><span class=p>.</span><span class=nx>Sys</span><span class=p>))</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;\tNumGC = %v\n&#34;</span><span class=p>,</span> <span class=nx>m</span><span class=p>.</span><span class=nx>NumGC</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>分析结果得出, 如果在 map 中存储的 value, 如果是引用值的话, 占用的内存是被 GC 回收
的. 但是, 如果是值类型如简单的<code>int</code>是不会被回收的.</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ynikl.github.io/tags/golang/>golang</a></li></ul><nav class=paginav><a class=prev href=https://ynikl.github.io/books/ein-hund-namens-money/><span class=title>« Prev Page</span><br><span>小狗钱钱</span>
</a><a class=next href=https://ynikl.github.io/books/asking-the-right-questions/><span class=title>Next Page »</span><br><span>Asking the Right Questions</span></a></nav></footer><script src=https://utteranc.es/client.js repo=ynikl/ynikl.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>2022 Ian Lin All rights reserved</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>