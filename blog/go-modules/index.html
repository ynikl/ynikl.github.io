<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>小窥 Go 中的 Modules | 潜水员的咖啡小屋</title>
<meta name=keywords content="golang"><meta name=description content="是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 > cat go."><meta name=author content="潜水员"><link rel=canonical href=https://ynikl.github.io/blog/go-modules/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.5b9ae0304f93db6cc493f51846f012428af399c614b4f2fbdb7fa59dd4d5ef5b.js integrity="sha256-W5rgME+T22zEk/UYRvASQorzmcYUtPL723+lndTV71s=" onload=hljs.initHighlightingOnLoad()></script><link rel=icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-35FCVN7C8X"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-35FCVN7C8X",{anonymize_ip:!1})}</script><meta property="og:title" content="小窥 Go 中的 Modules"><meta property="og:description" content="是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 > cat go."><meta property="og:type" content="article"><meta property="og:url" content="https://ynikl.github.io/blog/go-modules/"><meta property="og:image" content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-06-03T18:16:55+08:00"><meta property="article:modified_time" content="2022-06-03T18:16:55+08:00"><meta property="og:site_name" content="潜水员的咖啡小屋"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="小窥 Go 中的 Modules"><meta name=twitter:description content="是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 => example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 > cat go."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://ynikl.github.io/blog/"},{"@type":"ListItem","position":2,"name":"小窥 Go 中的 Modules","item":"https://ynikl.github.io/blog/go-modules/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"小窥 Go 中的 Modules","name":"小窥 Go 中的 Modules","description":"是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。\n在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。\n模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。\ngo.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =\u0026gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思\nmodule 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据\ngo.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。\n1 2 3 \u0026gt; cat go.","keywords":["golang"],"articleBody":"是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。\n在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。\n模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。\ngo.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =\u003e example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思\nmodule 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据\ngo.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。\n1 2 3 \u003e cat go.sum example.com/mod v1.0.0 h1:6Cz1EhbAk54HWaw6fhCpSPxWGjIMLuF9MlO4Ou568sQ= example.com/mod v1.0.0/go.mod h1:mgm3p5SY7FVOgVLVSXIYK9qk0umwLQLOG06xLpFUeTI= 文件中以：模块路径 + 版本号 + hash算法名 + hash值 的组合写入\nexample.com/mod 是模块路径名 v1.0.0 是版本号，在第二行有是以/go.mod结尾，代表该 hash 值是对依赖模块本身的go.mod文件的 hash 值 h1: 代表使用的 hash 算法，代表 SHA-256 哈希值，没什么好说的了 Module cache 本地的目录，用户存放下载下来的的模块文件。\n默认路径是在$GOPAth/pkg/mod\nModule cache 文件夹详细说明\n语义化版本 go 采用语义化版本 v1.18.1\n一个模块的版本是不变的 —— 只要拉过一次模块，该模块就会存在缓存在Go 官方的模块服务中，以后拉取改模块就会从官方的模块服务拉取，且该动作不可逆。\n版本号 = “v” + 主版本号 + 小版本号 + 补丁号\n主版本号的增加后，小版本号和补丁号要重新置零。主版本号增加，代表该版本出现不向后兼容的改动。比如移除旧的包 小版本号增加后，补丁号重新置零。表示版本改动公共接口但是向后兼容的，比如增加一个函数 补丁号增加，表示该版本对公开接口没有改动。比如修改bug 版本的后面可能还会增加一些提前发布的标识，比如 v1.18.1-beta v1.18.1-pre\n当 go 的 模块没有声明发布版本的时候(比如拉取某分支做为模块)，go 就会自己生成 伪版本, 可以仅作了解。\n如果使用模块的版本号大于等于v2的时候，需要在引入包的后缀加上/v2\n1 import \"github.com/urfave/cli/v2\" 怎么用 开启模块功能 模块功能的开启, 配置在环境变量GO111MODULE\n=off, 忽略GOPATH路径下的go.mod文件，直接引用GOPATH/src中的包文件 =on，启用模块功能 =auto, 如果项目有go.mod文件启用，没有则是用GOPATH模式 常用命令快览 go mod\n1 go mod init example.com/example/m1 初始化当前文件夹，让其成为一个 module\ngo get\n1 go get -d example.com/example/m1@v1.2.3 主要用法:修改当前项目的go.mod，引入新的依赖项目。\n-d 的标志，表示获取目标包之后，不进行本地编译或安装。Go 1.18 之后的默认行为。\n1 go get -d -u example.com/example/m1 也可以用来升级依赖模块的版本，升级到最新版本。如果目标模块的新版的所依赖的其他模块也可能会一并升级。也可以指定版本-u=patch\n修改制定依赖版本的操作也可以通过制定后缀版本号实现\n1 go get example.com/example/m1@v2.3.1 go mod edit\n通过指令修改go.mod文件，与直接修改go.mod效果一致\n1 go mod edit -replace example.com/a@v1.0.0=./a 将某个模块引用指向本地。可以用来解决引用正在开发中，还没有发布过的模块\ngo mod tidy\n根据项目的源码引用整理go.mod中的引用情况。添加缺少的依赖，或者移除冗余的依赖。\ngo mod vendor\n将依赖一并放在自己项目的中，可以省去自己拉取依赖的很多麻烦，提高可用性。go 项目的根目录中的 vendor 文件夹就是用来干这个事的\n将项目依赖移入vendor文件中，当存在了vendor文件夹，项目会使用vendor中的依赖。大于 1.14 版本需要指定参数-mod=vendor才会启用\n本地修改之后模块版本之后需要，重新使用go mod vendor将新的依赖模块同步入vendor中。\ngo mod verify\n用于检测模块再被下载之后入，模块中的代码是否有被修改过。\n对源码文件的 hash，与当前文件的go.sum中的 hash 对比校验是否有被修改过。 如果go.sum中没有该模块的hash值，就会从checksum database 中获取目标 hash 值。（除非设置了GOPRIVATE或者GONOSUMDB)\n1 2 ❯ go mod verify github.com/ynikl/playmod v1.0.0: dir has been modified (/Users/ian/go/pkg/mod/github.com/ynikl/playmod@v1.0.0) 上述例子，源文件被我手动强制修改过，就会报错\ngo mod why\n1 go mod why example.com/mod 用于解释当前项目为什么会依赖某一个模块，输出项目对目标模块的依赖树图\ngo list -m all\n可以用于输出当前项目依赖的所有模块\nMVS Minimal version selection（MVS), 当引入的不同模块，又存在依赖与相同模块的（相同大版本，不同版本小版本）的时候。\n在使用模块相关命令的时候，会选择所依赖的不同版本的中，构建项目所需要从最小版本。\nA.12 与 B1.2 分别需要 C1.3 和 C1.4 为了是项目能正常进行，需要使用 C1.4 版本\n参考 官网Go Modules参考 Minimal Version Seletion 官方介绍 Modules 博文 提议 ","wordCount":"281","inLanguage":"en","datePublished":"2022-06-03T18:16:55+08:00","dateModified":"2022-06-03T18:16:55+08:00","author":{"@type":"Person","name":"潜水员"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ynikl.github.io/blog/go-modules/"},"publisher":{"@type":"Organization","name":"潜水员的咖啡小屋","logo":{"@type":"ImageObject","url":"https://ynikl.github.io/apple-touch-icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ynikl.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ynikl.github.io/apple-touch-icon_hu580d61a4745e72e64f2a76fb3eea3190_18715_0x35_resize_box_3.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ynikl.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://ynikl.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://ynikl.github.io/books/ title=books><span>books</span></a></li><li><a href=https://ynikl.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://ynikl.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ynikl.github.io/me/ title=me?><span>me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ynikl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ynikl.github.io/blog/>Blogs</a></div><h1 class=post-title>小窥 Go 中的 Modules</h1><div class=post-meta>&lt;span title='2022-06-03 18:16:55 +0800 +0800'>June 3, 2022&lt;/span>&amp;nbsp;·&amp;nbsp;2 min&amp;nbsp;·&amp;nbsp;潜水员&nbsp;|&nbsp;<a href=https://github.com/ynikl/ynikl.github.io/tree/main/content/blog/go-modules/index.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=是什么>是什么<a hidden class=anchor aria-hidden=true href=#是什么>#</a></h2><p>Modules （下文称为模块）是 Go 语言设计用来管理依赖包。</p><p>在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。</p><p>模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在<code>go.mod</code>文件中。</p><h3 id=gomod-文件>go.mod 文件<a hidden class=anchor aria-hidden=true href=#gomod-文件>#</a></h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>module example.com/my/thing
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>go 1.12
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>require example.com/other/thing v1.0.2
</span></span><span class=line><span class=cl>require example.com/new/thing/v2 v2.3.4
</span></span><span class=line><span class=cl>exclude example.com/old/thing v1.2.3
</span></span><span class=line><span class=cl>replace example.com/bad/thing v1.4.5 =&gt; example.com/good/thing v1.4.5
</span></span><span class=line><span class=cl>retract [v1.9.0, v1.9.5]
</span></span></code></pre></td></tr></table></div></div><p>文件中各行意思</p><ul><li>module 当前自己模块的名的完整路径</li><li>go 版本号</li><li>require 需要依赖的目标模块以及最小的版本号</li><li>exclude 排除目标模块的特定版本</li><li>replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块</li><li>retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况</li></ul><p><code>go.mod</code> 可以通过相关命令修改，也可以直接修改文件数据</p><h3 id=gosum-文件>go.sum 文件<a hidden class=anchor aria-hidden=true href=#gosum-文件>#</a></h3><p>与<code>go.mod</code>经常在一起的会是一个<code>go.sum</code>文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>&gt; cat go.sum
</span></span><span class=line><span class=cl>example.com/mod v1.0.0 h1:6Cz1EhbAk54HWaw6fhCpSPxWGjIMLuF9MlO4Ou568sQ=
</span></span><span class=line><span class=cl>example.com/mod v1.0.0/go.mod h1:mgm3p5SY7FVOgVLVSXIYK9qk0umwLQLOG06xLpFUeTI=
</span></span></code></pre></td></tr></table></div></div><p>文件中以：模块路径 + 版本号 + hash算法名 + hash值 的组合写入</p><ul><li><code>example.com/mod</code> 是模块路径名</li><li>v1.0.0 是版本号，在第二行有是以<code>/go.mod</code>结尾，代表该 hash 值是对依赖模块本身的<code>go.mod</code>文件的 hash 值</li><li>h1: 代表使用的 hash 算法，代表 SHA-256</li><li>哈希值，没什么好说的了</li></ul><h3 id=module-cache>Module cache<a hidden class=anchor aria-hidden=true href=#module-cache>#</a></h3><p>本地的目录，用户存放下载下来的的模块文件。</p><p>默认路径是在<code>$GOPAth/pkg/mod</code></p><p><a href=https://go.dev/ref/mod#module-cache>Module cache 文件夹详细说明</a></p><h3 id=语义化版本>语义化版本<a hidden class=anchor aria-hidden=true href=#语义化版本>#</a></h3><p>go 采用语义化版本 v1.18.1</p><p>一个模块的版本是不变的 —— 只要拉过一次模块，该模块就会存在缓存在<a href=https://proxy.golang.org/>Go 官方的模块服务</a>中，以后拉取改模块就会从官方的模块服务拉取，且该动作不可逆。</p><p>版本号 = &ldquo;v&rdquo; + 主版本号 + 小版本号 + 补丁号</p><ul><li>主版本号的增加后，小版本号和补丁号要重新置零。主版本号增加，代表该版本出现不向后兼容的改动。比如移除旧的包</li><li>小版本号增加后，补丁号重新置零。表示版本改动公共接口但是向后兼容的，比如增加一个函数</li><li>补丁号增加，表示该版本对公开接口没有改动。比如修改bug</li></ul><p>版本的后面可能还会增加一些提前发布的标识，比如 v1.18.1-beta v1.18.1-pre</p><p>当 go 的 模块没有声明发布版本的时候(比如拉取某分支做为模块)，go 就会自己生成 <a href=https://go.dev/ref/mod#pseudo-versions>伪版本</a>, 可以仅作了解。</p><p><strong>如果使用模块的版本号大于等于v2的时候，需要在引入包的后缀加上<code>/v2</code></strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>import &#34;github.com/urfave/cli/v2&#34;
</span></span></code></pre></td></tr></table></div></div><h2 id=怎么用>怎么用<a hidden class=anchor aria-hidden=true href=#怎么用>#</a></h2><h3 id=开启模块功能>开启模块功能<a hidden class=anchor aria-hidden=true href=#开启模块功能>#</a></h3><p>模块功能的开启, 配置在环境变量<code>GO111MODULE</code></p><ul><li>=off, 忽略<code>GOPATH</code>路径下的<code>go.mod</code>文件，直接引用<code>GOPATH/src</code>中的包文件</li><li>=on，启用模块功能</li><li>=auto, 如果项目有<code>go.mod</code>文件启用，没有则是用<code>GOPATH</code>模式</li></ul><h3 id=常用命令快览>常用命令快览<a hidden class=anchor aria-hidden=true href=#常用命令快览>#</a></h3><p><strong>go mod</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>go mod init example.com/example/m1
</span></span></code></pre></td></tr></table></div></div><p>初始化当前文件夹，让其成为一个 module</p><p><strong>go get</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>go get -d example.com/example/m1@v1.2.3
</span></span></code></pre></td></tr></table></div></div><p>主要用法:修改当前项目的<code>go.mod</code>，引入新的依赖项目。</p><p><code>-d</code> 的标志，表示获取目标包之后，不进行本地编译或安装。Go 1.18 之后的默认行为。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>go get -d -u example.com/example/m1
</span></span></code></pre></td></tr></table></div></div><p>也可以用来升级依赖模块的版本，升级到最新版本。如果目标模块的新版的所依赖的其他模块也可能会一并升级。也可以指定版本<code>-u=patch</code></p><p>修改制定依赖版本的操作也可以通过制定后缀版本号实现</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>go get example.com/example/m1@v2.3.1
</span></span></code></pre></td></tr></table></div></div><p><strong>go mod edit</strong></p><p>通过指令修改<code>go.mod</code>文件，与直接修改<code>go.mod</code>效果一致</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>go mod edit -replace example.com/a@v1.0.0=./a
</span></span></code></pre></td></tr></table></div></div><p>将某个模块引用指向本地。可以用来解决引用正在开发中，还没有发布过的模块</p><p><strong>go mod tidy</strong></p><p>根据项目的源码引用整理<code>go.mod</code>中的引用情况。添加缺少的依赖，或者移除冗余的依赖。</p><p><strong>go mod vendor</strong></p><p>将依赖一并放在自己项目的中，可以省去自己拉取依赖的很多麻烦，提高可用性。go 项目的根目录中的 vendor 文件夹就是用来干这个事的</p><p>将项目依赖移入<code>vendor</code>文件中，当存在了vendor文件夹，项目会使用vendor中的依赖。大于 1.14 版本需要指定参数<code>-mod=vendor</code>才会启用</p><p>本地修改之后模块版本之后需要，重新使用<code>go mod vendor</code>将新的依赖模块同步入<code>vendor</code>中。</p><p><strong>go mod verify</strong></p><p>用于检测模块再被下载之后入，模块中的代码是否有被修改过。</p><p>对源码文件的 hash，与当前文件的<code>go.sum</code>中的 hash 对比校验是否有被修改过。
如果<code>go.sum</code>中没有该模块的hash值，就会从<a href=https://sum.golang.org>checksum database</a> 中获取目标 hash 值。（除非设置了<code>GOPRIVATE</code>或者<code>GONOSUMDB</code>)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>❯ go mod verify
</span></span><span class=line><span class=cl>github.com/ynikl/playmod v1.0.0: dir has been modified (/Users/ian/go/pkg/mod/github.com/ynikl/playmod@v1.0.0)
</span></span></code></pre></td></tr></table></div></div><p>上述例子，源文件被我手动强制修改过，就会报错</p><p><strong>go mod why</strong></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>go mod why example.com/mod
</span></span></code></pre></td></tr></table></div></div><p>用于解释当前项目为什么会依赖某一个模块，输出项目对目标模块的依赖树图</p><p><strong>go list -m all</strong></p><p>可以用于输出当前项目依赖的所有模块</p><h3 id=mvs>MVS<a hidden class=anchor aria-hidden=true href=#mvs>#</a></h3><p><em>Minimal version selection</em>（MVS), 当引入的不同模块，又存在依赖与相同模块的（相同大版本，不同版本小版本）的时候。</p><p>在使用模块相关命令的时候，会选择所依赖的不同版本的中，构建项目所需要从最小版本。</p><p><img loading=lazy src=mvs.png alt=图片来源于官网></p><p>A.12 与 B1.2 分别需要 C1.3 和 C1.4 为了是项目能正常进行，需要使用 C1.4 版本</p><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><ul><li><a href=https://go.dev/ref/mod>官网Go Modules参考</a></li><li><a href=https://research.swtch.com/vgo-mvs>Minimal Version Seletion</a></li><li><a href=https://go.dev/blog/modules2019>官方介绍 Modules 博文</a></li><li><a href=https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#checksum-database>提议</a></li></ul></div><footer class=post-footer><ul class=post-tags><li><a href=https://ynikl.github.io/tags/golang/>golang</a></li></ul><nav class=paginav><a class=prev href=https://ynikl.github.io/blog/endianness/><span class=title>« Prev Page</span><br><span>计算机中的：大端和小端</span>
</a><a class=next href=https://ynikl.github.io/blog/mysql-nested-transactions/><span class=title>Next Page »</span><br><span>Mysql 不支持事务嵌套</span></a></nav></footer><script src=https://utteranc.es/client.js repo=ynikl/ynikl.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>2022 Ian Lin All rights reserved</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>