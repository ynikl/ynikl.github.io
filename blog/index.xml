<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Blogs on 潜水员的咖啡小屋</title>
    <link>https://ynikl.github.io/blog/</link>
    <description>Recent content in Blogs on 潜水员的咖啡小屋</description>
    <image>
      <url>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <managingEditor>gilfoyle.k@outlook.com (潜水员)</managingEditor>
    <webMaster>gilfoyle.k@outlook.com (潜水员)</webMaster>
    <copyright>2022 Ian Lin All rights reserved</copyright>
    <lastBuildDate>Fri, 19 Aug 2022 00:14:54 +0800</lastBuildDate><atom:link href="https://ynikl.github.io/blog/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>FFmpeg 基本使用</title>
      <link>https://ynikl.github.io/blog/ffmpeg-basics/</link>
      <pubDate>Fri, 19 Aug 2022 00:14:54 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/ffmpeg-basics/</guid>
      <description>最近接手公司一个视频相关项目, 也是使用ffmpeg工具. 需要快速了解下.
概念 码率, 帧率, 文件大小 帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.
interlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i progressive: 现代整页整页呈现, 描述单位p: 60p 码率(bit rate) :视频一秒中有多少位, 决定视频的质量
ABR: 平均码率 CBR: 常量码率 VBR: 动态码率 文件大小 = 视频文件 + 音频文件
视频文件 = 码率 * 时间(s) / 8 音频文件 = 码率 * 时间(s) / 8
文件格式 不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers) 可以存储声音或者视频数据.
相关缩写 encoding (E) decoding (D) video (V) audio (A) subtitles (S) 文件元数据 metadata 描述媒体文件自身的信息, 比如:</description>
      <content:encoded><![CDATA[<p>最近接手公司一个视频相关项目, 也是使用<code>ffmpeg</code>工具.  需要快速了解下.</p>
<h2 id="概念">概念</h2>
<h2 id="码率-帧率-文件大小">码率, 帧率, 文件大小</h2>
<p>帧率(frame rate) : 视频一秒中有多少帧画面(frames per second, fps), 决定视频流畅度.</p>
<ul>
<li>interlaced: 古代黑白相机的交错扫描呈现, 描述单位i : 50i</li>
<li>progressive: 现代整页整页呈现, 描述单位p: 60p</li>
</ul>
<p>码率(bit rate) :视频一秒中有多少位, 决定视频的质量</p>
<ul>
<li>ABR: 平均码率</li>
<li>CBR: 常量码率</li>
<li>VBR: 动态码率</li>
</ul>
<p>文件大小 = 视频文件 + 音频文件</p>
<p>视频文件 =  码率 * 时间(s) / 8
音频文件 =  码率 * 时间(s) / 8</p>
<h3 id="文件格式">文件格式</h3>
<p>不同的视频文件类型, 用户存储特定的数据流( 在 ffmpeg 中称为 containers)
可以存储声音或者视频数据.</p>
<h3 id="相关缩写">相关缩写</h3>
<ul>
<li>encoding (E)</li>
<li>decoding (D)</li>
<li>video (V)</li>
<li>audio (A)</li>
<li>subtitles (S)</li>
</ul>
<h3 id="文件元数据-metadata">文件元数据 metadata</h3>
<p>描述媒体文件自身的信息, 比如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Metadata:
</span></span><span class="line"><span class="cl">	publisher : Ninja Tune
</span></span><span class="line"><span class="cl">	track : 1
</span></span><span class="line"><span class="cl">	album : Ninja Tuna
</span></span><span class="line"><span class="cl">	artist : Mr. Scruff
</span></span><span class="line"><span class="cl">	album_artist : Mr. Scruff
</span></span><span class="line"><span class="cl">	title : Kalimba
</span></span><span class="line"><span class="cl">	genre : Electronic
</span></span><span class="line"><span class="cl">	composer : A. Carthy and A. Kingslow
</span></span><span class="line"><span class="cl">	date : 2008
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="声音">声音</h3>
<p>数字音频是通过对声音的模拟信息, 抽样且用数据信号表示.</p>
<p>音频使用 bit depths 来表示声音的解析度:</p>
<p>8bit, 12bit, 14bit &hellip;</p>
<p>声音的样本频率用 Hz 表示</p>
<p>8000Hz, 11025Hz, 16000Hz &hellip;</p>
<h3 id="ffmpeg-其他套件">FFmpeg 其他套件</h3>
<ul>
<li>ffplay 播放器</li>
<li>ffprobe 查看媒体文件的信息</li>
<li>ffserver 流服务器</li>
</ul>
<h2 id="使用">使用</h2>
<h3 id="通用参数">通用参数</h3>
<p><code>-i</code> 输入源, 可以是文件也可以是 url</p>
<p><code>-vf</code> option for video filters
<code>-af</code> option for audio filters.</p>
<p><code>-filter_complex</code> 当多个输入源的时候使用</p>
<p><code>-y</code> 输出文件会强制覆盖已经存在的文件</p>
<h3 id="帮助">帮助</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 查看支持格式
</span></span><span class="line"><span class="cl">ffmpeg -formats
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; 编解码器
</span></span><span class="line"><span class="cl">ffmpeg -codecs 
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="调整帧率">调整帧率</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.avi -r 30 output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="调整码率">调整码率</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.avi -b:v 1500k output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="缩放视频大小">缩放视频大小</h3>
<ul>
<li>s : w x h 参数 宽乘以高</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 缩小分辨率
</span></span><span class="line"><span class="cl">ffmpeg -i input.avi -s 640x480 output.avi
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; 扩大分辨率
</span></span><span class="line"><span class="cl">ffmpeg -i input.mpg -vf scale=iw/PHI:ih/PHI output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="旋转-翻转">旋转, 翻转</h3>
<p>旋转</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i CMYK.avi -vf transpose=2 CMYK_transposed.avi
</span></span></code></pre></td></tr></table>
</div>
</div><p>竖直翻转</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i meta.mp4 -vf vflip output_flip.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="裁切">裁切</h3>
<p>裁切视频的画中画, 裁切视频的中心 1/2 的视频</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.avi -vf crop=iw/2:ih/2 output.avi
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="模糊化">模糊化</h3>
<p>模糊化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.mpg -vf boxblur=1.5:1 output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><p>锐化</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input -vf unsharp output.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="叠加">叠加</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input1 -i input2 -filter_complex overlay=x:y output
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="裁剪">裁剪</h3>
<p>获取一个时间段内的音频
<code>-t</code> 参数为秒</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i input.mp4 -t 180 output_3_min.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>--ss</code> 设置开始时间点 ( seek from start, 从视频开始过多少秒开始操作)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 直接截断开头3分钟
</span></span><span class="line"><span class="cl">ffmpeg -i input.mp4 -ss 180 output_without_start_3.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>截取某一段时间视频</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34; 截取第4分钟, 一分钟视频
</span></span><span class="line"><span class="cl">ffmpeg -i input.mp4 -ss 180 -t 60 clip_4th_min.mp4
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="图片操作">图片操作</h3>
<p>从视频中截取某一帧</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i videoclip.avi -ss 01:23:45 image.jpg
</span></span></code></pre></td></tr></table>
</div>
</div><p>翻转图片</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i orange.jpg -vf hflip orange_hflip.jpg
</span></span><span class="line"><span class="cl">ffmpeg -i orange.jpg -vf vflip orange_vflip.jpg
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; transpose [0, 1, 2, 3]
</span></span><span class="line"><span class="cl">ffmpeg -i image.png -vf transpose=1 image_rotated.png
</span></span></code></pre></td></tr></table>
</div>
</div><p>转换图片格式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i illustration.png illustration.jpg
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="格式转化">格式转化</h3>
<p>格式转化流程:</p>
<p>Demuxer (分解复用) : 将合成信号恢复成原本独立的信号数据
Decoder (解码器) : 解码
Encoder (编码器) : 编码
Muxer ( _ ): 将多个信号数据合并</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -y -i input.avi output.mp4
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; 改变格式, 但不更改编解码方式
</span></span><span class="line"><span class="cl">ffmpeg -i input.avi -q 1 -c copy output.mov
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="混音">混音</h3>
<p>将两个声合成一个文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i demo.mp3 -i louder_sound.aac -filter_complex amix=inputs=2 sounds.wav
</span></span></code></pre></td></tr></table>
</div>
</div><p>加强耳机的立体声效果</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">ffmpeg -i music.mp3 -af earwax -q 1 music_headphones.mp3
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<ul>
<li><em>FFmpeg Basics 2012 by Frantisek Korbel</em></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Redis 用于做分布式锁</title>
      <link>https://ynikl.github.io/blog/redis-do-distributed-lock/</link>
      <pubDate>Thu, 18 Aug 2022 12:18:53 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/redis-do-distributed-lock/</guid>
      <description>操作 演进 加锁后进程挂掉了 加锁成功之后, 进程挂掉了没有进行解锁操作. 导致进入死锁状态.
引入 expire 设置超时时长, 自动释放 key
1 2 3 4 5 6 7 8 &amp;gt; setnx lock:key true &amp;gt; OK &amp;gt; expire lock:key 5 &amp;#34; ... do something critical ... &amp;gt; del lock:codehole 加锁动作 到 expire 之间挂掉了 redis 2.8 之后支持 set 拓展指令
1 &amp;gt; set lock:key true ex 5 nx 加锁互斥锁, 并同时设置超时时长
执行超时, 被其他进程获取到了锁 加锁之后, 本身进程执行时间超过了预先设置的 expire 的时间. 就会导致锁被提前释放.
解决方案:
尽量不要用与锁住时间教长的任务, 尝试缩小锁定的&amp;quot;关键区域&amp;quot; 续锁 (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间 执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁 Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。 &amp;ndash; Redis深度历险</description>
      <content:encoded><![CDATA[<h2 id="操作">操作</h2>
<h2 id="演进">演进</h2>
<h3 id="加锁后进程挂掉了">加锁后进程挂掉了</h3>
<p>加锁成功之后, 进程挂掉了没有进行解锁操作.
导致进入死锁状态.</p>
<p>引入 <code>expire</code> 设置超时时长, 自动释放 key</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; setnx lock:key true 
</span></span><span class="line"><span class="cl">&gt; OK
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; expire lock:key 5 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&#34; ... do something critical ... 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">&gt; del lock:codehole
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="加锁动作-到-expire-之间挂掉了">加锁动作 到 expire 之间挂掉了</h3>
<p>redis 2.8 之后支持 <code>set</code> 拓展指令</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; set lock:key true ex 5 nx
</span></span></code></pre></td></tr></table>
</div>
</div><p>加锁互斥锁, 并同时设置超时时长</p>
<h3 id="执行超时-被其他进程获取到了锁">执行超时, 被其他进程获取到了锁</h3>
<p>加锁之后, 本身进程执行时间超过了预先设置的 <code>expire</code> 的时间. 就会导致锁被提前释放.</p>
<p>解决方案:</p>
<ol>
<li>尽量不要用与锁住时间教长的任务, 尝试缩小锁定的&quot;关键区域&quot;</li>
<li><strong>续锁</strong> (会使客户端负责化) : 起一个支线进程, 定期(在超时时间内) 检查锁和value(保证是自己的锁), 重新设置超时时间</li>
</ol>
<h3 id="执行超时-被其他进程获取到了锁之后-超时进程误删其他进程的锁">执行超时, 被其他进程获取到了锁之后, 超时进程误删其他进程的锁</h3>
<blockquote>
<p>Redis 的分布式锁不能解决超时问题，如果在加锁和释放锁之间的逻辑执行的太长，以至 于超出了锁的超时限制，就会出现问题。因为这时候锁过期了，第二个线程重新持有了这把锁， 但是紧接着第一个线程执行完了业务逻辑，就把锁给释放了，第三个线程就会在第二个线程逻 辑执行完之间拿到了锁。
&ndash; Redis深度历险</p>
</blockquote>
<p>解决方案: 给加锁的 key 设置随机数的value, 删除之前先匹配是否一致再删除</p>
<p>匹配和删除动作之间的原子性可以用 Lua 脚本保证</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-lua" data-lang="lua"><span class="line"><span class="cl"><span class="o">#</span> <span class="n">delifequals</span>
</span></span><span class="line"><span class="cl"><span class="kr">if</span> <span class="n">redis.call</span><span class="p">(</span><span class="s2">&#34;get&#34;</span><span class="p">,</span><span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="n">ARGV</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="kr">then</span>
</span></span><span class="line"><span class="cl">	<span class="kr">return</span> <span class="n">redis.call</span><span class="p">(</span><span class="s2">&#34;del&#34;</span><span class="p">,</span><span class="n">KEYS</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
</span></span><span class="line"><span class="cl"><span class="kr">else</span>
</span></span><span class="line"><span class="cl">	<span class="kr">return</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="kr">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="可重入锁">可重入锁</h3>
<p>利用线程的本地变量(Threadloacl), 维护锁的持有计数, 实现支持多次加锁, 多次解锁</p>
<h2 id="参考">参考</h2>
<ul>
<li><em>Redis 深度历险</em></li>
<li><a href="https://www.51cto.com/article/679902.html">阿里二面：Redis分布式锁过期了但业务还没有执行完，怎么办</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql- 数据类型 - 数字类型</title>
      <link>https://ynikl.github.io/blog/mysql-data-type-date/</link>
      <pubDate>Sun, 31 Jul 2022 17:49:46 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/mysql-data-type-date/</guid>
      <description>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期类型 空间 JSON 日期类型 Mysql 支持的数据类型
DATE TIME DATETIME TIMESTAMP YEAR Date 只存储日期数据, 不包含时间. YYYY-MM-DD, 范围是从 &amp;lsquo;1000-01-01&amp;rsquo; to &amp;lsquo;9999-12-31&amp;rsquo;
DateTime 存储日期, 也存储时间 &#39;YYYY-MM-DD hh:mm:ss&#39;
范围是从&#39;1000-01-01 00:00:00&amp;rsquo; to &amp;lsquo;9999-12-31 23:59:59&amp;rsquo;
TIMESTAMP 存储Unix时间戳数据 会受到服务器时区影响&amp;ndash; 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之 时区环境变量设置 范围 &amp;lsquo;1970-01-01 00:00:01&amp;rsquo; UTC to &amp;lsquo;2038-01-19 03:14:07&amp;rsquo; UTC.
相关函数:
FROM_UNIXTIME 把 Unix 时间戳转化成日期 UNIX_TIMESTAMP 把日期转化成 Unix 时间戳 YEAR 显示形式 YYYY, 可选显示位数YYYY(M)
默认4位显示 &amp;lsquo;1991&amp;rsquo; TIME 只有时间部分,没有日期部分 hh:mm:ss, 范围从 &amp;lsquo;-838:59:59&amp;rsquo; 到 &amp;lsquo;838:59:59&amp;rsquo;</description>
      <content:encoded><![CDATA[<h2 id="概览">概览</h2>
<p>Mysql 支持以下数据类型</p>
<ul>
<li>数字类型</li>
<li>串类型(字符和字节)</li>
<li>日期类型</li>
<li>空间</li>
<li>JSON</li>
</ul>
<h2 id="日期类型">日期类型</h2>
<p>Mysql 支持的数据类型</p>
<ul>
<li>DATE</li>
<li>TIME</li>
<li>DATETIME</li>
<li>TIMESTAMP</li>
<li>YEAR</li>
</ul>
<h3 id="date">Date</h3>
<p>只存储日期数据, 不包含时间. <code>YYYY-MM-DD</code>, 范围是从 &lsquo;1000-01-01&rsquo; to &lsquo;9999-12-31&rsquo;</p>
<h3 id="datetime">DateTime</h3>
<p>存储日期, 也存储时间 <code>'YYYY-MM-DD hh:mm:ss'</code></p>
<p>范围是从'1000-01-01 00:00:00&rsquo; to &lsquo;9999-12-31 23:59:59&rsquo;</p>
<h3 id="timestamp">TIMESTAMP</h3>
<ul>
<li>存储Unix时间戳数据</li>
<li>会受到服务器时区影响&ndash; 存储的时候转化成标准的Unix时间戳(0时区), 取数据时反之</li>
<li><a href="https://dev.mysql.com/doc/refman/8.0/en/server-system-variables.html#sysvar_time_zone">时区环境变量设置</a></li>
</ul>
<p>范围 &lsquo;1970-01-01 00:00:01&rsquo; UTC to &lsquo;2038-01-19 03:14:07&rsquo; UTC.</p>
<p>相关函数:</p>
<ul>
<li>FROM_UNIXTIME 把 Unix 时间戳转化成日期</li>
<li>UNIX_TIMESTAMP 把日期转化成 Unix 时间戳</li>
</ul>
<h3 id="year">YEAR</h3>
<p>显示形式 <code>YYYY</code>, 可选显示位数<code>YYYY(M)</code></p>
<ul>
<li>默认4位显示 &lsquo;1991&rsquo;</li>
</ul>
<h3 id="time">TIME</h3>
<p>只有时间部分,没有日期部分 <code>hh:mm:ss</code>, 范围从 &lsquo;-838:59:59&rsquo; 到 &lsquo;838:59:59&rsquo;</p>
<h3 id="自动更新">自动更新</h3>
<p>DateTime 和 Timestamp 在 <strong>Mysql 8.0</strong>, 支持自动初始化和当数据更新时自动更新.</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">ts</span><span class="w"> </span><span class="k">TIMESTAMP</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">UPDATE</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">dt</span><span class="w"> </span><span class="n">DATETIME</span><span class="w"> </span><span class="k">DEFAULT</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w"> </span><span class="k">ON</span><span class="w"> </span><span class="k">UPDATE</span><span class="w"> </span><span class="k">CURRENT_TIMESTAMP</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="存储毫秒级别的时间">存储毫秒级别的时间</h3>
<p>支持存储毫秒级别的时间类型有:</p>
<ul>
<li>TIME</li>
<li>DATETIME</li>
<li>TIMESTAMP</li>
</ul>
<p>声明模式为 <code>type_name(fsp)</code>, fsp 为0-6, 表示小数点后个数</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="k">CREATE</span><span class="w"> </span><span class="k">TABLE</span><span class="w"> </span><span class="n">fractest</span><span class="p">(</span><span class="w"> </span><span class="n">c1</span><span class="w"> </span><span class="n">TIME</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">c2</span><span class="w"> </span><span class="n">DATETIME</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span><span class="w"> </span><span class="n">c3</span><span class="w"> </span><span class="k">TIMESTAMP</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="k">INSERT</span><span class="w"> </span><span class="k">INTO</span><span class="w"> </span><span class="n">t1</span><span class="w"> </span><span class="k">VALUES</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">(</span><span class="s1">&#39;17:51:04.777&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;2018-09-08 17:51:04.777&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;2018-09-08 17:51:04.777&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h3 id="存储空间">存储空间</h3>
<p>| 类型      | 大小    | 其他                 |
| Year      | 1 bytes |                      |
| DATE      | 3 bytes |                      |
| Time      | 3 bytes | 5.6.4 之后支持小数点 |
| Timestamp | 4 bytes | 同上                 |
| DateTime  | 8 bytes | 同上                 |</p>
<p>小数点精度的位数</p>
<p>| 0    | 0 bytes |
| 1,2  | 1 bytes |
| 3,4  | 2 bytes |
| 4,5  | 3 bytes |</p>
<h3 id="使用推荐">使用推荐</h3>
<p><em>高性能 Mysql</em> 里面总结 DateTime 和 Timestamp 的使用选择:</p>
<ul>
<li>非特殊情况, 尽量使用 timestamp, 因为空间效率更高.</li>
<li>Timestamp 不会存储时区, 而 Datetime 会存储时区</li>
<li>Timestamp 做为索引的话会更加轻量</li>
</ul>
<p>Timestamp 和 Int 的使用选择</p>
<ul>
<li>没有必要用 INT 存储, 保存时间戳. 因为没有任何收益.</li>
<li>Timestamp 可以支持数据变更时自动更新.</li>
</ul>
<h3 id="相关的一些函数">相关的一些函数</h3>
<ul>
<li>FROM_UNIXTIME 可以将 Unix 时间戳转化成日期</li>
</ul>
<h2 id="参考">参考</h2>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">Mysql 8.0 官方文档</a>
<a href="https://dev.mysql.com/doc/internals/en/date-and-time-data-type-representation.html">Mysql date 内部数据结构</a>
[高性能 Mysql]</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Mysql- 数据类型 - 数字类型</title>
      <link>https://ynikl.github.io/blog/mysql-data-type-numbers/</link>
      <pubDate>Sun, 31 Jul 2022 17:49:46 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/mysql-data-type-numbers/</guid>
      <description>概览 Mysql 支持以下数据类型
数字类型 串类型(字符和字节) 日期和时间 空间 JSON 数字类型 整数类型 Interger 类型 存储大小 bytes 其他别名 TinyInt 1 bool, boolean = tinyint(1) SmallInt 2 MediumInt 3 Int 4 BigInt 8 int(M) 表示显示宽度, 最大显示宽度为(255), M 与存储空间的大小无关. 空间大小由具体类型决定.
如果具体数值达不到宽度, 左边就会用0值补齐至 M 位.
浮点 ( Floating-Point ) 类型 存储 补充 范围 Float 4 bytes 单精度 Double 8 bytes 双精度 Float(p) p 表示小数点后的精度位数
Float(M, D) Mysql 语法: M表示总显示位数, D表示小数点后个数 &amp;ndash; 由Mysql自己做约分处理. Mysql 8.0 后废弃该语法.
定点 ( Fixed-Point ) 用于需要准备保存字段数据, 如金钱相关字段.</description>
      <content:encoded><![CDATA[<h2 id="概览">概览</h2>
<p>Mysql 支持以下数据类型</p>
<ul>
<li>数字类型</li>
<li>串类型(字符和字节)</li>
<li>日期和时间</li>
<li>空间</li>
<li>JSON</li>
</ul>
<h2 id="数字类型">数字类型</h2>
<h3 id="整数类型-interger">整数类型 Interger</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储大小 bytes</th>
<th>其他别名</th>
</tr>
</thead>
<tbody>
<tr>
<td>TinyInt</td>
<td>1</td>
<td>bool, boolean = tinyint(1)</td>
</tr>
<tr>
<td>SmallInt</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>MediumInt</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>Int</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>BigInt</td>
<td>8</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong>int(M) 表示显示宽度, 最大显示宽度为(255), M 与存储空间的大小无关. 空间大小由具体类型决定.</strong></p>
<p>如果具体数值达不到宽度, 左边就会用0值补齐至 M 位.</p>
<h3 id="浮点--floating-point-">浮点 ( Floating-Point )</h3>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储</th>
<th>补充</th>
<th>范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>Float</td>
<td>4 bytes</td>
<td>单精度</td>
<td></td>
</tr>
<tr>
<td>Double</td>
<td>8 bytes</td>
<td>双精度</td>
<td></td>
</tr>
</tbody>
</table>
<p><code>Float(p)</code> p 表示小数点后的精度位数</p>
<p><code>Float(M, D)</code> Mysql 语法: M表示总显示位数, D表示小数点后个数 &ndash; 由Mysql自己做约分处理. Mysql 8.0 后废弃该语法.</p>
<h3 id="定点--fixed-point-">定点 ( Fixed-Point )</h3>
<p>用于需要准备保存字段数据, 如金钱相关字段.</p>
<p><code>Decimal(M, D)</code> 其中, M 表示字段中有效数据个数, D 表示小数点后个数</p>
<p>Decimal(5,2) 的精度为 <code>-999.99 - 999.99</code></p>
<h3 id="位--bit-value-">位 ( Bit-Value )</h3>
<p><code>BIT(M)</code> 用于存储位值, M范围(1-64), 当存储的数值小于 M, 会进行左边补0</p>
<p>example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql&gt; CREATE TABLE t (b BIT(8));
</span></span><span class="line"><span class="cl">mysql&gt; INSERT INTO t SET b = b&#39;11111111&#39;;
</span></span><span class="line"><span class="cl">mysql&gt; INSERT INTO t SET b = b&#39;1010&#39;;
</span></span><span class="line"><span class="cl">mysql&gt; INSERT INTO t SET b = b&#39;0101&#39;;
</span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">mysql&gt; SELECT b+0, BIN(b), OCT(b), HEX(b) FROM t;
</span></span><span class="line"><span class="cl">+------+----------+--------+--------+
</span></span><span class="line"><span class="cl">| b+0  | BIN(b)   | OCT(b) | HEX(b) |
</span></span><span class="line"><span class="cl">+------+----------+--------+--------+
</span></span><span class="line"><span class="cl">|  255 | 11111111 | 377    | FF     |
</span></span><span class="line"><span class="cl">|   10 | 1010     | 12     | A      |
</span></span><span class="line"><span class="cl">|    5 | 101      | 5      | 5      |
</span></span><span class="line"><span class="cl">+------+----------+--------+--------+
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="参考">参考</h2>
<p><a href="https://dev.mysql.com/doc/refman/8.0/en/">Mysql 8.0 官方文档</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>RabbitMQ 基本入门实践</title>
      <link>https://ynikl.github.io/blog/rabbitmq-learning-note/</link>
      <pubDate>Sat, 09 Jul 2022 16:43:26 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/rabbitmq-learning-note/</guid>
      <description>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.
介绍一下 RabbitMQ Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件
消息中间件的作用
解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性. 冗余存储: 保存失败的消息 拓展性 削峰 缓冲 结构 涉及的名词简单解释
Producer Consumer Broker: 服务节点 Queue: 内存存储消息数据的对象 Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据routingkey 和 bindingkey 决定投递到哪个队列 RoutingKey: 生产消息提供routingkey 给交换器用于指定要投递的队列 BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来 Connection: 客户端与 Broke 建立的 TCP 连接 Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接 交换器的类型
fanout : 投递到所有队列 direct: 投递到 routingkey 和 bindingkey 匹配的 topic: direct 的拓展, 支持模糊匹配 headers : 性能差, 少用 消息投递流程:</description>
      <content:encoded><![CDATA[<p>公司刚好有一个项目要使用到 RabbitMQ, 本文是我自己了解学习 RabbitMQ 的记录.</p>
<h2 id="介绍一下-rabbitmq">介绍一下 RabbitMQ</h2>
<p>Erlang 语言实现 AMQP (Advanced Message Queuing Protocal) 的消息中间件</p>
<p>消息中间件的作用</p>
<ul>
<li>解耦: 可以不需要依赖下游的可用性, 提高单独项目的可用性.</li>
<li>冗余存储: 保存失败的消息</li>
<li>拓展性</li>
<li>削峰</li>
<li>缓冲</li>
</ul>
<h3 id="结构">结构</h3>
<p>涉及的名词简单解释</p>
<ul>
<li>Producer</li>
<li>Consumer</li>
<li>Broker: 服务节点</li>
<li>Queue: 内存存储消息数据的对象</li>
<li>Exchange: 选择器, 生产者投递消息后, 提交给交换器, 由交换器根据<code>routingkey</code> 和 <code>bindingkey</code> 决定投递到哪个队列
<ul>
<li>RoutingKey: 生产消息提供<code>routingkey</code> 给交换器用于指定要投递的队列</li>
<li>BindingKey: 交换器, 通过 bindingkey 与对应的队列关联起来</li>
</ul>
</li>
<li>Connection: 客户端与 Broke 建立的 TCP 连接</li>
<li>Channel: 是建立在 Connection 上抽象的虚拟连接. 实现多线程可以 TCP 连接, 多个信道可能复用同一个 TCP 连接</li>
</ul>
<p>交换器的类型</p>
<ul>
<li>fanout : 投递到所有队列</li>
<li>direct: 投递到 <code>routingkey</code>  和 <code>bindingkey</code> 匹配的</li>
<li>topic: direct 的拓展, 支持模糊匹配</li>
<li>headers : 性能差, 少用</li>
</ul>
<p>消息投递流程:</p>
<ol>
<li>生产者连接到 Broker, 开启信道</li>
<li>生产者声明一个交换器</li>
<li>生产者声明一个队列</li>
<li>生产者通过路由键将交换器和队列绑定</li>
<li>生产者发送消息到 Broker</li>
<li>交换器根据接受对路由键匹配队列</li>
<li>投递到对应的消息队列</li>
<li>如果没有匹配的队列, 丢弃或者退回给生产者</li>
</ol>
<p>消费者接受消息流程:</p>
<ol>
<li>建立连接, 开启信道</li>
<li>消费者向 Broker 发起消息请求</li>
<li>Broker 回应并返回消息</li>
<li>消费者发送确认 (ack) 接受到消息</li>
<li>关闭信道</li>
<li>关闭连接</li>
</ol>
<h3 id="amqp">AMQP</h3>
<p>位于应用层的通信协议 ( 在 TCP 之上, 将数据填充到 TCP 中)</p>
<p>几个基础的协议定义的操作</p>
<ul>
<li>Protocal Header 0-9-1 指定协议</li>
<li>Connection.Start</li>
<li>Channel.Open</li>
<li>Basic.Publish 推送消息</li>
<li>Channel.Close</li>
<li>Connection.Close</li>
</ul>
<h2 id="部署">部署</h2>
<p>在你的机子上部署一个玩具吧</p>
<p>采用 docker 部署
<code>docker run -itd --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management</code></p>
<p>进入管理页面
访问 http://127.0.0.1:15672/</p>
<p>登入
用户名: guest
密码: guest</p>
<p><a href="https://www.rabbitmq.com/configure.html#supported-environment-variables">更多默认配置</a></p>
<h2 id="管理">管理</h2>
<p>进入交互 shell
<code>docker exec -it rabbitmq bash</code></p>
<p>增加一个用户
<code>rabbitmqctl add_user ian ian1234</code></p>
<p>增加一个 vhost
<code>rabbitmqctl add_vhost playground</code></p>
<p>vhost是什么?
vhost (virtual host), 虚拟主机, 在实例间提供逻辑上的分离 &ndash; 实现数据隔离.
RabbitMQ 默认创建一个名为 &ldquo;/&rdquo; 的 vhost</p>
<p>查看 vhost
<code>rabbitmqctl list_vhosts</code></p>
<p>设置权限
<code>rabbitmqctl set_permissions --vhost playground ian &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;</code></p>
<p><strong>amqp uri规则</strong>
<code>&quot;amqp://userName:password@ipAddress:portNumber/virtualHost&quot;</code>
根据我们上述的新增在用户和vhost, 可以得到uri:
<code>amqp://ian:ian1234@localhost:5672/playground</code>
5672为 rabbitmq的默认终端, 我们的 docker contain 需要把它映射到本机带端口</p>
<h2 id="实现生产者">实现生产者</h2>
<p>go 使用 <code>github.com/rabbitmq/amqp091-go</code> 包</p>
<p>根据上文的消息投递流程实现</p>
<p>连接到 broker</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">connectionUrl</span> <span class="o">:=</span> <span class="s">&#34;amqp://ian:ian1234@localhost:5672/playground&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">amqp</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">connectionUrl</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>打开 channel</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">ch</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Channel</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>声明一个交互器( 该步骤可以省略, 直接使用默认的 <code>direct</code>交换器)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">ExchangeDeclare</span><span class="p">(</span><span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="s">&#34;direct&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>声明一个队列</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">q</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">QueueDeclare</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>将 Exchange 绑定到队列上 (如果声明交换器的步骤省略了, 该步骤也可以省略)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">QueueBind</span><span class="p">(</span><span class="nx">q</span><span class="p">.</span><span class="nx">Name</span><span class="p">,</span> <span class="s">&#34;hellokey&#34;</span><span class="p">,</span> <span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>发送消息 (如果没有声明交换器, 对应的参数直接传入空字符串<code>&quot;&quot;</code>, 会使用默认的 <code>direct</code> 交换器)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">		<span class="nx">err</span> <span class="p">=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">Publish</span><span class="p">(</span><span class="s">&#34;hello-exchange&#34;</span><span class="p">,</span> <span class="s">&#34;hellokey&#34;</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="nx">amqp</span><span class="p">.</span><span class="nx">Publishing</span><span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">ContentType</span><span class="p">:</span> <span class="s">&#34;text/plain&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Body</span><span class="p">:</span>        <span class="p">[]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">body</span><span class="p">),</span>
</span></span><span class="line"><span class="cl">		<span class="p">})</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://github.com/ynikl/rabbitmq-demo/blob/main/cmd/producer/main.go">完整代码地址</a></p>
<p>登录到本地管理页面可以查看类似于下图, 有消息投递</p>
<p><img loading="lazy" src="/rabbitmq-producer-manager-pic-20220704.png" alt="生产消息成功"  />
</p>
<h2 id="实现消费者">实现消费者</h2>
<p>消费者相对于生产者就简单多了.
打开信道直接消费就可以了.</p>
<p>连接, 打开信道</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="nx">connectionUrl</span> <span class="o">:=</span> <span class="s">&#34;amqp://ian:ian1234@localhost:5672/playground&#34;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">conn</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">amqp</span><span class="p">.</span><span class="nf">Dial</span><span class="p">(</span><span class="nx">connectionUrl</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Fatal</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">ch</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">conn</span><span class="p">.</span><span class="nf">Channel</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>开始消费</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="c1">// msgsCh 是一个消息管道
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">msgsCh</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">ch</span><span class="p">.</span><span class="nf">Consume</span><span class="p">(</span><span class="s">&#34;hello&#34;</span><span class="p">,</span> <span class="s">&#34;consumer-name&#34;</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">msg</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">msgsCh</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;received a message: &#34;</span><span class="p">,</span> <span class="nb">string</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">Body</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">log</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">&#34;done, msg channel is closed&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/rabbitmq-receive-success-20220709.png" alt="消费成功"  />
</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://www.rabbitmq.com/tutorials/tutorial-one-go.html">官网 tutorial</a></li>
<li><a href="https://book.douban.com/subject/27591386/">RabbitMQ 实战指南</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>小窥 Go 中的 Modules</title>
      <link>https://ynikl.github.io/blog/go-modules/</link>
      <pubDate>Fri, 03 Jun 2022 18:16:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/go-modules/</guid>
      <description>是什么 Modules （下文称为模块）是 Go 语言设计用来管理依赖包。
在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。
模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在go.mod文件中。
go.mod 文件 1 2 3 4 5 6 7 8 9 module example.com/my/thing go 1.12 require example.com/other/thing v1.0.2 require example.com/new/thing/v2 v2.3.4 exclude example.com/old/thing v1.2.3 replace example.com/bad/thing v1.4.5 =&amp;gt; example.com/good/thing v1.4.5 retract [v1.9.0, v1.9.5] 文件中各行意思
module 当前自己模块的名的完整路径 go 版本号 require 需要依赖的目标模块以及最小的版本号 exclude 排除目标模块的特定版本 replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块 retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况 go.mod 可以通过相关命令修改，也可以直接修改文件数据
go.sum 文件 与go.mod经常在一起的会是一个go.sum文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。
1 2 3 &amp;gt; cat go.</description>
      <content:encoded><![CDATA[<h2 id="是什么">是什么</h2>
<p>Modules （下文称为模块）是 Go 语言设计用来管理依赖包。</p>
<p>在中文中我们经常把go中的 Module 和 Package 统称为“包”，其实 Module 是一个版本控制的“包”的集合。</p>
<p>模块的引入主要用于解决，项目依赖的不同版本的问题。（在旧的 GOPATH 中不同项目依赖不同版本）。引入的模块会声明在<code>go.mod</code>文件中。</p>
<h3 id="gomod-文件">go.mod 文件</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-v" data-lang="v"><span class="line"><span class="cl"><span class="kn">module</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">my</span><span class="o">/</span><span class="nv">thing</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">go</span> <span class="mf">1.12</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nv">require</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">other</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.0.2</span>
</span></span><span class="line"><span class="cl"><span class="nv">require</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">new</span><span class="o">/</span><span class="nv">thing</span><span class="o">/</span><span class="nv">v2</span> <span class="nv">v2</span><span class="mf">.3.4</span>
</span></span><span class="line"><span class="cl"><span class="nv">exclude</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">old</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.2.3</span>
</span></span><span class="line"><span class="cl"><span class="nv">replace</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">bad</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.4.5</span> <span class="o">=</span><span class="p">&gt;</span> <span class="nv">example</span><span class="p">.</span><span class="nv">com</span><span class="o">/</span><span class="nv">good</span><span class="o">/</span><span class="nv">thing</span> <span class="nv">v1</span><span class="mf">.4.5</span>
</span></span><span class="line"><span class="cl"><span class="nv">retract</span> <span class="p">[</span><span class="na">v1</span><span class="err">.</span><span class="na">9</span><span class="err">.</span><span class="na">0</span><span class="err">,</span> <span class="na">v1</span><span class="err">.</span><span class="na">9</span><span class="err">.</span><span class="na">5</span><span class="p">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>文件中各行意思</p>
<ul>
<li>module 当前自己模块的名的完整路径</li>
<li>go 版本号</li>
<li>require 需要依赖的目标模块以及最小的版本号</li>
<li>exclude 排除目标模块的特定版本</li>
<li>replace 将某个模块版本指向另一个模块版本，也可以指向本地，未发布的模块</li>
<li>retract 当前发布的模块，需要撤回不能用版本，用于处理意外发布版本的情况</li>
</ul>
<p><code>go.mod</code> 可以通过相关命令修改，也可以直接修改文件数据</p>
<h3 id="gosum-文件">go.sum 文件</h3>
<p>与<code>go.mod</code>经常在一起的会是一个<code>go.sum</code>文件，文件中存放着第一次添加依赖模块时，的模块源码的 hash 值。主要是用于校验，防止依赖模块代码被意外地修改到。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&gt; cat go.sum
</span></span><span class="line"><span class="cl">example.com/mod v1.0.0 h1:6Cz1EhbAk54HWaw6fhCpSPxWGjIMLuF9MlO4Ou568sQ=
</span></span><span class="line"><span class="cl">example.com/mod v1.0.0/go.mod h1:mgm3p5SY7FVOgVLVSXIYK9qk0umwLQLOG06xLpFUeTI=
</span></span></code></pre></td></tr></table>
</div>
</div><p>文件中以：模块路径 + 版本号 + hash算法名 + hash值 的组合写入</p>
<ul>
<li><code>example.com/mod</code> 是模块路径名</li>
<li>v1.0.0 是版本号，在第二行有是以<code>/go.mod</code>结尾，代表该 hash 值是对依赖模块本身的<code>go.mod</code>文件的 hash 值</li>
<li>h1: 代表使用的 hash 算法，代表 SHA-256</li>
<li>哈希值，没什么好说的了</li>
</ul>
<h3 id="module-cache">Module cache</h3>
<p>本地的目录，用户存放下载下来的的模块文件。</p>
<p>默认路径是在<code>$GOPAth/pkg/mod</code></p>
<p><a href="https://go.dev/ref/mod#module-cache">Module cache 文件夹详细说明</a></p>
<h3 id="语义化版本">语义化版本</h3>
<p>go 采用语义化版本 v1.18.1</p>
<p>一个模块的版本是不变的 —— 只要拉过一次模块，该模块就会存在缓存在<a href="https://proxy.golang.org/">Go 官方的模块服务</a>中，以后拉取改模块就会从官方的模块服务拉取，且该动作不可逆。</p>
<p>版本号 = &ldquo;v&rdquo; + 主版本号 + 小版本号 + 补丁号</p>
<ul>
<li>主版本号的增加后，小版本号和补丁号要重新置零。主版本号增加，代表该版本出现不向后兼容的改动。比如移除旧的包</li>
<li>小版本号增加后，补丁号重新置零。表示版本改动公共接口但是向后兼容的，比如增加一个函数</li>
<li>补丁号增加，表示该版本对公开接口没有改动。比如修改bug</li>
</ul>
<p>版本的后面可能还会增加一些提前发布的标识，比如 v1.18.1-beta v1.18.1-pre</p>
<p>当 go 的 模块没有声明发布版本的时候(比如拉取某分支做为模块)，go 就会自己生成 <a href="https://go.dev/ref/mod#pseudo-versions">伪版本</a>, 可以仅作了解。</p>
<p><strong>如果使用模块的版本号大于等于v2的时候，需要在引入包的后缀加上<code>/v2</code></strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">import &#34;github.com/urfave/cli/v2&#34;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="怎么用">怎么用</h2>
<h3 id="开启模块功能">开启模块功能</h3>
<p>模块功能的开启, 配置在环境变量<code>GO111MODULE</code></p>
<ul>
<li>=off, 忽略<code>GOPATH</code>路径下的<code>go.mod</code>文件，直接引用<code>GOPATH/src</code>中的包文件</li>
<li>=on，启用模块功能</li>
<li>=auto, 如果项目有<code>go.mod</code>文件启用，没有则是用<code>GOPATH</code>模式</li>
</ul>
<h3 id="常用命令快览">常用命令快览</h3>
<p><strong>go mod</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod init example.com/example/m1
</span></span></code></pre></td></tr></table>
</div>
</div><p>初始化当前文件夹，让其成为一个 module</p>
<p><strong>go get</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get -d example.com/example/m1@v1.2.3
</span></span></code></pre></td></tr></table>
</div>
</div><p>主要用法:修改当前项目的<code>go.mod</code>，引入新的依赖项目。</p>
<p><code>-d</code> 的标志，表示获取目标包之后，不进行本地编译或安装。Go 1.18 之后的默认行为。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get -d -u example.com/example/m1
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以用来升级依赖模块的版本，升级到最新版本。如果目标模块的新版的所依赖的其他模块也可能会一并升级。也可以指定版本<code>-u=patch</code></p>
<p>修改制定依赖版本的操作也可以通过制定后缀版本号实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go get example.com/example/m1@v2.3.1
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>go mod edit</strong></p>
<p>通过指令修改<code>go.mod</code>文件，与直接修改<code>go.mod</code>效果一致</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod edit -replace example.com/a@v1.0.0=./a
</span></span></code></pre></td></tr></table>
</div>
</div><p>将某个模块引用指向本地。可以用来解决引用正在开发中，还没有发布过的模块</p>
<p><strong>go mod tidy</strong></p>
<p>根据项目的源码引用整理<code>go.mod</code>中的引用情况。添加缺少的依赖，或者移除冗余的依赖。</p>
<p><strong>go mod vendor</strong></p>
<p>将依赖一并放在自己项目的中，可以省去自己拉取依赖的很多麻烦，提高可用性。go 项目的根目录中的 vendor 文件夹就是用来干这个事的</p>
<p>将项目依赖移入<code>vendor</code>文件中，当存在了vendor文件夹，项目会使用vendor中的依赖。大于 1.14 版本需要指定参数<code>-mod=vendor</code>才会启用</p>
<p>本地修改之后模块版本之后需要，重新使用<code>go mod vendor</code>将新的依赖模块同步入<code>vendor</code>中。</p>
<p><strong>go mod verify</strong></p>
<p>用于检测模块再被下载之后入，模块中的代码是否有被修改过。</p>
<p>对源码文件的 hash，与当前文件的<code>go.sum</code>中的 hash 对比校验是否有被修改过。
如果<code>go.sum</code>中没有该模块的hash值，就会从<a href="https://sum.golang.org">checksum database</a> 中获取目标 hash 值。（除非设置了<code>GOPRIVATE</code>或者<code>GONOSUMDB</code>)</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">❯ go mod verify
</span></span><span class="line"><span class="cl">github.com/ynikl/playmod v1.0.0: dir has been modified (/Users/ian/go/pkg/mod/github.com/ynikl/playmod@v1.0.0)
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述例子，源文件被我手动强制修改过，就会报错</p>
<p><strong>go mod why</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go mod why example.com/mod
</span></span></code></pre></td></tr></table>
</div>
</div><p>用于解释当前项目为什么会依赖某一个模块，输出项目对目标模块的依赖树图</p>
<p><strong>go list -m all</strong></p>
<p>可以用于输出当前项目依赖的所有模块</p>
<h3 id="mvs">MVS</h3>
<p><em>Minimal version selection</em>（MVS), 当引入的不同模块，又存在依赖与相同模块的（相同大版本，不同版本小版本）的时候。</p>
<p>在使用模块相关命令的时候，会选择所依赖的不同版本的中，构建项目所需要从最小版本。</p>
<p><img loading="lazy" src="mvs.png" alt="图片来源于官网"  />
</p>
<p>A.12 与 B1.2 分别需要 C1.3 和 C1.4 为了是项目能正常进行，需要使用 C1.4 版本</p>
<h2 id="参考">参考</h2>
<ul>
<li><a href="https://go.dev/ref/mod">官网Go Modules参考</a></li>
<li><a href="https://research.swtch.com/vgo-mvs">Minimal Version Seletion</a></li>
<li><a href="https://go.dev/blog/modules2019">官方介绍 Modules 博文</a></li>
<li><a href="https://go.googlesource.com/proposal/+/master/design/25530-sumdb.md#checksum-database">提议</a></li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go-互斥锁的实现</title>
      <link>https://ynikl.github.io/blog/go-sync_mutex/</link>
      <pubDate>Sun, 29 May 2022 20:52:35 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/go-sync_mutex/</guid>
      <description>Mutex 数据结构 1 2 3 4 type Mutex struct { state int32 sema uint32 } Mutex 使用过之后是不可被拷贝的 state 等于 0 值的时候才是无锁的状态 sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。 Mutex 对象总共有三个公开方法
Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞 TryLock Unlock 解除互斥锁， 解锁未锁定的互斥锁会发生panic Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。
Mutex 实现了一个 sync.Locker 接口, 该接口只有两个方法
Lock Unlock Mutex 锁有几种状态
mutexLocked = 1 已经锁定 mutexWoken = 2 表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量 mutexStarving = 4 当前锁已经进入了饥饿状态 其他常量
mutexWaiterShift = 3 统计的等待在Mutex.state字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving） starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms Mutex 锁的竞争方式 Mutex 锁有两种状态</description>
      <content:encoded><![CDATA[<h2 id="mutex-数据结构">Mutex 数据结构</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">Mutex</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">state</span> <span class="kt">int32</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sema</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>Mutex 使用过之后是不可被拷贝的</li>
<li>state 等于 0 值的时候才是无锁的状态</li>
<li>sema 字段为信号量字段，通过该字段控制协程的阻塞和唤醒，具体实现在runtime 中。</li>
</ul>
<p>Mutex 对象总共有三个公开方法</p>
<ul>
<li>Lock 尝试抢占互斥锁，如果已经被锁定，则调用协程进入阻塞</li>
<li>TryLock</li>
<li>Unlock 解除互斥锁， <strong>解锁未锁定的互斥锁会发生panic</strong></li>
</ul>
<p>Mutex 与协程无法关，允许一个协程锁定，另一个协程进行解锁。</p>
<p>Mutex 实现了一个 <code>sync.Locker</code> 接口, 该接口只有两个方法</p>
<ul>
<li>Lock</li>
<li>Unlock</li>
</ul>
<p>Mutex 锁有几种状态</p>
<ul>
<li>mutexLocked = 1 已经锁定</li>
<li>mutexWoken = 2  表示当前锁的等待队列，有协程正在活跃地获取锁，可以考虑不用释放信号量</li>
<li>mutexStarving = 4 当前锁已经进入了饥饿状态</li>
</ul>
<p>其他常量</p>
<ul>
<li>mutexWaiterShift = 3 统计的等待在<code>Mutex.state</code>字段等待数量。（前3位，用于表示锁的状态, 即 mutexLocked, mutexWoken, mutexStarving）</li>
<li>starvationThresholdNs = 1e6 进入饥饿模式的阈值 1ms</li>
</ul>
<h2 id="mutex-锁的竞争方式">Mutex 锁的竞争方式</h2>
<p>Mutex 锁有两种状态</p>
<ul>
<li>正常模式 normal</li>
<li>饥饿模式 starvation</li>
</ul>
<p>正常模式下，等待获取的锁的协程遵循先进先出的原则。</p>
<p>但是，当释放锁的时候如果有新协程进入获取锁代码的时候。因为新入协程本身已经运行在CPU上了，所以有抢占锁的优势。由于阻塞在等待队列上的协程，竞争不过新入协程。当等待时间操作 1ms，就会触发饥饿模式。</p>
<p>饥饿模式，进行互斥锁解锁的协程直接的将锁的所有权直接已经给等待队列的第一个协程。新进协程被禁止抢占互斥锁。</p>
<p>在转移所有权的时候，如果满足一下任意条件，则进入正常模式：</p>
<ul>
<li>锁的等待者只剩最后一个</li>
<li>等待时间小于1ms</li>
</ul>
<p>正常模式有利于更好的性能，饥饿模式则避免出现“饿死”情况。</p>
<h2 id="mutex-的方法详解">Mutex 的方法详解</h2>
<h3 id="lock">Lock</h3>
<p>第一步，通过调用 atomic 的 CAS 操作，尝试加锁，如果成功加锁直接返回</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">	atomic.CompareAndSwapInt32(&amp;m.state, 0, mutexLocked)
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果第一步失败，则代表该锁已经被加过锁，锁定了。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Mutex) lockSlow() {
</span></span><span class="line"><span class="cl">	// 当前协程的变量, 可以用于表示当前协程的状态
</span></span><span class="line"><span class="cl">	// 用于统计锁的等待时长，是否进入饥饿模式
</span></span><span class="line"><span class="cl">	var waitStartTime int64
</span></span><span class="line"><span class="cl">	starving := false // 当前协程是否处于饥饿
</span></span><span class="line"><span class="cl">	awoke := false // 是否处于唤醒
</span></span><span class="line"><span class="cl">	iter := 0 // 统计自旋次数
</span></span><span class="line"><span class="cl">	old := m.state
</span></span><span class="line"><span class="cl">	for {
</span></span><span class="line"><span class="cl">		// 进入自旋的状态条件， **已经锁定** 且非饥饿状态。
</span></span><span class="line"><span class="cl">		if old&amp;(mutexLocked|mutexStarving) == mutexLocked &amp;&amp; runtime_canSpin(iter) {
</span></span><span class="line"><span class="cl">			// 如果锁的状态 woken 字段未被标记， 将自身标记位唤醒，且将 Mutex 的 woken 位标记位1
</span></span><span class="line"><span class="cl">			// 当协程自己进入获取锁的第一候选人
</span></span><span class="line"><span class="cl">			if !awoke &amp;&amp; old&amp;mutexWoken == 0 &amp;&amp; old&gt;&gt;mutexWaiterShift != 0 &amp;&amp;
</span></span><span class="line"><span class="cl">				atomic.CompareAndSwapInt32(&amp;m.state, old, old|mutexWoken) {
</span></span><span class="line"><span class="cl">				awoke = true
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			runtime_doSpin()
</span></span><span class="line"><span class="cl">			// 控制自旋次数，大于4次之后不进入自旋状态
</span></span><span class="line"><span class="cl">			iter++
</span></span><span class="line"><span class="cl">			// 获取最新的状态
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">			continue
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 有可能，自旋自后已经解锁或者只是单纯不能自旋限制了。下面尝试通过 CAS 竞争锁。
</span></span><span class="line"><span class="cl">		// 新值用于设置新的状态
</span></span><span class="line"><span class="cl">		new := old
</span></span><span class="line"><span class="cl">		// 非饥饿状态才设置锁定
</span></span><span class="line"><span class="cl">		if old&amp;mutexStarving == 0 {
</span></span><span class="line"><span class="cl">			new |= mutexLocked
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if old&amp;(mutexLocked|mutexStarving) != 0 {
</span></span><span class="line"><span class="cl">			// 等待者加1
</span></span><span class="line"><span class="cl">			new += 1 &lt;&lt; mutexWaiterShift
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// 当前协程是饥饿状态，尝试标记锁的新状态位饥饿状态。
</span></span><span class="line"><span class="cl">		if starving &amp;&amp; old&amp;mutexLocked != 0 {
</span></span><span class="line"><span class="cl">			new |= mutexStarving
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		if awoke {
</span></span><span class="line"><span class="cl">			// The goroutine has been woken from sleep,
</span></span><span class="line"><span class="cl">			// so we need to reset the flag in either case.
</span></span><span class="line"><span class="cl">			if new&amp;mutexWoken == 0 {
</span></span><span class="line"><span class="cl">				// Mutex 的唤醒位被抢走，出现不一致。协程变量的唤醒位应该与 Mutex 的唤醒位一致
</span></span><span class="line"><span class="cl">				throw(&#34;sync: inconsistent mutex state&#34;)
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// 标志 锁的唤醒位为0
</span></span><span class="line"><span class="cl">			new &amp;^= mutexWoken
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">		// CAS 尝试, Mutex 状态没有被变更
</span></span><span class="line"><span class="cl">		if atomic.CompareAndSwapInt32(&amp;m.state, old, new) {
</span></span><span class="line"><span class="cl">			// 非饥饿状态下，CAS 成功新的 new 字段中会有 mutexLocked 标记（在new下的第一个if）。当前协程获取到了互斥锁,
</span></span><span class="line"><span class="cl">			if old&amp;(mutexLocked|mutexStarving) == 0 {
</span></span><span class="line"><span class="cl">				break // locked the mutex with CAS
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// queueLifo 表示该协程是否为第一次获取锁。如果中间被唤醒过，这放在等待队列头部
</span></span><span class="line"><span class="cl">			queueLifo := waitStartTime != 0
</span></span><span class="line"><span class="cl">			if waitStartTime == 0 {
</span></span><span class="line"><span class="cl">				waitStartTime = runtime_nanotime()
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// 通过信号量，进入阻塞 
</span></span><span class="line"><span class="cl">			runtime_SemacquireMutex(&amp;m.sema, queueLifo, 1)
</span></span><span class="line"><span class="cl">			// 进入饥饿模式
</span></span><span class="line"><span class="cl">			starving = starving || runtime_nanotime()-waitStartTime &gt; starvationThresholdNs
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">			// 当前是饥饿模式
</span></span><span class="line"><span class="cl">			if old&amp;mutexStarving != 0 {
</span></span><span class="line"><span class="cl">				// 如果当前锁的状态位饥饿模式，但是当前协程可以执行的当前行代码，代表当前协程已经被从阻塞中唤醒。
</span></span><span class="line"><span class="cl">				// 饥饿状态 + 被唤醒 =》当前锁已经已经到当前协程上
</span></span><span class="line"><span class="cl">				if old&amp;(mutexLocked|mutexWoken) != 0 || old&gt;&gt;mutexWaiterShift == 0 {
</span></span><span class="line"><span class="cl">					// 检查状态一致
</span></span><span class="line"><span class="cl">					throw(&#34;sync: inconsistent mutex state&#34;)
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">				// 由当协程来设置最新的锁定状态
</span></span><span class="line"><span class="cl">				delta := int32(mutexLocked - 1&lt;&lt;mutexWaiterShift)
</span></span><span class="line"><span class="cl">				// 判断是否需要退出饥饿模式
</span></span><span class="line"><span class="cl">				if !starving || old&gt;&gt;mutexWaiterShift == 1 {
</span></span><span class="line"><span class="cl">					delta -= mutexStarving
</span></span><span class="line"><span class="cl">				}
</span></span><span class="line"><span class="cl">				atomic.AddInt32(&amp;m.state, delta)
</span></span><span class="line"><span class="cl">				break
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// 当前是正常模式，通过CAS自由竞争锁。
</span></span><span class="line"><span class="cl">			awoke = true
</span></span><span class="line"><span class="cl">			iter = 0 // 重置计数
</span></span><span class="line"><span class="cl">		} else {
</span></span><span class="line"><span class="cl">			// 再来
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>是否可以进入自旋状态代码解释<a href="https://cs.opensource.google/go/go/+/master:src/runtime/proc.go;l=6175?q=sync_runtime_canSpin&amp;ss=go%2Fgo">源码地址</a></p>
<h3 id="unlock">Unlock</h3>
<p>第一步直接减去 mutexLocked 标志位常量，如果 new 等于0结束——简单（锁一次开一次，easy）。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">new := atomic.AddInt32(&amp;m.state, -mutexLocked)
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果 state 还不等于0（有协程等待，竞争锁）, 进入 unlockSlow</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">func (m *Mutex) unlockSlow(new int32) {
</span></span><span class="line"><span class="cl">	// 上一步已经减过 locked 位， 在加上应该等于1，否则不是正常解锁（解锁未锁定的锁）。
</span></span><span class="line"><span class="cl">	if (new+mutexLocked)&amp;mutexLocked == 0 {
</span></span><span class="line"><span class="cl">		fatal(&#34;sync: unlock of unlocked mutex&#34;)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	// 正常模式
</span></span><span class="line"><span class="cl">	if new&amp;mutexStarving == 0 {
</span></span><span class="line"><span class="cl">		old := new
</span></span><span class="line"><span class="cl">		for {
</span></span><span class="line"><span class="cl">			// If there are no waiters or a goroutine has already
</span></span><span class="line"><span class="cl">			// been woken or grabbed the lock, no need to wake anyone.
</span></span><span class="line"><span class="cl">			// In starvation mode ownership is directly handed off from unlocking
</span></span><span class="line"><span class="cl">			// goroutine to the next waiter. We are not part of this chain,
</span></span><span class="line"><span class="cl">			// since we did not observe mutexStarving when we unlocked the mutex above.
</span></span><span class="line"><span class="cl">			// So get off the way.
</span></span><span class="line"><span class="cl">			// 没有等待协程无需通过信号量唤醒
</span></span><span class="line"><span class="cl">			// 1. 如果 mutexLocked 位为1，则代表锁已经被新入协程获取。
</span></span><span class="line"><span class="cl">			// 2. mutexWoken 代表协程有协程正在活动，无需再释放信号量
</span></span><span class="line"><span class="cl">			// 3. mutexStarving 锁的状态一直被抢占，才会导致当前位饥饿状态，无需在释放信号量
</span></span><span class="line"><span class="cl">			if old&gt;&gt;mutexWaiterShift == 0 || old&amp;(mutexLocked|mutexWoken|mutexStarving) != 0 {
</span></span><span class="line"><span class="cl">				return
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			// Grab the right to wake someone.
</span></span><span class="line"><span class="cl">			new = (old - 1&lt;&lt;mutexWaiterShift) | mutexWoken
</span></span><span class="line"><span class="cl">			if atomic.CompareAndSwapInt3(&amp;m.state, old, new) {
</span></span><span class="line"><span class="cl">				// 信号量唤醒，各自竞争
</span></span><span class="line"><span class="cl">				runtime_Semrelease(&amp;m.sema, false, 1)
</span></span><span class="line"><span class="cl">				return
</span></span><span class="line"><span class="cl">			}
</span></span><span class="line"><span class="cl">			old = m.state
</span></span><span class="line"><span class="cl">		}
</span></span><span class="line"><span class="cl">	} else {
</span></span><span class="line"><span class="cl">		// 饥饿模式，通过信号量直接移交当前CPU时间
</span></span><span class="line"><span class="cl">		runtime_Semrelease(&amp;m.sema, true, 1)
</span></span><span class="line"><span class="cl">	}
</span></span><span class="line"><span class="cl">}2
</span></span></code></pre></td></tr></table>
</div>
</div><p>如何把锁移交给等待队列的协程？</p>
<p>使用 <code>Mutex.sema</code> 信号量实现锁转移</p>
<h2 id="参考">参考</h2>
<p><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.18:src/sync/mutex.go;bpv=1;bpt=1">源代码地址sync.mutex.go</a>
<a href="https://pkg.go.dev/sync#Mutex">包说明文档</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>【翻译】使用 Godoc 给 go 代码添加文档</title>
      <link>https://ynikl.github.io/blog/godoc-documenting-go-code/</link>
      <pubDate>Wed, 25 May 2022 16:11:10 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/godoc-documenting-go-code/</guid>
      <description>在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。
原文章地址 Godoc: documenting Go code
Go 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。
所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。
godoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。
godoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc&amp;quot;相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。
使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的Fprint函数的注释。
1 2 3 4 // Fprint formats using the default formats for its operands and writes to w. // Spaces are added between operands when neither is a string. // It returns the number of bytes written and any write error encountered.</description>
      <content:encoded><![CDATA[<p>在看官方文档的时候，突然心血来潮，想翻译一下一篇博客玩玩。</p>
<p>原文章地址
<a href="https://go.dev/blog/godoc">Godoc: documenting Go code</a></p>
<p>Go 语言官方对于代码的文档非常重视，文档对于软件的可阅读性和可维护性有着至关重要的地位。当然，文档必须要是准确可理解的，也需要易于编写和维护。理性情况下，文档应该与代码紧密联系。这样子才能方便于程序员修改和编写。</p>
<p>所以，我们开发了 godoc 文档工具。本文描述了的 godoc 关于的“文档”的方法论，和解释如何按照使用规范给你自己的项目写出一个好的文档。</p>
<p>godoc 会解析源文件代码和注释，生成基于HTML的页面或者纯文本格式的文档。这样子文档就与代码紧密联系。举个例子，通过在 godoc 的页面点击，你就可以在一个函数的文档说明和源代码中快速跳转。</p>
<p>godoc 在概念上与 Python 的“Docstring”和 Java 的“Javadoc&quot;相似，但是 godoc 设计的更加简单化。godoc 读取的代码注释的不需要特定的结构化（Docstring 使用），也不需要特定的语法（JavaDoc 使用），godoc 从代码读取的注释就是简单的“代码注释”，就算你不使用 godoc 也可以直接阅读的注释。</p>
<p>使用的规范很简单：在类型，变量，常量，函数，包声明的上方写下注释即可， 中间不要有空行。godoc 会把这些注释以文字的形式呈现在被注释的对象旁边。举个例子，下方就是 fmt 包的<code>Fprint</code>函数的注释。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Fprint formats using the default formats for its operands and writes to w.
</span></span></span><span class="line"><span class="cl"><span class="c1">// Spaces are added between operands when neither is a string.
</span></span></span><span class="line"><span class="cl"><span class="c1">// It returns the number of bytes written and any write error encountered.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">Fprint</span><span class="p">(</span><span class="nx">w</span> <span class="nx">io</span><span class="p">.</span><span class="nx">Writer</span><span class="p">,</span> <span class="nx">a</span> <span class="o">...</span><span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>值得注意的是该注释是以被注释的对象命名开头的一个完整的句子。 这个使用规范可以方便我们生成各种各样的格式文档，从简单的纯文本到 UNIX 是 man 的帮助页，还可以使用其他工具更见简单地获取到信息， 比如提取出第一行或者句子。</p>
<p>在包的声明处的注释，需要写整个包的概括说明。这些注释可以很简洁，就像 sort 包中的简短描述：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// Package sort provides primitives for sorting slices and user-defined
</span></span></span><span class="line"><span class="cl"><span class="c1">// collections.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kn">package</span> <span class="nx">sort</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>也可以很详细，比如 gob 包。有另一个使用惯例：像这种有这大量注释文档的包，单独一个<code>doc.go</code>文件，放置包的注释。</p>
<p>不论包的注释文档大小，第一句注释会被展示在 godoc 的呈现包列表中。</p>
<p>那些没有与最外层声明（可以简单理解为包内全局对象）连接在一块的注释会被 godoc 忽略。但是，有一个例外。那些写在最外层且以“BUG(who)”开头的注释，会被识别为已知的 bug，且会被包含在包文档的“Bugs”分区中。这个“who”部分应该填写可以提供更加详细信息的人名。举个已经在 bytes 包中注释的问题:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">// BUG(r): The rule Title uses for word boundaries does not handle Unicode punctuation properly.
</span></span></code></pre></td></tr></table>
</div>
</div><p>某些时候，当一个结构体字段，或者函数，类型，甚至一个整个包变成了冗余或者没有使用必要，但是还是需要与旧代码保持兼容。这时，可以增加一个一段落以“Deprecated:”开头后面跟废弃信息的注释。标识该对象不应该再被使用。</p>
<p>下面展示一些 godoc 把注释转化成网页的规则：</p>
<ul>
<li>不同的段落需要以空行分割。否则将会被识别成同一段。</li>
<li>带有格式的文本，需要要缩进。</li>
<li>URL 会被转化成网页连接，无需特殊处理。</li>
</ul>
<p>上方的这些规则不需要你做任何的特殊处理。</p>
<p>事实上，godoc 的极简处理方式使得它非常容易使用。所以，很多 go 项目，包括标准库，都已经开始开始遵循 godoc 的注释文档规范。</p>
<p>你自己的项目也可以通过编写符合文中规范的注释生成漂亮的文档。任何下载在<code>$GOROOT/src/pkg</code> 或者任何在 <code>GOPATH</code> 空间下的 go 代码包，都可以被 godoc 的命令行或者 HTTP 的接口访问， 你也可以通过在命令后添加<code>-path</code>参数或者直接使用<code>godoc .</code>来指定源码的路径。在<a href="https://pkg.go.dev/golang.org/x/tools/cmd/godoc">godoc 文档</a> 你可以查看到更加详细的内容。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Docker 基本使用</title>
      <link>https://ynikl.github.io/blog/docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</link>
      <pubDate>Thu, 07 Apr 2022 13:34:55 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/docker-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</guid>
      <description>启动一个容器 打个样
1 docker run -itd --rm --name hello image_name &amp;ndash; it 将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式
&amp;ndash;rm 当容器停止之后, 会自动删除改容器
外挂文件夹 参数 -v docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash
与容器交互 进入容器 docker attach
exec
docker -it exec CONTAIN_NAME bash
exex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯. 加上 -it, 进入交互的终端模式
查看日志 docker logs CONTAINER 可以查看容器日志
-f 可以持续输出容器内部的最新日志
管理容器 启动
1 docker start CONTAINER 暂停
1 docker stop CONTAINER 管理镜像 查看所有的镜像列表
1 docker image ls 删除镜像</description>
      <content:encoded><![CDATA[<h2 id="启动一个容器">启动一个容器</h2>
<p>打个样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker run -itd --rm --name hello image_name 
</span></span></code></pre></td></tr></table>
</div>
</div><p>&ndash; it
将当前的终端和容器内的终端连接在一起, 正式所谓的交互模式</p>
<p>&ndash;rm
当容器停止之后, 会自动删除改容器</p>
<p>外挂文件夹
参数 <code>-v </code></p>
<p><code>docker run -it -v /home/dock/Downloads:/usr/Downloads ubuntu64 /bin/bash</code></p>
<h2 id="与容器交互">与容器交互</h2>
<h3 id="进入容器">进入容器</h3>
<p><code>docker attach</code></p>
<p>exec</p>
<p><code>docker -it exec CONTAIN_NAME bash</code></p>
<p>exex 会再目标容器内部执行一个命令, 命令名为 bash, 就是起一个 shell 咯.
加上 <code>-it</code>, 进入交互的终端模式</p>
<h3 id="查看日志">查看日志</h3>
<p><code>docker logs CONTAINER</code>
可以查看容器日志</p>
<p>-f
可以持续输出容器内部的最新日志</p>
<h2 id="管理容器">管理容器</h2>
<p>启动</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker start CONTAINER
</span></span></code></pre></td></tr></table>
</div>
</div><p>暂停</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker stop CONTAINER
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="管理镜像">管理镜像</h2>
<p>查看所有的镜像列表</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker image ls
</span></span></code></pre></td></tr></table>
</div>
</div><p>删除镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rmi IMAGE
</span></span></code></pre></td></tr></table>
</div>
</div><p>删除 <code>&lt;none&gt;</code> 名称的镜像</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">docker rmi $(docker images --filter &#34;dangling=true&#34; -q --no-trunc)
</span></span></code></pre></td></tr></table>
</div>
</div>]]></content:encoded>
    </item>
    
    <item>
      <title>Channel</title>
      <link>https://ynikl.github.io/blog/go-channel/</link>
      <pubDate>Sat, 02 Apr 2022 10:09:22 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/go-channel/</guid>
      <description>Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本
channel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)
Do not communicate by sharing memory; instead, share memory by communicating.
channel 保证:
数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开 channel 的实现 channel 在内部实现的结构体为 runtime.hchan
有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe.</description>
      <content:encoded><![CDATA[<h1 id="go-中-channel-中用法和实现总结">Go 中 channel 中用法和实现总结</h1>
<p>以下分析和源码都是基于 go1.17 版本</p>
<h2 id="channel-简介">channel 简介</h2>
<p>Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (<strong>channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递</strong>)</p>
<blockquote>
<p>Do not communicate by sharing memory; instead, share memory by communicating.</p>
</blockquote>
<p>channel 保证:</p>
<ol>
<li>数据的先入先出</li>
<li>并发情况下的数据安全</li>
<li>已经关闭的 channel 不可重开</li>
</ol>
<h2 id="channel-的实现">channel 的实现</h2>
<p>channel 在内部实现的结构体为 <code>runtime.hchan</code></p>
<ol>
<li>有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲.</li>
<li>有一把互斥锁<code>mutex</code>, 在并发情况下, 保护自身数据结构的一致性</li>
<li>有两个协程等待链表, 用于挂载因为<strong>发送/接收</strong>而阻塞在该 channel 上的协程</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">hchan</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">qcount</span>   <span class="kt">uint</span>           <span class="c1">// 当前 buffer 中有暂存着多少个数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">dataqsiz</span> <span class="kt">uint</span>           <span class="c1">// 环形数组的buffer个数, 由 make 初始化的时候第二个参数容量决定的
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">buf</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 环形数组开始地址
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">elemsize</span> <span class="kt">uint16</span>         <span class="c1">// channel 传输的元素大小, 用于计算内存大小
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">closed</span>   <span class="kt">uint32</span>         <span class="c1">// channel 是否已经关闭 0未关闭, 非0关闭
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">elemtype</span> <span class="o">*</span><span class="nx">_type</span>         <span class="c1">// element type # channel 元素的类型
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sendx</span>    <span class="kt">uint</span>           <span class="c1">// 环形链表中, 发送数据存储的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">recvx</span>    <span class="kt">uint</span>           <span class="c1">// 环形链表中, 接受数据获取数据的下标
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">recvq</span>    <span class="nx">waitq</span>          <span class="c1">// 阻塞在该 channel 等待获取数据的 Groutine 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sendq</span>    <span class="nx">waitq</span>          <span class="c1">// 阻塞在该 channel 等待写入数据的 Groutine 列表
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="nx">lock</span> <span class="nx">mutex</span> <span class="c1">// # 互斥锁 用于保护自身数据变更
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化">初始化</h3>
<ol>
<li>channel 传递的元素不能太大</li>
<li>如果是空结构体或者无缓冲队列, 是不需要分配环形队列内存</li>
<li>如果传递数据类型有内含指针, 需要将环形队列分配到堆上</li>
</ol>
<p>内部实现函数<code>runtime.makechan</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">makechan</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">chantype</span><span class="p">,</span> <span class="nx">size</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">hchan</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// compiler checks this but be safe.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// 编译器会校验channel元素的大小, 小于64KB. 若大于64KB, 编译器会报错
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">size</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">16</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: invalid channel element type&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">hchanSize</span><span class="o">%</span><span class="nx">maxAlign</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">align</span> <span class="p">&gt;</span> <span class="nx">maxAlign</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;makechan: bad alignment&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">mem</span><span class="p">,</span> <span class="nx">overflow</span> <span class="o">:=</span> <span class="nx">math</span><span class="p">.</span><span class="nf">MulUintptr</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">size</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">overflow</span> <span class="o">||</span> <span class="nx">mem</span> <span class="p">&gt;</span> <span class="nx">maxAlloc</span><span class="o">-</span><span class="nx">hchanSize</span> <span class="o">||</span> <span class="nx">size</span> <span class="p">&lt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;makechan: size out of range&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Hchan does not contain pointers interesting for GC when elements stored in buf do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// buf points into the same allocation, elemtype is persistent.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// SudoG&#39;s are referenced from their owning thread so they can&#39;t be collected.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// TODO(dvyukov,rlh): Rethink when collector can move allocated objects.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="kd">var</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">mem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Queue or element size is zero. # 无缓冲队列或者空结构体为传递值, 不需要额外分配队列内存
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Race detector uses this location for synchronization.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">elem</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">// # channel 元素不存在指针引导数据, 将环形数组分配在 hchan 后面
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Elements do not contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Allocate hchan and buf in one call.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">hchan</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">hchanSize</span><span class="o">+</span><span class="nx">mem</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">c</span><span class="p">),</span> <span class="nx">hchanSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Elements contain pointers.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hchan</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">buf</span> <span class="p">=</span> <span class="nf">mallocgc</span><span class="p">(</span><span class="nx">mem</span><span class="p">,</span> <span class="nx">elem</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">elemsize</span> <span class="p">=</span> <span class="nb">uint16</span><span class="p">(</span><span class="nx">elem</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span> <span class="p">=</span> <span class="nx">elem</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">=</span> <span class="nb">uint</span><span class="p">(</span><span class="nx">size</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lockInit</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">,</span> <span class="nx">lockRankHchan</span><span class="p">)</span> <span class="c1">// # locakRankHchan 锁的等级
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="关闭">关闭</h3>
<p>核心代码<code>runtime.closechan</code>更新自身数据结构中的关闭状态, 并 <strong>唤醒阻塞在 channel 上的所有协程</strong>. 被唤醒的协程(<code>sudog</code>)的 success 标识会被置为 false.</p>
<p>被唤醒的 写操作的协程, 也会发生panic. ( &ldquo;send on closed channel&rdquo; )</p>
<p>自身操作会发生 panic 的情况</p>
<ol>
<li>未初始化 channel</li>
<li>重复关闭 channel</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">closechan</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 未初始化的channel 会发生panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of nil channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 开始关闭, 锁定之后数据都进不来了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;close of closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="p">=</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">glist</span> <span class="nx">gList</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// release all readers # 唤醒所有因为读取数据阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # [channel 唤醒协议总是设置params为sudog](https://github.com/golang/go/commit/30a68bfb806b5217932e280f5a5f521237e69077)
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// release all writers (they will panic) # 唤醒所有因为写入数据阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">sg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="nf">cputicks</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sg</span><span class="p">.</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sg</span><span class="p">.</span><span class="nx">success</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">raceacquireg</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">glist</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// Ready all Gs now that we&#39;ve dropped the channel lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">for</span> <span class="p">!</span><span class="nx">glist</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">glist</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">.</span><span class="nx">schedlink</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 唤醒协程, 将协程加入调度
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="发送数据">发送数据</h3>
<p><strong>向已经关闭的 channel 发送数据会发生 panic</strong></p>
<p>数据流程:</p>
<ol>
<li>检查是否已经初始化</li>
<li>非阻塞写入数据, 检查数据是否已经满, 快速返回</li>
<li>是否已经关闭</li>
<li>检查 channel 中是否已经有等待获取数据而阻塞的协程,  如果有直接将数据发送给等待的协程.</li>
<li>channel 的 buffer 是否还有空间, 如果有将数据放置到 buffer 中, 返回</li>
<li>channel 的 buffer 已经满了, 根据是否为 select 操作, 判断是否需要将协程阻塞</li>
<li>当协程阻塞之后,  在被唤醒之后需要再检查一次, channel 是否已经关闭.</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1">// # block 的参数是由是否在 select 中, 由编译过程决定的; 只有在select语句中block = true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chansend</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 向未初始化的 channel 发送数据会永远阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanSendNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 带 select 的 channel 在数据已经满了情况直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nf">full</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 保护数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 先从接受协程队列中获取阻塞的协程, 直接将数据发送给阻塞的协程
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Found a waiting receiver. We pass the value we want to send
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// directly to the receiver, bypassing the channel buffer (if any).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">send</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # channel 的 buffer 中还有剩余空间
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&lt;</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Space is available in the channel buffer. Enqueue the element to send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 环形队列, 当索引到最后从头开始
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">sendx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 增加当前 channel buffer 存储的数据个数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 发送数据的协程阻塞在当前 channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Block on the channel. Some receiver will complete our operation for us.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanSend</span><span class="p">,</span> <span class="nx">traceEvGoBlockSend</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Ensure the value being sent is kept alive until the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// receiver copies it out. The sudog has a pointer to the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack object, but sudogs aren&#39;t considered as roots of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack tracer.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">KeepAlive</span><span class="p">(</span><span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 协程被唤醒了
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// someone woke us up.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">closed</span> <span class="o">:=</span> <span class="p">!</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">blockevent</span><span class="p">(</span><span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span><span class="o">-</span><span class="nx">t0</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// # 挂载在协程上的发送协程会 panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">closed</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;chansend: spurious wakeup&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="nf">plainError</span><span class="p">(</span><span class="s">&#34;send on closed channel&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="接收数据">接收数据</h3>
<p>与发送数据一样, 同样带着是否阻塞的参数. 在编译时,由是否有 select 操作决定. 核心代码<code>runtime.chanrecv</code></p>
<ol>
<li>不带 select 从未初始化的 channel 获取数据, 会永远阻塞</li>
<li><code>runtime.chanrecv</code> 返回值中, 第一个返回值<code>selected</code>表示在,select 语句中, 该 case 是否会被选中执行</li>
</ol>
<p>接收数据流程:</p>
<ol>
<li>检查是否已经初始化</li>
<li>检查非阻塞获取数据下, 是否可以直接返回</li>
<li>如果已经关闭的 channel 且没有已经没有缓冲数据, 返回数据类型的默认值.</li>
<li>检查有因发送数据阻塞在 channel 的协程, 如果没有 buffer, 直接从阻塞的协程中获取数据, 否则从 buffer 中获取数据数据, 将第一个阻塞的协程的数据放入 buffer 中.</li>
<li>如果缓冲 buffer 有数据, 则从buffer 中获取数据.</li>
<li>非阻塞操作, 直接返回. 否则协程进行阻塞.</li>
</ol>
<p>注意事项:</p>
<p><strong>当 select 一个 已经关闭的 channel 的时候, 该 case 会被疯狂输出, 导致cpu使用率上升</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span><span class="lnt">116
</span><span class="lnt">117
</span><span class="lnt">118
</span><span class="lnt">119
</span><span class="lnt">120
</span><span class="lnt">121
</span><span class="lnt">122
</span><span class="lnt">123
</span><span class="lnt">124
</span><span class="lnt">125
</span><span class="lnt">126
</span><span class="lnt">127
</span><span class="lnt">128
</span><span class="lnt">129
</span><span class="lnt">130
</span><span class="lnt">131
</span><span class="lnt">132
</span><span class="lnt">133
</span><span class="lnt">134
</span><span class="lnt">135
</span><span class="lnt">136
</span><span class="lnt">137
</span><span class="lnt">138
</span><span class="lnt">139
</span><span class="lnt">140
</span><span class="lnt">141
</span><span class="lnt">142
</span><span class="lnt">143
</span><span class="lnt">144
</span><span class="lnt">145
</span><span class="lnt">146
</span><span class="lnt">147
</span><span class="lnt">148
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// chanrecv receives on channel c and writes the received data to ep.
</span></span></span><span class="line"><span class="cl"><span class="c1">// ep may be nil, in which case received data is ignored.
</span></span></span><span class="line"><span class="cl"><span class="c1">// If block == false and no elements are available, returns (false, false).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, if c is closed, zeros *ep and returns (true, false).
</span></span></span><span class="line"><span class="cl"><span class="c1">// Otherwise, fills in *ep with an element and returns (true, true).
</span></span></span><span class="line"><span class="cl"><span class="c1">// A non-nil ep must point to the heap or the caller&#39;s stack.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">func</span> <span class="nf">chanrecv</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">hchan</span><span class="p">,</span> <span class="nx">ep</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">block</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">(</span><span class="nx">selected</span><span class="p">,</span> <span class="nx">received</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// select 情况下, selected = false, 不执行该 case
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// # 非 select 会永远阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nf">gopark</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="kc">nil</span><span class="p">,</span> <span class="nx">waitReasonChanReceiveNilChan</span><span class="p">,</span> <span class="nx">traceEvGoStop</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unreachable&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 不加锁检查, 带 select 接收操作, 如果 channel 未关闭, 且没有可以获取的数据直接返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// Fast path: check for failed non-blocking operation without acquiring the lock.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="o">&amp;&amp;</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// After observing that the channel is not ready for receiving, we observe whether the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// channel is closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Reordering of these checks could lead to incorrect behavior when racing with a close.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// For example, if the channel was open and not empty, was closed, and then drained,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// reordered reads could incorrectly indicate &#34;open and empty&#34;. To prevent reordering,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// we use atomic loads for both checks, and rely on emptying and closing to happen in
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// separate critical sections under the same lock.  This assumption fails when closing
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// an unbuffered channel with a blocked send, but that is an error condition anyway.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">closed</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Because a channel cannot be reopened, the later observation of the channel
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// being not closed implies that it was also not closed at the moment of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// first observation. We behave as if we observed the channel at that moment
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// and report that the receive cannot proceed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The channel is irreversibly closed. Re-check whether the channel has any pending data
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// to receive, which could have arrived between the empty and closed checks above.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Sequential consistency is also required here, when racing with such a send.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nf">empty</span><span class="p">(</span><span class="nx">c</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// The channel is irreversibly closed and empty.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// select 会选择改 case 疯狂输出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">closed</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// # 如果 channel 已经关闭, 且buffer 中已经没有数据了, 返回传输数据类型的默认值
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">raceacquire</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nf">raceaddr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// # 在返回的时候有可能刚好有数据会进来, 所以需要进行加锁操作
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// The channel has been closed, but the channel&#39;s buffer have data.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">		<span class="c1">// # 如果 channel 没有 buffer 会直接从阻塞中的发送数据协程中获取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// # 如果 channel 有 buffer. 当可以获取到因为发送数据而阻塞的协程时, 代表缓冲的 buffer 已经满了. 所以, 将从 buffer 中获取数据, 并将获取到的第一个阻塞协程, 的数据放入 buffer 尾端. 保证先入先出
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="c1">// Just found waiting sender with not closed.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="k">if</span> <span class="nx">sg</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nx">sendq</span><span class="p">.</span><span class="nf">dequeue</span><span class="p">();</span> <span class="nx">sg</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">// Found a waiting sender. If buffer is size 0, receive value
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// directly from sender. Otherwise, receive from head of queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// and add sender&#39;s value to the tail of the queue (both map to
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="c1">// the same buffer slot because the queue is full).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="nf">recv</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">sg</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span> <span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span> <span class="p">},</span> <span class="mi">3</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 从 buffer 中获取数据
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// Receive directly from queue
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">qp</span> <span class="o">:=</span> <span class="nf">chanbuf</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">raceenabled</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">racenotify</span><span class="p">(</span><span class="nx">c</span><span class="p">,</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">ep</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">typedmemmove</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">ep</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nf">typedmemclr</span><span class="p">(</span><span class="nx">c</span><span class="p">.</span><span class="nx">elemtype</span><span class="p">,</span> <span class="nx">qp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="o">==</span> <span class="nx">c</span><span class="p">.</span><span class="nx">dataqsiz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">c</span><span class="p">.</span><span class="nx">recvx</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">c</span><span class="p">.</span><span class="nx">qcount</span><span class="o">--</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// # 非阻塞操作, 返回
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="p">!</span><span class="nx">block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// 将获取数据的协程阻塞
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// no sender available: block on this channel.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span> <span class="o">:=</span> <span class="nf">acquireSudog</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">mysg</span><span class="p">.</span><span class="nx">releasetime</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// No stack splits between assigning elem and enqueuing mysg
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// on gp.waiting where copystack can find it.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">mysg</span><span class="p">.</span><span class="nx">elem</span> <span class="p">=</span> <span class="nx">ep</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">waitlink</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="nx">mysg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">isSelect</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="nx">c</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">c</span><span class="p">.</span><span class="nx">recvq</span><span class="p">.</span><span class="nf">enqueue</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// Signal to anyone trying to shrink our stack that we&#39;re about
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// to park on a channel. The window between when this G&#39;s status
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// changes and when we set gp.activeStackChans is not safe for
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// stack shrinking.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">atomic</span><span class="p">.</span><span class="nf">Store8</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">parkingOnChan</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gopark</span><span class="p">(</span><span class="nx">chanparkcommit</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">c</span><span class="p">.</span><span class="nx">lock</span><span class="p">),</span> <span class="nx">waitReasonChanReceive</span><span class="p">,</span> <span class="nx">traceEvGoBlockRecv</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// someone woke us up
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="k">if</span> <span class="nx">mysg</span> <span class="o">!=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;G waiting list is corrupted&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waiting</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">activeStackChans</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	<span class="c1">// 如果是因为 channel的关闭 操作唤醒的, success 值为 false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">success</span> <span class="o">:=</span> <span class="nx">mysg</span><span class="p">.</span><span class="nx">success</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mysg</span><span class="p">.</span><span class="nx">c</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releaseSudog</span><span class="p">(</span><span class="nx">mysg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">success</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="用法总结">用法总结</h2>
<p>初始化:</p>
<ol>
<li>避免对未初始化 channel 的进行读写操作, 可能会造成阻塞</li>
<li>在 select 语句中, 对已经关闭的 channel 可以赋予  <code>nil</code> 值, 避免 cpu 飙高</li>
</ol>
<p>关闭协程:</p>
<ol>
<li>关闭协程的动作, 应该由数据写入方操作</li>
<li>channel 当参数传递时, 尽可能带上操作方向(读取/写入), 编译器会保证, 单向写入协程不允许关闭</li>
<li>关闭的时候要确保所有的写入协程都已经操作完毕. 避免引起写入协程发生 panic</li>
</ol>
<p>在 channel 中阻塞的协程, 唤醒条件</p>
<ol>
<li>到达协程数据操作的目标, 写入 / 读取数据</li>
<li>channel 关闭</li>
</ol>
<h2 id="referrences">Referrences</h2>
<ol>
<li><a href="https://cs.opensource.google/go/go/+/refs/tags/go1.17:src/runtime/chan.go">Go官方源码</a></li>
<li><a href="https://go.dev/blog/codelab-share">Share Memory By Communication</a></li>
</ol>
]]></content:encoded>
    </item>
    
    <item>
      <title>Go 常用的命令汇总</title>
      <link>https://ynikl.github.io/blog/go-cmd/</link>
      <pubDate>Fri, 01 Apr 2022 19:56:59 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/go-cmd/</guid>
      <description>工具分类 go build 编译源代码文件
-race 编译出的目标程序，会启用数据竞争检测
go doc 查看包的文档(定义于doc.go的注释中), 于包中公开的函数签名
example
1 2 3 go doc go doc encoding/json go env 查看 go 相关的环境变量
1 2 3 4 5 # -w 设置环境变量 go env -w GOPAHT=&amp;#39;/some/path&amp;#39; # -u 恢复成默认设置 go env -u GOPATH go generate 扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”
注释的指令格式
//go:generate command argument...
ps: wire 也是利用命令, 生成依赖注入文件
go get 管理当前module依赖
1 2 3 4 5 6 7 8 # 添加依赖包 go get example.</description>
      <content:encoded><![CDATA[<h1 id="工具分类">工具分类</h1>
<h2 id="go-build">go build</h2>
<p>编译源代码文件</p>
<p><code>-race</code>
编译出的目标程序，会启用数据竞争检测</p>
<h2 id="go-doc">go doc</h2>
<p>查看包的文档(定义于<code>doc.go</code>的注释中), 于包中公开的函数签名</p>
<p>example</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go doc
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">go doc encoding/json
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-env">go env</h2>
<p>查看 go 相关的环境变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl"><span class="c1"># -w 设置环境变量</span>
</span></span><span class="line"><span class="cl">go env -w <span class="nv">GOPAHT</span><span class="o">=</span><span class="s1">&#39;/some/path&#39;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># -u 恢复成默认设置</span>
</span></span><span class="line"><span class="cl">go env -u GOPATH
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-generate">go generate</h2>
<p>扫描文件中的指令并执行, 相关指令目的应该是“生成或者修改源文件”</p>
<p><strong>注释的指令格式</strong></p>
<p><code>//go:generate command argument...</code></p>
<p>ps: wire 也是利用命令, 生成依赖注入文件</p>
<h2 id="go-get">go get</h2>
<p>管理当前module依赖</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 添加依赖包
</span></span><span class="line"><span class="cl">go get example.com/pkg
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 指定包版本
</span></span><span class="line"><span class="cl">go get example.com/pkg@1.2.3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 移除依赖
</span></span><span class="line"><span class="cl">go get example.com/pkg@none
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-install">go install</h2>
<p>获取包文件，并编译和安装。可执行文件编译到<code>$GOBIN</code>路径下, 包文件编译到<code>$GOPATH/pkg</code></p>
<h2 id="go-list">go list</h2>
<p>列出包的数据信息</p>
<h2 id="go-mod">go mod</h2>
<p>管理 modules</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">edit	修改go.mod
</span></span><span class="line"><span class="cl">init	初始化
</span></span><span class="line"><span class="cl">tidy	自动补全依赖包
</span></span><span class="line"><span class="cl">vendor	生成一个所有依赖的vendor文件夹
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-test">go test</h2>
<p>跑单元测试</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">go test -v .
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 指定函数
</span></span><span class="line"><span class="cl">go test -run 函数名
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 性能测试
</span></span><span class="line"><span class="cl">go test -v -bench . -benchtime 50s
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 单元测试覆盖率
</span></span><span class="line"><span class="cl">go test -cover
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 强制重新跑测试, 不使用缓存的结果 source: https://stackoverflow.com/a/48882892/9992963
</span></span><span class="line"><span class="cl">go test -count=1
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="go-tool">go tool</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"># 不带参数，显示工具列表
</span></span><span class="line"><span class="cl">go tool
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="compile">compile</h3>
<p>使用<code>go tool compile -N -l -S main.go</code>生成汇编代码</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Hugo 文章分类管理</title>
      <link>https://ynikl.github.io/blog/hugo-%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</link>
      <pubDate>Wed, 09 Mar 2022 11:29:17 +0800</pubDate>
      <author>gilfoyle.k@outlook.com (潜水员)</author>
      <guid>https://ynikl.github.io/blog/hugo-%E5%88%86%E7%B1%BB%E7%AE%A1%E7%90%86/</guid>
      <description>Hugo 文章分类管理 文件夹 内容存放在content/目录下方, content/下方的子目录会形成资源URI,
例如 content/blog/doc.md 文章访问目录即为 https//XXX.github.io/blog.doc.md
分类管理 文章内容表述 (Front Matter) 使用进行分类, 默认只有tags
1 2 3 tags: - Go - fast 可以在config添加自定的分类选项
1 2 3 taxonomies: series: series category: categories 文章路径 类别 描述 地址 home 网站homepage /index.html page 指定页面 /post/页面/index.html section 分区 /section/index.html taxonomy 分类 /tags/index.html term 分类系列 /tags/go/index.html _index.md 和 index.md 在文件夹下方添加_index.md会识别成section. 在文件夹下方添加index.md会被识别成文章.
千万不要在默认的content目录下方添加index.md</description>
      <content:encoded><![CDATA[<h1 id="hugo-文章分类管理">Hugo 文章分类管理</h1>
<h2 id="文件夹">文件夹</h2>
<p>内容存放在<code>content/</code>目录下方, <code>content/</code>下方的子目录会形成资源URI,</p>
<p>例如
<code>content/blog/doc.md</code> 文章访问目录即为 <code>https//XXX.github.io/blog.doc.md</code></p>
<h2 id="分类管理-taxonomies">分类管理 <!-- raw HTML omitted --></h2>
<h2 id="文章内容表述-front-matter">文章内容表述 (Front Matter)</h2>
<p>使用<!-- raw HTML omitted -->进行分类, 默认只有tags</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">tags</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="l">Go</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span>- <span class="l">fast</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以在<code>config</code>添加自定的分类选项</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-yaml" data-lang="yaml"><span class="line"><span class="cl"><span class="nt">taxonomies</span><span class="p">:</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">series</span><span class="p">:</span><span class="w"> </span><span class="l">series</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="nt">category</span><span class="p">:</span><span class="w"> </span><span class="l">categories</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><h2 id="文章路径">文章路径</h2>
<table>
<thead>
<tr>
<th>类别</th>
<th>描述</th>
<th>地址</th>
</tr>
</thead>
<tbody>
<tr>
<td>home</td>
<td>网站homepage</td>
<td>/index.html</td>
</tr>
<tr>
<td>page</td>
<td>指定页面</td>
<td>/post/页面/index.html</td>
</tr>
<tr>
<td>section</td>
<td>分区</td>
<td>/section/index.html</td>
</tr>
<tr>
<td>taxonomy</td>
<td>分类</td>
<td>/tags/index.html</td>
</tr>
<tr>
<td>term</td>
<td>分类系列</td>
<td>/tags/go/index.html</td>
</tr>
</tbody>
</table>
<h2 id="_indexmd-和-indexmd"><code>_index.md</code> 和 <code>index.md</code></h2>
<p>在文件夹下方添加<code>_index.md</code>会识别成section.
在文件夹下方添加<code>index.md</code>会被识别成文章.</p>
<p><strong>千万不要在默认的content目录下方添加<code>index.md</code></strong></p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
