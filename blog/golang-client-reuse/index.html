<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Golang 是否需要为每个请求 New 一个 Client | 潜水员的咖啡小屋</title><meta name=keywords content="golang"><meta name=description content="背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致上流的 nginx 的连接数暴涨.
问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client
探索 在 StackOverflow 发现的相关答案
How to release http.Client in Go?
给的答案是建议复用 Client
The Client&rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
http.Client 的结构体
1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time."><meta name=author content="潜水员"><link rel=canonical href=https://ynikl.github.io/blog/golang-client-reuse/><link crossorigin=anonymous href=/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js integrity="sha256-uVus3DnjejMqn4g7Hni+Srwf3KK8HyZB9V4809q9TWE=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=icon type=image/png sizes=16x16 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=icon type=image/png sizes=32x32 href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><link rel=apple-touch-icon href=https://ynikl.github.io/apple-touch-icon.png><link rel=mask-icon href=https://ynikl.github.io/%3Clink%20/%20abs%20url%3E><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><script async src="https://www.googletagmanager.com/gtag/js?id=G-35FCVN7C8X"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-35FCVN7C8X",{anonymize_ip:!1})}</script><meta property="og:title" content="Golang 是否需要为每个请求 New 一个 Client"><meta property="og:description" content="背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致上流的 nginx 的连接数暴涨.
问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client
探索 在 StackOverflow 发现的相关答案
How to release http.Client in Go?
给的答案是建议复用 Client
The Client&rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
http.Client 的结构体
1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time."><meta property="og:type" content="article"><meta property="og:url" content="https://ynikl.github.io/blog/golang-client-reuse/"><meta property="og:image" content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-12-19T15:35:53+08:00"><meta property="article:modified_time" content="2022-12-19T15:35:53+08:00"><meta property="og:site_name" content="潜水员的咖啡小屋"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://ynikl.github.io/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Golang 是否需要为每个请求 New 一个 Client"><meta name=twitter:description content="背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致上流的 nginx 的连接数暴涨.
问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client
探索 在 StackOverflow 发现的相关答案
How to release http.Client in Go?
给的答案是建议复用 Client
The Client&rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.
http.Client 的结构体
1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://ynikl.github.io/blog/"},{"@type":"ListItem","position":2,"name":"Golang 是否需要为每个请求 New 一个 Client","item":"https://ynikl.github.io/blog/golang-client-reuse/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Golang 是否需要为每个请求 New 一个 Client","name":"Golang 是否需要为每个请求 New 一个 Client","description":"背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致上流的 nginx 的连接数暴涨.\n问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client\n探索 在 StackOverflow 发现的相关答案\nHow to release http.Client in Go?\n给的答案是建议复用 Client\nThe Client\u0026rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.\nhttp.Client 的结构体\n1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time.","keywords":["golang"],"articleBody":"背景 在改动旧代码的时候把, 一个使用全局 http.Client 的代码弄成了每一个请求会新 New 一个 http.Client 导致上流的 nginx 的连接数暴涨.\n问题 处理多个请求的时候, 是否需要为每个请求 New 一个 Client\n探索 在 StackOverflow 发现的相关答案\nHow to release http.Client in Go?\n给的答案是建议复用 Client\nThe Client’s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.\nhttp.Client 的结构体\n1 2 3 4 5 6 7 8 9 10 type Client struct { Transport RoundTripper CheckRedirect func(req *Request, via []*Request) error Jar CookieJar Timeout time.Duration } 在 RoundTripper 中实现了连接复用的逻辑\n1 2 3 type RoundTripper interface { RoundTrip(*Request) (*Response, error) } 中定义了 RoundTrip 方法, 提供客户端请求的时候调用.\n调用地址\n查看一下 Golang Transport 的基本实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 type Transport struct { idleMu sync.Mutex closeIdle bool // user has requested to close all idle conns idleConn map[connectMethodKey][]*persistConn // most recently used at end idleConnWait map[connectMethodKey]wantConnQueue // waiting getConns idleLRU connLRU connsPerHostMu sync.Mutex connsPerHost map[connectMethodKey]int connsPerHostWait map[connectMethodKey]wantConnQueue // waiting getConns // 还有其他字段略 } 结构体中间有很多连接存储相关的字段.\n在 http 请求调用 Transport 中间有一个关键方法 getConn 获取一个连接\n方法声明一个想要的连接地址, wantConn 推入到 queueForDial\nQueueForDial 方法会判断时候connsPerHost 中间是否有当前的请求的缓存连接\n如果有直接拿来重复使用 如果没有, 就需要重新进行拨号 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 w.beforeDial() if t.MaxConnsPerHost \u003c= 0 { go t.dialConnFor(w) return } t.connsPerHostMu.Lock() defer t.connsPerHostMu.Unlock() if n := t.connsPerHost[w.key]; n \u003c t.MaxConnsPerHost { if t.connsPerHost == nil { t.connsPerHost = make(map[connectMethodKey]int) } t.connsPerHost[w.key] = n + 1 go t.dialConnFor(w) return } if t.connsPerHostWait == nil { t.connsPerHostWait = make(map[connectMethodKey]wantConnQueue) } q := t.connsPerHostWait[w.key] q.cleanFront() q.pushBack(w) t.connsPerHostWait[w.key] = q 结论 重复使用 http.Client 可以达到 TCP 连接复用的效果\n","wordCount":"272","inLanguage":"en","datePublished":"2022-12-19T15:35:53+08:00","dateModified":"2022-12-19T15:35:53+08:00","author":{"@type":"Person","name":"潜水员"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://ynikl.github.io/blog/golang-client-reuse/"},"publisher":{"@type":"Organization","name":"潜水员的咖啡小屋","logo":{"@type":"ImageObject","url":"https://ynikl.github.io/apple-touch-icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://ynikl.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://ynikl.github.io/apple-touch-icon_hu580d61a4745e72e64f2a76fb3eea3190_18715_0x35_resize_box_3.png alt=logo aria-label=logo height=35>Home</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=https://ynikl.github.io/blog/ title=blog><span>blog</span></a></li><li><a href=https://ynikl.github.io/posts/ title=posts><span>posts</span></a></li><li><a href=https://ynikl.github.io/books/ title=books><span>books</span></a></li><li><a href=https://ynikl.github.io/notes/ title=notes><span>notes</span></a></li><li><a href=https://ynikl.github.io/tags/ title=tags><span>tags</span></a></li><li><a href=https://ynikl.github.io/me/ title=me?><span>me?</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://ynikl.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://ynikl.github.io/blog/>Blogs</a></div><h1 class=post-title>Golang 是否需要为每个请求 New 一个 Client</h1><div class=post-meta><span title='2022-12-19 15:35:53 +0800 +0800'>December 19, 2022</span>&nbsp;·&nbsp;2 min&nbsp;·&nbsp;潜水员&nbsp;|&nbsp;<a href=https://github.com/ynikl/ynikl.github.io/tree/main/content/blog/golang-client-reuse.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=post-content><h2 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h2><p>在改动旧代码的时候把, 一个使用全局 <code>http.Client</code> 的代码弄成了每一个请求会新 New
一个 <code>http.Client</code> 导致上流的 nginx 的连接数暴涨.</p><h2 id=问题>问题<a hidden class=anchor aria-hidden=true href=#问题>#</a></h2><p>处理多个请求的时候, 是否需要为每个请求 New 一个 Client</p><h2 id=探索>探索<a hidden class=anchor aria-hidden=true href=#探索>#</a></h2><p>在 StackOverflow 发现的相关答案</p><p><a href=https://stackoverflow.com/a/36688970/9992963>How to release http.Client in Go?</a></p><p>给的答案是建议复用 <code>Client</code></p><blockquote><p>The Client&rsquo;s Transport typically has internal state (cached TCP connections), so Clients should be reused instead of created as needed. Clients are safe for concurrent use by multiple goroutines.</p></blockquote><p>http.Client 的结构体</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Client struct {
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	Transport RoundTripper
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	CheckRedirect func(req *Request, via []*Request) error
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	Jar CookieJar
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	Timeout time.Duration
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>在 <code>RoundTripper</code> 中实现了连接复用的逻辑</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type RoundTripper interface {
</span></span><span class=line><span class=cl>	RoundTrip(*Request) (*Response, error)
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>中定义了 <code>RoundTrip</code> 方法, 提供客户端请求的时候调用.</p><p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=1;bpt=1;l=512?q=%2Fnet%2Fhttp%2Ftransport.go&ss=go%2Fgo">调用地址</a></p><p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;l=95?q=%2Fnet%2Fhttp%2Ftransport.go&ss=go%2Fgo">查看一下 Golang Transport 的基本实现</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>type Transport struct {
</span></span><span class=line><span class=cl>	idleMu       sync.Mutex
</span></span><span class=line><span class=cl>	closeIdle    bool                                // user has requested to close all idle conns
</span></span><span class=line><span class=cl>	idleConn     map[connectMethodKey][]*persistConn // most recently used at end
</span></span><span class=line><span class=cl>	idleConnWait map[connectMethodKey]wantConnQueue  // waiting getConns
</span></span><span class=line><span class=cl>	idleLRU      connLRU
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	connsPerHostMu   sync.Mutex
</span></span><span class=line><span class=cl>	connsPerHost     map[connectMethodKey]int
</span></span><span class=line><span class=cl>	connsPerHostWait map[connectMethodKey]wantConnQueue // waiting getConns
</span></span><span class=line><span class=cl>	
</span></span><span class=line><span class=cl>	// 还有其他字段略
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>结构体中间有很多连接存储相关的字段.</p><p>在 http 请求调用 Transport 中间有一个关键方法 <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;bpv=1;bpt=1;l=1338">getConn</a> 获取一个连接</p><p>方法声明一个想要的连接地址, <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=1b2ad1d815ea8967c49b32d848b2992d0c588d88;l=1194">wantConn</a> 推入到 <a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=0;bpt=1;l=1422">queueForDial</a></p><p><a href="https://cs.opensource.google/go/go/+/master:src/net/http/transport.go;drc=0b2ad1d815ea8967c49b32d848b2992d0c588d88;bpv=1;bpt=1;l=1422">QueueForDial 方法</a>会判断时候<code>connsPerHost</code> 中间是否有当前的请求的缓存连接</p><ul><li>如果有直接拿来重复使用</li><li>如果没有, 就需要重新进行拨号</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>	w.beforeDial()
</span></span><span class=line><span class=cl>	if t.MaxConnsPerHost &lt;= 0 {
</span></span><span class=line><span class=cl>		go t.dialConnFor(w)
</span></span><span class=line><span class=cl>		return
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	t.connsPerHostMu.Lock()
</span></span><span class=line><span class=cl>	defer t.connsPerHostMu.Unlock()
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	if n := t.connsPerHost[w.key]; n &lt; t.MaxConnsPerHost {
</span></span><span class=line><span class=cl>		if t.connsPerHost == nil {
</span></span><span class=line><span class=cl>			t.connsPerHost = make(map[connectMethodKey]int)
</span></span><span class=line><span class=cl>		}
</span></span><span class=line><span class=cl>		t.connsPerHost[w.key] = n + 1
</span></span><span class=line><span class=cl>		go t.dialConnFor(w)
</span></span><span class=line><span class=cl>		return
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>	if t.connsPerHostWait == nil {
</span></span><span class=line><span class=cl>		t.connsPerHostWait = make(map[connectMethodKey]wantConnQueue)
</span></span><span class=line><span class=cl>	}
</span></span><span class=line><span class=cl>	q := t.connsPerHostWait[w.key]
</span></span><span class=line><span class=cl>	q.cleanFront()
</span></span><span class=line><span class=cl>	q.pushBack(w)
</span></span><span class=line><span class=cl>	t.connsPerHostWait[w.key] = q
</span></span></code></pre></td></tr></table></div></div><h2 id=结论>结论<a hidden class=anchor aria-hidden=true href=#结论>#</a></h2><p>重复使用 http.Client 可以达到 TCP 连接复用的效果</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://ynikl.github.io/tags/golang/>golang</a></li></ul><nav class=paginav><a class=next href=https://ynikl.github.io/blog/linux-server-device-info/><span class=title>Next Page »</span><br><span>查看 Linux 的负载情况</span></a></nav></footer><script src=https://utteranc.es/client.js repo=ynikl/ynikl.github.io issue-term=pathname label=comment theme=preferred-color-scheme crossorigin=anonymous async></script></article></main><footer class=footer><span>2022 Ian Lin All rights reserved</span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerText="copy";function s(){t.innerText="copied!",setTimeout(()=>{t.innerText="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>