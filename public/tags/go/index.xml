<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>go on Diver-Café</title>
    <link>https://ynikl.github.io/tags/go/</link>
    <description>Recent content in go on Diver-Café</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 02 Apr 2022 10:09:22 +0800</lastBuildDate><atom:link href="https://ynikl.github.io/tags/go/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Channel</title>
      <link>https://ynikl.github.io/go/channel/</link>
      <pubDate>Sat, 02 Apr 2022 10:09:22 +0800</pubDate>
      
      <guid>https://ynikl.github.io/go/channel/</guid>
      <description>Go 中 channel 中用法和实现总结 以下分析和源码都是基于 go1.17 版本
channel 简介 Go 语言的基础类型之一, 用于在协程与协程之间传递数据 (channel 数据的传输方式也是值传递, Go语言的数据传输只有值传递)
 Do not communicate by sharing memory; instead, share memory by communicating.
 channel 保证:
 数据的先入先出 并发情况下的数据安全 已经关闭的 channel 不可重开  channel 的实现 channel 在内部实现的结构体为 runtime.hchan
 有一个环形链表, 暂存要传输的数据. 无 buffer 的channel 该队列长度为0, 所以不进行数据缓冲. 有一把互斥锁mutex, 在并发情况下, 保护自身数据结构的一致性 有两个协程等待链表, 用于挂载因为发送/接收而阻塞在该 channel 上的协程  type hchan struct { qcount uint // 当前 buffer 中有暂存着多少个数据 dataqsiz uint // 环形数据的buffer个数, 由 make 初始化的时候第二个参数容量决定的 buf unsafe.</description>
    </item>
    
  </channel>
</rss>
